@pagedown

# Lazp: An untyped, lazy Lambda Calculus with Macros and Primitives

To facilitate macros, Lazp uses abstract syntax trees, made from LC cons-lists (i.e. like LISP):

a b c -> (_apply (_ref a) (_ref b) (_ref c))  
𝛌a . b -> (_lambda (a) (_ref b))  
𝛍a . b -> (_macro (a) (_ref b)) -- macro: returns an AST which is then evaluated  
𝜋x y z -> (_prim x (_ref y) (_ref z)) -- call a primitive function x with arguments y and z  

Template Haskell demonstrates a perceived need for macros, even in a lazy language, like Haskell.  Macros expose the Lazp code-generator to developers which helps with creating external DSLs, among other things. Eval, which takes an AST as an argument, is the identity macro and the Lazp compiler can be exposed as a macro.

## AST Function usage

_lit v -- literal value  
_ref v -- variable reference: should be a string
_lambda var body -- lambda binding: var should be a string, body is an AST
_apply func arg -- function application: func can be any AST function except a _prim  
_prim arg rest -- primitive call: rest is either a _prim, _lit, or _ref  

The AST functions serve as an embedded DSL.
## Examples

eval x = 𝛍x . x  
apply func arg = 𝛍 func arg . _apply (_lit func) (_lit arg)  
compile code-string -- function returning AST  

## Parser macros  

How these work depends on the parser you use, but they run Lazp code at parse-time.  Parser macros can implement things like splicing primitive values into the AST and importing libraries, but the most important thing is that they allow developers to extend the parser.  Parser macros can be activated using a standard parser macro (of course :) ).

## Implementation

Lazp will start as a virtual machine in JavaScript, with the intent to generate LLVM code.  Potentially, there could be a C version in between, so that there’s a native one before the LLVM one is done.  The LLVM version could use the VMKit’s garbage collector or the Boehm-Demers-Weiser garbage collector, which performs well with small objects (like function contexts).

## Function IDs

Functions and unbound variables will have IDs that act like runtime types

## Parser

(the parser should eventually be written in Lazp)  

\ is equivalent to 𝛌  
\m\ is equivalent to 𝛍  
\p\ is equivalent to 𝜋  

Since \xxx\ is not legal Lazp syntax, it’s a good way to name character macros.

## LISP-like syntax for Lazp (an alternate parser for curmudgeons)

(lambda (a) b) -> (_lambda (a) (_ref b))  
(a b c) -> (_apply (_ref a) (_ref b) (_ref c))  
