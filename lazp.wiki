@pagedown

# Lazp: An untyped, lazy Lambda Calculus with Macros and Primitives

To facilitate macros, Lazp uses abstract syntax trees, made from LC cons-lists (i.e. like LISP):

a b c -> (_apply (_ref a) (_ref b) (_ref c))  
𝛌a . b -> (_lambda (a) (_ref b))  
𝛍a . b -> (_macro (a) (_ref b)) -- macro: returns an AST which is then evaluated  
𝜋x y z -> (_prim x (_ref y) (_ref z)) -- call a primitive function x with arguments y and z  

Template Haskell demonstrates a perceived need for macros, even in a lazy language, like Haskell.  Macros expose the Lazp code-generator to developers which helps with creating external DSLs, among other things. Eval, which takes an AST as an argument, is the identity macro and the Lazp compiler can be exposed as a macro.

## Standard Functions

_lit v -- AST literal value  
_ref v -- AST variable reference  
_apply[ func, arg, arg, arg] -- AST function application (uses , and ] for varargs)  
_lambda var body -- AST lambda binding  
_macro var body -- AST macro binding  
_prim name -- AST primitive call  
cons head tail  
nil head tail -- normally, this is curried as just “nil”  
string head tail -- a string  
int head tail -- identify an int value  

The AST functions serve as an embedded DSL.
## Values

function  
macro  
unbound variable  
primitive value  

## Examples

eval x = 𝛍x . x  
apply func arg = 𝛍 func arg . _apply[ _lit func, _lit arg]  
compile code-string -- function returning AST  

## Parser macros  

How these work depends on the parser you use, but they run Lazp code at parse-time.  Parser macros can implement things like splicing primitive values into the AST and importing libraries, but the most important thing is that they allow developers to extend the parser.  Parser macros can be activated using a standard parser macro (of course :) ).

## Implementation

Lazp will start as a virtual machine in JavaScript, with the intent to generate LLVM code.  Potentially, there could be a C version in between, so that there’s a native one before the LLVM one is done.  The LLVM version could use the VMKit’s garbage collector or the Boehm-Demers-Weiser garbage collector, which performs well with small objects (like function contexts).

## Function IDs

Functions and unbound variables will have IDs that act like runtime types

## Parser

(the parser should eventually be written in Lazp)  

\ is equivalent to 𝛌  
\m\ is equivalent to 𝛍  
\p\ is equivalent to 𝜋  

Since \xxx\ is not legal Lazp syntax, it’s a good way to name character macros.

## LISP-like syntax for Lazp (an alternate parser for curmudgeons)

(lambda (a) b) -> (_lambda (a) (_ref b))  
(a b c) -> (_apply (_ref a) (_ref b) (_ref c))  
