;(function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require=="function"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error("Cannot find module '"+n+"'")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require=="function"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({1:[function(require,module,exports){
(function(global){// Generated by CoffeeScript 1.6.2
/*
Copyright (C) 2012, Bill Burdick, Tiny Concepts: https://github.com/zot/Leisure

(licensed with ZLIB license)

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software
in a product, an acknowledgment in the product documentation would be
appreciated but is not required.

2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.

3. This notice may not be removed or altered from any source distribution.
*/


(function() {
  var L_anno, L_apply, L_lambda, L_let, L_lit, L_ref, LeisureObject, Leisure_BaseCons, Leisure_cons, Leisure_nil, Nil, anno, apply, ast2Json, ast2JsonEncodings, astString, charCodes, checkType, cons, consEq, consFrom, define, ensureLeisureClass, evalFunc, foldLeft, functionInfo, getAnnoBody, getAnnoData, getAnnoName, getApplyArg, getApplyFunc, getDataType, getLambdaBody, getLambdaVar, getLetBody, getLetName, getLetValue, getLitVal, getRefName, getType, head, jsType, json2Ast, json2AstEncodings, lambda, lazy, leisureAddFunc, letStr, lit, llet, lz, makeSuper, mkProto, nameFunc, nameSub, primCons, primFoldLeft, ref, resolve, root, rz, save, setDataType, setType, supertypes, tail, throwError, _, _ref, _ref1, _ref2, _ref3,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ref = root = module.exports = require('./base'), resolve = _ref.resolve, lazy = _ref.lazy;

  _ = require('./lodash.min');

  rz = resolve;

  lz = lazy;

  charCodes = {
    "'": '$a',
    ',': '$b',
    '$': '$$',
    '@': '$d',
    '?': '$e',
    '/': '$f',
    '*': '$g',
    '&': '$h',
    '^': '$i',
    '!': '$k',
    '`': '$l',
    '~': '$m',
    '-': '$_',
    '+': '$o',
    '=': '$p',
    '|': '$q',
    '[': '$r',
    ']': '$s',
    '{': '$t',
    '}': '$u',
    '"': '$v',
    ':': '$w',
    ';': '$x',
    '<': '$y',
    '>': '$z',
    '%': '$A',
    '.': '$B'
  };

  nameSub = function(name) {
    var code, i, s, _i, _ref1;

    s = '';
    for (i = _i = 0, _ref1 = name.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
      code = charCodes[name[i]];
      s += code != null ? code : name[i];
    }
    return s;
  };

  setDataType = function(func, dataType) {
    if (dataType) {
      func.dataType = dataType;
    }
    return func;
  };

  setType = function(func, type) {
    if (type) {
      func.type = type;
    }
    func.__proto__ = (ensureLeisureClass(type)).prototype;
    return func;
  };

  LeisureObject = (function() {
    function LeisureObject() {}

    return LeisureObject;

  })();

  LeisureObject.prototype.__proto__ = Function.prototype;

  LeisureObject.prototype.className = 'LeisureObject';

  global.Leisure_Object = LeisureObject;

  supertypes = {};

  root.leisureClassChange = 0;

  ensureLeisureClass = function(leisureClass) {
    var cl;

    cl = "Leisure_" + (nameSub(leisureClass));
    if (global[cl] == null) {
      global[cl] = eval("(function " + cl + "(){})");
      supertypes[cl] = 'Leisure_Object';
      global[cl].prototype.__proto__ = LeisureObject.prototype;
      root.leisureClassChange++;
    }
    return global[cl];
  };

  makeSuper = function(type, supertype) {
    supertypes["Leisure_" + (nameSub(type))] = "Leisure_" + (nameSub(supertype));
    return root.leisureClassChange++;
  };

  ensureLeisureClass('cons');

  ensureLeisureClass('nil');

  supertypes.Leisure_cons = 'Leisure_Object';

  supertypes.Leisure_nil = 'Leisure_Object';

  ensureLeisureClass('ast');

  ensureLeisureClass('lit');

  Leisure_lit.prototype.toString = function() {
    return "lit(" + (getLitVal(this)) + ")";
  };

  ensureLeisureClass('ref');

  Leisure_ref.prototype.toString = function() {
    return "ref(" + (getRefName(this)) + ")";
  };

  ensureLeisureClass('lambda');

  Leisure_lambda.prototype.toString = function() {
    return "lambda(" + (astString(this)) + ")";
  };

  ensureLeisureClass('apply');

  Leisure_apply.prototype.toString = function() {
    return "apply(" + (astString(this)) + ")";
  };

  ensureLeisureClass('let');

  Leisure_let.prototype.toString = function() {
    return "let(" + (astString(this)) + ")";
  };

  ensureLeisureClass('anno');

  Leisure_anno.prototype.toString = function() {
    return "anno(" + (astString(this)) + ")";
  };

  ensureLeisureClass('doc');

  ensureLeisureClass('srcLocation');

  ensureLeisureClass('pattern');

  makeSuper('lit', 'ast');

  makeSuper('ref', 'ast');

  makeSuper('lambda', 'ast');

  makeSuper('apply', 'ast');

  makeSuper('let', 'ast');

  makeSuper('anno', 'ast');

  astString = function(ast) {
    var argStr, funcStr, _ref1;

    switch (getType(ast)) {
      case 'lit':
        return getLitVal(ast);
      case 'ref':
        return getRefName(ast);
      case 'apply':
        funcStr = astString(getApplyFunc(ast));
        if ((_ref1 = getType(getApplyFunc(ast))) === 'lambda' || _ref1 === 'let') {
          funcStr = "(" + funcStr + ")";
        }
        argStr = astString(getApplyArg(ast));
        if (getType(getApplyArg(ast)) === 'apply') {
          argStr = "(" + argStr + ")";
        }
        return "" + funcStr + " " + argStr;
      case 'lambda':
        return "\\" + (getLambdaVar(ast)) + " . " + (astString(getLambdaBody(ast)));
      case 'let':
        return "\\\\" + (letStr(ast));
      case 'anno':
        return "\\@" + (getAnnoName(ast)) + " " + (getAnnoData(ast)) + " . " + (astString(getAnnoBody(ast)));
    }
  };

  letStr = function(ast) {
    var binding, body;

    body = getLetBody(ast);
    binding = "(" + (getLetName(ast)) + " = " + (astString(getLetValue(ast))) + ")";
    if (body instanceof Leisure_let) {
      return "" + binding + " " + (letStr(body));
    } else {
      return "" + binding + " . " + (astString(body));
    }
  };

  Leisure_BaseCons = (function(_super) {
    __extends(Leisure_BaseCons, _super);

    function Leisure_BaseCons() {
      _ref1 = Leisure_BaseCons.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    Leisure_BaseCons.prototype.head = function() {
      throw new Error("Not Implemented");
    };

    Leisure_BaseCons.prototype.tail = function() {
      throw new Error("Not Implemented");
    };

    Leisure_BaseCons.prototype.isNil = function() {
      return false;
    };

    Leisure_BaseCons.prototype.find = function(func) {
      if (func(this.head())) {
        return this.head();
      } else {
        return this.tail().find(func);
      }
    };

    Leisure_BaseCons.prototype.removeAll = function(func) {
      var t;

      t = this.tail().removeAll(func);
      if (func(this.head())) {
        return t;
      } else if (t === this.tail()) {
        return this;
      } else {
        return cons(this.head(), t);
      }
    };

    Leisure_BaseCons.prototype.map = function(func) {
      return cons(func(this.head()), this.tail().map(func));
    };

    Leisure_BaseCons.prototype.foldl = function(func, arg) {
      return this.tail().foldl(func, func(arg, this.head()));
    };

    Leisure_BaseCons.prototype.foldl1 = function(func) {
      return this.tail().foldl(func, this.head());
    };

    Leisure_BaseCons.prototype.foldr = function(func, arg) {
      return func(this.head(), this.tail().foldr(func, arg));
    };

    Leisure_BaseCons.prototype.foldr1 = function(func) {
      if (this.tail() === Nil) {
        return this.head();
      } else {
        return func(this.head(), this.tail().foldr1(func));
      }
    };

    Leisure_BaseCons.prototype.toArray = function() {
      return this.foldl((function(i, el) {
        i.push(el);
        return i;
      }), []);
    };

    Leisure_BaseCons.prototype.join = function(str) {
      return this.toArray().join(str);
    };

    Leisure_BaseCons.prototype.reverse = function() {
      return this.rev(Nil);
    };

    Leisure_BaseCons.prototype.rev = function(result) {
      return this.tail().rev(cons(this.head(), result));
    };

    Leisure_BaseCons.prototype.elementString = function() {
      var _ref2;

      return "" + (((_ref2 = this.head()) != null ? _ref2.constructor : void 0) === this.constructor || this.head() instanceof Leisure_nil ? '[' + this.head().elementString() + ']' : this.head()) + (this.tail() instanceof Leisure_nil ? '' : this.tail() instanceof Leisure_BaseCons ? " " + (this.tail().elementString()) : " | " + (this.tail()));
    };

    Leisure_BaseCons.prototype.equals = function(other) {
      return this === other || (other instanceof Leisure_BaseCons && consEq(this.head(), other.head()) && consEq(this.tail(), other.tail()));
    };

    Leisure_BaseCons.prototype.each = function(block) {
      block(this.head());
      return this.tail().each(block);
    };

    Leisure_BaseCons.prototype.length = function() {
      return this.foldl((function(i, el) {
        return i + 1;
      }), 0);
    };

    Leisure_BaseCons.prototype.last = function() {
      var t;

      t = this.tail();
      if (t === Nil) {
        return this.head();
      } else {
        return t.last();
      }
    };

    Leisure_BaseCons.prototype.append = function(l) {
      return cons(this.head(), this.tail().append(l));
    };

    Leisure_BaseCons.prototype.toString = function() {
      return "" + (this.stringName()) + "[" + (this.elementString()) + "]";
    };

    Leisure_BaseCons.prototype.stringName = function() {
      return "BaseCons";
    };

    return Leisure_BaseCons;

  })(LeisureObject);

  consEq = function(a, b) {
    return a === b || (a instanceof Leisure_BaseCons && a.equals(b));
  };

  Leisure_cons = (function(_super) {
    __extends(Leisure_cons, _super);

    function Leisure_cons() {
      _ref2 = Leisure_cons.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    Leisure_cons.prototype.head = function() {
      return this(function() {
        return function(a) {
          return function(b) {
            return rz(a);
          };
        };
      });
    };

    Leisure_cons.prototype.tail = function() {
      return this(function() {
        return function(a) {
          return function(b) {
            return rz(b);
          };
        };
      });
    };

    Leisure_cons.prototype.stringName = function() {
      return "Cons";
    };

    return Leisure_cons;

  })(Leisure_BaseCons);

  global.Leisure_cons = Leisure_cons;

  Leisure_nil = (function(_super) {
    __extends(Leisure_nil, _super);

    function Leisure_nil() {
      _ref3 = Leisure_nil.__super__.constructor.apply(this, arguments);
      return _ref3;
    }

    Leisure_nil.prototype.isNil = function() {
      return true;
    };

    Leisure_nil.prototype.find = function() {
      return this;
    };

    Leisure_nil.prototype.removeAll = function() {
      return this;
    };

    Leisure_nil.prototype.map = function(func) {
      return Nil;
    };

    Leisure_nil.prototype.foldl = function(func, arg) {
      return arg;
    };

    Leisure_nil.prototype.foldr = function(func, arg) {
      return arg;
    };

    Leisure_nil.prototype.reverse = function() {
      return this;
    };

    Leisure_nil.prototype.rev = function(result) {
      return result;
    };

    Leisure_nil.prototype.equals = function(other) {
      return other instanceof Leisure_nil;
    };

    Leisure_nil.prototype.each = function() {};

    Leisure_nil.prototype.toArray = function() {
      return [];
    };

    Leisure_nil.prototype.join = function() {
      return '';
    };

    Leisure_nil.prototype.append = function(l) {
      return l;
    };

    Leisure_nil.prototype.toString = function() {
      return "Cons[]";
    };

    Leisure_nil.prototype.elementString = function() {
      return '';
    };

    return Leisure_nil;

  })(LeisureObject);

  global.Leisure_nil = Leisure_nil;

  jsType = function(v) {
    var t;

    t = typeof v;
    if (t === 'object') {
      return v.constructor || t;
    } else {
      return t;
    }
  };

  mkProto = function(protoFunc, value) {
    value.__proto__ = protoFunc.prototype;
    return value;
  };

  throwError = function(msg) {
    throw (msg instanceof Error ? msg : new Error(String(msg)));
  };

  checkType = function(value, type) {
    if (!(value instanceof type)) {
      return throwError("Type error: expected type: " + type + ", but got: " + (jsType(value)));
    }
  };

  primCons = setDataType((function(a) {
    return function(b) {
      return mkProto(Leisure_cons, setType((function(f) {
        return rz(f)(a)(b);
      }), 'cons'));
    };
  }), 'cons');

  Nil = mkProto(Leisure_nil, setDataType(setType((function(a) {
    return function(b) {
      return rz(b);
    };
  }), 'nil'), 'nil'));

  cons = function(a, b) {
    return primCons(lz(a))(lz(b));
  };

  foldLeft = function(func, val, thing) {
    if (thing instanceof Leisure_cons) {
      return thing.foldl(func, val);
    } else {
      return primFoldLeft(func, val, thing, 0);
    }
  };

  primFoldLeft = function(func, val, array, index) {
    if (index < array.length) {
      return primFoldLeft(func, func(val, array[index]), array, index + 1);
    } else {
      return val;
    }
  };

  global.leisureFuncs = {};

  global.leisureFuncNames = Nil;

  leisureAddFunc = global.leisureAddFunc = function(nm) {
    return global.leisureFuncNames = cons(nm, global.leisureFuncNames);
  };

  root.evalFunc = evalFunc = eval;

  root.functionCount = 0;

  functionInfo = {};

  nameFunc = function(func, name) {
    var f;

    f = null;
    return function() {
      if (f === null) {
        f = rz(func);
        if (typeof f === 'function') {
          f.leisureName = name;
        }
        return f;
      } else {
        return f;
      }
    };
  };

  define = function(name, func, arity, src, method) {
    var nm;

    functionInfo[name] = {
      src: src,
      arity: arity,
      leisureName: name,
      alts: {},
      altList: []
    };
    nm = 'L_' + nameSub(name);
    if (!method && global.noredefs && (global[nm] != null)) {
      throwError("[DEF] Attempt to redefine definition: " + name);
    }
    functionInfo[name].mainDef = global[nm] = global.leisureFuncs[nm] = nameFunc(func, name);
    leisureAddFunc(name);
    root.functionCount++;
    return func;
  };

  L_lit = setDataType((function(_x) {
    return setType((function(_f) {
      return rz(_f)(_x);
    }), 'lit');
  }), 'lit');

  L_ref = setDataType((function(_x) {
    return setType((function(_f) {
      return rz(_f)(_x);
    }), 'ref');
  }), 'ref');

  L_lambda = setDataType((function(_v) {
    return function(_f) {
      return setType((function(_g) {
        return rz(_g)(_v)(_f);
      }), 'lambda');
    };
  }), 'lambda');

  L_apply = setDataType((function(_func) {
    return function(_arg) {
      return setType((function(_f) {
        return rz(_f)(_func)(_arg);
      }), 'apply');
    };
  }), 'apply');

  L_let = setDataType((function(_n) {
    return function(_v) {
      return function(_b) {
        return setType((function(_f) {
          return rz(_f)(_n)(_v)(_b);
        }), 'let');
      };
    };
  }), 'let');

  L_anno = setDataType((function(_name) {
    return function(_data) {
      return function(_body) {
        return setType((function(_f) {
          return rz(_f)(_name)(_data)(_body);
        }), 'anno');
      };
    };
  }), 'anno');

  getType = function(f) {
    var t, _ref4;

    t = typeof f;
    return (t === 'function' && (f != null ? f.type : void 0)) || ("*" + ((t === 'object' && ((_ref4 = f.constructor) != null ? _ref4.name : void 0)) || t));
  };

  define('getType', lz(function(value) {
    return getType(rz(value));
  }), 1);

  getDataType = function(f) {
    return (typeof f === 'function' && f.dataType) || '';
  };

  define('getDataType', lz(function(value) {
    return getDataType(rz(value));
  }), 1);

  save = {};

  save.lit = lit = function(l) {
    return L_lit(lz(l));
  };

  save.ref = ref = function(r) {
    return L_ref(lz(r));
  };

  save.lambda = lambda = function(v, body) {
    return L_lambda(lz(v))(lz(body));
  };

  save.apply = apply = function(f, a) {
    return L_apply(lz(f))(lz(a));
  };

  save.llet = llet = function(n, v, b) {
    return L_let(lz(n))(lz(v))(lz(b));
  };

  save.anno = anno = function(name, data, body) {
    return L_anno(lz(name))(lz(data))(lz(body));
  };

  save.cons = cons;

  getLitVal = function(lt) {
    return lt(lz(function(v) {
      return rz(v);
    }));
  };

  getRefName = function(rf) {
    return rf(lz(function(v) {
      return rz(v);
    }));
  };

  getLambdaVar = function(lam) {
    return lam(lz(function(v) {
      return function(b) {
        return rz(v);
      };
    }));
  };

  getLambdaBody = function(lam) {
    return lam(lz(function(v) {
      return function(b) {
        return rz(b);
      };
    }));
  };

  getApplyFunc = function(apl) {
    return apl(lz(function(a) {
      return function(b) {
        return rz(a);
      };
    }));
  };

  getApplyArg = function(apl) {
    return apl(lz(function(a) {
      return function(b) {
        return rz(b);
      };
    }));
  };

  getLetName = function(lt) {
    return lt(lz(function(n) {
      return function(v) {
        return function(b) {
          return rz(n);
        };
      };
    }));
  };

  getLetValue = function(lt) {
    return lt(lz(function(n) {
      return function(v) {
        return function(b) {
          return rz(v);
        };
      };
    }));
  };

  getLetBody = function(lt) {
    return lt(lz(function(n) {
      return function(v) {
        return function(b) {
          return rz(b);
        };
      };
    }));
  };

  getAnnoName = function(anno) {
    return anno(lz(function(name) {
      return function(data) {
        return function(body) {
          return rz(name);
        };
      };
    }));
  };

  getAnnoData = function(anno) {
    return anno(lz(function(name) {
      return function(data) {
        return function(body) {
          return rz(data);
        };
      };
    }));
  };

  getAnnoBody = function(anno) {
    return anno(lz(function(name) {
      return function(data) {
        return function(body) {
          return rz(body);
        };
      };
    }));
  };

  json2AstEncodings = {
    lit: function(json) {
      return L_lit(lz(json.value));
    },
    ref: function(json) {
      return L_ref(lz(json.varName));
    },
    lambda: function(json) {
      return L_lambda(lz(json.varName))(lz(json2Ast(json.body)));
    },
    apply: function(json) {
      return L_apply(lz(json2Ast(json.func)))(lz(json2Ast(json.arg)));
    },
    "let": function(json) {
      return L_let(lz(json.varName))(lz(json2Ast(json.value)))(lz(json2Ast(json.body)));
    },
    anno: function(json) {
      return L_anno(lz(json.name))(lz(json2Ast(json.data)))(lz(json2Ast(json.body)));
    },
    cons: function(json) {
      return save.cons(json2Ast(json.head), json2Ast(json.tail));
    },
    nil: function(json) {
      return Nil;
    }
  };

  lit = save.lit;

  ref = save.ref;

  lambda = save.lambda;

  apply = save.apply;

  llet = save.llet;

  anno = save.anno;

  cons = save.cons;

  json2Ast = function(json) {
    if (typeof json === 'object') {
      return json2AstEncodings[json._type](json);
    } else {
      return json;
    }
  };

  ast2JsonEncodings = {
    Leisure_lit: function(ast) {
      return {
        _type: 'lit',
        value: getLitVal(ast)
      };
    },
    Leisure_ref: function(ast) {
      return {
        _type: 'ref',
        varName: getRefName(ast)
      };
    },
    Leisure_lambda: function(ast) {
      return {
        _type: 'lambda',
        varName: getLambdaVar(ast),
        body: ast2Json(getLambdaBody(ast))
      };
    },
    Leisure_apply: function(ast) {
      return {
        _type: 'apply',
        func: ast2Json(getApplyFunc(ast)),
        arg: ast2Json(getApplyArg(ast))
      };
    },
    Leisure_let: function(ast) {
      return {
        _type: 'let',
        varName: getLetName(ast),
        value: ast2Json(getLetValue(ast)),
        body: ast2Json(getLetBody(ast))
      };
    },
    Leisure_anno: function(ast) {
      return {
        _type: 'anno',
        name: getAnnoName(ast),
        data: ast2Json(getAnnoData(ast)),
        body: ast2Json(getAnnoBody(ast))
      };
    },
    Leisure_cons: function(ast) {
      return {
        _type: 'cons',
        head: ast2Json(ast.head()),
        tail: ast2Json(ast.tail())
      };
    },
    Leisure_nil: function(ast) {
      return {
        _type: 'nil'
      };
    }
  };

  ast2Json = function(ast) {
    var _ref4;

    if (ast2JsonEncodings[(_ref4 = ast.constructor) != null ? _ref4.name : void 0]) {
      return ast2JsonEncodings[ast.constructor.name](ast);
    } else {
      return ast;
    }
  };

  define('json2Ast', lz(function(json) {
    return json2Ast(JSON.parse(rz(json)));
  }));

  define('ast2Json', lz(function(ast) {
    return JSON.stringify(ast2Json(rz(ast)));
  }));

  consFrom = function(array, i) {
    i = i || 0;
    if (i < array.length) {
      return cons(array[i], consFrom(array, i + 1));
    } else {
      return Nil;
    }
  };

  head = function(l) {
    return l.head();
  };

  tail = function(l) {
    return l.tail();
  };

  root.head = head;

  root.tail = tail;

  root.consFrom = consFrom;

  root.nameSub = nameSub;

  root.setDataType = setDataType;

  root.setType = setType;

  root.mkProto = mkProto;

  root.Nil = Nil;

  root.cons = cons;

  root.primCons = primCons;

  root.define = define;

  root.getType = getType;

  root.getDataType = getDataType;

  root.lit = lit;

  root.ref = ref;

  root.lambda = lambda;

  root.apply = apply;

  root.anno = anno;

  root.llet = llet;

  root.getRefName = getRefName;

  root.getLitVal = getLitVal;

  root.getLambdaBody = getLambdaBody;

  root.getLambdaVar = getLambdaVar;

  root.getApplyFunc = getApplyFunc;

  root.getApplyArg = getApplyArg;

  root.getLetName = getLetName;

  root.getLetValue = getLetValue;

  root.getLetBody = getLetBody;

  root.getAnnoName = getAnnoName;

  root.getAnnoData = getAnnoData;

  root.getAnnoBody = getAnnoBody;

  root.throwError = throwError;

  root.foldLeft = foldLeft;

  root.LeisureObject = LeisureObject;

  root.evalFunc = evalFunc;

  root.json2Ast = json2Ast;

  root.ast2Json = ast2Json;

  root.Leisure_lit = Leisure_lit;

  root.Leisure_ref = Leisure_ref;

  root.Leisure_lambda = Leisure_lambda;

  root.Leisure_apply = Leisure_apply;

  root.Leisure_let = Leisure_let;

  root.Leisure_anno = Leisure_anno;

  root.ensureLeisureClass = ensureLeisureClass;

  root.makeSuper = makeSuper;

  root.supertypes = supertypes;

  root.functionInfo = functionInfo;

}).call(this);

/*
*/

})(self)
},{"./base":2,"./lodash.min":6}],2:[function(require,module,exports){
(function(global){// Generated by CoffeeScript 1.6.2
/*
Copyright (C) 2013, Bill Burdick, Tiny Concepts: https://github.com/zot/Leisure

(licensed with ZLIB license)

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software
in a product, an acknowledgment in the product documentation would be
appreciated but is not required.

2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.

3. This notice may not be removed or altered from any source distribution.
*/


(function() {
  var SimpyCons, defaultEnv, readDir, readFile, root, simpyCons, statFile, writeFile;

  root = module.exports;

  defaultEnv = {
    presentValue: function(x) {
      return x;
    },
    values: {},
    errorHandlers: []
  };

  global.resolve = function(value) {
    if (typeof value === 'function') {
      return value.memo || (value.memo = value());
    } else {
      return value;
    }
  };

  global.lazy = function(l) {
    if (typeof l === 'function') {
      return function() {
        return l;
      };
    } else {
      return l;
    }
  };

  readFile = function(fileName, cont) {
    return defaultEnv.readFile(fileName, cont);
  };

  writeFile = function(fileName, data, cont) {
    return defaultEnv.writeFile(fileName, data, cont);
  };

  readDir = function(fileName, cont) {
    return defaultEnv.readDir(fileName, cont);
  };

  statFile = function(fileName, cont) {
    return defaultEnv.statFile(fileName, cont);
  };

  SimpyCons = (function() {
    function SimpyCons(head, tail) {
      this.head = head;
      this.tail = tail;
    }

    SimpyCons.prototype.toArray = function() {
      var array, h;

      h = this;
      array = [];
      while (h !== null) {
        array.push(h.head);
        h = h.tail;
      }
      return array;
    };

    return SimpyCons;

  })();

  simpyCons = function(a, b) {
    return new SimpyCons(a, b);
  };

  root.defaultEnv = defaultEnv;

  root.readFile = readFile;

  root.readDir = readDir;

  root.writeFile = writeFile;

  root.statFile = statFile;

  root.SimpyCons = SimpyCons;

  root.simpyCons = simpyCons;

  root.resolve = global.resolve;

  root.lazy = global.lazy;

}).call(this);

/*
*/

})(self)
},{}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var Leisure, exports, k, nb, v, _ref;

  window.marked = require('./marked');

  Leisure = exports = module.exports = require('./base');

  require('./ast');

  require('./gen');

  require('./runtime');

  require('./generatedPrelude');

  require('./std');

  require('./md');

  window.Notebook = nb = require('./notebook');

  _ref = window.Leisure;
  for (k in _ref) {
    v = _ref[k];
    Leisure[k] = v;
  }

  window.Leisure = Leisure;

}).call(this);

/*
*/

},{"./ast":1,"./base":2,"./gen":4,"./generatedPrelude":5,"./marked":7,"./md":8,"./notebook":9,"./runtime":10,"./std":11}],4:[function(require,module,exports){
(function(global){// Generated by CoffeeScript 1.6.2
/*
Copyright (C) 2013, Bill Burdick, Tiny Concepts: https://github.com/zot/Leisure

(licensed with ZLIB license)

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software
in a product, an acknowledgment in the product documentation would be
appreciated but is not required.

2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.

3. This notice may not be removed or altered from any source distribution.
*/


(function() {
  var Leisure_anno, Leisure_apply, Leisure_lambda, Leisure_let, Leisure_lit, Leisure_ref, Nil, addLambdaProperties, addUniq, arrayify, assocListProps, cons, consFrom, curry, define, dumpAnno, gen, genApply, genApplyArg, genLambda, genLets, genUniq, getAnnoBody, getAnnoData, getAnnoName, getApplyArg, getApplyFunc, getAssocListProps, getLambdaBody, getLambdaProperties, getLambdaVar, getLastLetBody, getLetBody, getLetName, getLetValue, getLitVal, getRefName, lacons, lazy, lcons, lconsFrom, left, letList, lz, makeSyncMonad, memoize, nameSub, resolve, right, root, runMonad, rz, setDataType, setType, simpyCons, specialAnnotations, uniqName, varNameSub, _, _false, _ref, _ref1, _ref2,
    __slice = [].slice;

  _ref = require('./base'), simpyCons = _ref.simpyCons, resolve = _ref.resolve, lazy = _ref.lazy;

  rz = resolve;

  lz = lazy;

  _ref1 = root = module.exports = require('./ast'), nameSub = _ref1.nameSub, getLitVal = _ref1.getLitVal, getRefName = _ref1.getRefName, getLambdaVar = _ref1.getLambdaVar, getLambdaBody = _ref1.getLambdaBody, getApplyFunc = _ref1.getApplyFunc, getApplyArg = _ref1.getApplyArg, getAnnoName = _ref1.getAnnoName, getAnnoData = _ref1.getAnnoData, getAnnoBody = _ref1.getAnnoBody, getLetName = _ref1.getLetName, getLetValue = _ref1.getLetValue, getLetBody = _ref1.getLetBody, Leisure_lit = _ref1.Leisure_lit, Leisure_ref = _ref1.Leisure_ref, Leisure_lambda = _ref1.Leisure_lambda, Leisure_apply = _ref1.Leisure_apply, Leisure_let = _ref1.Leisure_let, Leisure_anno = _ref1.Leisure_anno, setType = _ref1.setType, setDataType = _ref1.setDataType, cons = _ref1.cons, Nil = _ref1.Nil, consFrom = _ref1.consFrom, define = _ref1.define;

  _ref2 = require('./runtime'), makeSyncMonad = _ref2.makeSyncMonad, runMonad = _ref2.runMonad, _false = _ref2._false, left = _ref2.left, right = _ref2.right;

  _ = require('./lodash.min');

  varNameSub = function(n) {
    return "L_" + (nameSub(n));
  };

  gen = function(ast) {
    return genUniq(ast, Nil, [Nil, 0]);
  };

  genUniq = function(ast, names, uniq) {
    var arity, data, funcName, genned, name, src, _ref3;

    switch (ast.constructor) {
      case Leisure_lit:
        return JSON.stringify(getLitVal(ast));
      case Leisure_ref:
        return "resolve(" + (uniqName(getRefName(ast), uniq)) + ")";
      case Leisure_lambda:
        return genLambda(ast, names, uniq, 0);
      case Leisure_apply:
        return "" + (genUniq(getApplyFunc(ast), names, uniq)) + "(" + (genApplyArg(getApplyArg(ast), names, uniq)) + ")";
      case Leisure_let:
        return "(function(){\n" + (genLets(ast, names, uniq)) + "})()";
      case Leisure_anno:
        name = getAnnoName(ast);
        data = getAnnoData(ast);
        genned = genUniq(getAnnoBody(ast), names, uniq);
        switch (name) {
          case 'type':
            return "setType(" + genned + ", '" + data + "')";
          case 'dataType':
            return "setDataType(" + genned + ", '" + data + "')";
          case 'define':
            _ref3 = data.toArray(), funcName = _ref3[0], arity = _ref3[1], src = _ref3[2];
            return "define('" + funcName + "', (function(){return " + genned + "}), " + arity + ", " + (JSON.stringify(src)) + ")";
          default:
            return genned;
        }
        break;
      default:
        return "DUR? " + ast + ", " + ast.constructor + " " + Leisure_lambda;
    }
  };

  genLambda = function(ast, names, uniq, count) {
    var n, name, u;

    name = getLambdaVar(ast);
    u = addUniq(name, names, uniq);
    n = cons(name, names);
    return addLambdaProperties(ast, "function(" + (uniqName(name, u)) + "){return " + (genUniq(getLambdaBody(ast), n, u)) + "}");
  };

  specialAnnotations = ['type', 'dataType', 'define'];

  arrayify = function(cons) {
    if (cons instanceof Leisure_cons) {
      return cons.map(function(el) {
        return arrayify(el);
      }).toArray();
    } else {
      return cons;
    }
  };

  getLambdaProperties = function(body, props) {
    var value;

    if (body instanceof Leisure_anno) {
      if (!_.contains(specialAnnotations, getAnnoName(body))) {
        if (!props) {
          props = {};
        }
        value = getAnnoData(body);
        props[getAnnoName(body)] = arrayify(value);
      }
      getLambdaProperties(getAnnoBody(body), props);
    }
    return props;
  };

  addLambdaProperties = function(ast, def) {
    var props;

    props = getLambdaProperties(getLambdaBody(ast));
    if (props) {
      return "setLambdaProperties(" + def + ", " + (JSON.stringify(props)) + ")";
    } else {
      return def;
    }
  };

  lcons = function(a, b) {
    return rz(L_cons)(lz(a))(lz(b));
  };

  lconsFrom = function(array) {
    var el, p, _i, _len, _ref3;

    if (array instanceof Array) {
      p = rz(L_nil);
      _ref3 = array.reverse();
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        el = _ref3[_i];
        p = lcons(lconsFrom(el), p);
      }
      return p;
    } else {
      return array;
    }
  };

  assocListProps = null;

  getAssocListProps = function() {
    if (!assocListProps) {
      assocListProps = lcons(lcons('assoc', 'true'), rz(L_nil));
      assocListProps.properties = assocListProps;
    }
    return assocListProps;
  };

  lacons = function(key, value, list) {
    var alist;

    alist = lcons(lcons(key, value), list);
    alist.properties = getAssocListProps();
    return alist;
  };

  global.setLambdaProperties = function(def, props) {
    var k, p, v;

    p = rz(L_nil);
    for (k in props) {
      v = props[k];
      p = lacons(k, lconsFrom(v), p);
    }
    def.properties = p;
    return def;
  };

  memoize = function(func) {
    return "function(){return " + func + "}";
  };

  dumpAnno = function(ast) {
    if (ast instanceof Leisure_anno) {
      return dumpAnno(getAnnoBody(ast));
    } else {
      return ast;
    }
  };

  genApply = function(ast, names, uniq) {
    var args;

    args = [];
    while (dumpAnno(ast) instanceof Leisure_apply) {
      args.push("(" + (genApplyArg(getApplyArg(dumpAnno(ast)), names, uniq)) + ")");
      ast = getApplyFunc(dumpAnno(ast));
    }
    args.reverse();
    return "" + (genUniq(ast, names, uniq)) + ".leisureCall(" + (args.join(', ')) + ")";
  };

  genApplyArg = function(arg, names, uniq) {
    if (dumpAnno(arg) instanceof Leisure_apply) {
      return memoize(genUniq(arg, names, uniq));
    } else if (arg instanceof Leisure_ref) {
      return uniqName(getRefName(arg), uniq);
    } else if (arg instanceof Leisure_lit) {
      return "" + (JSON.stringify(getLitVal(arg)));
    } else if (arg instanceof Leisure_let) {
      return "function(){" + (genLets(arg, names, uniq)) + "}";
    } else if (dumpAnno(arg) instanceof Leisure_lambda) {
      return "lazy(" + (genUniq(arg, names, uniq)) + ")";
    } else {
      return "function(){return " + (genUniq(arg, names, uniq)) + "}";
    }
  };

  genLets = function(ast, names, uniq) {
    var assigns, decs, _ref3;

    _ref3 = _.foldl(letList(ast, []), (function(result, l) {
      var code, letName, letNames, n, newU, u;

      n = result[0], u = result[1], letNames = result[2], code = result[3];
      newU = addUniq(getLetName(l), n, u);
      letName = uniqName(getLetName(l), newU);
      return [cons(getLetName(l), n), newU, cons(letName, letNames), cons('\n' + letName + ' = ' + genApplyArg(getLetValue(l), n, u), code)];
    }), [names, uniq, Nil, Nil]), names = _ref3[0], uniq = _ref3[1], decs = _ref3[2], assigns = _ref3[3];
    return "\nvar " + (decs.join(', ')) + ";\n" + (assigns.join(';\n')) + ";\nreturn " + (genUniq(getLastLetBody(ast), names, uniq));
  };

  addUniq = function(name, names, uniq) {
    var num, overrides;

    if ((names.find(function(el) {
      return el === name;
    })) !== Nil) {
      overrides = uniq[0], num = uniq[1];
      return [cons(cons(name, "" + name + "_" + num), overrides), num + 1];
    } else {
      return uniq;
    }
  };

  uniqName = function(name, uniq) {
    var kv;

    uniq = uniq[0];
    kv = uniq.find((function(el) {
      return el.head() === name;
    }), uniq);
    return varNameSub((kv !== Nil ? kv.tail() : name));
  };

  letList = function(ast, buf) {
    if (ast instanceof Leisure_let) {
      buf.push(ast);
      return letList(getLetBody(ast), buf);
    } else {
      return buf;
    }
  };

  getLastLetBody = function(ast) {
    if (ast instanceof Leisure_let) {
      return getLastLetBody(getLetBody(ast));
    } else {
      return ast;
    }
  };

  define('runAst', lz(function(ast) {
    var err;

    try {
      return eval("(" + (gen(rz(ast))) + ")");
    } catch (_error) {
      err = _error;
      return rz(L_parseErr)(lz("\n\nParse error: " + err.toString() + "\nAST: "))(ast);
    }
  }));

  curry = function(func, args, pos) {
    if (pos === func.length) {
      return func.apply(null, args.toArray(func.length - 1, []));
    } else {
      return function(arg) {
        return curry(func, simpyCons(arg, args), pos + 1);
      };
    }
  };

  Function.prototype.leisureCall = function() {
    var a, args, f, next, pos;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (args.length === this.length) {
      return this.apply(null, args);
    } else {
      pos = 0;
      f = this;
      while (pos < args.length) {
        next = pos + f.length;
        if (next <= args.length) {
          f = f.apply(null, args.slice(pos, next));
        } else {
          a = args.slice(pos);
          return function() {
            var newArgs;

            newArgs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            return f.leisureCall.apply(f, a.concat(newArgs));
          };
        }
        pos = next;
      }
      return f;
    }
  };

  root.gen = gen;

  root.curry = curry;

}).call(this);

/*
*/

})(self)
},{"./ast":1,"./base":2,"./lodash.min":6,"./runtime":10}],5:[function(require,module,exports){
L_runMonads([
  function(){return resolve(L_define)("true")(0)("true = \\a b . a")(lazy(setDataType(setType(function(L_a){return function(L_b){return resolve(L_a)}}, 'true'), 'true')))},
  function(){return resolve(L_define)("false")(0)("false = \\a b . b")(lazy(setDataType(setType(function(L_a){return function(L_b){return resolve(L_b)}}, 'false'), 'false')))},
  function(){return resolve(L_define)("not")(1)("not b = b false true")(lazy(function(L_b){return resolve(L_b)(L_false)(L_true)}))},
  function(){return resolve(L_define)("and")(2)("and a b = a b false")(lazy(function(L_a){return function(L_b){return resolve(L_a)(L_b)(L_false)}}))},
  function(){return resolve(L_define)("or")(2)("or a b = a true b")(lazy(function(L_a){return function(L_b){return resolve(L_a)(L_true)(L_b)}}))},
  function(){return resolve(L_define)("some")(1)("some x = \\someCase noneCase . someCase x")(lazy(setDataType(function(L_x){return setType(function(L_someCase){return function(L_noneCase){return resolve(L_someCase)(L_x)}}, 'some')}, 'some')))},
  function(){return resolve(L_define)("some2")(2)("some2 a b = \\someCase noneCase . someCase a b")(lazy(setDataType(function(L_a){return function(L_b){return setType(function(L_someCase){return function(L_noneCase){return resolve(L_someCase)(L_a)(L_b)}}, 'some2')}}, 'some2')))},
  function(){return resolve(L_define)("none")(0)("none = \\someCase noneCase . noneCase")(lazy(setDataType(setType(function(L_someCase){return function(L_noneCase){return resolve(L_noneCase)}}, 'none'), 'none')))},
  function(){return resolve(L_define)("isNone")(1)("isNone obj = hasType obj none")(lazy(function(L_obj){return resolve(L_hasType)(L_obj)(L_none)}))},
  function(){return resolve(L_define)("isSome")(1)("isSome obj = hasType obj some")(lazy(function(L_obj){return resolve(L_hasType)(L_obj)(L_some)}))},
  function(){return resolve(L_define)("isSome2")(1)("isSome2 obj = hasType obj some2")(lazy(function(L_obj){return resolve(L_hasType)(L_obj)(L_some2)}))},
  function(){return resolve(L_define)("neq")(2)("neq a b = not (eq a b)")(lazy(function(L_a){return function(L_b){return resolve(L_not)(function(){return resolve(L_eq)(L_a)(L_b)})}}))},
  function(){return resolve(L_define)("left")(1)("left x = \\lCase rCase . lCase x")(lazy(setDataType(function(L_x){return setType(function(L_lCase){return function(L_rCase){return resolve(L_lCase)(L_x)}}, 'left')}, 'left')))},
  function(){return resolve(L_define)("right")(1)("right x = \\lCase rCase . rCase x")(lazy(setDataType(function(L_x){return setType(function(L_lCase){return function(L_rCase){return resolve(L_rCase)(L_x)}}, 'right')}, 'right')))},
  function(){return resolve(L_define)("strAsc")(1)("strAsc string = _strAsc (assertType 'strAsc string' '*string' string)")(lazy(function(L_string){return resolve(L__strAsc)(function(){return resolve(L_assertType)("strAsc string")("*string")(L_string)})}))},
  function(){return resolve(L_define)("strChr")(1)("strChr ascii = _strChr (assertType 'strChr string' '*number' ascii)")(lazy(function(L_ascii){return resolve(L__strChr)(function(){return resolve(L_assertType)("strChr string")("*number")(L_ascii)})}))},
  function(){return resolve(L_define)("strAt")(2)("strAt string index = _strAt\n  assertType 'strAt string' '*string' string\n  assertType 'strAt index' '*number' index")(lazy(function(L_string){return function(L_index){return resolve(L__strAt)(function(){return resolve(L_assertType)("strAt string")("*string")(L_string)})(function(){return resolve(L_assertType)("strAt index")("*number")(L_index)})}}))},
  function(){return resolve(L_define)("strStartsWith")(2)("strStartsWith string prefix = _strStartsWith\n  assertType 'strStartsWith string' '*string' string\n  assertType 'strStartsWith prefix' '*string' prefix")(lazy(function(L_string){return function(L_prefix){return resolve(L__strStartsWith)(function(){return resolve(L_assertType)("strStartsWith string")("*string")(L_string)})(function(){return resolve(L_assertType)("strStartsWith prefix")("*string")(L_prefix)})}}))},
  function(){return resolve(L_define)("strLen")(1)("strLen string = _strLen (assertType 'strLen string' '*string' string)")(lazy(function(L_string){return resolve(L__strLen)(function(){return resolve(L_assertType)("strLen string")("*string")(L_string)})}))},
  function(){return resolve(L_define)("strToLowerCase")(1)("strToLowerCase string = _strToLowerCase (assertType 'strToLowerCase string' '*string' string)")(lazy(function(L_string){return resolve(L__strToLowerCase)(function(){return resolve(L_assertType)("strToLowerCase string")("*string")(L_string)})}))},
  function(){return resolve(L_define)("strToUpperCase")(1)("strToUpperCase string = _strToUpperCase (assertType 'strToUpperCase string' '*string' string)")(lazy(function(L_string){return resolve(L__strToUpperCase)(function(){return resolve(L_assertType)("strToUpperCase string")("*string")(L_string)})}))},
  function(){return resolve(L_define)("strReplace")(3)("strReplace string pat repl = _strReplace\n  assertType 'strReplace string' '*string' string\n  assert (or (hasType pat '*string') (hasType pat '*RegExp')) (strCat (cons 'strStartsWith pat should be type string or RegExp but it is type ' (cons (getType pat) (cons ': ' (cons (show pat) nil))))) pat\n  assertType 'strReplace repl' '*string' repl")(lazy(function(L_string){return function(L_pat){return function(L_repl){return resolve(L__strReplace)(function(){return resolve(L_assertType)("strReplace string")("*string")(L_string)})(function(){return resolve(L_assert)(function(){return resolve(L_or)(function(){return resolve(L_hasType)(L_pat)("*string")})(function(){return resolve(L_hasType)(L_pat)("*RegExp")})})(function(){return resolve(L_strCat)(function(){return resolve(L_cons)("strStartsWith pat should be type string or RegExp but it is type ")(function(){return resolve(L_cons)(function(){return resolve(L_getType)(L_pat)})(function(){return resolve(L_cons)(": ")(function(){return resolve(L_cons)(function(){return resolve(L_show)(L_pat)})(L_nil)})})})})})(L_pat)})(function(){return resolve(L_assertType)("strReplace repl")("*string")(L_repl)})}}}))},
  function(){return resolve(L_define)("strSubstring")(3)("strSubstring str start end = _strSubstring\n  assertType 'strSubstring str' '*string' str\n  assertType 'strSubstring start' '*number' start\n  assertType 'strSubstring end' '*number' end")(lazy(function(L_str){return function(L_start){return function(L_end){return resolve(L__strSubstring)(function(){return resolve(L_assertType)("strSubstring str")("*string")(L_str)})(function(){return resolve(L_assertType)("strSubstring start")("*number")(L_start)})(function(){return resolve(L_assertType)("strSubstring end")("*number")(L_end)})}}}))},
  function(){return resolve(L_define)("strSplit")(2)("strSplit str pat = _strSplit\n  assertType 'strSplit str' '*string' str\n  assert (or (hasType pat '*string') (hasType pat '*RegExp')) (strCat (cons 'strSplit pat should be type string or RegExp but it is type ' (cons (getType pat) (cons ': ' (cons (show pat) nil))))) pat")(lazy(function(L_str){return function(L_pat){return resolve(L__strSplit)(function(){return resolve(L_assertType)("strSplit str")("*string")(L_str)})(function(){return resolve(L_assert)(function(){return resolve(L_or)(function(){return resolve(L_hasType)(L_pat)("*string")})(function(){return resolve(L_hasType)(L_pat)("*RegExp")})})(function(){return resolve(L_strCat)(function(){return resolve(L_cons)("strSplit pat should be type string or RegExp but it is type ")(function(){return resolve(L_cons)(function(){return resolve(L_getType)(L_pat)})(function(){return resolve(L_cons)(": ")(function(){return resolve(L_cons)(function(){return resolve(L_show)(L_pat)})(L_nil)})})})})})(L_pat)})}}))},
  function(){return resolve(L_define)("strCat")(1)("strCat list = _strCat\n  assert (isList list) (strCat (cons 'strCat list should be type cons or nil but it is type ' (cons (getType list) (cons ': ' (cons list))))) list")(lazy(function(L_list){return resolve(L__strCat)(function(){return resolve(L_assert)(function(){return resolve(L_isList)(L_list)})(function(){return resolve(L_strCat)(function(){return resolve(L_cons)("strCat list should be type cons or nil but it is type ")(function(){return resolve(L_cons)(function(){return resolve(L_getType)(L_list)})(function(){return resolve(L_cons)(": ")(function(){return resolve(L_cons)(L_list)})})})})})(L_list)})}))},
  function(){return resolve(L_define)("strAdd")(2)("strAdd str1 str2 = _strAdd (assertType 'strAdd str1' '*string' str1) (assertType 'strAdd str2' '*string' str2)")(lazy(function(L_str1){return function(L_str2){return resolve(L__strAdd)(function(){return resolve(L_assertType)("strAdd str1")("*string")(L_str1)})(function(){return resolve(L_assertType)("strAdd str2")("*string")(L_str2)})}}))},
  function(){return resolve(L_define)("strMatch")(2)("strMatch str pat = _strMatch\n  assertType 'strMatch str' '*string' str\n  assert (or (hasType pat '*string') (hasType pat '*RegExp')) (strCat (cons 'strMatch pat should be type string or RegExp but it is type ' (cons (getType pat) (cons ': ' (cons (show pat) nil))))) pat")(lazy(function(L_str){return function(L_pat){return resolve(L__strMatch)(function(){return resolve(L_assertType)("strMatch str")("*string")(L_str)})(function(){return resolve(L_assert)(function(){return resolve(L_or)(function(){return resolve(L_hasType)(L_pat)("*string")})(function(){return resolve(L_hasType)(L_pat)("*RegExp")})})(function(){return resolve(L_strCat)(function(){return resolve(L_cons)("strMatch pat should be type string or RegExp but it is type ")(function(){return resolve(L_cons)(function(){return resolve(L_getType)(L_pat)})(function(){return resolve(L_cons)(": ")(function(){return resolve(L_cons)(function(){return resolve(L_show)(L_pat)})(L_nil)})})})})})(L_pat)})}}))},
  function(){return resolve(L_define)("strToList")(1)("strToList str = _strToList (assertType 'strToList str' '*string' str)")(lazy(function(L_str){return resolve(L__strToList)(function(){return resolve(L_assertType)("strToList str")("*string")(L_str)})}))},
  function(){return resolve(L_define)("strFromList")(1)("strFromList list = _strFromList\n  assert (isList list) (strCat (cons 'strFromList list should be type cons or nil but it is type ' (cons (getType list) (cons ': ' (cons list))))) list")(lazy(function(L_list){return resolve(L__strFromList)(function(){return resolve(L_assert)(function(){return resolve(L_isList)(L_list)})(function(){return resolve(L_strCat)(function(){return resolve(L_cons)("strFromList list should be type cons or nil but it is type ")(function(){return resolve(L_cons)(function(){return resolve(L_getType)(L_list)})(function(){return resolve(L_cons)(": ")(function(){return resolve(L_cons)(L_list)})})})})})(L_list)})}))},
  function(){return resolve(L_define)("regexp")(1)("regexp str = _regexp (assertType 'regexp str' '*string' str)")(lazy(function(L_str){return resolve(L__regexp)(function(){return resolve(L_assertType)("regexp str")("*string")(L_str)})}))},
  function(){return resolve(L_define)("regexpFlags")(2)("regexpFlags str flags = _regexpFlags\n  assertType 'regexp str' '*string' str\n  assertType 'regexp flags' '*string' flags")(lazy(function(L_str){return function(L_flags){return resolve(L__regexpFlags)(function(){return resolve(L_assertType)("regexp str")("*string")(L_str)})(function(){return resolve(L_assertType)("regexp flags")("*string")(L_flags)})}}))},
  function(){return resolve(L_define)("jsonParse")(3)("jsonParse str failure success = _jsonParse\n  assertType 'jsonParse str' '*string' str\n  failure\n  success")(lazy(function(L_str){return function(L_failure){return function(L_success){return resolve(L__jsonParse)(function(){return resolve(L_assertType)("jsonParse str")("*string")(L_str)})(L_failure)(L_success)}}}))},
  function(){return resolve(L_define)("show")(1)("show x = _show x")(lazy(function(L_x){return resolve(L__show)(L_x)}))},
  function(){return resolve(L_define)("id")(1)("id x = x")(lazy(function(L_x){return resolve(L_x)}))},
  function(){return resolve(L_define)("compose")(2)("compose f g = \\x . f (g x)")(lazy(setDataType(function(L_f){return function(L_g){return setType(function(L_x){return resolve(L_f)(function(){return resolve(L_g)(L_x)})}, 'compose')}}, 'compose')))},
  function(){return resolve(L_define)("flip")(1)("flip func = \\x y . func y x")(lazy(setDataType(function(L_func){return setType(function(L_x){return function(L_y){return resolve(L_func)(L_y)(L_x)}}, 'flip')}, 'flip')))},
  function(){return resolve(L_define)("cons")(2)("cons a b = \\f . f a b")(lazy(setDataType(function(L_a){return function(L_b){return setType(function(L_f){return resolve(L_f)(L_a)(L_b)}, 'cons')}}, 'cons')))},
  function(){return resolve(L_define)("isCons")(1)("isCons c = hasType c cons")(lazy(function(L_c){return resolve(L_hasType)(L_c)(L_cons)}))},
  function(){return resolve(L_define)("isList")(1)("isList l = or (hasType l cons) (hasType l nil)")(lazy(function(L_l){return resolve(L_or)(function(){return resolve(L_hasType)(L_l)(L_cons)})(function(){return resolve(L_hasType)(L_l)(L_nil)})}))},
  function(){return resolve(L_define)("assertType")(3)("assertType msg type value = assert (hasType value type) (strCat (cons msg (cons ' should be type ' (cons (getDataType type) (cons ', but its type is ' (cons (getType value) (cons ': ' (cons (show value) nil)))))))) value")(lazy(function(L_msg){return function(L_type){return function(L_value){return resolve(L_assert)(function(){return resolve(L_hasType)(L_value)(L_type)})(function(){return resolve(L_strCat)(function(){return resolve(L_cons)(L_msg)(function(){return resolve(L_cons)(" should be type ")(function(){return resolve(L_cons)(function(){return resolve(L_getDataType)(L_type)})(function(){return resolve(L_cons)(", but its type is ")(function(){return resolve(L_cons)(function(){return resolve(L_getType)(L_value)})(function(){return resolve(L_cons)(": ")(function(){return resolve(L_cons)(function(){return resolve(L_show)(L_value)})(L_nil)})})})})})})})})(L_value)}}}))},
  function(){return resolve(L_define)("nil")(0)("nil = \\a b . b")(lazy(setDataType(setType(function(L_a){return function(L_b){return resolve(L_b)}}, 'nil'), 'nil')))},
  function(){return resolve(L_define)("isNil")(1)("isNil n = hasType n nil")(lazy(function(L_n){return resolve(L_hasType)(L_n)(L_nil)}))},
  function(){return resolve(L_define)("head")(1)("head l = l \\h t . h")(lazy(function(L_l){return resolve(L_l)(lazy(function(L_h){return function(L_t){return resolve(L_h)}}))}))},
  function(){return resolve(L_define)("tail")(1)("tail l = l \\h t . t")(lazy(function(L_l){return resolve(L_l)(lazy(function(L_h){return function(L_t){return resolve(L_t)}}))}))},
  function(){return resolve(L_define)("last")(1)("last l = isNil (tail l)\n  head l\n  last (tail l)")(lazy(function(L_l){return resolve(L_isNil)(function(){return resolve(L_tail)(L_l)})(function(){return resolve(L_head)(L_l)})(function(){return resolve(L_last)(function(){return resolve(L_tail)(L_l)})})}))},
  function(){return resolve(L_define)("removeLast")(1)("removeLast l = isNil (tail l)\n  nil\n  cons (head l) (removeLast (tail l))")(lazy(function(L_l){return resolve(L_isNil)(function(){return resolve(L_tail)(L_l)})(L_nil)(function(){return resolve(L_cons)(function(){return resolve(L_head)(L_l)})(function(){return resolve(L_removeLast)(function(){return resolve(L_tail)(L_l)})})})}))},
  function(){return resolve(L_define)("length")(1)("length list = isCons list\n  + 1 (length (tail list))\n  0")(lazy(function(L_list){return resolve(L_isCons)(L_list)(function(){return resolve(L_$o)(1)(function(){return resolve(L_length)(function(){return resolve(L_tail)(L_list)})})})(0)}))},
  function(){return resolve(L_define)("append")(2)("append a b = isNil a\n  b\n  cons (head a) (append (tail a) b)")(lazy(function(L_a){return function(L_b){return resolve(L_isNil)(L_a)(L_b)(function(){return resolve(L_cons)(function(){return resolve(L_head)(L_a)})(function(){return resolve(L_append)(function(){return resolve(L_tail)(L_a)})(L_b)})})}}))},
  function(){return resolve(L_define)("flatten")(1)("flatten list = isCons list\n  subflatten list nil\n  list")(lazy(function(L_list){return resolve(L_isCons)(L_list)(function(){return resolve(L_subflatten)(L_list)(L_nil)})(L_list)}))},
  function(){return resolve(L_define)("subflatten")(2)("subflatten list result = isNil list\n  result\n  isCons list\n    subflatten (head list) (subflatten (tail list) result)\n    cons list result")(lazy(function(L_list){return function(L_result){return resolve(L_isNil)(L_list)(L_result)(function(){return resolve(L_isCons)(L_list)(function(){return resolve(L_subflatten)(function(){return resolve(L_head)(L_list)})(function(){return resolve(L_subflatten)(function(){return resolve(L_tail)(L_list)})(L_result)})})(function(){return resolve(L_cons)(L_list)(L_result)})})}}))},
  function(){return resolve(L_define)("reverse")(1)("reverse l = rev l nil")(lazy(function(L_l){return resolve(L_rev)(L_l)(L_nil)}))},
  function(){return resolve(L_define)("rev")(2)("rev l result = isNil l\n  result\n  rev (tail l) (cons (head l) result)")(lazy(function(L_l){return function(L_result){return resolve(L_isNil)(L_l)(L_result)(function(){return resolve(L_rev)(function(){return resolve(L_tail)(L_l)})(function(){return resolve(L_cons)(function(){return resolve(L_head)(L_l)})(L_result)})})}}))},
  function(){return resolve(L_define)("filter")(2)("filter func list = isNil list\n  nil\n  func (head list) (cons (head list)) id (filter func (tail list))")(lazy(function(L_func){return function(L_list){return resolve(L_isNil)(L_list)(L_nil)(function(){return resolve(L_func)(function(){return resolve(L_head)(L_list)})(function(){return resolve(L_cons)(function(){return resolve(L_head)(L_list)})})(L_id)(function(){return resolve(L_filter)(L_func)(function(){return resolve(L_tail)(L_list)})})})}}))},
  function(){return resolve(L_define)("find")(2)("find predicate list = isNil list\n  none\n  predicate (head list) (some (head list)) (find predicate (tail list))")(lazy(function(L_predicate){return function(L_list){return resolve(L_isNil)(L_list)(L_none)(function(){return resolve(L_predicate)(function(){return resolve(L_head)(L_list)})(function(){return resolve(L_some)(function(){return resolve(L_head)(L_list)})})(function(){return resolve(L_find)(L_predicate)(function(){return resolve(L_tail)(L_list)})})})}}))},
  function(){return resolve(L_define)("contains")(2)("contains list item = find (\\el . eq el item) list (\\x . true) false")(lazy(function(L_list){return function(L_item){return resolve(L_find)(lazy(function(L_el){return resolve(L_eq)(L_el)(L_item)}))(L_list)(lazy(function(L_x){return resolve(L_true)}))(L_false)}}))},
  function(){return resolve(L_define)("map")(2)("map func l = isNil l\n  nil\n  cons (func (head l)) (map func (tail l))")(lazy(function(L_func){return function(L_l){return resolve(L_isNil)(L_l)(L_nil)(function(){return resolve(L_cons)(function(){return resolve(L_func)(function(){return resolve(L_head)(L_l)})})(function(){return resolve(L_map)(L_func)(function(){return resolve(L_tail)(L_l)})})})}}))},
  function(){return resolve(L_define)("mapSave")(2)("mapSave func l = isNil l\n  nil\n  \\\\\n    newH = func (head l)\n    newT = mapSave func (tail l)\n    .\n    and (eq newH (head l)) (eq newT (tail l))\n      l\n      cons newH newT")(lazy(function(L_func){return function(L_l){return resolve(L_isNil)(L_l)(L_nil)(function(){
var L_newT, L_newH;

L_newT = function(){return resolve(L_mapSave)(L_func)(function(){return resolve(L_tail)(L_l)})};

L_newH = function(){return resolve(L_func)(function(){return resolve(L_head)(L_l)})};
return resolve(L_and)(function(){return resolve(L_eq)(L_newH)(function(){return resolve(L_head)(L_l)})})(function(){return resolve(L_eq)(L_newT)(function(){return resolve(L_tail)(L_l)})})(L_l)(function(){return resolve(L_cons)(L_newH)(L_newT)})})}}))},
  function(){return resolve(L_define)("foldl")(3)("foldl func initialValue l = l (\\h t D . foldl func (func initialValue h) t) initialValue")(lazy(function(L_func){return function(L_initialValue){return function(L_l){return resolve(L_l)(lazy(function(L_h){return function(L_t){return function(L_D){return resolve(L_foldl)(L_func)(function(){return resolve(L_func)(L_initialValue)(L_h)})(L_t)}}}))(L_initialValue)}}}))},
  function(){return resolve(L_define)("foldl1")(2)("foldl1 func l = l \\h t . foldl func h t")(lazy(function(L_func){return function(L_l){return resolve(L_l)(lazy(function(L_h){return function(L_t){return resolve(L_foldl)(L_func)(L_h)(L_t)}}))}}))},
  function(){return resolve(L_define)("foldr")(3)("foldr func initialValue list = list\n  \\h t D . func h (foldr func initialValue t)\n  initialValue")(lazy(function(L_func){return function(L_initialValue){return function(L_list){return resolve(L_list)(lazy(function(L_h){return function(L_t){return function(L_D){return resolve(L_func)(L_h)(function(){return resolve(L_foldr)(L_func)(L_initialValue)(L_t)})}}}))(L_initialValue)}}}))},
  function(){return resolve(L_define)("foldr1")(2)("foldr1 func list = list \\h t . isNil t\n  h\n  func h (foldr1 func t)")(lazy(function(L_func){return function(L_list){return resolve(L_list)(lazy(function(L_h){return function(L_t){return resolve(L_isNil)(L_t)(L_h)(function(){return resolve(L_func)(L_h)(function(){return resolve(L_foldr1)(L_func)(L_t)})})}}))}}))},
  function(){return resolve(L_define)("intersperse")(2)("intersperse list element = list (\\h t D .\n  isNil t\n    list\n    cons h (cons element (intersperse t element))) nil")(lazy(function(L_list){return function(L_element){return resolve(L_list)(lazy(function(L_h){return function(L_t){return function(L_D){return resolve(L_isNil)(L_t)(L_list)(function(){return resolve(L_cons)(L_h)(function(){return resolve(L_cons)(L_element)(function(){return resolve(L_intersperse)(L_t)(L_element)})})})}}}))(L_nil)}}))},
  function(){return resolve(L_define)("join")(2)("join list el = strCat (intersperse list el)")(lazy(function(L_list){return function(L_el){return resolve(L_strCat)(function(){return resolve(L_intersperse)(L_list)(L_el)})}}))},
  function(){return resolve(L_define)("findIndex")(2)("findIndex func list = idx list func 0")(lazy(function(L_func){return function(L_list){return resolve(L_idx)(L_list)(L_func)(0)}}))},
  function(){return resolve(L_define)("idx")(3)("idx list func pos = list\n  \\h t D . func h\n    pos\n    idx t func (+ 1 pos)\n  -1")(lazy(function(L_list){return function(L_func){return function(L_pos){return resolve(L_list)(lazy(function(L_h){return function(L_t){return function(L_D){return resolve(L_func)(L_h)(L_pos)(function(){return resolve(L_idx)(L_t)(L_func)(function(){return resolve(L_$o)(1)(L_pos)})})}}}))(-1)}}}))},
  function(){return resolve(L_define)("index")(2)("index list el = find (\\item . == el item) list")(lazy(function(L_list){return function(L_el){return resolve(L_find)(lazy(function(L_item){return resolve(L_$p$p)(L_el)(L_item)}))(L_list)}}))},
  function(){return resolve(L_define)("assertAlist")(3)("assertAlist msg value result = assert (isAlist value) (strCat (cons msg (cons ' should be a association list, but it is not; its type is ' (cons (getType value) (cons ': ' (cons (show value) nil)))))) result")(lazy(function(L_msg){return function(L_value){return function(L_result){return resolve(L_assert)(function(){return resolve(L_isAlist)(L_value)})(function(){return resolve(L_strCat)(function(){return resolve(L_cons)(L_msg)(function(){return resolve(L_cons)(" should be a association list, but it is not; its type is ")(function(){return resolve(L_cons)(function(){return resolve(L_getType)(L_value)})(function(){return resolve(L_cons)(": ")(function(){return resolve(L_cons)(function(){return resolve(L_show)(L_value)})(L_nil)})})})})})})(L_result)}}}))},
  function(){return resolve(L_define)("acons")(3)("acons k v alist = assertAlist \"acons alist\" alist (\\@ type cons . \\f . \\@ assoc true . f (cons k v) alist)")(lazy(function(L_k){return function(L_v){return function(L_alist){return resolve(L_assertAlist)("acons alist")(L_alist)(lazy(setType(setLambdaProperties(function(L_f){return resolve(L_f)(function(){return resolve(L_cons)(L_k)(L_v)})(L_alist)}, {"assoc":"true"}), 'cons')))}}}))},
  function(){return resolve(L_define)("assoc")(2)("assoc k alist  = find (\\el . eq k (head el)) alist (\\cell . cell \\head tail . some tail) none")(lazy(function(L_k){return function(L_alist){return resolve(L_find)(lazy(function(L_el){return resolve(L_eq)(L_k)(function(){return resolve(L_head)(L_el)})}))(L_alist)(lazy(function(L_cell){return resolve(L_cell)(lazy(function(L_head){return function(L_tail){return resolve(L_some)(L_tail)}}))}))(L_none)}}))},
  function(){return resolve(L_define)("rassoc")(2)("rassoc v alist = find (\\el . eq v (tail el)) alist (\\cell . cell \\head tail . some head) none")(lazy(function(L_v){return function(L_alist){return resolve(L_find)(lazy(function(L_el){return resolve(L_eq)(L_v)(function(){return resolve(L_tail)(L_el)})}))(L_alist)(lazy(function(L_cell){return resolve(L_cell)(lazy(function(L_head){return function(L_tail){return resolve(L_some)(L_head)}}))}))(L_none)}}))},
  function(){return resolve(L_define)("isAlist")(1)("isAlist obj = or (isNil obj) (hasProperty obj 'assoc')")(lazy(function(L_obj){return resolve(L_or)(function(){return resolve(L_isNil)(L_obj)})(function(){return resolve(L_hasProperty)(L_obj)("assoc")})}))},
  function(){return resolve(L_define)("aconsPair")(2)("aconsPair keyValue list = \\@ type cons . \\f . \\@ assoc true . f keyValue list")(lazy(function(L_keyValue){return function(L_list){return setType(setLambdaProperties(function(L_f){return resolve(L_f)(L_keyValue)(L_list)}, {"assoc":"true"}), 'cons')}}))},
  function(){return resolve(L_define)("appendAlist")(2)("appendAlist a b = isNil a\n  b\n  aconsPair (head a) (appendAlist (tail a) b)")(lazy(function(L_a){return function(L_b){return resolve(L_isNil)(L_a)(L_b)(function(){return resolve(L_aconsPair)(function(){return resolve(L_head)(L_a)})(function(){return resolve(L_appendAlist)(function(){return resolve(L_tail)(L_a)})(L_b)})})}}))},
  function(){return resolve(L_define)("keys")(1)("keys list = map (\\l . head l) list")(lazy(function(L_list){return resolve(L_map)(lazy(function(L_l){return resolve(L_head)(L_l)}))(L_list)}))},
  function(){return resolve(L_define)("getProperty")(2)("getProperty func prop = getProperties func\n  \\props . assoc prop props\n  none")(lazy(function(L_func){return function(L_prop){return resolve(L_getProperties)(L_func)(lazy(function(L_props){return resolve(L_assoc)(L_prop)(L_props)}))(L_none)}}))},
  function(){return resolve(L_define)("hasProperty")(2)("hasProperty func prop = getProperty func prop\n  \\_ . true\n  false")(lazy(function(L_func){return function(L_prop){return resolve(L_getProperty)(L_func)(L_prop)(lazy(function(L__){return resolve(L_true)}))(L_false)}}))},
  function(){return resolve(L_define)("quicksort")(2)("quicksort less list = (qs less list) nil")(lazy(function(L_less){return function(L_list){return resolve(L_qs)(L_less)(L_list)(L_nil)}}))},
  function(){return resolve(L_define)("qs")(2)("qs sortedFunc list = list\n  \\h t D . \\\\\n    greater = filter (sortedFunc h) t\n    lesser = filter (compose not (sortedFunc h)) t\n    .\n    \\rest . (qs sortedFunc lesser) (cons h ((qs sortedFunc greater) rest))\n  id")(lazy(function(L_sortedFunc){return function(L_list){return resolve(L_list)(lazy(function(L_h){return function(L_t){return function(L_D){return (function(){

var L_lesser, L_greater;

L_lesser = function(){return resolve(L_filter)(function(){return resolve(L_compose)(L_not)(function(){return resolve(L_sortedFunc)(L_h)})})(L_t)};

L_greater = function(){return resolve(L_filter)(function(){return resolve(L_sortedFunc)(L_h)})(L_t)};
return function(L_rest){return resolve(L_qs)(L_sortedFunc)(L_lesser)(function(){return resolve(L_cons)(L_h)(function(){return resolve(L_qs)(L_sortedFunc)(L_greater)(L_rest)})})}})()}}}))(L_id)}}))},
  function(){return resolve(L_define)("insertSorted")(3)("insertSorted sortFunc item list = list\n  \\h t D . sortFunc item h (cons item list) (cons h (insertSorted sortFunc item t))\n  cons item nil")(lazy(function(L_sortFunc){return function(L_item){return function(L_list){return resolve(L_list)(lazy(function(L_h){return function(L_t){return function(L_D){return resolve(L_sortFunc)(L_item)(L_h)(function(){return resolve(L_cons)(L_item)(L_list)})(function(){return resolve(L_cons)(L_h)(function(){return resolve(L_insertSorted)(L_sortFunc)(L_item)(L_t)})})}}}))(function(){return resolve(L_cons)(L_item)(L_nil)})}}}))},
  function(){return resolve(L_define)("token")(2)("token txt pos = \\f . f txt pos")(lazy(setDataType(function(L_txt){return function(L_pos){return setType(function(L_f){return resolve(L_f)(L_txt)(L_pos)}, 'token')}}, 'token')))},
  function(){return resolve(L_define)("tokenString")(1)("tokenString tok = tok \\t p . t")(lazy(function(L_tok){return resolve(L_tok)(lazy(function(L_t){return function(L_p){return resolve(L_t)}}))}))},
  function(){return resolve(L_define)("tokenPos")(1)("tokenPos tok = tok \\t p . p")(lazy(function(L_tok){return resolve(L_tok)(lazy(function(L_t){return function(L_p){return resolve(L_p)}}))}))},
  function(){return resolve(L_define)("isToken")(1)("isToken t = hasType t token")(lazy(function(L_t){return resolve(L_hasType)(L_t)(L_token)}))},
  function(){return resolve(L_define)("parens")(3)("parens start end content = \\f . f start end content")(lazy(setDataType(function(L_start){return function(L_end){return function(L_content){return setType(function(L_f){return resolve(L_f)(L_start)(L_end)(L_content)}, 'parens')}}}, 'parens')))},
  function(){return resolve(L_define)("parensStart")(1)("parensStart p = p \\s e c . s")(lazy(function(L_p){return resolve(L_p)(lazy(function(L_s){return function(L_e){return function(L_c){return resolve(L_s)}}}))}))},
  function(){return resolve(L_define)("parensEnd")(1)("parensEnd p = p \\s e c . e")(lazy(function(L_p){return resolve(L_p)(lazy(function(L_s){return function(L_e){return function(L_c){return resolve(L_e)}}}))}))},
  function(){return resolve(L_define)("parensContent")(1)("parensContent p = p \\s e c . c")(lazy(function(L_p){return resolve(L_p)(lazy(function(L_s){return function(L_e){return function(L_c){return resolve(L_c)}}}))}))},
  function(){return resolve(L_define)("isParens")(1)("isParens p = hasType p parens")(lazy(function(L_p){return resolve(L_hasType)(L_p)(L_parens)}))},
  function(){return resolve(L_define)("makeParens")(3)("makeParens start end content =\n  and (isCons content) (isNil (tail content))\n    makeParens start end (head content)\n    or (isToken content) (isParens content)\n      content\n      parens start end content")(lazy(function(L_start){return function(L_end){return function(L_content){return resolve(L_and)(function(){return resolve(L_isCons)(L_content)})(function(){return resolve(L_isNil)(function(){return resolve(L_tail)(L_content)})})(function(){return resolve(L_makeParens)(L_start)(L_end)(function(){return resolve(L_head)(L_content)})})(function(){return resolve(L_or)(function(){return resolve(L_isToken)(L_content)})(function(){return resolve(L_isParens)(L_content)})(L_content)(function(){return resolve(L_parens)(L_start)(L_end)(L_content)})})}}}))},
  function(){return resolve(L_define)("parensFromToks")(3)("parensFromToks left right content = \\\\\n  start = tokenPos left\n  end = + (tokenPos right) (strLen (tokenString right))\n  .\n  parens start end content")(lazy(function(L_left){return function(L_right){return function(L_content){return (function(){

var L_end, L_start;

L_end = function(){return resolve(L_$o)(function(){return resolve(L_tokenPos)(L_right)})(function(){return resolve(L_strLen)(function(){return resolve(L_tokenString)(L_right)})})};

L_start = function(){return resolve(L_tokenPos)(L_left)};
return resolve(L_parens)(L_start)(L_end)(L_content)})()}}}))},
  function(){return resolve(L_define)("stripParens")(1)("stripParens p = isParens p (parensContent p) p")(lazy(function(L_p){return resolve(L_isParens)(L_p)(function(){return resolve(L_parensContent)(L_p)})(L_p)}))},
  function(){return resolve(L_define)("parseErr")(2)("parseErr msg1 msg2 = \\f . f (strCat (cons msg1 (cons msg2 nil)))")(lazy(setDataType(function(L_msg1){return function(L_msg2){return setType(function(L_f){return resolve(L_f)(function(){return resolve(L_strCat)(function(){return resolve(L_cons)(L_msg1)(function(){return resolve(L_cons)(L_msg2)(L_nil)})})})}, 'parseErr')}}, 'parseErr')))},
  function(){return resolve(L_define)("parseErrMsg")(1)("parseErrMsg err = err \\m . m")(lazy(function(L_err){return resolve(L_err)(lazy(function(L_m){return resolve(L_m)}))}))},
  function(){return resolve(L_define)("isParseErr")(1)("isParseErr thing = hasType thing parseErr")(lazy(function(L_thing){return resolve(L_hasType)(L_thing)(L_parseErr)}))},
  function(){return resolve(L_define)("emptyToken")(0)("emptyToken = regexp '^\\\\n[ \\\\i]*(#|$)'")(function(){return resolve(L_regexp)("^\\n[ \\i]*(#|$)")})},
  function(){return resolve(L_define)("makeTokens")(2)("makeTokens strings start = strings (\\h t D . makeMoreTokens h t start) nil")(lazy(function(L_strings){return function(L_start){return resolve(L_strings)(lazy(function(L_h){return function(L_t){return function(L_D){return resolve(L_makeMoreTokens)(L_h)(L_t)(L_start)}}}))(L_nil)}}))},
  function(){return resolve(L_define)("makeMoreTokens")(3)("makeMoreTokens h t start = \\\\\n  next = makeTokens t (+ start (strLen h))\n  .\n  and (strMatches h emptyToken) (or (isNil t) (strStartsWith (head t) '\\n'))\n    makeTokens t (+ start (strLen h))\n    or (strStartsWith h ' ') (strStartsWith h '#')\n      next\n      and (strStartsWith h '\\n') (strStartsWith (head t) '#')\n        makeTokens (tail t) (+ start (+ (strLen h) (strLen (head t))))\n        cons (token h start) next")(lazy(function(L_h){return function(L_t){return function(L_start){return (function(){

var L_next;

L_next = function(){return resolve(L_makeTokens)(L_t)(function(){return resolve(L_$o)(L_start)(function(){return resolve(L_strLen)(L_h)})})};
return resolve(L_and)(function(){return resolve(L_strMatches)(L_h)(L_emptyToken)})(function(){return resolve(L_or)(function(){return resolve(L_isNil)(L_t)})(function(){return resolve(L_strStartsWith)(function(){return resolve(L_head)(L_t)})("\n")})})(function(){return resolve(L_makeTokens)(L_t)(function(){return resolve(L_$o)(L_start)(function(){return resolve(L_strLen)(L_h)})})})(function(){return resolve(L_or)(function(){return resolve(L_strStartsWith)(L_h)(" ")})(function(){return resolve(L_strStartsWith)(L_h)("#")})(L_next)(function(){return resolve(L_and)(function(){return resolve(L_strStartsWith)(L_h)("\n")})(function(){return resolve(L_strStartsWith)(function(){return resolve(L_head)(L_t)})("#")})(function(){return resolve(L_makeTokens)(function(){return resolve(L_tail)(L_t)})(function(){return resolve(L_$o)(L_start)(function(){return resolve(L_$o)(function(){return resolve(L_strLen)(L_h)})(function(){return resolve(L_strLen)(function(){return resolve(L_head)(L_t)})})})})})(function(){return resolve(L_cons)(function(){return resolve(L_token)(L_h)(L_start)})(L_next)})})})})()}}}))},
  function(){return resolve(L_define)("splitTokens")(2)("splitTokens str pat = filter (\\s . not (eq s '')) (basicSplitTokens str pat true)")(lazy(function(L_str){return function(L_pat){return resolve(L_filter)(lazy(function(L_s){return resolve(L_not)(function(){return resolve(L_eq)(L_s)("")})}))(function(){return resolve(L_basicSplitTokens)(L_str)(L_pat)(L_true)})}}))},
  function(){return resolve(L_define)("numberPat")(0)("numberPat = regexp '-?([0-9]+(\\\\.[0-9]+)?|\\\\.[0-9]+)'")(function(){return resolve(L_regexp)("-?([0-9]+(\\.[0-9]+)?|\\.[0-9]+)")})},
  function(){return resolve(L_define)("matchOffset")(2)("matchOffset str match = isNil match\n  strLen str\n  head (tail (tail match))")(lazy(function(L_str){return function(L_match){return resolve(L_isNil)(L_match)(function(){return resolve(L_strLen)(L_str)})(function(){return resolve(L_head)(function(){return resolve(L_tail)(function(){return resolve(L_tail)(L_match)})})})}}))},
  function(){return resolve(L_define)("basicSplitTokens")(3)("basicSplitTokens str pat prevIsDel = == str ''\n  nil\n  \\\\\n    num = strMatch str numberPat\n    del = strMatch str pat\n    numOffset = matchOffset str num\n    delOffset = matchOffset str del\n    select = and (== numOffset 0) prevIsDel\n      \\del num first . num\n      == delOffset 0\n        \\del num first . del\n        \\del num first . first\n    first = select (head del) (head num) (strSubstring str 0 delOffset)\n    .\n    cons\n      first\n      basicSplitTokens\n        strSubstring str (strLen first) 0\n        pat\n        select true false false")(lazy(function(L_str){return function(L_pat){return function(L_prevIsDel){return resolve(L_$p$p)(L_str)("")(L_nil)(function(){
var L_first, L_select, L_delOffset, L_numOffset, L_del, L_num;

L_first = function(){return resolve(L_select)(function(){return resolve(L_head)(L_del)})(function(){return resolve(L_head)(L_num)})(function(){return resolve(L_strSubstring)(L_str)(0)(L_delOffset)})};

L_select = function(){return resolve(L_and)(function(){return resolve(L_$p$p)(L_numOffset)(0)})(L_prevIsDel)(lazy(function(L_del_0){return function(L_num_1){return function(L_first){return resolve(L_num_1)}}}))(function(){return resolve(L_$p$p)(L_delOffset)(0)(lazy(function(L_del_0){return function(L_num_1){return function(L_first){return resolve(L_del_0)}}}))(lazy(function(L_del_0){return function(L_num_1){return function(L_first){return resolve(L_first)}}}))})};

L_delOffset = function(){return resolve(L_matchOffset)(L_str)(L_del)};

L_numOffset = function(){return resolve(L_matchOffset)(L_str)(L_num)};

L_del = function(){return resolve(L_strMatch)(L_str)(L_pat)};

L_num = function(){return resolve(L_strMatch)(L_str)(L_numberPat)};
return resolve(L_cons)(L_first)(function(){return resolve(L_basicSplitTokens)(function(){return resolve(L_strSubstring)(L_str)(function(){return resolve(L_strLen)(L_first)})(0)})(L_pat)(function(){return resolve(L_select)(L_true)(L_false)(L_false)})})})}}}))},
  function(){return resolve(L_define)("tokens")(2)("tokens str pat = makeTokens (splitTokens str pat) 0")(lazy(function(L_str){return function(L_pat){return resolve(L_makeTokens)(function(){return resolve(L_splitTokens)(L_str)(L_pat)})(0)}}))},
  function(){return resolve(L_define)("isString")(1)("isString s = == (getType s) '*string'")(lazy(function(L_s){return resolve(L_$p$p)(function(){return resolve(L_getType)(L_s)})("*string")}))},
  function(){return resolve(L_define)("isNumber")(1)("isNumber s = == (getType s) '*number'")(lazy(function(L_s){return resolve(L_$p$p)(function(){return resolve(L_getType)(L_s)})("*number")}))},
  function(){return resolve(L_define)("isTokenString")(2)("isTokenString tok str = or\n  and (isToken tok) (eq (tokenString tok) str)\n  and (isString tok) (eq tok str)")(lazy(function(L_tok){return function(L_str){return resolve(L_or)(function(){return resolve(L_and)(function(){return resolve(L_isToken)(L_tok)})(function(){return resolve(L_eq)(function(){return resolve(L_tokenString)(L_tok)})(L_str)})})(function(){return resolve(L_and)(function(){return resolve(L_isString)(L_tok)})(function(){return resolve(L_eq)(L_tok)(L_str)})})}}))},
  function(){return resolve(L_define)("isTokenStart")(2)("isTokenStart tok str = or\n  and (isToken tok) (strStartsWith (tokenString tok) str)\n  and (isString tok) (strStartsWith tok str)")(lazy(function(L_tok){return function(L_str){return resolve(L_or)(function(){return resolve(L_and)(function(){return resolve(L_isToken)(L_tok)})(function(){return resolve(L_strStartsWith)(function(){return resolve(L_tokenString)(L_tok)})(L_str)})})(function(){return resolve(L_and)(function(){return resolve(L_isString)(L_tok)})(function(){return resolve(L_strStartsWith)(L_tok)(L_str)})})}}))},
  function(){return resolve(L_define)("strTokenString")(1)("strTokenString tok = withToken tok nil \\str pos . str")(lazy(function(L_tok){return resolve(L_withToken)(L_tok)(L_nil)(lazy(function(L_str){return function(L_pos){return resolve(L_str)}}))}))},
  function(){return resolve(L_define)("withToken")(3)("withToken tok nonTokCase tokCase = isToken tok\n  tok tokCase\n  isString tok\n    tokCase tok -1\n    nonTokCase")(lazy(function(L_tok){return function(L_nonTokCase){return function(L_tokCase){return resolve(L_isToken)(L_tok)(function(){return resolve(L_tok)(L_tokCase)})(function(){return resolve(L_isString)(L_tok)(function(){return resolve(L_tokCase)(L_tok)(-1)})(L_nonTokCase)})}}}))},
  function(){return resolve(L_define)("withCons")(3)("withCons l nilCase cont = isCons l (l (\\h t D . cont h t) nilCase) nilCase")(lazy(function(L_l){return function(L_nilCase){return function(L_cont){return resolve(L_isCons)(L_l)(function(){return resolve(L_l)(lazy(function(L_h){return function(L_t){return function(L_D){return resolve(L_cont)(L_h)(L_t)}}}))(L_nilCase)})(L_nilCase)}}}))},
  function(){return resolve(L_define)("ifNotErr")(2)("ifNotErr thing cont = hasType thing parseErr thing (cont thing)")(lazy(function(L_thing){return function(L_cont){return resolve(L_hasType)(L_thing)(L_parseErr)(L_thing)(function(){return resolve(L_cont)(L_thing)})}}))},
  function(){return resolve(L_define)("parseToks")(2)("parseToks toks groups =\n  isNil toks nil\n    ifNotErr (parseTok toks groups) \\list . list \\h t .\n      ifNotErr (parseToks t groups) \\res .\n        cons h\n          and (isCons res) (isBlockStart (head res))\n            cons res nil\n            res")(lazy(function(L_toks){return function(L_groups){return resolve(L_isNil)(L_toks)(L_nil)(function(){return resolve(L_ifNotErr)(function(){return resolve(L_parseTok)(L_toks)(L_groups)})(lazy(function(L_list){return resolve(L_list)(lazy(function(L_h){return function(L_t){return resolve(L_ifNotErr)(function(){return resolve(L_parseToks)(L_t)(L_groups)})(lazy(function(L_res){return resolve(L_cons)(L_h)(function(){return resolve(L_and)(function(){return resolve(L_isCons)(L_res)})(function(){return resolve(L_isBlockStart)(function(){return resolve(L_head)(L_res)})})(function(){return resolve(L_cons)(L_res)(L_nil)})(L_res)})}))}}))}))})}}))},
  function(){return resolve(L_define)("parseTok")(2)("parseTok toks groups = withCons toks nil \\h t .\n  withToken h toks \\txt pos .\n    assoc txt groups\n      \\close . parseGroup h t nil close groups\n      isTokenStart h '\\n' (parseIndent h t nil groups)\n        toks")(lazy(function(L_toks){return function(L_groups){return resolve(L_withCons)(L_toks)(L_nil)(lazy(function(L_h){return function(L_t){return resolve(L_withToken)(L_h)(L_toks)(lazy(function(L_txt){return function(L_pos){return resolve(L_assoc)(L_txt)(L_groups)(lazy(function(L_close){return resolve(L_parseGroup)(L_h)(L_t)(L_nil)(L_close)(L_groups)}))(function(){return resolve(L_isTokenStart)(L_h)("\n")(function(){return resolve(L_parseIndent)(L_h)(L_t)(L_nil)(L_groups)})(L_toks)})}}))}}))}}))},
  function(){return resolve(L_define)("parseGroup")(5)("parseGroup left toks gr close groups = withCons toks (parseErr 'Unterminated group starting ' (loc left))\n  \\h t . isTokenString h close\n    eq close ')'\n      cons (parensFromToks left h (reverse gr)) t\n      cons (cons left (cons (reverse gr) (cons h nil))) t\n    withToken h\n      ifNotErr (parseTok toks groups) \\list . list \\restH restT .\n        parseGroup left restT (cons restH gr) close groups\n      \\txt pos .\n        rassoc txt groups\n          \\open . parseErr (strCat (cons 'Mismatched group: ' (cons (tokenString left) (cons txt (cons ' ' nil))))) (loc left)\n          ifNotErr (parseTok toks groups) \\list . list \\restH restT . parseGroup left restT (cons restH gr) close groups")(lazy(function(L_left){return function(L_toks){return function(L_gr){return function(L_close){return function(L_groups){return resolve(L_withCons)(L_toks)(function(){return resolve(L_parseErr)("Unterminated group starting ")(function(){return resolve(L_loc)(L_left)})})(lazy(function(L_h){return function(L_t){return resolve(L_isTokenString)(L_h)(L_close)(function(){return resolve(L_eq)(L_close)(")")(function(){return resolve(L_cons)(function(){return resolve(L_parensFromToks)(L_left)(L_h)(function(){return resolve(L_reverse)(L_gr)})})(L_t)})(function(){return resolve(L_cons)(function(){return resolve(L_cons)(L_left)(function(){return resolve(L_cons)(function(){return resolve(L_reverse)(L_gr)})(function(){return resolve(L_cons)(L_h)(L_nil)})})})(L_t)})})(function(){return resolve(L_withToken)(L_h)(function(){return resolve(L_ifNotErr)(function(){return resolve(L_parseTok)(L_toks)(L_groups)})(lazy(function(L_list){return resolve(L_list)(lazy(function(L_restH){return function(L_restT){return resolve(L_parseGroup)(L_left)(L_restT)(function(){return resolve(L_cons)(L_restH)(L_gr)})(L_close)(L_groups)}}))}))})(lazy(function(L_txt){return function(L_pos){return resolve(L_rassoc)(L_txt)(L_groups)(lazy(function(L_open){return resolve(L_parseErr)(function(){return resolve(L_strCat)(function(){return resolve(L_cons)("Mismatched group: ")(function(){return resolve(L_cons)(function(){return resolve(L_tokenString)(L_left)})(function(){return resolve(L_cons)(L_txt)(function(){return resolve(L_cons)(" ")(L_nil)})})})})})(function(){return resolve(L_loc)(L_left)})}))(function(){return resolve(L_ifNotErr)(function(){return resolve(L_parseTok)(L_toks)(L_groups)})(lazy(function(L_list){return resolve(L_list)(lazy(function(L_restH){return function(L_restT){return resolve(L_parseGroup)(L_left)(L_restT)(function(){return resolve(L_cons)(L_restH)(L_gr)})(L_close)(L_groups)}}))}))})}}))})}}))}}}}}))},
  function(){return resolve(L_define)("parseIndent")(4)("parseIndent indent toks gr groups =\n  withCons toks (cons (makeParens (tokenPos indent) (lexEnd (head gr)) (reverse gr)) nil)\n    \\h t . or (withToken h false (\\txt pos . rassoc txt groups (\\open . true) false))\n      and (isTokenStart h '\\n') (<= (strLen (tokenString h)) (strLen (tokenString indent)))\n      cons (makeParens (tokenPos indent) (tokenPos h) (reverse gr)) toks\n      ifNotErr (parseTok toks groups) \\list . list \\restH restT . parseIndent indent restT (cons restH gr) groups")(lazy(function(L_indent){return function(L_toks){return function(L_gr){return function(L_groups){return resolve(L_withCons)(L_toks)(function(){return resolve(L_cons)(function(){return resolve(L_makeParens)(function(){return resolve(L_tokenPos)(L_indent)})(function(){return resolve(L_lexEnd)(function(){return resolve(L_head)(L_gr)})})(function(){return resolve(L_reverse)(L_gr)})})(L_nil)})(lazy(function(L_h){return function(L_t){return resolve(L_or)(function(){return resolve(L_withToken)(L_h)(L_false)(lazy(function(L_txt){return function(L_pos){return resolve(L_rassoc)(L_txt)(L_groups)(lazy(function(L_open){return resolve(L_true)}))(L_false)}}))})(function(){return resolve(L_and)(function(){return resolve(L_isTokenStart)(L_h)("\n")})(function(){return resolve(L_$y$p)(function(){return resolve(L_strLen)(function(){return resolve(L_tokenString)(L_h)})})(function(){return resolve(L_strLen)(function(){return resolve(L_tokenString)(L_indent)})})})})(function(){return resolve(L_cons)(function(){return resolve(L_makeParens)(function(){return resolve(L_tokenPos)(L_indent)})(function(){return resolve(L_tokenPos)(L_h)})(function(){return resolve(L_reverse)(L_gr)})})(L_toks)})(function(){return resolve(L_ifNotErr)(function(){return resolve(L_parseTok)(L_toks)(L_groups)})(lazy(function(L_list){return resolve(L_list)(lazy(function(L_restH){return function(L_restT){return resolve(L_parseIndent)(L_indent)(L_restT)(function(){return resolve(L_cons)(L_restH)(L_gr)})(L_groups)}}))}))})}}))}}}}))},
  function(){return resolve(L_define)("lit")(1)("lit value = \\f . f value")(lazy(setDataType(function(L_value){return setType(function(L_f){return resolve(L_f)(L_value)}, 'lit')}, 'lit')))},
  function(){return resolve(L_define)("ref")(1)("ref name = \\f . f name")(lazy(setDataType(function(L_name){return setType(function(L_f){return resolve(L_f)(L_name)}, 'ref')}, 'ref')))},
  function(){return resolve(L_define)("lambda")(2)("lambda name body = \\f . f name body")(lazy(setDataType(function(L_name){return function(L_body){return setType(function(L_f){return resolve(L_f)(L_name)(L_body)}, 'lambda')}}, 'lambda')))},
  function(){return resolve(L_define)("apply")(2)("apply func arg = \\f . f func arg")(lazy(setDataType(function(L_func){return function(L_arg){return setType(function(L_f){return resolve(L_f)(L_func)(L_arg)}, 'apply')}}, 'apply')))},
  function(){return resolve(L_define)("let")(3)("let name value body = \\f . f name value body")(lazy(setDataType(function(L_name){return function(L_value){return function(L_body){return setType(function(L_f){return resolve(L_f)(L_name)(L_value)(L_body)}, 'let')}}}, 'let')))},
  function(){return resolve(L_define)("anno")(3)("anno name data body = \\f . f name data body")(lazy(setDataType(function(L_name){return function(L_data){return function(L_body){return setType(function(L_f){return resolve(L_f)(L_name)(L_data)(L_body)}, 'anno')}}}, 'anno')))},
  function(){return resolve(L_define)("withParens")(3)("withParens p err cont = isParens p (p cont) err")(lazy(function(L_p){return function(L_err){return function(L_cont){return resolve(L_isParens)(L_p)(function(){return resolve(L_p)(L_cont)})(L_err)}}}))},
  function(){return resolve(L_define)("setParens")(2)("setParens p func = isParens p\n  p \\start end content . parens start end (func content)\n  func p")(lazy(function(L_p){return function(L_func){return resolve(L_isParens)(L_p)(function(){return resolve(L_p)(lazy(function(L_start){return function(L_end){return function(L_content){return resolve(L_parens)(L_start)(L_end)(function(){return resolve(L_func)(L_content)})}}}))})(function(){return resolve(L_func)(L_p)})}}))},
  function(){return resolve(L_define)("withStripped")(2)("withStripped list cont = withParens list (cont list) \\start end content . withStripped content cont")(lazy(function(L_list){return function(L_cont){return resolve(L_withParens)(L_list)(function(){return resolve(L_cont)(L_list)})(lazy(function(L_start){return function(L_end){return function(L_content){return resolve(L_withStripped)(L_content)(L_cont)}}}))}}))},
  function(){return resolve(L_define)("position")(1)("position thing = isToken thing (tokenPos thing)\n  isParens thing (parensStart thing)\n    isCons thing (position (head thing))\n      -1")(lazy(function(L_thing){return resolve(L_isToken)(L_thing)(function(){return resolve(L_tokenPos)(L_thing)})(function(){return resolve(L_isParens)(L_thing)(function(){return resolve(L_parensStart)(L_thing)})(function(){return resolve(L_isCons)(L_thing)(function(){return resolve(L_position)(function(){return resolve(L_head)(L_thing)})})(-1)})})}))},
  function(){return resolve(L_define)("lexEnd")(1)("lexEnd thing = isToken thing (+ (tokenPos thing) (strLen (tokenString thing)))\n  isParens thing (parensEnd thing)\n    isCons thing (lexEnd (last thing))\n      -1")(lazy(function(L_thing){return resolve(L_isToken)(L_thing)(function(){return resolve(L_$o)(function(){return resolve(L_tokenPos)(L_thing)})(function(){return resolve(L_strLen)(function(){return resolve(L_tokenString)(L_thing)})})})(function(){return resolve(L_isParens)(L_thing)(function(){return resolve(L_parensEnd)(L_thing)})(function(){return resolve(L_isCons)(L_thing)(function(){return resolve(L_lexEnd)(function(){return resolve(L_last)(L_thing)})})(-1)})})}))},
  function(){return resolve(L_define)("loc")(1)("loc thing = \\\\\n  p = position thing\n  l = eq p -1 'an unknown location' p\n  .\n  strCat (cons 'at ' (cons l nil))")(lazy(function(L_thing){return (function(){

var L_l, L_p;

L_l = function(){return resolve(L_eq)(L_p)(-1)("an unknown location")(L_p)};

L_p = function(){return resolve(L_position)(L_thing)};
return resolve(L_strCat)(function(){return resolve(L_cons)("at ")(function(){return resolve(L_cons)(L_l)(L_nil)})})})()}))},
  function(){return resolve(L_define)("scrub")(1)("scrub str = strFromList (scrubList (strToList str))")(lazy(function(L_str){return resolve(L_strFromList)(function(){return resolve(L_scrubList)(function(){return resolve(L_strToList)(L_str)})})}))},
  function(){return resolve(L_define)("scrubList")(1)("scrubList list = list\n  \\h t D . \\\\\n    next = scrubList t\n    .\n    eq h '\\\\' (cons h (cons (head t) (scrubList (tail t))))\n      eq h '\\\"' (cons '\\\\' (cons '\\\"' next))\n        cons h next\n  nil")(lazy(function(L_list){return resolve(L_list)(lazy(function(L_h){return function(L_t){return function(L_D){return (function(){

var L_next;

L_next = function(){return resolve(L_scrubList)(L_t)};
return resolve(L_eq)(L_h)("\\")(function(){return resolve(L_cons)(L_h)(function(){return resolve(L_cons)(function(){return resolve(L_head)(L_t)})(function(){return resolve(L_scrubList)(function(){return resolve(L_tail)(L_t)})})})})(function(){return resolve(L_eq)(L_h)("\"")(function(){return resolve(L_cons)("\\")(function(){return resolve(L_cons)("\"")(L_next)})})(function(){return resolve(L_cons)(L_h)(L_next)})})})()}}}))(L_nil)}))},
  function(){return resolve(L_define)("createAst")(2)("createAst inList names = withStripped inList \\list .\n  isToken list (createLitOrRef (tokenString list) names)\n    list\n      \\h t D .\n        isTokenString h '\\\\\\\\' (createLet h t names)\n          isTokenString h '\\\\@' (createAnno h t names)\n            isTokenString h '\\\\' (createLambda h t names)\n              createApply list names\n      nil")(lazy(function(L_inList){return function(L_names){return resolve(L_withStripped)(L_inList)(lazy(function(L_list){return resolve(L_isToken)(L_list)(function(){return resolve(L_createLitOrRef)(function(){return resolve(L_tokenString)(L_list)})(L_names)})(function(){return resolve(L_list)(lazy(function(L_h){return function(L_t){return function(L_D){return resolve(L_isTokenString)(L_h)("\\\\")(function(){return resolve(L_createLet)(L_h)(L_t)(L_names)})(function(){return resolve(L_isTokenString)(L_h)("\\@")(function(){return resolve(L_createAnno)(L_h)(L_t)(L_names)})(function(){return resolve(L_isTokenString)(L_h)("\\")(function(){return resolve(L_createLambda)(L_h)(L_t)(L_names)})(function(){return resolve(L_createApply)(L_list)(L_names)})})})}}}))(L_nil)})}))}}))},
  function(){return resolve(L_define)("strMatches")(2)("strMatches str pat = isCons (strMatch str pat)")(lazy(function(L_str){return function(L_pat){return resolve(L_isCons)(function(){return resolve(L_strMatch)(L_str)(L_pat)})}}))},
  function(){return resolve(L_define)("digit")(0)("digit = regexp '^[0-9]+$'")(function(){return resolve(L_regexp)("^[0-9]+$")})},
  function(){return resolve(L_define)("backslashCodes")(0)("backslashCodes = 'bfnrt'")("bfnrt")},
  function(){return resolve(L_define)("backslashValues")(0)("backslashValues = '\\b\\f\\n\\r\\t'")("\b\f\n\r\t")},
  function(){return resolve(L_define)("convertStringEscape")(3)("convertStringEscape char codes values =\n  eq codes ''\n    char\n    eq char (strAt codes 0)\n      strAt values 0\n      convertStringEscape char (strSubstring codes 1 0) (strSubstring values 1 0)")(lazy(function(L_char){return function(L_codes){return function(L_values){return resolve(L_eq)(L_codes)("")(L_char)(function(){return resolve(L_eq)(L_char)(function(){return resolve(L_strAt)(L_codes)(0)})(function(){return resolve(L_strAt)(L_values)(0)})(function(){return resolve(L_convertStringEscape)(L_char)(function(){return resolve(L_strSubstring)(L_codes)(1)(0)})(function(){return resolve(L_strSubstring)(L_values)(1)(0)})})})}}}))},
  function(){return resolve(L_define)("convertStringEscapes")(3)("convertStringEscapes orig str cont =\n  eq str ''\n    cont str\n    eq (strAt str 0) '\\\\'\n      eq (strLen str) 1 (parseErr \"Error, backslash without character in string: \" orig)\n        convertStringEscapes orig (strSubstring str 2 0) \\rest . cont\n          strAdd\n            convertStringEscape (strAt str 1) backslashCodes backslashValues\n            rest\n      convertStringEscapes orig (strSubstring str 1 0) \\rest . cont\n        strAdd\n          strAt str 0\n          rest")(lazy(function(L_orig){return function(L_str){return function(L_cont){return resolve(L_eq)(L_str)("")(function(){return resolve(L_cont)(L_str)})(function(){return resolve(L_eq)(function(){return resolve(L_strAt)(L_str)(0)})("\\")(function(){return resolve(L_eq)(function(){return resolve(L_strLen)(L_str)})(1)(function(){return resolve(L_parseErr)("Error, backslash without character in string: ")(L_orig)})(function(){return resolve(L_convertStringEscapes)(L_orig)(function(){return resolve(L_strSubstring)(L_str)(2)(0)})(lazy(function(L_rest){return resolve(L_cont)(function(){return resolve(L_strAdd)(function(){return resolve(L_convertStringEscape)(function(){return resolve(L_strAt)(L_str)(1)})(L_backslashCodes)(L_backslashValues)})(L_rest)})}))})})(function(){return resolve(L_convertStringEscapes)(L_orig)(function(){return resolve(L_strSubstring)(L_str)(1)(0)})(lazy(function(L_rest){return resolve(L_cont)(function(){return resolve(L_strAdd)(function(){return resolve(L_strAt)(L_str)(0)})(L_rest)})}))})})}}}))},
  function(){return resolve(L_define)("parseString")(2)("parseString str cont =\n  neq (strAt str 0) (strAt str -1) (parseErr \"Badly terminated string: \" str)\n    convertStringEscapes str (strSubstring str 1 -1) cont")(lazy(function(L_str){return function(L_cont){return resolve(L_neq)(function(){return resolve(L_strAt)(L_str)(0)})(function(){return resolve(L_strAt)(L_str)(-1)})(function(){return resolve(L_parseErr)("Badly terminated string: ")(L_str)})(function(){return resolve(L_convertStringEscapes)(L_str)(function(){return resolve(L_strSubstring)(L_str)(1)(-1)})(L_cont)})}}))},
  function(){return resolve(L_define)("createLitOrRef")(2)("createLitOrRef tok names =\n  contains names tok\n    ref tok\n    or (strStartsWith tok '\\\"') (strStartsWith tok \"'\")\n      parseString tok \\str . lit str\n      strStartsWith tok '.'\n        jsonParse (strCat (cons '0' (cons tok nil))) (\\err . ref tok) (\\item . lit item)\n        or (and (>= (strAt tok 0) '0') (<= (strAt tok 0) '9')) (strStartsWith tok '-')\n          jsonParse tok (\\err . ref tok) (\\item . lit item)\n          ref tok")(lazy(function(L_tok){return function(L_names){return resolve(L_contains)(L_names)(L_tok)(function(){return resolve(L_ref)(L_tok)})(function(){return resolve(L_or)(function(){return resolve(L_strStartsWith)(L_tok)("\"")})(function(){return resolve(L_strStartsWith)(L_tok)("'")})(function(){return resolve(L_parseString)(L_tok)(lazy(function(L_str){return resolve(L_lit)(L_str)}))})(function(){return resolve(L_strStartsWith)(L_tok)(".")(function(){return resolve(L_jsonParse)(function(){return resolve(L_strCat)(function(){return resolve(L_cons)("0")(function(){return resolve(L_cons)(L_tok)(L_nil)})})})(lazy(function(L_err){return resolve(L_ref)(L_tok)}))(lazy(function(L_item){return resolve(L_lit)(L_item)}))})(function(){return resolve(L_or)(function(){return resolve(L_and)(function(){return resolve(L_$z$p)(function(){return resolve(L_strAt)(L_tok)(0)})("0")})(function(){return resolve(L_$y$p)(function(){return resolve(L_strAt)(L_tok)(0)})("9")})})(function(){return resolve(L_strStartsWith)(L_tok)("-")})(function(){return resolve(L_jsonParse)(L_tok)(lazy(function(L_err){return resolve(L_ref)(L_tok)}))(lazy(function(L_item){return resolve(L_lit)(L_item)}))})(function(){return resolve(L_ref)(L_tok)})})})})}}))},
  function(){return resolve(L_define)("createLambda")(3)("createLambda start list names = \\\\\n  err = parseErr \"Lambda needs a variable name, a dot, and a body \" (loc start)\n  .\n  withCons list err \\name rest .\n    withToken name err \\n p .\n      withCons rest err \\dot body .\n        # are these partial applications too hard to read?\n        isTokenString dot '.'\n          ifNotErr (createAst body (cons n names)) \\bodyAst . lambda n bodyAst\n          ifNotErr (createLambda start rest (cons n names)) \\bodyAst . lambda n bodyAst")(lazy(function(L_start){return function(L_list){return function(L_names){return (function(){

var L_err;

L_err = function(){return resolve(L_parseErr)("Lambda needs a variable name, a dot, and a body ")(function(){return resolve(L_loc)(L_start)})};
return resolve(L_withCons)(L_list)(L_err)(lazy(function(L_name){return function(L_rest){return resolve(L_withToken)(L_name)(L_err)(lazy(function(L_n){return function(L_p){return resolve(L_withCons)(L_rest)(L_err)(lazy(function(L_dot){return function(L_body){return resolve(L_isTokenString)(L_dot)(".")(function(){return resolve(L_ifNotErr)(function(){return resolve(L_createAst)(L_body)(function(){return resolve(L_cons)(L_n)(L_names)})})(lazy(function(L_bodyAst){return resolve(L_lambda)(L_n)(L_bodyAst)}))})(function(){return resolve(L_ifNotErr)(function(){return resolve(L_createLambda)(L_start)(L_rest)(function(){return resolve(L_cons)(L_n)(L_names)})})(lazy(function(L_bodyAst){return resolve(L_lambda)(L_n)(L_bodyAst)}))})}}))}}))}}))})()}}}))},
  function(){return resolve(L_define)("createAnno")(3)("createAnno start list names =\n  withCons list (parseErr \"No annotation name or data in annotation \" (loc start)) \\name rest .\n    withCons rest (parseErr \"No data for annotation \" (loc start)) \\data rest . \\\\\n      finish data body = ifNotErr (createAst body names) \\bodyAst .\n        cleanTokens start name \\name .\n          cleanTokens start data \\data .\n            anno name data bodyAst\n      .\n      isTokenString data '.'\n        finish nil rest\n        withStripped data \\data .\n          withCons rest (parseErr \"No body for annotation \" (loc start)) \\dot body .\n            isTokenString dot '.'\n              finish data body\n              parseErr \"Annotation expects dot after name and data \" (loc start)")(lazy(function(L_start){return function(L_list){return function(L_names){return resolve(L_withCons)(L_list)(function(){return resolve(L_parseErr)("No annotation name or data in annotation ")(function(){return resolve(L_loc)(L_start)})})(lazy(function(L_name){return function(L_rest){return resolve(L_withCons)(L_rest)(function(){return resolve(L_parseErr)("No data for annotation ")(function(){return resolve(L_loc)(L_start)})})(lazy(function(L_data){return function(L_rest_0){return (function(){

var L_finish;

L_finish = lazy(function(L_data_1){return function(L_body){return resolve(L_ifNotErr)(function(){return resolve(L_createAst)(L_body)(L_names)})(lazy(function(L_bodyAst){return resolve(L_cleanTokens)(L_start)(L_name)(lazy(function(L_name_2){return resolve(L_cleanTokens)(L_start)(L_data_1)(lazy(function(L_data_3){return resolve(L_anno)(L_name_2)(L_data_3)(L_bodyAst)}))}))}))}});
return resolve(L_isTokenString)(L_data)(".")(function(){return resolve(L_finish)(L_nil)(L_rest_0)})(function(){return resolve(L_withStripped)(L_data)(lazy(function(L_data_1){return resolve(L_withCons)(L_rest_0)(function(){return resolve(L_parseErr)("No body for annotation ")(function(){return resolve(L_loc)(L_start)})})(lazy(function(L_dot){return function(L_body){return resolve(L_isTokenString)(L_dot)(".")(function(){return resolve(L_finish)(L_data_1)(L_body)})(function(){return resolve(L_parseErr)("Annotation expects dot after name and data ")(function(){return resolve(L_loc)(L_start)})})}}))}))})})()}}))}}))}}}))},
  function(){return resolve(L_define)("bodyStructPat")(0)("bodyStructPat = regexp '\\\\|\\\\\\\\|\\\\@'")(function(){return resolve(L_regexp)("\\|\\\\|\\@")})},
  function(){return resolve(L_define)("createApply")(2)("createApply inList names = withStripped inList \\list .\n  withCons list (parseErr \"Funcion apply expecting a non-empty list \" (loc inList)) \\h t .\n    ifNotErr (createAst h names) \\func . chainApply func t names")(lazy(function(L_inList){return function(L_names){return resolve(L_withStripped)(L_inList)(lazy(function(L_list){return resolve(L_withCons)(L_list)(function(){return resolve(L_parseErr)("Funcion apply expecting a non-empty list ")(function(){return resolve(L_loc)(L_inList)})})(lazy(function(L_h){return function(L_t){return resolve(L_ifNotErr)(function(){return resolve(L_createAst)(L_h)(L_names)})(lazy(function(L_func){return resolve(L_chainApply)(L_func)(L_t)(L_names)}))}}))}))}}))},
  function(){return resolve(L_define)("blockStarts")(0)("blockStarts = cons '\\\\' (cons '\\\\\\\\' (cons '\\\\@' nil))")(function(){return resolve(L_cons)("\\")(function(){return resolve(L_cons)("\\\\")(function(){return resolve(L_cons)("\\@")(L_nil)})})})},
  function(){return resolve(L_define)("chainApply")(3)("chainApply func list names = withCons list func \\argItem rest .\n  and (isToken argItem) (contains blockStarts (tokenString argItem))\n    ifNotErr (createAst list names) \\arg . apply func arg\n    ifNotErr (createAst argItem names) \\arg . chainApply (apply func arg) rest names")(lazy(function(L_func){return function(L_list){return function(L_names){return resolve(L_withCons)(L_list)(L_func)(lazy(function(L_argItem){return function(L_rest){return resolve(L_and)(function(){return resolve(L_isToken)(L_argItem)})(function(){return resolve(L_contains)(L_blockStarts)(function(){return resolve(L_tokenString)(L_argItem)})})(function(){return resolve(L_ifNotErr)(function(){return resolve(L_createAst)(L_list)(L_names)})(lazy(function(L_arg){return resolve(L_apply)(L_func)(L_arg)}))})(function(){return resolve(L_ifNotErr)(function(){return resolve(L_createAst)(L_argItem)(L_names)})(lazy(function(L_arg){return resolve(L_chainApply)(function(){return resolve(L_apply)(L_func)(L_arg)})(L_rest)(L_names)}))})}}))}}}))},
  function(){return resolve(L_define)("cleanTokens")(3)("cleanTokens start toks cont = isToken toks\n  cont (tokenString toks)\n  withCons toks (cont toks) \\head tail .\n    cleanTokens start head \\head .\n      cleanTokens start tail \\tail .\n        cont (cons head tail)")(lazy(function(L_start){return function(L_toks){return function(L_cont){return resolve(L_isToken)(L_toks)(function(){return resolve(L_cont)(function(){return resolve(L_tokenString)(L_toks)})})(function(){return resolve(L_withCons)(L_toks)(function(){return resolve(L_cont)(L_toks)})(lazy(function(L_head){return function(L_tail){return resolve(L_cleanTokens)(L_start)(L_head)(lazy(function(L_head_0){return resolve(L_cleanTokens)(L_start)(L_tail)(lazy(function(L_tail_1){return resolve(L_cont)(function(){return resolve(L_cons)(L_head_0)(L_tail_1)})}))}))}}))})}}}))},
  function(){return resolve(L_define)("createLet")(3)("createLet start list names = withCons list\n  parseErr \"No variable or body for let \" (loc start)\n  \\binding body . eq body nil (createAst binding name)\n    getLetNames start list names \\newNames .\n      createSublets start binding body newNames id")(lazy(function(L_start){return function(L_list){return function(L_names){return resolve(L_withCons)(L_list)(function(){return resolve(L_parseErr)("No variable or body for let ")(function(){return resolve(L_loc)(L_start)})})(lazy(function(L_binding){return function(L_body){return resolve(L_eq)(L_body)(L_nil)(function(){return resolve(L_createAst)(L_binding)(L_name)})(function(){return resolve(L_getLetNames)(L_start)(L_list)(L_names)(lazy(function(L_newNames){return resolve(L_createSublets)(L_start)(L_binding)(L_body)(L_newNames)(L_id)}))})}}))}}}))},
  function(){return resolve(L_define)("getLetNames")(4)("getLetNames start list names cont = \\\\\n  err = parseErr \"Let expected binding \" (loc start)\n  .\n  withCons list (cont names) \\binding body .\n    isTokenString binding '.' (cont names)\n      withParens binding err \\start end def .\n        withCons def err \\name rest .\n          withToken name err \\str pos .\n            getLetNames start body (cons str names) cont")(lazy(function(L_start){return function(L_list){return function(L_names){return function(L_cont){return (function(){

var L_err;

L_err = function(){return resolve(L_parseErr)("Let expected binding ")(function(){return resolve(L_loc)(L_start)})};
return resolve(L_withCons)(L_list)(function(){return resolve(L_cont)(L_names)})(lazy(function(L_binding){return function(L_body){return resolve(L_isTokenString)(L_binding)(".")(function(){return resolve(L_cont)(L_names)})(function(){return resolve(L_withParens)(L_binding)(L_err)(lazy(function(L_start_0){return function(L_end){return function(L_def){return resolve(L_withCons)(L_def)(L_err)(lazy(function(L_name){return function(L_rest){return resolve(L_withToken)(L_name)(L_err)(lazy(function(L_str){return function(L_pos){return resolve(L_getLetNames)(L_start_0)(L_body)(function(){return resolve(L_cons)(L_str)(L_names)})(L_cont)}}))}}))}}}))})}}))})()}}}}))},
  function(){return resolve(L_define)("createSublets")(5)("createSublets start binding body names cont =\n  isTokenString binding '.' (ifNotErr (createAst body names) cont)\n    withCons body (parseErr \"Let expected a body \" (loc start)) \\bodyH bodyT .\n      getNameAndDef (parensStart binding) (parensContent binding) names \\name def .\n        createSublets start bodyH bodyT names \\bodyAst .\n          cont (let (tokenString name) def bodyAst)")(lazy(function(L_start){return function(L_binding){return function(L_body){return function(L_names){return function(L_cont){return resolve(L_isTokenString)(L_binding)(".")(function(){return resolve(L_ifNotErr)(function(){return resolve(L_createAst)(L_body)(L_names)})(L_cont)})(function(){return resolve(L_withCons)(L_body)(function(){return resolve(L_parseErr)("Let expected a body ")(function(){return resolve(L_loc)(L_start)})})(lazy(function(L_bodyH){return function(L_bodyT){return resolve(L_getNameAndDef)(function(){return resolve(L_parensStart)(L_binding)})(function(){return resolve(L_parensContent)(L_binding)})(L_names)(lazy(function(L_name){return function(L_def){return resolve(L_createSublets)(L_start)(L_bodyH)(L_bodyT)(L_names)(lazy(function(L_bodyAst){return resolve(L_cont)(function(){return resolve(L_let)(function(){return resolve(L_tokenString)(L_name)})(L_def)(L_bodyAst)})}))}}))}}))})}}}}}))},
  function(){return resolve(L_define)("getNameAndDef")(4)("getNameAndDef pos binding names cont =\n  withCons (tail binding) (parseErr \"Let expected binding at \" pos) \\snd sndT .\n    isTokenString snd '=' (ifNotErr (createAst sndT names) \\def . cont (head binding) def)\n      getLetLambda pos (tail binding) nil names \\lamb . cont (head binding) lamb")(lazy(function(L_pos){return function(L_binding){return function(L_names){return function(L_cont){return resolve(L_withCons)(function(){return resolve(L_tail)(L_binding)})(function(){return resolve(L_parseErr)("Let expected binding at ")(L_pos)})(lazy(function(L_snd){return function(L_sndT){return resolve(L_isTokenString)(L_snd)("=")(function(){return resolve(L_ifNotErr)(function(){return resolve(L_createAst)(L_sndT)(L_names)})(lazy(function(L_def){return resolve(L_cont)(function(){return resolve(L_head)(L_binding)})(L_def)}))})(function(){return resolve(L_getLetLambda)(L_pos)(function(){return resolve(L_tail)(L_binding)})(L_nil)(L_names)(lazy(function(L_lamb){return resolve(L_cont)(function(){return resolve(L_head)(L_binding)})(L_lamb)}))})}}))}}}}))},
  function(){return resolve(L_define)("getLetLambda")(5)("getLetLambda pos def args names cont =\n  withCons def (parseErr \"Let expected binding at \" pos) \\arg rest .\n    not (isToken arg) (parseErr \"Let expected binding at \" pos)\n      isTokenString arg '='\n        ifNotErr (createAst (cons (token '\\\\' pos) (append (reverse args) (cons (token '.' (position arg)) rest))) names) cont\n        getLetLambda pos rest (cons arg args) names cont")(lazy(function(L_pos){return function(L_def){return function(L_args){return function(L_names){return function(L_cont){return resolve(L_withCons)(L_def)(function(){return resolve(L_parseErr)("Let expected binding at ")(L_pos)})(lazy(function(L_arg){return function(L_rest){return resolve(L_not)(function(){return resolve(L_isToken)(L_arg)})(function(){return resolve(L_parseErr)("Let expected binding at ")(L_pos)})(function(){return resolve(L_isTokenString)(L_arg)("=")(function(){return resolve(L_ifNotErr)(function(){return resolve(L_createAst)(function(){return resolve(L_cons)(function(){return resolve(L_token)("\\")(L_pos)})(function(){return resolve(L_append)(function(){return resolve(L_reverse)(L_args)})(function(){return resolve(L_cons)(function(){return resolve(L_token)(".")(function(){return resolve(L_position)(L_arg)})})(L_rest)})})})(L_names)})(L_cont)})(function(){return resolve(L_getLetLambda)(L_pos)(L_rest)(function(){return resolve(L_cons)(L_arg)(L_args)})(L_names)(L_cont)})})}}))}}}}}))},
  function(){return resolve(L_define)("scanLineG")(5)("scanLineG str pat groups onDef onExpr = \\\\\n  toks = tokens str pat\n  groupToks = foldr (\\el value . el \\h t . cons h (cons t value)) (cons '=' blockStarts) groups\n  .\n  # check if it's a definition\n  find (\\tok . or (contains groupToks (tokenString tok)) (isCons (strMatch (tokenString tok) '^\\n'))) toks (\\item . isTokenString item '=') false\n    toks \\name rest . \\\\\n      parseIt func = \\\\\n        parsed = parseToks (checkSetDataType func rest name) groups\n        .\n        onDef (ifNotErr parsed \\list . createDef list name (arity rest 0) str)\n      .\n      isTokenString (head rest) '='\n        isTokenString (head (tail rest)) '\\\\'\n          parseIt (setTypeAnno (tail rest) (tokenString name))\n          parseIt (tail rest)\n        transformDef name rest \\def .\n          parseIt (cons (token '\\\\' (- (position (head rest)) 1)) def)\n    ifNotErr (parseToks toks groups) \\list . onExpr list")(lazy(function(L_str){return function(L_pat){return function(L_groups){return function(L_onDef){return function(L_onExpr){return (function(){

var L_groupToks, L_toks;

L_groupToks = function(){return resolve(L_foldr)(lazy(function(L_el){return function(L_value){return resolve(L_el)(lazy(function(L_h){return function(L_t){return resolve(L_cons)(L_h)(function(){return resolve(L_cons)(L_t)(L_value)})}}))}}))(function(){return resolve(L_cons)("=")(L_blockStarts)})(L_groups)};

L_toks = function(){return resolve(L_tokens)(L_str)(L_pat)};
return resolve(L_find)(lazy(function(L_tok){return resolve(L_or)(function(){return resolve(L_contains)(L_groupToks)(function(){return resolve(L_tokenString)(L_tok)})})(function(){return resolve(L_isCons)(function(){return resolve(L_strMatch)(function(){return resolve(L_tokenString)(L_tok)})("^\n")})})}))(L_toks)(lazy(function(L_item){return resolve(L_isTokenString)(L_item)("=")}))(L_false)(function(){return resolve(L_toks)(lazy(function(L_name){return function(L_rest){return (function(){

var L_parseIt;

L_parseIt = lazy(function(L_func){return (function(){

var L_parsed;

L_parsed = function(){return resolve(L_parseToks)(function(){return resolve(L_checkSetDataType)(L_func)(L_rest)(L_name)})(L_groups)};
return resolve(L_onDef)(function(){return resolve(L_ifNotErr)(L_parsed)(lazy(function(L_list){return resolve(L_createDef)(L_list)(L_name)(function(){return resolve(L_arity)(L_rest)(0)})(L_str)}))})})()});
return resolve(L_isTokenString)(function(){return resolve(L_head)(L_rest)})("=")(function(){return resolve(L_isTokenString)(function(){return resolve(L_head)(function(){return resolve(L_tail)(L_rest)})})("\\")(function(){return resolve(L_parseIt)(function(){return resolve(L_setTypeAnno)(function(){return resolve(L_tail)(L_rest)})(function(){return resolve(L_tokenString)(L_name)})})})(function(){return resolve(L_parseIt)(function(){return resolve(L_tail)(L_rest)})})})(function(){return resolve(L_transformDef)(L_name)(L_rest)(lazy(function(L_def){return resolve(L_parseIt)(function(){return resolve(L_cons)(function(){return resolve(L_token)("\\")(function(){return resolve(L_$_)(function(){return resolve(L_position)(function(){return resolve(L_head)(L_rest)})})(1)})})(L_def)})}))})})()}}))})(function(){return resolve(L_ifNotErr)(function(){return resolve(L_parseToks)(L_toks)(L_groups)})(lazy(function(L_list){return resolve(L_onExpr)(L_list)}))})})()}}}}}))},
  function(){return resolve(L_define)("parseLineG")(6)("parseLineG str pat names groups onDef onExpr = \\\\\n  astCallback cb = \\list . ifNotErr (createAst list names) \\ast . cb ast\n  .\n  scanLineG str pat groups (astCallback onDef) (astCallback onExpr)")(lazy(function(L_str){return function(L_pat){return function(L_names){return function(L_groups){return function(L_onDef){return function(L_onExpr){return (function(){

var L_astCallback;

L_astCallback = lazy(function(L_cb){return function(L_list){return resolve(L_ifNotErr)(function(){return resolve(L_createAst)(L_list)(L_names)})(lazy(function(L_ast){return resolve(L_cb)(L_ast)}))}});
return resolve(L_scanLineG)(L_str)(L_pat)(L_groups)(function(){return resolve(L_astCallback)(L_onDef)})(function(){return resolve(L_astCallback)(L_onExpr)})})()}}}}}}))},
  function(){return resolve(L_define)("transformDef")(3)("transformDef name toks cont = withCons toks (parseErr \"Bad definition, expecting tokens\" (loc name)) \\h t .\n  isTokenString h '='\n    isTokenString (head t) '\\\\'\n      cont (cons (token '.' (position h)) (setTypeAnno t (tokenString name)))\n      cont (cons (token '.' (position h)) t)\n    transformDef name t \\list . cont (cons h list)")(lazy(function(L_name){return function(L_toks){return function(L_cont){return resolve(L_withCons)(L_toks)(function(){return resolve(L_parseErr)("Bad definition, expecting tokens")(function(){return resolve(L_loc)(L_name)})})(lazy(function(L_h){return function(L_t){return resolve(L_isTokenString)(L_h)("=")(function(){return resolve(L_isTokenString)(function(){return resolve(L_head)(L_t)})("\\")(function(){return resolve(L_cont)(function(){return resolve(L_cons)(function(){return resolve(L_token)(".")(function(){return resolve(L_position)(L_h)})})(function(){return resolve(L_setTypeAnno)(L_t)(function(){return resolve(L_tokenString)(L_name)})})})})(function(){return resolve(L_cont)(function(){return resolve(L_cons)(function(){return resolve(L_token)(".")(function(){return resolve(L_position)(L_h)})})(L_t)})})})(function(){return resolve(L_transformDef)(L_name)(L_t)(lazy(function(L_list){return resolve(L_cont)(function(){return resolve(L_cons)(L_h)(L_list)})}))})}}))}}}))},
  function(){return resolve(L_define)("setTypeAnno")(2)("setTypeAnno toks name = \\\\\n  tok = \\str . token str (position toks)\n  .\n  cons (tok '\\\\@') (cons (tok 'type') (cons (tok name) (cons (tok '.') toks)))")(lazy(function(L_toks){return function(L_name){return (function(){

var L_tok;

L_tok = lazy(function(L_str){return resolve(L_token)(L_str)(function(){return resolve(L_position)(L_toks)})});
return resolve(L_cons)(function(){return resolve(L_tok)("\\@")})(function(){return resolve(L_cons)(function(){return resolve(L_tok)("type")})(function(){return resolve(L_cons)(function(){return resolve(L_tok)(L_name)})(function(){return resolve(L_cons)(function(){return resolve(L_tok)(".")})(L_toks)})})})})()}}))},
  function(){return resolve(L_define)("setDataTypeAnno")(2)("setDataTypeAnno toks name = \\\\\n  tok = \\str . token str (position toks)\n  .\n  cons (tok '\\\\@') (cons (tok 'dataType') (cons (tok (tokenString name)) (cons (tok '.') toks)))")(lazy(function(L_toks){return function(L_name){return (function(){

var L_tok;

L_tok = lazy(function(L_str){return resolve(L_token)(L_str)(function(){return resolve(L_position)(L_toks)})});
return resolve(L_cons)(function(){return resolve(L_tok)("\\@")})(function(){return resolve(L_cons)(function(){return resolve(L_tok)("dataType")})(function(){return resolve(L_cons)(function(){return resolve(L_tok)(function(){return resolve(L_tokenString)(L_name)})})(function(){return resolve(L_cons)(function(){return resolve(L_tok)(".")})(L_toks)})})})})()}}))},
  function(){return resolve(L_define)("createDef")(4)("createDef def name arity src = \\\\\n  tok str = token str (position def)\n  .\n  jsonStringify (tokenString name) (\\err . parseErr (strCat (cons \"Bad function name \" (cons (loc name) nil))) err) \\nameStr .\n    jsonStringify src (\\err . parseErr (strCat (cons \"Bad source \" (cons (loc name) nil))) err) \\srcStr .\n      #cons (tok 'define') (cons (tok nameStr) (cons (tok (strString arity)) (cons (tok srcStr) (cons def nil))))\n      cons (tok '\\\\@') (cons (cons (tok 'definition') (cons (tok name) nil)) (cons (tok '.') (cons (tok 'define') (cons (tok nameStr) (cons (tok (strString arity)) (cons (tok srcStr) (cons def nil)))))))")(lazy(function(L_def){return function(L_name){return function(L_arity){return function(L_src){return (function(){

var L_tok;

L_tok = lazy(function(L_str){return resolve(L_token)(L_str)(function(){return resolve(L_position)(L_def)})});
return resolve(L_jsonStringify)(function(){return resolve(L_tokenString)(L_name)})(lazy(function(L_err){return resolve(L_parseErr)(function(){return resolve(L_strCat)(function(){return resolve(L_cons)("Bad function name ")(function(){return resolve(L_cons)(function(){return resolve(L_loc)(L_name)})(L_nil)})})})(L_err)}))(lazy(function(L_nameStr){return resolve(L_jsonStringify)(L_src)(lazy(function(L_err){return resolve(L_parseErr)(function(){return resolve(L_strCat)(function(){return resolve(L_cons)("Bad source ")(function(){return resolve(L_cons)(function(){return resolve(L_loc)(L_name)})(L_nil)})})})(L_err)}))(lazy(function(L_srcStr){return resolve(L_cons)(function(){return resolve(L_tok)("\\@")})(function(){return resolve(L_cons)(function(){return resolve(L_cons)(function(){return resolve(L_tok)("definition")})(function(){return resolve(L_cons)(function(){return resolve(L_tok)(L_name)})(L_nil)})})(function(){return resolve(L_cons)(function(){return resolve(L_tok)(".")})(function(){return resolve(L_cons)(function(){return resolve(L_tok)("define")})(function(){return resolve(L_cons)(function(){return resolve(L_tok)(L_nameStr)})(function(){return resolve(L_cons)(function(){return resolve(L_tok)(function(){return resolve(L_strString)(L_arity)})})(function(){return resolve(L_cons)(function(){return resolve(L_tok)(L_srcStr)})(function(){return resolve(L_cons)(L_def)(L_nil)})})})})})})})}))}))})()}}}}))},
  function(){return resolve(L_define)("checkSetDataType")(3)("checkSetDataType toks curToks name = withCons curToks toks \\h t .\n  isTokenString h '='\n    isTokenString (head t) '\\\\'\n      setDataTypeAnno toks name\n      toks\n    checkSetDataType toks t name")(lazy(function(L_toks){return function(L_curToks){return function(L_name){return resolve(L_withCons)(L_curToks)(L_toks)(lazy(function(L_h){return function(L_t){return resolve(L_isTokenString)(L_h)("=")(function(){return resolve(L_isTokenString)(function(){return resolve(L_head)(L_t)})("\\")(function(){return resolve(L_setDataTypeAnno)(L_toks)(L_name)})(L_toks)})(function(){return resolve(L_checkSetDataType)(L_toks)(L_t)(L_name)})}}))}}}))},
  function(){return resolve(L_define)("arity")(2)("arity toks n = isTokenString (head toks) '=' n (arity (tail toks) (+ n 1))")(lazy(function(L_toks){return function(L_n){return resolve(L_isTokenString)(function(){return resolve(L_head)(L_toks)})("=")(L_n)(function(){return resolve(L_arity)(function(){return resolve(L_tail)(L_toks)})(function(){return resolve(L_$o)(L_n)(1)})})}}))},
  function(){return resolve(L_define)("tokListStr")(1)("tokListStr toks = jsonStringify (join (map (\\t . tokenString t) toks) ' ')")(lazy(function(L_toks){return resolve(L_jsonStringify)(function(){return resolve(L_join)(function(){return resolve(L_map)(lazy(function(L_t){return resolve(L_tokenString)(L_t)}))(L_toks)})(" ")})}))},
  function(){return resolve(L_define)("linePat")(0)("linePat = regexp '\\\\r?\\\\n(?=[^ ]|$)'")(function(){return resolve(L_regexp)("\\r?\\n(?=[^ ]|$)")})},
  function(){return resolve(L_define)("emptyLinePat")(0)("emptyLinePat = regexp '(^[ \\\\i]*\\\\#.*|^[ \\\\i]*$|^\\\\r?\\\\n[ \\\\i]*$)'")(function(){return resolve(L_regexp)("(^[ \\i]*\\#.*|^[ \\i]*$|^\\r?\\n[ \\i]*$)")})},
  function(){return resolve(L_define)("lineScrub")(0)("lineScrub = regexpFlags '\\\\r\\\\n' 'g'")(function(){return resolve(L_regexpFlags)("\\r\\n")("g")})},
  function(){return resolve(L_define)("linesForFile")(1)("linesForFile text = filter\n  \\line . isNil (strMatch line emptyLinePat)\n  strSplit (strReplace text lineScrub '\\n') linePat")(lazy(function(L_text){return resolve(L_filter)(lazy(function(L_line){return resolve(L_isNil)(function(){return resolve(L_strMatch)(L_line)(L_emptyLinePat)})}))(function(){return resolve(L_strSplit)(function(){return resolve(L_strReplace)(L_text)(L_lineScrub)("\n")})(L_linePat)})}))},
  function(){return resolve(L_define)("defPat")(0)("defPat = regexp '^[^ =]+.* =( |$)'")(function(){return resolve(L_regexp)("^[^ =]+.* =( |$)")})},
  function(){return resolve(L_define)("unanchoredDefPat")(0)("unanchoredDefPat = regexp '^((?:\\\\s*\\\\n|#[^\\\\n]*\\\\n)*)([^=\\\\n]*)(=\\\\([^=]+=|=)?'")(function(){return resolve(L_regexp)("^((?:\\s*\\n|#[^\\n]*\\n)*)([^=\\n]*)(=\\([^=]+=|=)?")})},
  function(){return resolve(L_define)("namesForLines")(1)("namesForLines lines = foldl\n  \\result line . \\\\\n    m = strMatch line defPat\n    .\n    isNil m result (cons (head (tail m)) result)\n  nil\n  lines")(lazy(function(L_lines){return resolve(L_foldl)(lazy(function(L_result){return function(L_line){return (function(){

var L_m;

L_m = function(){return resolve(L_strMatch)(L_line)(L_defPat)};
return resolve(L_isNil)(L_m)(L_result)(function(){return resolve(L_cons)(function(){return resolve(L_head)(function(){return resolve(L_tail)(L_m)})})(L_result)})})()}}))(L_nil)(L_lines)}))},
  function(){return resolve(L_define)("runParseFilters")(2)("runParseFilters filters line = filters\n  \\h t D . bind (h line) \\filtered . runParseFilters t filtered\n  line")(lazy(function(L_filters){return function(L_line){return resolve(L_filters)(lazy(function(L_h){return function(L_t){return function(L_D){return resolve(L_bind)(function(){return resolve(L_h)(L_line)})(lazy(function(L_filtered){return resolve(L_runParseFilters)(L_t)(L_filtered)}))}}}))(L_line)}}))},
  function(){return resolve(L_define)("isBlockStart")(1)("isBlockStart tok = and\n  or (isToken tok) (isString tok)\n  contains blockStarts (strTokenString tok)")(lazy(function(L_tok){return resolve(L_and)(function(){return resolve(L_or)(function(){return resolve(L_isToken)(L_tok)})(function(){return resolve(L_isString)(L_tok)})})(function(){return resolve(L_contains)(L_blockStarts)(function(){return resolve(L_strTokenString)(L_tok)})})}))},
  function(){return resolve(L_define)("macroSub")(2)("macroSub macs expr = postProcessMacro -1 -1 (baseMacroSub macs expr)")(lazy(function(L_macs){return function(L_expr){return resolve(L_postProcessMacro)(-1)(-1)(function(){return resolve(L_baseMacroSub)(L_macs)(L_expr)})}}))},
  function(){return resolve(L_define)("consifyMacroValue")(1)("consifyMacroValue value = isCons value value (cons value nil)")(lazy(function(L_value){return resolve(L_isCons)(L_value)(L_value)(function(){return resolve(L_cons)(L_value)(L_nil)})}))},
  function(){return resolve(L_define)("baseMacroSub")(2)("baseMacroSub macs expr = isToken expr\n  expr\n  isParens expr\n    expr \\start end content . \\\\\n      result = baseMacroSub macs content\n      .\n      isToken result result (parens start end result)\n    withCons expr expr \\h t .\n      isBlockStart h\n        cons h\n          isTokenString h '\\\\\\\\'\n            macroSubLet macs t\n            macroSubBody '.' macs t\n        withToken h\n          \\\\\n            subH = baseMacroSub macs h\n            .\n            withToken subH\n              cons subH (map (baseMacroSub macs) t)\n              \\tok pos . baseMacroSub macs (cons subH t)\n          \\tok pos . assoc tok macs\n            \\def . baseMacroSub macs (def t)\n            cons h (map (baseMacroSub macs) t)")(lazy(function(L_macs){return function(L_expr){return resolve(L_isToken)(L_expr)(L_expr)(function(){return resolve(L_isParens)(L_expr)(function(){return resolve(L_expr)(lazy(function(L_start){return function(L_end){return function(L_content){return (function(){

var L_result;

L_result = function(){return resolve(L_baseMacroSub)(L_macs)(L_content)};
return resolve(L_isToken)(L_result)(L_result)(function(){return resolve(L_parens)(L_start)(L_end)(L_result)})})()}}}))})(function(){return resolve(L_withCons)(L_expr)(L_expr)(lazy(function(L_h){return function(L_t){return resolve(L_isBlockStart)(L_h)(function(){return resolve(L_cons)(L_h)(function(){return resolve(L_isTokenString)(L_h)("\\\\")(function(){return resolve(L_macroSubLet)(L_macs)(L_t)})(function(){return resolve(L_macroSubBody)(".")(L_macs)(L_t)})})})(function(){return resolve(L_withToken)(L_h)(function(){
var L_subH;

L_subH = function(){return resolve(L_baseMacroSub)(L_macs)(L_h)};
return resolve(L_withToken)(L_subH)(function(){return resolve(L_cons)(L_subH)(function(){return resolve(L_map)(function(){return resolve(L_baseMacroSub)(L_macs)})(L_t)})})(lazy(function(L_tok){return function(L_pos){return resolve(L_baseMacroSub)(L_macs)(function(){return resolve(L_cons)(L_subH)(L_t)})}}))})(lazy(function(L_tok){return function(L_pos){return resolve(L_assoc)(L_tok)(L_macs)(lazy(function(L_def){return resolve(L_baseMacroSub)(L_macs)(function(){return resolve(L_def)(L_t)})}))(function(){return resolve(L_cons)(L_h)(function(){return resolve(L_map)(function(){return resolve(L_baseMacroSub)(L_macs)})(L_t)})})}}))})}}))})})}}))},
  function(){return resolve(L_define)("macroSubLet")(2)("macroSubLet macs list = list\n  \\h t D . isTokenString h '.'\n    cons h (baseMacroSub macs t)\n    cons (setParens h \\content . macroSubBody '=' macs content) (macroSubLet macs t)\n  # Don't bother with parse errors at this point -- ast generator will detect them\n  nil")(lazy(function(L_macs){return function(L_list){return resolve(L_list)(lazy(function(L_h){return function(L_t){return function(L_D){return resolve(L_isTokenString)(L_h)(".")(function(){return resolve(L_cons)(L_h)(function(){return resolve(L_baseMacroSub)(L_macs)(L_t)})})(function(){return resolve(L_cons)(function(){return resolve(L_setParens)(L_h)(lazy(function(L_content){return resolve(L_macroSubBody)("=")(L_macs)(L_content)}))})(function(){return resolve(L_macroSubLet)(L_macs)(L_t)})})}}}))(L_nil)}}))},
  function(){return resolve(L_define)("macroSubBody")(3)("macroSubBody char macs list = list\n  \\h t D . cons h\n    isTokenString h char baseMacroSub (macroSubBody char)\n      macs\n      t\n  nil")(lazy(function(L_char){return function(L_macs){return function(L_list){return resolve(L_list)(lazy(function(L_h){return function(L_t){return function(L_D){return resolve(L_cons)(L_h)(function(){return resolve(L_isTokenString)(L_h)(L_char)(L_baseMacroSub)(function(){return resolve(L_macroSubBody)(L_char)})(L_macs)(L_t)})}}}))(L_nil)}}}))},
  function(){return resolve(L_define)("postProcessMacro")(3)("postProcessMacro before after expr = isString expr\n  token expr (eq after -1 before after)\n  isParens expr\n    expr \\start end contents . parens start end (postProcessMacro start end contents)\n    isCons expr\n      expr \\h t .\n        isToken h\n          cons h (postProcessMacro (+ 1 (+ (tokenPos h) (strLen (tokenString h)))) -1 t)\n          \\\\\n            posStart = position h\n            posEnd = position t\n            t2 = postProcessMacro -1 after t\n            h2 = postProcessMacro before -1 h\n            .\n            eq posStart -1\n              cons (postProcessMacro before (position t2) h) t2\n              cons h2 (postProcessMacro (+ 1 (lexEnd h2)) after t)\n      isNumber expr\n        token (strString expr) (eq after -1 before after)\n        expr")(lazy(function(L_before){return function(L_after){return function(L_expr){return resolve(L_isString)(L_expr)(function(){return resolve(L_token)(L_expr)(function(){return resolve(L_eq)(L_after)(-1)(L_before)(L_after)})})(function(){return resolve(L_isParens)(L_expr)(function(){return resolve(L_expr)(lazy(function(L_start){return function(L_end){return function(L_contents){return resolve(L_parens)(L_start)(L_end)(function(){return resolve(L_postProcessMacro)(L_start)(L_end)(L_contents)})}}}))})(function(){return resolve(L_isCons)(L_expr)(function(){return resolve(L_expr)(lazy(function(L_h){return function(L_t){return resolve(L_isToken)(L_h)(function(){return resolve(L_cons)(L_h)(function(){return resolve(L_postProcessMacro)(function(){return resolve(L_$o)(1)(function(){return resolve(L_$o)(function(){return resolve(L_tokenPos)(L_h)})(function(){return resolve(L_strLen)(function(){return resolve(L_tokenString)(L_h)})})})})(-1)(L_t)})})(function(){
var L_h2, L_t2, L_posEnd, L_posStart;

L_h2 = function(){return resolve(L_postProcessMacro)(L_before)(-1)(L_h)};

L_t2 = function(){return resolve(L_postProcessMacro)(-1)(L_after)(L_t)};

L_posEnd = function(){return resolve(L_position)(L_t)};

L_posStart = function(){return resolve(L_position)(L_h)};
return resolve(L_eq)(L_posStart)(-1)(function(){return resolve(L_cons)(function(){return resolve(L_postProcessMacro)(L_before)(function(){return resolve(L_position)(L_t2)})(L_h)})(L_t2)})(function(){return resolve(L_cons)(L_h2)(function(){return resolve(L_postProcessMacro)(function(){return resolve(L_$o)(1)(function(){return resolve(L_lexEnd)(L_h2)})})(L_after)(L_t)})})})}}))})(function(){return resolve(L_isNumber)(L_expr)(function(){return resolve(L_token)(function(){return resolve(L_strString)(L_expr)})(function(){return resolve(L_eq)(L_after)(-1)(L_before)(L_after)})})(L_expr)})})})}}}))},
  function(){return resolve(L_define)("defMacro")(2)("defMacro name def = bind (getValue 'macroDefs') \\macs . setValue 'macroDefs' (acons name def macs)")(lazy(function(L_name){return function(L_def){return resolve(L_bind)(function(){return resolve(L_getValue)("macroDefs")})(lazy(function(L_macs){return resolve(L_setValue)("macroDefs")(function(){return resolve(L_acons)(L_name)(L_def)(L_macs)})}))}}))},
  function(){return resolve(L_define)("delimiterListPrefix")(0)("delimiterListPrefix = \"\\\"(?:\\\\\\\\.|[^\\\"])*\\\"|'(?:\\\\\\\\.|[^'])*'|\\\\n *|#.*| +\"")("\"(?:\\\\.|[^\"])*\"|'(?:\\\\.|[^'])*'|\\n *|#.*| +")},
  function(){return resolve(L_define)("regexpEscapePat")(0)("regexpEscapePat = regexpFlags '[\\\\-\\\\[\\\\]/\\\\{\\\\}\\\\(\\\\)\\\\*\\\\+\\\\?\\\\.\\\\\\\\\\\\^\\\\$\\\\|]' 'g'")(function(){return resolve(L_regexpFlags)("[\\-\\[\\]/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]")("g")})},
  function(){return resolve(L_define)("addToken")(1)("addToken del = bind (getValue 'tokenList')\n  \\dels . contains dels del\n    false\n    \\\\\n      newDels = insertSorted (\\a b . > (strLen a) (strLen b)) del dels\n      .\n      bind (setValue 'tokenList' newDels)\n        \\_ . computeTokenPat newDels")(lazy(function(L_del){return resolve(L_bind)(function(){return resolve(L_getValue)("tokenList")})(lazy(function(L_dels){return resolve(L_contains)(L_dels)(L_del)(L_false)(function(){
var L_newDels;

L_newDels = function(){return resolve(L_insertSorted)(lazy(function(L_a){return function(L_b){return resolve(L_$z)(function(){return resolve(L_strLen)(L_a)})(function(){return resolve(L_strLen)(L_b)})}}))(L_del)(L_dels)};
return resolve(L_bind)(function(){return resolve(L_setValue)("tokenList")(L_newDels)})(lazy(function(L__){return resolve(L_computeTokenPat)(L_newDels)}))})}))}))},
  function(){return resolve(L_define)("computeTokenPat")(1)("computeTokenPat dels = \\\\\n  delPats = map (\\item . strReplace item regexpEscapePat \"\\\\$&\") dels\n  newPat = strCat (cons '(' (cons (join (cons delimiterListPrefix delPats) '|') (cons ')' nil)))\n  .\n  setValue 'tokenPat' newPat")(lazy(function(L_dels){return (function(){

var L_newPat, L_delPats;

L_newPat = function(){return resolve(L_strCat)(function(){return resolve(L_cons)("(")(function(){return resolve(L_cons)(function(){return resolve(L_join)(function(){return resolve(L_cons)(L_delimiterListPrefix)(L_delPats)})("|")})(function(){return resolve(L_cons)(")")(L_nil)})})})};

L_delPats = function(){return resolve(L_map)(lazy(function(L_item){return resolve(L_strReplace)(L_item)(L_regexpEscapePat)("\\$&")}))(L_dels)};
return resolve(L_setValue)("tokenPat")(L_newPat)})()}))},
  function(){return resolve(L_define)("addTokenGroup")(2)("addTokenGroup open close = bind (addToken open)\n  \\_ . bind (addToken close)\n    \\_ . bind (getValue 'tokenGroups')\n      \\gr . setValue 'tokenGroups' (acons open close gr)")(lazy(function(L_open){return function(L_close){return resolve(L_bind)(function(){return resolve(L_addToken)(L_open)})(lazy(function(L__){return resolve(L_bind)(function(){return resolve(L_addToken)(L_close)})(lazy(function(L___0){return resolve(L_bind)(function(){return resolve(L_getValue)("tokenGroups")})(lazy(function(L_gr){return resolve(L_setValue)("tokenGroups")(function(){return resolve(L_acons)(L_open)(L_close)(L_gr)})}))}))}))}}))},
  function(){return resolve(L_define)("parenGroups")(0)("parenGroups = acons '(' ')' nil")(function(){return resolve(L_acons)("(")(")")(L_nil)})},
  function(){return resolve(L_define)("parse")(2)("parse str pat = ifNotErr (parseIndent (token '\\n' 0) (tokens str pat) nil parenGroups) \\list . list \\h t . stripParens h")(lazy(function(L_str){return function(L_pat){return resolve(L_ifNotErr)(function(){return resolve(L_parseIndent)(function(){return resolve(L_token)("\n")(0)})(function(){return resolve(L_tokens)(L_str)(L_pat)})(L_nil)(L_parenGroups)})(lazy(function(L_list){return resolve(L_list)(lazy(function(L_h){return function(L_t){return resolve(L_stripParens)(L_h)}}))}))}}))},
  function(){return resolve(L_define)("parseG")(3)("parseG str pat groups = ifNotErr (parseIndent (token '\\n' 0) (tokens str pat) nil groups) \\list . list \\h t . stripParens h")(lazy(function(L_str){return function(L_pat){return function(L_groups){return resolve(L_ifNotErr)(function(){return resolve(L_parseIndent)(function(){return resolve(L_token)("\n")(0)})(function(){return resolve(L_tokens)(L_str)(L_pat)})(L_nil)(L_groups)})(lazy(function(L_list){return resolve(L_list)(lazy(function(L_h){return function(L_t){return resolve(L_stripParens)(L_h)}}))}))}}}))},
  function(){return resolve(L_define)("parseToAst")(2)("parseToAst str pat = createAst (parse str pat) nil")(lazy(function(L_str){return function(L_pat){return resolve(L_createAst)(function(){return resolve(L_parse)(L_str)(L_pat)})(L_nil)}}))},
  function(){return resolve(L_define)("parseM")(1)("parseM str =\n  bind (getValue 'tokenPat')\n    \\tokPat . bind (getValue 'tokenGroups')\n      \\groups . parseG str tokPat groups")(lazy(function(L_str){return resolve(L_bind)(function(){return resolve(L_getValue)("tokenPat")})(lazy(function(L_tokPat){return resolve(L_bind)(function(){return resolve(L_getValue)("tokenGroups")})(lazy(function(L_groups){return resolve(L_parseG)(L_str)(L_tokPat)(L_groups)}))}))}))},
  function(){return resolve(L_define)("scanLine")(4)("scanLine str pat onDef onExpr = scanLineG str pat parenGroups onDef onExpr")(lazy(function(L_str){return function(L_pat){return function(L_onDef){return function(L_onExpr){return resolve(L_scanLineG)(L_str)(L_pat)(L_parenGroups)(L_onDef)(L_onExpr)}}}}))},
  function(){return resolve(L_define)("parseLine")(5)("parseLine str pat names onDef onExpr = parseLineG str pat names parenGroups onDef onExpr")(lazy(function(L_str){return function(L_pat){return function(L_names){return function(L_onDef){return function(L_onExpr){return resolve(L_parseLineG)(L_str)(L_pat)(L_names)(L_parenGroups)(L_onDef)(L_onExpr)}}}}}))},
  function(){return resolve(L_define)("parseLineM")(1)("parseLineM str = bind (getValue 'tokenPat')\n  \\tokPat . bind (getValue 'tokenGroups')\n    \\groups . parseLineG str tokPat nil groups id id")(lazy(function(L_str){return resolve(L_bind)(function(){return resolve(L_getValue)("tokenPat")})(lazy(function(L_tokPat){return resolve(L_bind)(function(){return resolve(L_getValue)("tokenGroups")})(lazy(function(L_groups){return resolve(L_parseLineG)(L_str)(L_tokPat)(L_nil)(L_groups)(L_id)(L_id)}))}))}))},
  function(){return resolve(L_define)("macroSubM")(1)("macroSubM expr =\n  bind (getValue 'macroDefs')\n    \\macs . macroSub macs expr")(lazy(function(L_expr){return resolve(L_bind)(function(){return resolve(L_getValue)("macroDefs")})(lazy(function(L_macs){return resolve(L_macroSub)(L_macs)(L_expr)}))}))},
  function(){return resolve(L_define)("macroParse")(1)("macroParse str =\n  bind (parseM str)\n    \\ex . macroSubM ex")(lazy(function(L_str){return resolve(L_bind)(function(){return resolve(L_parseM)(L_str)})(lazy(function(L_ex){return resolve(L_macroSubM)(L_ex)}))}))},
  function(){return resolve(L_define)("tokensM")(1)("tokensM str =\n  bind (getValue 'tokenPat')\n    \\delimiterPat . tokens str delimiterPat")(lazy(function(L_str){return resolve(L_bind)(function(){return resolve(L_getValue)("tokenPat")})(lazy(function(L_delimiterPat){return resolve(L_tokens)(L_str)(L_delimiterPat)}))}))},
  function(){return resolve(L_define)("parseLines")(2)("parseLines lines result = lines\n  \\h t D . bind (parseLineM h)\n    \\ast . parseLines t (cons ast result)\n  reverse result")(lazy(function(L_lines){return function(L_result){return resolve(L_lines)(lazy(function(L_h){return function(L_t){return function(L_D){return resolve(L_bind)(function(){return resolve(L_parseLineM)(L_h)})(lazy(function(L_ast){return resolve(L_parseLines)(L_t)(function(){return resolve(L_cons)(L_ast)(L_result)})}))}}}))(function(){return resolve(L_reverse)(L_result)})}}))},
  function(){return resolve(L_define)("parseFile")(1)("parseFile text = parseLines (linesForFile text) nil")(lazy(function(L_text){return resolve(L_parseLines)(function(){return resolve(L_linesForFile)(L_text)})(L_nil)}))},
  function(){return resolve(L_define)("simpleScanLine")(1)("simpleScanLine line = bind (getValue 'tokenPat')\n  \\tokenPat . bind (getValue 'tokenGroups')\n    \\groups . scanLineG line tokenPat groups id id")(lazy(function(L_line){return resolve(L_bind)(function(){return resolve(L_getValue)("tokenPat")})(lazy(function(L_tokenPat){return resolve(L_bind)(function(){return resolve(L_getValue)("tokenGroups")})(lazy(function(L_groups){return resolve(L_scanLineG)(L_line)(L_tokenPat)(L_groups)(L_id)(L_id)}))}))}))},
  function(){return resolve(L_define)("scanLineM")(1)("scanLineM line = bind (getValue 'tokenPat')\n  \\tokenPat . bind (getValue 'tokenGroups')\n    \\groups . bind (getValue 'parseFilters')\n      \\filters . bind (getValue 'macroDefs')\n        \\macros . bind (runParseFilters filters (scanLineG line tokenPat groups id id))\n          \\scanned . macroSub macros scanned")(lazy(function(L_line){return resolve(L_bind)(function(){return resolve(L_getValue)("tokenPat")})(lazy(function(L_tokenPat){return resolve(L_bind)(function(){return resolve(L_getValue)("tokenGroups")})(lazy(function(L_groups){return resolve(L_bind)(function(){return resolve(L_getValue)("parseFilters")})(lazy(function(L_filters){return resolve(L_bind)(function(){return resolve(L_getValue)("macroDefs")})(lazy(function(L_macros){return resolve(L_bind)(function(){return resolve(L_runParseFilters)(L_filters)(function(){return resolve(L_scanLineG)(L_line)(L_tokenPat)(L_groups)(L_id)(L_id)})})(lazy(function(L_scanned){return resolve(L_macroSub)(L_macros)(L_scanned)}))}))}))}))}))}))},
  function(){return resolve(L_define)("newParseLine")(2)("newParseLine names line = bind (scanLineM line)\n  \\scanned . ifNotErr (createAst scanned names) \\ast . ast")(lazy(function(L_names){return function(L_line){return resolve(L_bind)(function(){return resolve(L_scanLineM)(L_line)})(lazy(function(L_scanned){return resolve(L_ifNotErr)(function(){return resolve(L_createAst)(L_scanned)(L_names)})(lazy(function(L_ast){return resolve(L_ast)}))}))}}))},
  function(){return resolve(L_define)("runLine")(2)("runLine names line = bind (newParseLine names line)\n  \\ast . bind (runAst ast)\n    \\result . cons\n      ast\n      isParseErr result\n        left (parseErrMsg result)\n        right result")(lazy(function(L_names){return function(L_line){return resolve(L_bind)(function(){return resolve(L_newParseLine)(L_names)(L_line)})(lazy(function(L_ast){return resolve(L_bind)(function(){return resolve(L_runAst)(L_ast)})(lazy(function(L_result){return resolve(L_cons)(L_ast)(function(){return resolve(L_isParseErr)(L_result)(function(){return resolve(L_left)(function(){return resolve(L_parseErrMsg)(L_result)})})(function(){return resolve(L_right)(L_result)})})}))}))}}))},
  function(){return resolve(L_define)("runLines")(2)("runLines names lines = lines\n  \\h t D . bind (runLine names h)\n    \\line . bind (runLines names t)\n      \\rest . cons line rest\n  nil")(lazy(function(L_names){return function(L_lines){return resolve(L_lines)(lazy(function(L_h){return function(L_t){return function(L_D){return resolve(L_bind)(function(){return resolve(L_runLine)(L_names)(L_h)})(lazy(function(L_line){return resolve(L_bind)(function(){return resolve(L_runLines)(L_names)(L_t)})(lazy(function(L_rest){return resolve(L_cons)(L_line)(L_rest)}))}))}}}))(L_nil)}}))},
  function(){return resolve(L_define)("runFile")(1)("runFile text = \\\\\n  lines = linesForFile text\n  names = namesForLines lines\n  .\n  runLines names lines")(lazy(function(L_text){return (function(){

var L_names, L_lines;

L_names = function(){return resolve(L_namesForLines)(L_lines)};

L_lines = function(){return resolve(L_linesForFile)(L_text)};
return resolve(L_runLines)(L_names)(L_lines)})()}))},
  function(){return resolve(L_define)("baseLoad")(1)("baseLoad file = bind (readFile file)\n  \\result . result\n    \\err . err\n    \\contents . bind (getValue 'activeTokenPacks')\n      \\activePacks . bind resetStdTokenPacks\n        \\_ . bind (runFile contents)\n          \\result . isNil activePacks\n            bind resetStdTokenPacks\n              \\_ . result\n            bind (resetTokenPacks activePacks)\n                \\_ . result")(lazy(function(L_file){return resolve(L_bind)(function(){return resolve(L_readFile)(L_file)})(lazy(function(L_result){return resolve(L_result)(lazy(function(L_err){return resolve(L_err)}))(lazy(function(L_contents){return resolve(L_bind)(function(){return resolve(L_getValue)("activeTokenPacks")})(lazy(function(L_activePacks){return resolve(L_bind)(L_resetStdTokenPacks)(lazy(function(L__){return resolve(L_bind)(function(){return resolve(L_runFile)(L_contents)})(lazy(function(L_result_0){return resolve(L_isNil)(L_activePacks)(function(){return resolve(L_bind)(L_resetStdTokenPacks)(lazy(function(L___1){return resolve(L_result_0)}))})(function(){return resolve(L_bind)(function(){return resolve(L_resetTokenPacks)(L_activePacks)})(lazy(function(L___1){return resolve(L_result_0)}))})}))}))}))}))}))}))},
  function(){return resolve(L_define)("load")(1)("load file = bind (baseLoad file)\n  \\result . \\\\\n    errs = foldr (\\line results . tail line (\\er . cons er results) (\\x . results)) nil result\n    .\n    isNil errs\n      right true\n      left errs")(lazy(function(L_file){return resolve(L_bind)(function(){return resolve(L_baseLoad)(L_file)})(lazy(function(L_result){return (function(){

var L_errs;

L_errs = function(){return resolve(L_foldr)(lazy(function(L_line){return function(L_results){return resolve(L_tail)(L_line)(lazy(function(L_er){return resolve(L_cons)(L_er)(L_results)}))(lazy(function(L_x){return resolve(L_results)}))}}))(L_nil)(L_result)};
return resolve(L_isNil)(L_errs)(function(){return resolve(L_right)(L_true)})(function(){return resolve(L_left)(L_errs)})})()}))}))},
  function(){return resolve(L_define)("require")(1)("require file = bind (getValue 'requiredFiles')\n  \\files . contains files file\n    false\n    bind (load file)\n      \\result . result\n        \\x . left x\n        \\_ . bind (setValue 'requiredFiles' (cons file files))\n          \\_ . right true")(lazy(function(L_file){return resolve(L_bind)(function(){return resolve(L_getValue)("requiredFiles")})(lazy(function(L_files){return resolve(L_contains)(L_files)(L_file)(L_false)(function(){return resolve(L_bind)(function(){return resolve(L_load)(L_file)})(lazy(function(L_result){return resolve(L_result)(lazy(function(L_x){return resolve(L_left)(L_x)}))(lazy(function(L__){return resolve(L_bind)(function(){return resolve(L_setValue)("requiredFiles")(function(){return resolve(L_cons)(L_file)(L_files)})})(lazy(function(L___0){return resolve(L_right)(L_true)}))}))}))})}))}))},
  function(){return resolve(L_define)("defTokenPack")(2)("defTokenPack name pack = bind (getValue 'tokenPacks')\n  \\packs . setValue 'tokenPacks' (acons name pack packs)")(lazy(function(L_name){return function(L_pack){return resolve(L_bind)(function(){return resolve(L_getValue)("tokenPacks")})(lazy(function(L_packs){return resolve(L_setValue)("tokenPacks")(function(){return resolve(L_acons)(L_name)(L_pack)(L_packs)})}))}}))},
  function(){return resolve(L_define)("useTokenPack")(1)("useTokenPack name = bind (getValue 'tokenPacks')\n  \\packs . bind (getValue 'tokenGroups')\n    \\groups . bind (getValue 'tokenList')\n      \\tokens . bind (getValue 'activeTokenPacks')\n        \\activePacks . bind (getValue 'parseFilters')\n          \\filters . assoc name packs\n            \\pack . \\\\\n              groupToks = foldl (\\value el . el \\h t . cons h (cons t value)) nil (head (tail pack))\n              newToks = quicksort (\\a b . > (strLen a) (strLen b)) (append (head pack) (append groupToks tokens))\n              .\n              bind (setValue 'tokenList' newToks)\n                \\_ . bind (setValue 'tokenGroups' (appendAlist (head (tail pack)) groups))\n                  \\_ . bind (setValue 'parseFilters' (append filters (head (tail (tail pack)))))\n                    \\_ . bind (computeTokenPat newToks)\n                      \\_ . setValue 'activeTokenPacks' (cons name activePacks)\n            nil")(lazy(function(L_name){return resolve(L_bind)(function(){return resolve(L_getValue)("tokenPacks")})(lazy(function(L_packs){return resolve(L_bind)(function(){return resolve(L_getValue)("tokenGroups")})(lazy(function(L_groups){return resolve(L_bind)(function(){return resolve(L_getValue)("tokenList")})(lazy(function(L_tokens){return resolve(L_bind)(function(){return resolve(L_getValue)("activeTokenPacks")})(lazy(function(L_activePacks){return resolve(L_bind)(function(){return resolve(L_getValue)("parseFilters")})(lazy(function(L_filters){return resolve(L_assoc)(L_name)(L_packs)(lazy(function(L_pack){return (function(){

var L_newToks, L_groupToks;

L_newToks = function(){return resolve(L_quicksort)(lazy(function(L_a){return function(L_b){return resolve(L_$z)(function(){return resolve(L_strLen)(L_a)})(function(){return resolve(L_strLen)(L_b)})}}))(function(){return resolve(L_append)(function(){return resolve(L_head)(L_pack)})(function(){return resolve(L_append)(L_groupToks)(L_tokens)})})};

L_groupToks = function(){return resolve(L_foldl)(lazy(function(L_value){return function(L_el){return resolve(L_el)(lazy(function(L_h){return function(L_t){return resolve(L_cons)(L_h)(function(){return resolve(L_cons)(L_t)(L_value)})}}))}}))(L_nil)(function(){return resolve(L_head)(function(){return resolve(L_tail)(L_pack)})})};
return resolve(L_bind)(function(){return resolve(L_setValue)("tokenList")(L_newToks)})(lazy(function(L__){return resolve(L_bind)(function(){return resolve(L_setValue)("tokenGroups")(function(){return resolve(L_appendAlist)(function(){return resolve(L_head)(function(){return resolve(L_tail)(L_pack)})})(L_groups)})})(lazy(function(L___0){return resolve(L_bind)(function(){return resolve(L_setValue)("parseFilters")(function(){return resolve(L_append)(L_filters)(function(){return resolve(L_head)(function(){return resolve(L_tail)(function(){return resolve(L_tail)(L_pack)})})})})})(lazy(function(L___1){return resolve(L_bind)(function(){return resolve(L_computeTokenPat)(L_newToks)})(lazy(function(L___2){return resolve(L_setValue)("activeTokenPacks")(function(){return resolve(L_cons)(L_name)(L_activePacks)})}))}))}))}))})()}))(L_nil)}))}))}))}))}))}))},
  function(){return resolve(L_define)("resetTokenPacks")(1)("resetTokenPacks packs = bind (setValue 'tokenGroups' nil)\n  \\_ . bind (setValue 'tokenList' nil)\n    \\_ . bind (setValue 'activeTokenPacks' nil)\n      \\_ . bind (setValue 'parseFilters' nil)\n        \\_ . foldr1\n          \\packCmd result . bind packCmd \\_ . result\n          map useTokenPack packs")(lazy(function(L_packs){return resolve(L_bind)(function(){return resolve(L_setValue)("tokenGroups")(L_nil)})(lazy(function(L__){return resolve(L_bind)(function(){return resolve(L_setValue)("tokenList")(L_nil)})(lazy(function(L___0){return resolve(L_bind)(function(){return resolve(L_setValue)("activeTokenPacks")(L_nil)})(lazy(function(L___1){return resolve(L_bind)(function(){return resolve(L_setValue)("parseFilters")(L_nil)})(lazy(function(L___2){return resolve(L_foldr1)(lazy(function(L_packCmd){return function(L_result){return resolve(L_bind)(L_packCmd)(lazy(function(L___3){return resolve(L_result)}))}}))(function(){return resolve(L_map)(L_useTokenPack)(L_packs)})}))}))}))}))}))},
  function(){return resolve(L_define)("resetStdTokenPacks")(0)("resetStdTokenPacks = bind (getValue 'stdTokenPacks')\n  \\stds . bind (resetTokenPacks stds)\n    \\_ . setValue 'activeTokenPacks' nil")(function(){return resolve(L_bind)(function(){return resolve(L_getValue)("stdTokenPacks")})(lazy(function(L_stds){return resolve(L_bind)(function(){return resolve(L_resetTokenPacks)(L_stds)})(lazy(function(L__){return resolve(L_setValue)("activeTokenPacks")(L_nil)}))}))})},
  function(){return resolve(L_define)("addStdTokenPacks")(1)("addStdTokenPacks morePacks = bind (getValue 'stdTokenPacks')\n  \\stds . setValue 'stdTokenPacks' (append stds morePacks)")(lazy(function(L_morePacks){return resolve(L_bind)(function(){return resolve(L_getValue)("stdTokenPacks")})(lazy(function(L_stds){return resolve(L_setValue)("stdTokenPacks")(function(){return resolve(L_append)(L_stds)(L_morePacks)})}))}))},
  function(){return resolve(L_define)("addParseFilter")(1)("addParseFilter filt = bind (getValue 'parseFilters')\n  \\filters . setValue 'parseFilters' (append filters (cons filt nil))")(lazy(function(L_filt){return resolve(L_bind)(function(){return resolve(L_getValue)("parseFilters")})(lazy(function(L_filters){return resolve(L_setValue)("parseFilters")(function(){return resolve(L_append)(L_filters)(function(){return resolve(L_cons)(L_filt)(L_nil)})})}))}))},
  function(){return resolve(L_define)("d")(3)("d label value expr = log (strCat (cons label (cons value nil))) expr")(lazy(function(L_label){return function(L_value){return function(L_expr){return resolve(L_log)(function(){return resolve(L_strCat)(function(){return resolve(L_cons)(L_label)(function(){return resolve(L_cons)(L_value)(L_nil)})})})(L_expr)}}}))},
  function(){return resolve(L_define)("dd")(2)("dd label arg = d label arg arg")(lazy(function(L_label){return function(L_arg){return resolve(L_d)(L_label)(L_arg)(L_arg)}}))},
  function(){return resolve(L_setValue)("macroDefs")(L_nil)},
  function(){return resolve(L_setValue)("requiredFiles")(L_nil)},
  function(){return resolve(L_setValue)("tokenPacks")(L_nil)},
  function(){return resolve(L_setValue)("activeTokenPacks")(L_nil)},
  function(){return resolve(L_setValue)("stdTokenPacks")(function(){return resolve(L_cons)("std")(L_nil)})},
  function(){return resolve(L_defTokenPack)("std")(function(){return resolve(L_cons)(function(){return resolve(L_cons)(".")(function(){return resolve(L_cons)("\\")(function(){return resolve(L_cons)("\\\\")(function(){return resolve(L_cons)("\\@")(L_nil)})})})})(function(){return resolve(L_cons)(function(){return resolve(L_acons)("(")(")")(L_nil)})(function(){return resolve(L_cons)(L_nil)(L_nil)})})})},
  function(){return resolve(L_resetStdTokenPacks)},
  function(){return resolve(L_addTokenGroup)("[")("]")},
  function(){return resolve(L_addToken)("|")},
  function(){return resolve(L_define)("listifyOp")(2)("listifyOp op list = list\n  \\h t D . isTokenString h '|'\n    cons t nil\n    cons (cons op (cons h (listifyOp op t))) nil\n  cons 'nil' nil")(lazy(function(L_op){return function(L_list){return resolve(L_list)(lazy(function(L_h){return function(L_t){return function(L_D){return resolve(L_isTokenString)(L_h)("|")(function(){return resolve(L_cons)(L_t)(L_nil)})(function(){return resolve(L_cons)(function(){return resolve(L_cons)(L_op)(function(){return resolve(L_cons)(L_h)(function(){return resolve(L_listifyOp)(L_op)(L_t)})})})(L_nil)})}}}))(function(){return resolve(L_cons)("nil")(L_nil)})}}))},
  function(){return resolve(L_define)("listify")(1)("listify list = listifyOp 'cons' list")(lazy(function(L_list){return resolve(L_listifyOp)("cons")(L_list)}))},
  function(){return resolve(L_defMacro)("[")(lazy(function(L_list){return resolve(L_list)(lazy(function(L_h){return function(L_t){return resolve(L_listify)(L_h)}}))}))},
  function(){return resolve(L_define)("listFilter")(1)("listFilter code = bind (getValue 'listMacros')\n  \\listMacros . filterApplies code \\list . list \\h t .\n    and (isToken h) (contains listMacros (tokenString h))\n      listFilterTail list\n      list")(lazy(function(L_code){return resolve(L_bind)(function(){return resolve(L_getValue)("listMacros")})(lazy(function(L_listMacros){return resolve(L_filterApplies)(L_code)(lazy(function(L_list){return resolve(L_list)(lazy(function(L_h){return function(L_t){return resolve(L_and)(function(){return resolve(L_isToken)(L_h)})(function(){return resolve(L_contains)(L_listMacros)(function(){return resolve(L_tokenString)(L_h)})})(function(){return resolve(L_listFilterTail)(L_list)})(L_list)}}))}))}))}))},
  function(){return resolve(L_define)("listFilterTail")(1)("listFilterTail list = list\n  \\h t D . isTokenString h '|'\n    > (length t) 2\n      cons h (cons (removeLast t) (cons (last t) nil))\n      list\n    cons h (listFilterTail t)\n  nil")(lazy(function(L_list){return resolve(L_list)(lazy(function(L_h){return function(L_t){return function(L_D){return resolve(L_isTokenString)(L_h)("|")(function(){return resolve(L_$z)(function(){return resolve(L_length)(L_t)})(2)(function(){return resolve(L_cons)(L_h)(function(){return resolve(L_cons)(function(){return resolve(L_removeLast)(L_t)})(function(){return resolve(L_cons)(function(){return resolve(L_last)(L_t)})(L_nil)})})})(L_list)})(function(){return resolve(L_cons)(L_h)(function(){return resolve(L_listFilterTail)(L_t)})})}}}))(L_nil)}))},
  function(){return resolve(L_define)("filterApplies")(2)("filterApplies code func = isParens code\n  code \\start end contents . parens start end (filterApplies contents func)\n  isCons code\n    \\\\\n      filtered = filterApplyElements code func\n      .\n      and (isCons filtered) (isBlockStart (head filtered))\n        filtered\n        func filtered\n    code")(lazy(function(L_code){return function(L_func){return resolve(L_isParens)(L_code)(function(){return resolve(L_code)(lazy(function(L_start){return function(L_end){return function(L_contents){return resolve(L_parens)(L_start)(L_end)(function(){return resolve(L_filterApplies)(L_contents)(L_func)})}}}))})(function(){return resolve(L_isCons)(L_code)(function(){
var L_filtered;

L_filtered = function(){return resolve(L_filterApplyElements)(L_code)(L_func)};
return resolve(L_and)(function(){return resolve(L_isCons)(L_filtered)})(function(){return resolve(L_isBlockStart)(function(){return resolve(L_head)(L_filtered)})})(L_filtered)(function(){return resolve(L_func)(L_filtered)})})(L_code)})}}))},
  function(){return resolve(L_define)("filterApplyElements")(2)("filterApplyElements code func = code\n  \\h t D . isBlockStart h\n    cons h (filterBlock h t func)\n    cons (filterApplies h func)\n      and (isCons t) (isBlockStart (head t))\n        cons (filterApplyElements t func) nil\n        filterApplyElements t func\n  nil")(lazy(function(L_code){return function(L_func){return resolve(L_code)(lazy(function(L_h){return function(L_t){return function(L_D){return resolve(L_isBlockStart)(L_h)(function(){return resolve(L_cons)(L_h)(function(){return resolve(L_filterBlock)(L_h)(L_t)(L_func)})})(function(){return resolve(L_cons)(function(){return resolve(L_filterApplies)(L_h)(L_func)})(function(){return resolve(L_and)(function(){return resolve(L_isCons)(L_t)})(function(){return resolve(L_isBlockStart)(function(){return resolve(L_head)(L_t)})})(function(){return resolve(L_cons)(function(){return resolve(L_filterApplyElements)(L_t)(L_func)})(L_nil)})(function(){return resolve(L_filterApplyElements)(L_t)(L_func)})})})}}}))(L_nil)}}))},
  function(){return resolve(L_define)("filterBlock")(3)("filterBlock type code func = isTokenString type '\\\\'\n  filterLambda code func\n  filterLet code func")(lazy(function(L_type){return function(L_code){return function(L_func){return resolve(L_isTokenString)(L_type)("\\")(function(){return resolve(L_filterLambda)(L_code)(L_func)})(function(){return resolve(L_filterLet)(L_code)(L_func)})}}}))},
  function(){return resolve(L_define)("filterLet")(2)("filterLet code func = code \\h t . isTokenString h '.'\n  cons h (filterApplies t func)\n  cons (filterLetBinding h func)\n    filterLet t func")(lazy(function(L_code){return function(L_func){return resolve(L_code)(lazy(function(L_h){return function(L_t){return resolve(L_isTokenString)(L_h)(".")(function(){return resolve(L_cons)(L_h)(function(){return resolve(L_filterApplies)(L_t)(L_func)})})(function(){return resolve(L_cons)(function(){return resolve(L_filterLetBinding)(L_h)(L_func)})(function(){return resolve(L_filterLet)(L_t)(L_func)})})}}))}}))},
  function(){return resolve(L_define)("filterLetBinding")(2)("filterLetBinding code func = isParens code\n  setParens code \\contents . filterLetBinding contents func\n  isCons code\n    code \\h t . cons h\n      isTokenString h '='\n        filterApplies t func\n        filterLetBinding t func\n    code")(lazy(function(L_code){return function(L_func){return resolve(L_isParens)(L_code)(function(){return resolve(L_setParens)(L_code)(lazy(function(L_contents){return resolve(L_filterLetBinding)(L_contents)(L_func)}))})(function(){return resolve(L_isCons)(L_code)(function(){return resolve(L_code)(lazy(function(L_h){return function(L_t){return resolve(L_cons)(L_h)(function(){return resolve(L_isTokenString)(L_h)("=")(function(){return resolve(L_filterApplies)(L_t)(L_func)})(function(){return resolve(L_filterLetBinding)(L_t)(L_func)})})}}))})(L_code)})}}))},
  function(){return resolve(L_define)("filterLambda")(2)("filterLambda code func = code \\h t . cons h\n  isTokenString h '.'\n    filterApplies t func\n    filterLambda t func")(lazy(function(L_code){return function(L_func){return resolve(L_code)(lazy(function(L_h){return function(L_t){return resolve(L_cons)(L_h)(function(){return resolve(L_isTokenString)(L_h)(".")(function(){return resolve(L_filterApplies)(L_t)(L_func)})(function(){return resolve(L_filterLambda)(L_t)(L_func)})})}}))}}))},
  function(){return resolve(L_setValue)("listMacros")(function(){return resolve(L_cons)("[")(function(){return resolve(L_cons)("{")(function(){return resolve(L_cons)("hamt{")(L_nil)})})})},
  function(){return resolve(L_addParseFilter)(L_listFilter)},
  function(){return resolve(L_addTokenGroup)("{")("}")},
  function(){return resolve(L_defMacro)("{")(lazy(function(L_list){return resolve(L_list)(lazy(function(L_h){return function(L_t){return resolve(L_listifyOp)("aconsPair")(L_h)}}))}))},
  function(){return resolve(L_addTokenGroup)("hamt{")("}")},
  function(){return resolve(L_defMacro)("hamt{")(lazy(function(L_list){return resolve(L_list)(lazy(function(L_h){return function(L_t){return resolve(L_hamtify)(L_h)}}))}))},
  function(){return resolve(L_define)("hamtWithPair")(2)("hamtWithPair pair t = hamtWith (head pair) (tail pair) t")(lazy(function(L_pair){return function(L_t){return resolve(L_hamtWith)(function(){return resolve(L_head)(L_pair)})(function(){return resolve(L_tail)(L_pair)})(L_t)}}))},
  function(){return resolve(L_define)("hamtify")(1)("hamtify list = list\n  \\h t D . isTokenString h '|'\n    cons t nil\n    and (isCons h) (or (isTokenString (head h) 'cons') (isTokenString (head h) ':'))\n      [['hamtWith' (head (tail h)) (head (tail (tail h))) | hamtify t]]\n      [['hamtWithPair' h | hamtify t]]\n  ['hamt']")(lazy(function(L_list){return resolve(L_list)(lazy(function(L_h){return function(L_t){return function(L_D){return resolve(L_isTokenString)(L_h)("|")(function(){return resolve(L_cons)(L_t)(L_nil)})(function(){return resolve(L_and)(function(){return resolve(L_isCons)(L_h)})(function(){return resolve(L_or)(function(){return resolve(L_isTokenString)(function(){return resolve(L_head)(L_h)})("cons")})(function(){return resolve(L_isTokenString)(function(){return resolve(L_head)(L_h)})(":")})})(function(){return resolve(L_cons)(function(){return resolve(L_cons)("hamtWith")(function(){return resolve(L_cons)(function(){return resolve(L_head)(function(){return resolve(L_tail)(L_h)})})(function(){return resolve(L_cons)(function(){return resolve(L_head)(function(){return resolve(L_tail)(function(){return resolve(L_tail)(L_h)})})})(function(){return resolve(L_hamtify)(L_t)})})})})(L_nil)})(function(){return resolve(L_cons)(function(){return resolve(L_cons)("hamtWithPair")(function(){return resolve(L_cons)(L_h)(function(){return resolve(L_hamtify)(L_t)})})})(L_nil)})})}}}))(function(){return resolve(L_cons)("hamt")(L_nil)})}))},
  function(){return resolve(L_defTokenPack)("list")(function(){return resolve(L_cons)(function(){return resolve(L_cons)("|")(function(){return resolve(L_cons)("=")(L_nil)})})(function(){return resolve(L_cons)(function(){return resolve(L_aconsPair)(function(){return resolve(L_cons)("{")("}")})(function(){return resolve(L_aconsPair)(function(){return resolve(L_cons)("hamt{")("}")})(function(){return resolve(L_aconsPair)(function(){return resolve(L_cons)("[")("]")})(function(){return resolve(L_aconsPair)(function(){return resolve(L_cons)("or[")("]")})(function(){return resolve(L_aconsPair)(function(){return resolve(L_cons)("and[")("]")})(function(){return resolve(L_aconsPair)(function(){return resolve(L_cons)("concat[")("]")})(function(){return resolve(L_aconsPair)(function(){return resolve(L_cons)("concatFlat[")("]")})(L_nil)})})})})})})})(function(){return resolve(L_cons)(function(){return resolve(L_cons)(L_listFilter)(L_nil)})(L_nil)})})})},
  function(){return resolve(L_addTokenGroup)("or[")("]")},
  function(){return resolve(L_addTokenGroup)("and[")("]")},
  function(){return resolve(L_addTokenGroup)("concat[")("]")},
  function(){return resolve(L_addTokenGroup)("concatFlat[")("]")},
  function(){return resolve(L_define)("listMacroFoldOp")(3)("listMacroFoldOp op emptyCase list = list \\h t . foldr\n    \\case result . [op case result]\n    emptyCase\n    h")(lazy(function(L_op){return function(L_emptyCase){return function(L_list){return resolve(L_list)(lazy(function(L_h){return function(L_t){return resolve(L_foldr)(lazy(function(L_case){return function(L_result){return resolve(L_cons)(L_op)(function(){return resolve(L_cons)(L_case)(function(){return resolve(L_cons)(L_result)(L_nil)})})}}))(L_emptyCase)(L_h)}}))}}}))},
  function(){return resolve(L_defMacro)("or[")(lazy(function(L_list){return resolve(L_listMacroFoldOp)("or")("false")(L_list)}))},
  function(){return resolve(L_defMacro)("and[")(lazy(function(L_list){return resolve(L_listMacroFoldOp)("and")("true")(L_list)}))},
  function(){return resolve(L_defMacro)("concat[")(lazy(function(L_list){return resolve(L_cons)("strCat")(function(){return resolve(L_cons)(function(){return resolve(L_cons)(function(){return resolve(L_listify)(function(){return resolve(L_head)(L_list)})})(L_nil)})(L_nil)})}))},
  function(){return resolve(L_defMacro)("concatFlat[")(lazy(function(L_list){return resolve(L_cons)("strCat")(function(){return resolve(L_cons)(function(){return resolve(L_cons)("flatten")(function(){return resolve(L_cons)(function(){return resolve(L_cons)(function(){return resolve(L_listify)(function(){return resolve(L_head)(L_list)})})(L_nil)})(L_nil)})})(L_nil)})}))},
  function(){return resolve(L_bind)(function(){return resolve(L_getValue)("listMacros")})(lazy(function(L_lm){return resolve(L_cons)("concat[")(L_lm)}))},
  function(){return resolve(L_define)("infix")(1)("infix code = bind (getValue 'infixPrecedence')\n  \\prec . bind (getValue 'infixRightAssociative')\n    \\right . bind (getValue 'tokenGroups')\n      \\groups . filterApplies\n        code\n        \\expr . infixRearrange prec right (map (\\cell . tail cell) groups) expr")(lazy(function(L_code){return resolve(L_bind)(function(){return resolve(L_getValue)("infixPrecedence")})(lazy(function(L_prec){return resolve(L_bind)(function(){return resolve(L_getValue)("infixRightAssociative")})(lazy(function(L_right){return resolve(L_bind)(function(){return resolve(L_getValue)("tokenGroups")})(lazy(function(L_groups){return resolve(L_filterApplies)(L_code)(lazy(function(L_expr){return resolve(L_infixRearrange)(L_prec)(L_right)(function(){return resolve(L_map)(lazy(function(L_cell){return resolve(L_tail)(L_cell)}))(L_groups)})(L_expr)}))}))}))}))}))},
  function(){return resolve(L_define)("infixRearrange")(4)("infixRearrange prec right closes list = \\\\\n  len = length list\n  head1 = head list\n  tail1 = tail list\n  head2 = head tail1\n  tail2 = tail tail1\n  head3 = head tail2\n  opPrec = getPrec prec head2\n  .\n  < len 2\n    list\n    isInfix opPrec head1 head2 len\n      or (== len 2) (not (isInfixArg closes head3))\n        [[head2 head1] | tail2]\n        infixRearrange prec right closes (absorbArgument opPrec prec right closes head1 head2 tail2 head3 (- len 2))\n      [head1 | infixRearrange prec right closes tail1]")(lazy(function(L_prec){return function(L_right){return function(L_closes){return function(L_list){return (function(){

var L_opPrec, L_head3, L_tail2, L_head2, L_tail1, L_head1, L_len;

L_opPrec = function(){return resolve(L_getPrec)(L_prec)(L_head2)};

L_head3 = function(){return resolve(L_head)(L_tail2)};

L_tail2 = function(){return resolve(L_tail)(L_tail1)};

L_head2 = function(){return resolve(L_head)(L_tail1)};

L_tail1 = function(){return resolve(L_tail)(L_list)};

L_head1 = function(){return resolve(L_head)(L_list)};

L_len = function(){return resolve(L_length)(L_list)};
return resolve(L_$y)(L_len)(2)(L_list)(function(){return resolve(L_isInfix)(L_opPrec)(L_head1)(L_head2)(L_len)(function(){return resolve(L_or)(function(){return resolve(L_$p$p)(L_len)(2)})(function(){return resolve(L_not)(function(){return resolve(L_isInfixArg)(L_closes)(L_head3)})})(function(){return resolve(L_cons)(function(){return resolve(L_cons)(L_head2)(function(){return resolve(L_cons)(L_head1)(L_nil)})})(L_tail2)})(function(){return resolve(L_infixRearrange)(L_prec)(L_right)(L_closes)(function(){return resolve(L_absorbArgument)(L_opPrec)(L_prec)(L_right)(L_closes)(L_head1)(L_head2)(L_tail2)(L_head3)(function(){return resolve(L_$_)(L_len)(2)})})})})(function(){return resolve(L_cons)(L_head1)(function(){return resolve(L_infixRearrange)(L_prec)(L_right)(L_closes)(L_tail1)})})})})()}}}}))},
  function(){return resolve(L_define)("absorbArgument")(9)("absorbArgument opPrec prec right closes head1 head2 tail2 head3 len = \\\\\n  tail3 = tail tail2\n  head4 = head tail3\n  tail4 = tail tail3\n  head5 = head tail4\n  .\n  infixShouldEatNext opPrec prec (contains right (strTokenString head2)) head3 head4 head5 closes len\n    [head1 head2 | absorbArgument (getPrec prec head4) prec right closes head3 head4 tail4 head5 (- len 2)]\n    [[head2 head1 head3] | tail3]")(lazy(function(L_opPrec){return function(L_prec){return function(L_right){return function(L_closes){return function(L_head1){return function(L_head2){return function(L_tail2){return function(L_head3){return function(L_len){return (function(){

var L_head5, L_tail4, L_head4, L_tail3;

L_head5 = function(){return resolve(L_head)(L_tail4)};

L_tail4 = function(){return resolve(L_tail)(L_tail3)};

L_head4 = function(){return resolve(L_head)(L_tail3)};

L_tail3 = function(){return resolve(L_tail)(L_tail2)};
return resolve(L_infixShouldEatNext)(L_opPrec)(L_prec)(function(){return resolve(L_contains)(L_right)(function(){return resolve(L_strTokenString)(L_head2)})})(L_head3)(L_head4)(L_head5)(L_closes)(L_len)(function(){return resolve(L_cons)(L_head1)(function(){return resolve(L_cons)(L_head2)(function(){return resolve(L_absorbArgument)(function(){return resolve(L_getPrec)(L_prec)(L_head4)})(L_prec)(L_right)(L_closes)(L_head3)(L_head4)(L_tail4)(L_head5)(function(){return resolve(L_$_)(L_len)(2)})})})})(function(){return resolve(L_cons)(function(){return resolve(L_cons)(L_head2)(function(){return resolve(L_cons)(L_head1)(function(){return resolve(L_cons)(L_head3)(L_nil)})})})(L_tail3)})})()}}}}}}}}}))},
  function(){return resolve(L_define)("isInfixArg")(2)("isInfixArg closes item = or[\n  isParens item\n  isCons item\n  and[\n    isToken item\n    not (contains closes (tokenString item))\n    not (isBlockStart item)]]")(lazy(function(L_closes){return function(L_item){return resolve(L_or)(function(){return resolve(L_isParens)(L_item)})(function(){return resolve(L_or)(function(){return resolve(L_isCons)(L_item)})(function(){return resolve(L_or)(function(){return resolve(L_and)(function(){return resolve(L_isToken)(L_item)})(function(){return resolve(L_and)(function(){return resolve(L_not)(function(){return resolve(L_contains)(L_closes)(function(){return resolve(L_tokenString)(L_item)})})})(function(){return resolve(L_and)(function(){return resolve(L_not)(function(){return resolve(L_isBlockStart)(L_item)})})(L_true)})})})(L_false)})})}}))},
  function(){return resolve(L_define)("isInfix")(4)("isInfix opPrec head1 head2 len = and[\n  > len 1\n  > opPrec -1\n  isInfixArg nil head1]")(lazy(function(L_opPrec){return function(L_head1){return function(L_head2){return function(L_len){return resolve(L_and)(function(){return resolve(L_$z)(L_len)(1)})(function(){return resolve(L_and)(function(){return resolve(L_$z)(L_opPrec)(-1)})(function(){return resolve(L_and)(function(){return resolve(L_isInfixArg)(L_nil)(L_head1)})(L_true)})})}}}}))},
  function(){return resolve(L_define)("getPrec")(2)("getPrec prec token = \\\\\n  str = tokenString token\n  .\n  isToken token\n    findIndex (\\level . contains level str) prec\n    -1")(lazy(function(L_prec){return function(L_token){return (function(){

var L_str;

L_str = function(){return resolve(L_tokenString)(L_token)};
return resolve(L_isToken)(L_token)(function(){return resolve(L_findIndex)(lazy(function(L_level){return resolve(L_contains)(L_level)(L_str)}))(L_prec)})(-1)})()}}))},
  function(){return resolve(L_define)("infixShouldEatNext")(8)("infixShouldEatNext opPrec prec isRight curArg nextOp nextArg closes len = \\\\\n  nextPrec = getPrec prec nextOp\n  .\n  and[\n    > len 2\n    isInfix nextPrec curArg nextOp len\n    or (> opPrec nextPrec) (and (== opPrec nextPrec) isRight)\n    isInfixArg closes nextArg]")(lazy(function(L_opPrec){return function(L_prec){return function(L_isRight){return function(L_curArg){return function(L_nextOp){return function(L_nextArg){return function(L_closes){return function(L_len){return (function(){

var L_nextPrec;

L_nextPrec = function(){return resolve(L_getPrec)(L_prec)(L_nextOp)};
return resolve(L_and)(function(){return resolve(L_$z)(L_len)(2)})(function(){return resolve(L_and)(function(){return resolve(L_isInfix)(L_nextPrec)(L_curArg)(L_nextOp)(L_len)})(function(){return resolve(L_and)(function(){return resolve(L_or)(function(){return resolve(L_$z)(L_opPrec)(L_nextPrec)})(function(){return resolve(L_and)(function(){return resolve(L_$p$p)(L_opPrec)(L_nextPrec)})(L_isRight)})})(function(){return resolve(L_and)(function(){return resolve(L_isInfixArg)(L_closes)(L_nextArg)})(L_true)})})})})()}}}}}}}}))},
  function(){return resolve(L_defMacro)(":")(lazy(function(L_list){return resolve(L_cons)("cons")(L_list)}))},
  function(){return resolve(L_define)("iprec")(0)("iprec = [['*' '/' '%'] ['+' '-'] [':'] ['<' '>' '<=' '>='] ['==' '!=']]")(function(){return resolve(L_cons)(function(){return resolve(L_cons)("*")(function(){return resolve(L_cons)("/")(function(){return resolve(L_cons)("%")(L_nil)})})})(function(){return resolve(L_cons)(function(){return resolve(L_cons)("+")(function(){return resolve(L_cons)("-")(L_nil)})})(function(){return resolve(L_cons)(function(){return resolve(L_cons)(":")(L_nil)})(function(){return resolve(L_cons)(function(){return resolve(L_cons)("<")(function(){return resolve(L_cons)(">")(function(){return resolve(L_cons)("<=")(function(){return resolve(L_cons)(">=")(L_nil)})})})})(function(){return resolve(L_cons)(function(){return resolve(L_cons)("==")(function(){return resolve(L_cons)("!=")(L_nil)})})(L_nil)})})})})})},
  function(){return resolve(L_define)("rightAssoc")(0)("rightAssoc = [':']")(function(){return resolve(L_cons)(":")(L_nil)})},
  function(){return resolve(L_setValue)("infixPrecedence")(L_iprec)},
  function(){return resolve(L_setValue)("infixRightAssociative")(L_rightAssoc)},
  function(){return resolve(L_defTokenPack)("infix")(function(){return resolve(L_cons)(function(){return resolve(L_flatten)(L_iprec)})(function(){return resolve(L_cons)(L_nil)(function(){return resolve(L_cons)(function(){return resolve(L_cons)(L_infix)(L_nil)})(L_nil)})})})},
  function(){return resolve(L_useTokenPack)("infix")},
  function(){return resolve(L_defMacro)("do")(lazy(function(L_list){return resolve(L_handleDo)(L_list)(L_false)(L_id)}))},
  function(){return resolve(L_define)("handleDo")(3)("handleDo list inLet cont = list\n  \\h t D . isNil t\n    cont (inLet ['.' h] [h])\n    doClause (stripParens h) h nil inLet \\newInLet chain .\n      handleDo t newInLet \\rest . cont (chain rest)\n  cont nil")(lazy(function(L_list){return function(L_inLet){return function(L_cont){return resolve(L_list)(lazy(function(L_h){return function(L_t){return function(L_D){return resolve(L_isNil)(L_t)(function(){return resolve(L_cont)(function(){return resolve(L_inLet)(function(){return resolve(L_cons)(".")(function(){return resolve(L_cons)(L_h)(L_nil)})})(function(){return resolve(L_cons)(L_h)(L_nil)})})})(function(){return resolve(L_doClause)(function(){return resolve(L_stripParens)(L_h)})(L_h)(L_nil)(L_inLet)(lazy(function(L_newInLet){return function(L_chain){return resolve(L_handleDo)(L_t)(L_newInLet)(lazy(function(L_rest){return resolve(L_cont)(function(){return resolve(L_chain)(L_rest)})}))}}))})}}}))(function(){return resolve(L_cont)(L_nil)})}}}))},
  function(){return resolve(L_define)("doClause")(5)("doClause steppingClause clause prefix inLet cont = \\\\\n  makeBind var monad = cont false \\rest . inLet (cons '.') id\n    ['bind' monad ['\\\\' var '.' | rest]]\n  .\n  isCons steppingClause\n    steppingClause \\h t . isTokenString h '='\n      inLet\n        cont true \\rest . [clause | rest]\n        cont true \\rest . ['\\\\\\\\' clause | rest]\n      isTokenString h '<-'\n        isNil t\n          parseErr \"No monad in do-clause: \" clause\n          prefix\n            \\ph pt D . isNil pt\n              makeBind (isNil prefix '_' (head prefix)) t\n              parseErr \"More than one variable in do-clause: \" clause\n            makeBind '_' t\n        doClause t clause [h | prefix] inLet cont\n    makeBind '_' clause")(lazy(function(L_steppingClause){return function(L_clause){return function(L_prefix){return function(L_inLet){return function(L_cont){return (function(){

var L_makeBind;

L_makeBind = lazy(function(L_var){return function(L_monad){return resolve(L_cont)(L_false)(lazy(function(L_rest){return resolve(L_inLet)(function(){return resolve(L_cons)(".")})(L_id)(function(){return resolve(L_cons)("bind")(function(){return resolve(L_cons)(L_monad)(function(){return resolve(L_cons)(function(){return resolve(L_cons)("\\")(function(){return resolve(L_cons)(L_var)(function(){return resolve(L_cons)(".")(L_rest)})})})(L_nil)})})})}))}});
return resolve(L_isCons)(L_steppingClause)(function(){return resolve(L_steppingClause)(lazy(function(L_h){return function(L_t){return resolve(L_isTokenString)(L_h)("=")(function(){return resolve(L_inLet)(function(){return resolve(L_cont)(L_true)(lazy(function(L_rest){return resolve(L_cons)(L_clause)(L_rest)}))})(function(){return resolve(L_cont)(L_true)(lazy(function(L_rest){return resolve(L_cons)("\\\\")(function(){return resolve(L_cons)(L_clause)(L_rest)})}))})})(function(){return resolve(L_isTokenString)(L_h)("<-")(function(){return resolve(L_isNil)(L_t)(function(){return resolve(L_parseErr)("No monad in do-clause: ")(L_clause)})(function(){return resolve(L_prefix)(lazy(function(L_ph){return function(L_pt){return function(L_D){return resolve(L_isNil)(L_pt)(function(){return resolve(L_makeBind)(function(){return resolve(L_isNil)(L_prefix)("_")(function(){return resolve(L_head)(L_prefix)})})(L_t)})(function(){return resolve(L_parseErr)("More than one variable in do-clause: ")(L_clause)})}}}))(function(){return resolve(L_makeBind)("_")(L_t)})})})(function(){return resolve(L_doClause)(L_t)(L_clause)(function(){return resolve(L_cons)(L_h)(L_prefix)})(L_inLet)(L_cont)})})}}))})(function(){return resolve(L_makeBind)("_")(L_clause)})})()}}}}}))},
  function(){return resolve(L_defTokenPack)("do")(function(){return resolve(L_cons)(function(){return resolve(L_cons)("<-")(L_nil)})(function(){return resolve(L_cons)(L_nil)(function(){return resolve(L_cons)(L_nil)(L_nil)})})})},
  function(){return resolve(L_addStdTokenPacks)(function(){return resolve(L_cons)("list")(function(){return resolve(L_cons)("infix")(function(){return resolve(L_cons)("do")(L_nil)})})})},
  function(){return resolve(L_resetStdTokenPacks)}]);

},{}],6:[function(require,module,exports){
(function(global){/*!
 Lo-Dash 0.7.0 lodash.com/license
 Underscore.js 1.3.3 github.com/documentcloud/underscore/blob/master/LICENSE
*/
;(function(e,t){function s(e){return new o(e)}function o(e){if(e&&e.__wrapped__)return e;this.__wrapped__=e}function u(e,t){return function(n,r,i){return e.call(t,n,r,i)}}function a(e,t,n){t||(t=0);var r=e.length,i=r-t>=(n||W),s=i?{}:e;if(i)for(var o=t-1;++o<r;)n=e[o]+"",(at.call(s,n)?s[n]:s[n]=[]).push(e[o]);return function(e){if(i){var n=e+"";return at.call(s,n)&&-1<L(s[n],e)}return-1<L(s,e,t)}}function f(e,n){var r=e.b,i=n.b,e=e.a,n=n.a;if(e!==n){if(e>n||e===t)return 1;if(e<n||n===t)return-1}return r<
i?-1:1}function l(e,t,n){function r(){var u=arguments,a=s?this:t;return i||(e=t[o]),n.length&&(u=u.length?n.concat(ct.call(u)):n),this instanceof r?(v.prototype=e.prototype,a=new v,(u=e.apply(a,u))&&$t[typeof u]?u:a):e.apply(a,u)}var i=E(e),s=!n,o=e;return s&&(n=t),r}function c(){for(var e,t,n,s=-1,o=arguments.length,a={e:"",f:"",j:"",q:"",c:{d:""},m:{d:""}};++s<o;)for(t in e=arguments[s],e)n=(n=e[t])==r?"":n,/d|i/.test(t)?("string"==typeof n&&(n={b:n,l:n}),a.c[t]=n.b||"",a.m[t]=n.l||""):a[t]=n;e=
a.a,t=/^[^,]+/.exec(e)[0],n=a.s,a.g=t,a.h=Mt,a.k=Rt,a.n=Pt,a.p=rt,a.r=a.r!==i,a.s=n==r?Ut:n,a.o==r&&(a.o=jt),a.f||(a.f="if(!"+t+")return u");if("e"!=t||!a.c.i)a.c=r;t="",a.s&&(t+="'use strict';"),t+="var j,A,k="+a.g+",u",a.j&&(t+="="+a.j),t+=";"+a.f+";"+a.q+";",a.c&&(t+="var l=k.length;j=-1;",a.m&&(t+="if(l===+l){"),a.o&&(t+="if(z.call(k)==x){k=k.split('')}"),t+=a.c.d+";while(++j<l){A=k[j];"+a.c.i+"}",a.m&&(t+="}"));if(a.m){a.c?t+="else{":a.n&&(t+="var l=k.length;j=-1;if(l&&O(k)){while(++j<l){A=k[j+=''];"+
a.m.i+"}}else{"),a.h||(t+="var v=typeof k=='function'&&r.call(k,'prototype');");if(a.k&&a.r)t+="var o=-1,p=X[typeof k]?m(k):[],l=p.length;"+a.m.d+";while(++o<l){j=p[o];",a.h||(t+="if(!(v&&j=='prototype')){"),t+="A=k[j];"+a.m.i+"",a.h||(t+="}");else{t+=a.m.d+";for(j in k){";if(!a.h||a.r)t+="if(",a.h||(t+="!(v&&j=='prototype')"),!a.h&&a.r&&(t+="&&"),a.r&&(t+="h.call(k,j)"),t+="){";t+="A=k[j];"+a.m.i+";";if(!a.h||a.r)t+="}"}t+="}";if(a.h){t+="var g=k.constructor;";for(n=0;7>n;n++)t+="j='"+a.p[n]+"';if("
,"constructor"==a.p[n]&&(t+="!(g&&g.prototype===k)&&"),t+="h.call(k,j)){A=k[j];"+a.m.i+"}"}if(a.c||a.n)t+="}"}return t+=a.e+";return u",Function("D,E,F,c,I,f,J,h,i,M,O,Q,S,T,W,X,m,r,w,x,z","var G=function("+e+"){"+t+"};return G")(zt,R,D,u,f,ut,ln,at,P,L,w,sn,E,on,Ct,$t,gt,lt,ct,Lt,ht)}function h(e,t){return ot[t]}function p(e){return"\\"+Jt[e]}function d(e){return Xt[e]}function v(){}function m(e,t){if(e&&V.test(t))return"<e%-"+t+"%>";var n=ot.length;return ot[n]="'+__e("+t+")+'",it+n+st}function g
(e,t,n,i){return i?(e=ot.length,ot[e]="';"+i+";__p+='",it+e+st):t?m(r,t):y(r,n)}function y(e,t){if(e&&V.test(t))return"<e%="+t+"%>";var n=ot.length;return ot[n]="'+((__t=("+t+"))==null?'':__t)+'",it+n+st}function b(e){return Vt[e]}function w(e){return ht.call(e)==Et}function E(e){return"function"==typeof e}function S(e,t){var n=i;if(!e||"object"!=typeof e||!t&&w(e))return n;var r=e.constructor;return(!Ft||"function"==typeof e.toString||"string"!=typeof (e+""))&&(!E(r)||r instanceof r)?Dt?(ln(e,function(
e,t,r){return n=!at.call(r,t),i}),n===i):(ln(e,function(e,t){n=t}),n===i||at.call(e,n)):n}function x(e,t,s,o,u){if(e==r)return e;s&&(t=i);if(s=$t[typeof e]){var a=ht.call(e);if(!Wt[a]||Ht&&w(e))return e;var f=a==St,s=f||(a==Ct?on(e,n):s)}if(!s||!t)return s?f?ct.call(e):fn({},e):e;s=e.constructor;switch(a){case xt:return new s(e==n);case Tt:return new s(+e);case Nt:case Lt:return new s(e);case kt:return s(e.source,G.exec(e))}o||(o=[]),u||(u=[]);for(a=o.length;a--;)if(o[a]==e)return u[a];var l=f?s(
a=e.length):{};o.push(e),u.push(l);if(f)for(f=-1;++f<a;)l[f]=x(e[f],t,r,o,u);else cn(e,function(e,n){l[n]=x(e,t,r,o,u)});return l}function T(e,t,s,o){if(e==r||t==r)return e===t;if(e===t)return 0!==e||1/e==1/t;if($t[typeof e]||$t[typeof t])e=e.__wrapped__||e,t=t.__wrapped__||t;var u=ht.call(e);if(u!=ht.call(t))return i;switch(u){case xt:case Tt:return+e==+t;case Nt:return e!=+e?t!=+t:0==e?1/e==1/t:e==+t;case kt:case Lt:return e==t+""}var a=zt[u];if(Ht&&!a&&(a=w(e))&&!w(t)||!a&&(u!=Ct||Ft&&("function"!=typeof 
e.toString&&"string"==typeof (e+"")||"function"!=typeof t.toString&&"string"==typeof (t+""))))return i;s||(s=[]),o||(o=[]);for(u=s.length;u--;)if(s[u]==e)return o[u]==t;var u=-1,f=n,l=0;s.push(e),o.push(t);if(a){l=e.length;if(f=l==t.length)for(;l--&&(f=T(e[l],t[l],s,o)););return f}a=e.constructor,f=t.constructor;if(a!=f&&(!E(a)||!(a instanceof a&&E(f)&&f instanceof f)))return i;for(var c in e)if(at.call(e,c)&&(l++,!at.call(t,c)||!T(e[c],t[c],s,o)))return i;for(c in t)if(at.call(t,c)&&!(l--))return i
;if(Mt)for(;7>++u;)if(c=rt[u],at.call(e,c)&&(!at.call(t,c)||!T(e[c],t[c],s,o)))return i;return n}function N(e,t,n,r){if(!e)return n;var i=e.length,s=3>arguments.length;r&&(t=u(t,r));if(i===+i){var o=jt&&ht.call(e)==Lt?e.split(""):e;for(i&&s&&(n=o[--i]);i--;)n=t(n,o[i],i,e);return n}o=vn(e);for((i=o.length)&&s&&(n=e[o[--i]]);i--;)s=o[i],n=t(n,e[s],s,e);return n}function C(e,t,n){if(e)return t==r||n?e[0]:ct.call(e,0,t)}function k(e,t){var n=[];if(!e)return n;for(var r,i=-1,s=e.length;++i<s;)r=e[i],
sn(r)?ft.apply(n,t?r:k(r)):n.push(r);return n}function L(e,t,n){if(!e)return-1;var r=-1,i=e.length;if(n){if("number"!=typeof n)return r=M(e,t),e[r]===t?r:-1;r=(0>n?yt(0,i+n):n)-1}for(;++r<i;)if(e[r]===t)return r;return-1}function A(e,t,n){var r=-Infinity,i=r;if(!e)return i;var s=-1,o=e.length;if(!t){for(;++s<o;)e[s]>i&&(i=e[s]);return i}for(n&&(t=u(t,n));++s<o;)n=t(e[s],s,e),n>r&&(r=n,i=e[s]);return i}function O(e,t,n){return e?ct.call(e,t==r||n?1:t):[]}function M(e,t,n,r){if(!e)return 0;var i=0,
s=e.length;if(n){r&&(n=D(n,r));for(t=n(t);i<s;)r=i+s>>>1,n(e[r])<t?i=r+1:s=r}else for(;i<s;)r=i+s>>>1,e[r]<t?i=r+1:s=r;return i}function _(e,t,n,r){var s=[];if(!e)return s;var o=-1,a=e.length,f=[];"function"==typeof t&&(r=n,n=t,t=i);for(n?r&&(n=u(n,r)):n=P;++o<a;)if(r=n(e[o],o,e),t?!o||f[f.length-1]!==r:0>L(f,r))f.push(r),s.push(e[o]);return s}function D(e,t){return qt||pt&&2<arguments.length?pt.call.apply(pt,arguments):l(e,t,ct.call(arguments,2))}function P(e){return e}function H(e){Cn(hn(e),function(
t){var r=s[t]=e[t];o.prototype[t]=function(){var e=[this.__wrapped__];return arguments.length&&ft.apply(e,arguments),e=r.apply(s,e),this.__chain__&&(e=new o(e),e.__chain__=n),e}})}var n=!0,r=null,i=!1,B,j,F,I,q="object"==typeof exports&&exports&&("object"==typeof global&&global&&global==global.global&&(e=global),exports),R=Array.prototype,U=Object.prototype,z=0,W=30,X=e._,V=/[-?+=!~*%&^<>|{(\/]|\[\D|\b(?:delete|in|instanceof|new|typeof|void)\b/,$=/&(?:amp|lt|gt|quot|#x27);/g,J=/\b__p\+='';/g,K=/\b(__p\+=)''\+/g
,Q=/(__e\(.*?\)|\b__t\))\+'';/g,G=/\w*$/,Y=/(?:__e|__t=)\(\s*(?![\d\s"']|this\.)/g,Z=RegExp("^"+(U.valueOf+"").replace(/[.*+?^=!:${}()|[\]\/\\]/g,"\\$&").replace(/valueOf|for [^\]]+/g,".+?")+"$"),et=/__token(\d+)__/g,tt=/[&<>"']/g,nt=/['\n\r\t\u2028\u2029\\]/g,rt="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" "),it="__token",st="__",ot=[],ut=R.concat,at=U.hasOwnProperty,ft=R.push,lt=U.propertyIsEnumerable,ct=R.slice,ht=U.toString,pt=Z.test(
pt=ct.bind)&&pt,dt=Math.floor,vt=Z.test(vt=Array.isArray)&&vt,mt=e.isFinite,gt=Z.test(gt=Object.keys)&&gt,yt=Math.max,bt=Math.min,wt=Math.random,Et="[object Arguments]",St="[object Array]",xt="[object Boolean]",Tt="[object Date]",Nt="[object Number]",Ct="[object Object]",kt="[object RegExp]",Lt="[object String]",At=e.clearTimeout,Ot=e.setTimeout,Mt,_t,Dt,Pt=n;(function(){function e(){this.x=1}var t={0:1,length:1},n=[];e.prototype={valueOf:1,y:1};for(var r in new e)n.push(r);for(r in arguments)Pt=!r;Mt=4>
(n+"").length,Dt="x"!=n[0],_t=(n.splice.call(t,0,1),t[0])})(1);var Ht=!w(arguments),Bt="x"!=ct.call("x")[0],jt="xx"!="x"[0]+Object("x")[0];try{var Ft=("[object Object]",ht.call(e.document||0)==Ct)}catch(It){}var qt=pt&&/\n|Opera/.test(pt+ht.call(e.opera)),Rt=gt&&/^.+$|true/.test(gt+!!e.attachEvent),Ut=!qt,zt={};zt[xt]=zt[Tt]=zt["[object Function]"]=zt[Nt]=zt[Ct]=zt[kt]=i,zt[Et]=zt[St]=zt[Lt]=n;var Wt={};Wt[Et]=Wt["[object Function]"]=i,Wt[St]=Wt[xt]=Wt[Tt]=Wt[Nt]=Wt[Ct]=Wt[kt]=Wt[Lt]=n;var Xt={"&"
:"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;"},Vt={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#x27;":"'"},$t={"boolean":i,"function":n,object:n,number:i,string:i,"undefined":i,unknown:n},Jt={"\\":"\\","'":"'","\n":"n","\r":"r","	":"t","\u2028":"u2028","\u2029":"u2029"};s.templateSettings={escape:/<%-([\s\S]+?)%>/g,evaluate:/<%([\s\S]+?)%>/g,interpolate:/<%=([\s\S]+?)%>/g,variable:""};var Kt={a:"e,d,y",j:"e",q:"if(!d)d=i;else if(y)d=c(d,y)",i:"if(d(A,j,e)===false)return u"},Qt={j:"{}"
,q:"var q;if(typeof d!='function'){var hh=d;d=function(A){return A[hh]}}else if(y)d=c(d,y)",i:"q=d(A,j,e);(h.call(u,q)?u[q]++:u[q]=1)"},Gt={j:"true",i:"if(!d(A,j,e))return!u"},Yt={r:i,s:i,a:"n",j:"n",q:"for(var a=1,b=arguments.length;a<b;a++){if(k=arguments[a]){",i:"u[j]=A",e:"}}"},Zt={j:"[]",i:"d(A,j,e)&&u.push(A)"},en={q:"if(y)d=c(d,y)"},tn={i:{l:Kt.i}},nn={j:"",f:"if(!e)return[]",d:{b:"u=Array(l)",l:"u="+(Rt?"Array(l)":"[]")},i:{b:"u[j]=d(A,j,e)",l:"u"+(Rt?"[o]=":".push")+"(d(A,j,e))"}},rn={r:
i,a:"n,d,y",j:"{}",q:"var R=typeof d=='function';if(!R){var t=f.apply(E,arguments)}else if(y)d=c(d,y)",i:"if(R?!d(A,j,n):M(t,j)<0)u[j]=A"};Ht&&(w=function(e){return!!e&&!!at.call(e,"callee")});var sn=vt||function(e){return ht.call(e)==St};E(/x/)&&(E=function(e){return"[object Function]"==ht.call(e)});var on=$t.__proto__!=U?S:function(e,t){if(!e)return i;var n=e.valueOf,r="function"==typeof n&&(r=n.__proto__)&&r.__proto__;return r?e==r||e.__proto__==r&&(t||!w(e)):S(e)},un=c({a:"n",j:"[]",i:"u.push(j)"
}),an=c(Yt,{i:"if(u[j]==null)"+Yt.i}),fn=c(Yt),ln=c(Kt,en,tn,{r:i}),cn=c(Kt,en,tn),hn=c({r:i,a:"n",j:"[]",i:"if(S(A))u.push(j)",e:"u.sort()"}),pn=c({a:"n",j:"{}",i:"u[A]=j"}),dn=c({a:"A",j:"true",q:"var H=z.call(A),l=A.length;if(D[H]"+(Ht?"||O(A)":"")+"||(H==W&&l===+l&&S(A.splice)))return!l",i:{l:"return false"}}),vn=gt?function(e){var t=typeof e;return"function"==t&&lt.call(e,"prototype")?un(e):e&&$t[t]?gt(e):[]}:un,mn=c(Yt,{a:"n,cc,N",q:"var b,P,dd,ee,C=arguments,a=0;if(N==T){b=2;dd=C[3];ee=C[4]}else{b=C.length;dd=[];ee=[]}while(++a<b){if(k=C[a]){"
,i:"if((cc=A)&&((P=Q(cc))||T(cc))){var K=false,ff=dd.length;while(ff--)if(K=dd[ff]==cc)break;if(K){u[j]=ee[ff]}else{dd.push(cc);ee.push(A=(A=u[j])&&P?(Q(A)?A:[]):(T(A)?A:{}));u[j]=G(A,cc,T,dd,ee)}}else if(cc!=null)u[j]=cc"}),gn=c(rn),yn=c({a:"n",j:"[]",i:"u"+(Rt?"[o]=":".push")+"([j,A])"}),bn=c(rn,{q:"if(typeof d!='function'){var q,t=f.apply(E,arguments),l=t.length;for(j=1;j<l;j++){q=t[j];if(q in n)u[q]=n[q]}}else{if(y)d=c(d,y)",i:"if(d(A,j,n))u[j]=A",e:"}"}),wn=c({a:"n",j:"[]",i:"u.push(A)"}),En=
c({a:"e,gg",j:"false",o:i,d:{b:"if(z.call(e)==x)return e.indexOf(gg)>-1"},i:"if(A===gg)return true"}),Sn=c(Kt,Qt),xn=c(Kt,Gt),Tn=c(Kt,Zt),Nn=c(Kt,en,{j:"",i:"if(d(A,j,e))return A"}),Cn=c(Kt,en),kn=c(Kt,Qt,{i:"q=d(A,j,e);(h.call(u,q)?u[q]:u[q]=[]).push(A)"}),Ln=c(nn,{a:"e,U",q:"var C=w.call(arguments,2),R=typeof U=='function'",i:{b:"u[j]=(R?U:A[U]).apply(A,C)",l:"u"+(Rt?"[o]=":".push")+"((R?U:A[U]).apply(A,C))"}}),An=c(Kt,nn),On=c(nn,{a:"e,aa",i:{b:"u[j]=A[aa]",l:"u"+(Rt?"[o]=":".push")+"(A[aa])"}
}),Mn=c({a:"e,d,B,y",j:"B",q:"var V=arguments.length<3;if(y)d=c(d,y)",d:{b:"if(V)u=k[++j]"},i:{b:"u=d(u,A,j,e)",l:"u=V?(V=false,A):d(u,A,j,e)"}}),_n=c(Kt,Zt,{i:"!"+Zt.i}),Dn=c(Kt,Gt,{j:"false",i:Gt.i.replace("!","")}),Pn=c(Kt,Qt,nn,{i:{b:"u[j]={a:d(A,j,e),b:j,c:A}",l:"u"+(Rt?"[o]=":".push")+"({a:d(A,j,e),b:j,c:A})"},e:"u.sort(I);l=u.length;while(l--)u[l]=u[l].c"}),Hn=c(Zt,{a:"e,Z",q:"var t=[];J(Z,function(A,q){t.push(q)});var bb=t.length",i:"for(var q,Y=true,s=0;s<bb;s++){q=t[s];if(!(Y=A[q]===Z[q]))break}Y&&u.push(A)"
}),Bn=c({r:i,s:i,a:"n",j:"n",q:"var L=arguments,l=L.length;if(l>1){for(var j=1;j<l;j++)u[L[j]]=F(u[L[j]],u);return u}",i:"if(S(u[j]))u[j]=F(u[j],u)"});s.VERSION="0.7.0",s.after=function(e,t){return 1>e?t():function(){if(1>--e)return t.apply(this,arguments)}},s.bind=D,s.bindAll=Bn,s.chain=function(e){return e=new o(e),e.__chain__=n,e},s.clone=x,s.compact=function(e){var t=[];if(!e)return t;for(var n=-1,r=e.length;++n<r;)e[n]&&t.push(e[n]);return t},s.compose=function(){var e=arguments;return function(
){for(var t=arguments,n=e.length;n--;)t=[e[n].apply(this,t)];return t[0]}},s.contains=En,s.countBy=Sn,s.debounce=function(e,t,n){function i(){a=r,n||(o=e.apply(u,s))}var s,o,u,a;return function(){var r=n&&!a;return s=arguments,u=this,At(a),a=Ot(i,t),r&&(o=e.apply(u,s)),o}},s.defaults=an,s.defer=function(e){var n=ct.call(arguments,1);return Ot(function(){return e.apply(t,n)},1)},s.delay=function(e,n){var r=ct.call(arguments,2);return Ot(function(){return e.apply(t,r)},n)},s.difference=function(e){
var t=[];if(!e)return t;for(var n=-1,r=e.length,i=ut.apply(t,arguments),i=a(i,r);++n<r;)i(e[n])||t.push(e[n]);return t},s.escape=function(e){return e==r?"":(e+"").replace(tt,d)},s.every=xn,s.extend=fn,s.filter=Tn,s.find=Nn,s.first=C,s.flatten=k,s.forEach=Cn,s.forIn=ln,s.forOwn=cn,s.functions=hn,s.groupBy=kn,s.has=function(e,t){return e?at.call(e,t):i},s.identity=P,s.indexOf=L,s.initial=function(e,t,n){return e?ct.call(e,0,-(t==r||n?1:t)):[]},s.intersection=function(e){var t=[];if(!e)return t;var n
,r=arguments.length,i=[],s=-1,o=e.length;e:for(;++s<o;)if(n=e[s],0>L(t,n)){for(var u=1;u<r;u++)if(!(i[u]||(i[u]=a(arguments[u])))(n))continue e;t.push(n)}return t},s.invert=pn,s.invoke=Ln,s.isArguments=w,s.isArray=sn,s.isBoolean=function(e){return e===n||e===i||ht.call(e)==xt},s.isElement=function(e){return e?1===e.nodeType:i},s.isEmpty=dn,s.isEqual=T,s.isFinite=function(e){return mt(e)&&ht.call(e)==Nt},s.isFunction=E,s.isNaN=function(e){return ht.call(e)==Nt&&e!=+e},s.isNull=function(e){return e===
r},s.isObject=function(e){return e?$t[typeof e]:i},s.isUndefined=function(e){return e===t},s.keys=vn,s.last=function(e,t,n){if(e){var i=e.length;return t==r||n?e[i-1]:ct.call(e,-t||i)}},s.lastIndexOf=function(e,t,n){if(!e)return-1;var r=e.length;for(n&&"number"==typeof n&&(r=(0>n?yt(0,r+n):bt(n,r-1))+1);r--;)if(e[r]===t)return r;return-1},s.lateBind=function(e,t){return l(t,e,ct.call(arguments,2))},s.map=An,s.max=A,s.memoize=function(e,t){var n={};return function(){var r=t?t.apply(this,arguments)
:arguments[0];return at.call(n,r)?n[r]:n[r]=e.apply(this,arguments)}},s.merge=mn,s.min=function(e,t,n){var r=Infinity,i=r;if(!e)return i;var s=-1,o=e.length;if(!t){for(;++s<o;)e[s]<i&&(i=e[s]);return i}for(n&&(t=u(t,n));++s<o;)n=t(e[s],s,e),n<r&&(r=n,i=e[s]);return i},s.mixin=H,s.noConflict=function(){return e._=X,this},s.object=function(e,t){if(!e)return{};for(var n=-1,r=e.length,i={};++n<r;)t?i[e[n]]=t[n]:i[e[n][0]]=e[n][1];return i},s.omit=gn,s.once=function(e){var t,s=i;return function(){return s?
t:(s=n,t=e.apply(this,arguments),e=r,t)}},s.pairs=yn,s.partial=function(e){return l(e,ct.call(arguments,1))},s.pick=bn,s.pluck=On,s.random=function(e,t){return e==r&&t==r?wt():(e=+e||0,t==r&&(t=e,e=0),e+dt(wt()*((+t||0)-e+1)))},s.range=function(e,t,n){e=+e||0,n=+n||1,t==r&&(t=e,e=0);for(var i=-1,t=yt(0,Math.ceil((t-e)/n)),s=Array(t);++i<t;)s[i]=e,e+=n;return s},s.reduce=Mn,s.reduceRight=N,s.reject=_n,s.rest=O,s.result=function(e,t){if(!e)return r;var n=e[t];return E(n)?e[t]():n},s.shuffle=function(
e){if(!e)return[];for(var t,n=-1,r=e.length,i=Array(r);++n<r;)t=dt(wt()*(n+1)),i[n]=i[t],i[t]=e[n];return i},s.size=function(e){if(!e)return 0;var t=e.length;return t===+t?t:vn(e).length},s.some=Dn,s.sortBy=Pn,s.sortedIndex=M,s.tap=function(e,t){return t(e),e},s.template=function(e,t,n){n||(n={});var e=e+"",o,u;o=n.escape;var a=n.evaluate,f=n.interpolate,l=s.templateSettings,c=n=n.variable||l.variable;o==r&&(o=l.escape),a==r&&(a=l.evaluate||i),f==r&&(f=l.interpolate),o&&(e=e.replace(o,m)),f&&(e=e
.replace(f,y)),a!=B&&(B=a,I=RegExp("<e%-([\\s\\S]+?)%>|<e%=([\\s\\S]+?)%>"+(a?"|"+a.source:""),"g")),o=ot.length,e=e.replace(I,g),o=o!=ot.length,e="__p += '"+e.replace(nt,p).replace(et,h)+"';",ot.length=0,c||(n=j||"obj",o?e="with("+n+"){"+e+"}":(n!=j&&(j=n,F=RegExp("(\\(\\s*)"+n+"\\."+n+"\\b","g")),e=e.replace(Y,"$&"+n+".").replace(F,"$1__d"))),e=(o?e.replace(J,""):e).replace(K,"$1").replace(Q,"$1;"),e="function("+n+"){"+(c?"":n+"||("+n+"={});")+"var __t,__p='',__e=_.escape"+(o?",__j=Array.prototype.join;function print(){__p+=__j.call(arguments,'')}"
:(c?"":",__d="+n+"."+n+"||"+n)+";")+e+"return __p}";try{u=Function("_","return "+e)(s)}catch(d){throw d.source=e,d}return t?u(t):(u.source=e,u)},s.throttle=function(e,t){function n(){a=new Date,u=r,s=e.apply(o,i)}var i,s,o,u,a=0;return function(){var r=new Date,f=t-(r-a);return i=arguments,o=this,0>=f?(a=r,s=e.apply(o,i)):u||(u=Ot(n,f)),s}},s.times=function(e,t,n){var r=-1;if(n)for(;++r<e;)t.call(n,r);else for(;++r<e;)t(r)},s.toArray=function(e){if(!e)return[];var t=e.length;return t===+t?(Bt?ht.
call(e)==Lt:"string"==typeof e)?e.split(""):ct.call(e):wn(e)},s.unescape=function(e){return e==r?"":(e+"").replace($,b)},s.union=function(){for(var e=-1,t=[],n=ut.apply(t,arguments),r=n.length;++e<r;)0>L(t,n[e])&&t.push(n[e]);return t},s.uniq=_,s.uniqueId=function(e){var t=z++;return e?e+t:t},s.values=wn,s.where=Hn,s.without=function(e){var t=[];if(!e)return t;for(var n=-1,r=e.length,i=a(arguments,1,20);++n<r;)i(e[n])||t.push(e[n]);return t},s.wrap=function(e,t){return function(){var n=[e];return arguments
.length&&ft.apply(n,arguments),t.apply(this,n)}},s.zip=function(e){if(!e)return[];for(var t=-1,n=A(On(arguments,"length")),r=Array(n);++t<n;)r[t]=On(arguments,t);return r},s.all=xn,s.any=Dn,s.collect=An,s.detect=Nn,s.drop=O,s.each=Cn,s.foldl=Mn,s.foldr=N,s.head=C,s.include=En,s.inject=Mn,s.methods=hn,s.select=Tn,s.tail=O,s.take=C,s.unique=_,Cn({Date:Tt,Number:Nt,RegExp:kt,String:Lt},function(e,t){s["is"+t]=function(t){return ht.call(t)==e}}),o.prototype=s.prototype,H(s),o.prototype.chain=function(
){return this.__chain__=n,this},o.prototype.value=function(){return this.__wrapped__},Cn("pop push reverse shift sort splice unshift".split(" "),function(e){var t=R[e];o.prototype[e]=function(){var e=this.__wrapped__;return t.apply(e,arguments),_t&&e.length===0&&delete e[0],this.__chain__&&(e=new o(e),e.__chain__=n),e}}),Cn(["concat","join","slice"],function(e){var t=R[e];o.prototype[e]=function(){var e=t.apply(this.__wrapped__,arguments);return this.__chain__&&(e=new o(e),e.__chain__=n),e}}),typeof 
define=="function"&&typeof define.amd=="object"&&define.amd?(e._=s,define(function(){return s})):q?"object"==typeof module&&module&&module.exports==q?(module.exports=s)._=s:q._=s:e._=s})(this);
})(self)
},{}],7:[function(require,module,exports){
(function(global){/**
 * marked - A markdown parser (https://github.com/chjj/marked)
 * Copyright (c) 2011-2012, Christopher Jeffrey. (MIT Licensed)
 */

;(function() {

/**
 * Block-Level Grammar
 */

var block = {
  newline: /^\n+/,
  code: /^( {4}[^\n]+\n*)+/,
  fences: noop,
  hr: /^( *[-*_]){3,} *(?:\n+|$)/,
  heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
  lheading: /^([^\n]+)\n *(=|-){3,} *\n*/,
  blockquote: /^( *>[^\n]+(\n[^\n]+)*\n*)+/,
  list: /^( *)(bull) [^\0]+?(?:hr|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
  html: /^ *(?:comment|closed|closing) *(?:\n{2,}|\s*$)/,
  def: /^ *\[([^\]]+)\]: *([^\s]+)(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
  paragraph: /^([^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+\n*/,
  text: /^[^\n]+/
};

block.bullet = /(?:[*+-]|\d+\.)/;
block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
block.item = replace(block.item, 'gm')
  (/bull/g, block.bullet)
  ();

block.list = replace(block.list)
  (/bull/g, block.bullet)
  ('hr', /\n+(?=(?: *[-*_]){3,} *(?:\n+|$))/)
  ();

block.html = replace(block.html)
  ('comment', /<!--[^\0]*?-->/)
  ('closed', /<(tag)[^\0]+?<\/\1>/)
  ('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)
  (/tag/g, tag())
  ();

block.paragraph = replace(block.paragraph)
  ('hr', block.hr)
  ('heading', block.heading)
  ('lheading', block.lheading)
  ('blockquote', block.blockquote)
  ('tag', '<' + tag())
  ('def', block.def)
  ();

block.normal = {
  fences: block.fences,
  paragraph: block.paragraph
};

block.gfm = {
  fences: /^ *(```|~~~) *(\w+)? *\n([^\0]+?)\s*\1 *(?:\n+|$)/,
  paragraph: /^/
};

block.gfm.paragraph = replace(block.paragraph)
  ('(?!', '(?!' + block.gfm.fences.source.replace('\\1', '\\2') + '|')
  ();

/**
 * Block Lexer
 */

block.lexer = function(src) {
  var tokens = [];

  tokens.links = {};

  src = src
    .replace(/\r\n|\r/g, '\n')
    .replace(/\t/g, '    ');

  return block.token(src, tokens, true);
};

block.token = function(src, tokens, top) {
  var src = src.replace(/^ +$/gm, '')
    , next
    , loose
    , cap
    , item
    , space
    , i
    , l
    , start;

  while (src) {
    start = src.length;
    // newline
    if (cap = block.newline.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[0].length > 1) {
        tokens.push({
          type: 'space'
        });
      }
    }

    // code
    if (cap = block.code.exec(src)) {
      src = src.substring(cap[0].length);
      cap = cap[0].replace(/^ {4}/gm, '');
      tokens.push({
        type: 'code',
        text: !options.pedantic
          ? cap.replace(/\n+$/, '')
          : cap,
        textLen: start - src.length,
        remain: src.length
      });
      continue;
    }

    // fences (gfm)
    if (cap = block.fences.exec(src)) {
      src = src.substring(cap[0].length);
      tokens.push({
        type: 'code',
        lang: cap[2],
        text: cap[3],
        textLen: start - src.length,
        remain: src.length
      });
      continue;
    }

    // heading
    if (cap = block.heading.exec(src)) {
      src = src.substring(cap[0].length);
      tokens.push({
        type: 'heading',
        depth: cap[1].length,
        text: cap[2]
      });
      continue;
    }

    // lheading
    if (cap = block.lheading.exec(src)) {
      src = src.substring(cap[0].length);
      tokens.push({
        type: 'heading',
        depth: cap[2] === '=' ? 1 : 2,
        text: cap[1]
      });
      continue;
    }

    // hr
    if (cap = block.hr.exec(src)) {
      src = src.substring(cap[0].length);
      tokens.push({
        type: 'hr'
      });
      continue;
    }

    // blockquote
    if (cap = block.blockquote.exec(src)) {
      src = src.substring(cap[0].length);

      tokens.push({
        type: 'blockquote_start'
      });

      cap = cap[0].replace(/^ *> ?/gm, '');

      // Pass `top` to keep the current
      // "toplevel" state. This is exactly
      // how markdown.pl works.
      block.token(cap, tokens, top);

      tokens.push({
        type: 'blockquote_end'
      });

      continue;
    }

    // list
    if (cap = block.list.exec(src)) {
      src = src.substring(cap[0].length);

      tokens.push({
        type: 'list_start',
        ordered: isFinite(cap[2])
      });

      // Get each top-level item.
      cap = cap[0].match(block.item);

      next = false;
      l = cap.length;
      i = 0;

      for (; i < l; i++) {
        item = cap[i];

        // Remove the list item's bullet
        // so it is seen as the next token.
        space = item.length;
        item = item.replace(/^ *([*+-]|\d+\.) +/, '');

        // Outdent whatever the
        // list item contains. Hacky.
        if (~item.indexOf('\n ')) {
          space -= item.length;
          item = !options.pedantic
            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
            : item.replace(/^ {1,4}/gm, '');
        }

        // Determine whether item is loose or not.
        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
        // for discount behavior.
        loose = next || /\n\n(?!\s*$)/.test(item);
        if (i !== l - 1) {
          next = item[item.length-1] === '\n';
          if (!loose) loose = next;
        }

        tokens.push({
          type: loose
            ? 'loose_item_start'
            : 'list_item_start'
        });

        // Recurse.
        block.token(item, tokens);

        tokens.push({
          type: 'list_item_end'
        });
      }

      tokens.push({
        type: 'list_end'
      });

      continue;
    }

    // html
    if (cap = block.html.exec(src)) {
      src = src.substring(cap[0].length);
      tokens.push({
        type: options.sanitize
          ? 'paragraph'
          : 'html',
        pre: cap[1] === 'pre',
        text: cap[0]
      });
      continue;
    }

    // def
    if (top && (cap = block.def.exec(src))) {
      src = src.substring(cap[0].length);
      tokens.links[cap[1].toLowerCase()] = {
        href: cap[2],
        title: cap[3]
      };
      continue;
    }

    // top-level paragraph
    if (top && (cap = block.paragraph.exec(src))) {
      src = src.substring(cap[0].length);
      tokens.push({
        type: 'paragraph',
        text: cap[0]
      });
      continue;
    }

    // text
    if (cap = block.text.exec(src)) {
      // Top-level should never reach here.
      src = src.substring(cap[0].length);
      tokens.push({
        type: 'text',
        text: cap[0]
      });
      continue;
    }
  }

  return tokens;
};

/**
 * Inline Processing
 */

var inline = {
  escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
  autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
  url: noop,
  tag: /^<!--[^\0]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
  link: /^!?\[(inside)\]\(href\)/,
  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
  nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
  strong: /^__([^\0]+?)__(?!_)|^\*\*([^\0]+?)\*\*(?!\*)/,
  em: /^\b_((?:__|[^\0])+?)_\b|^\*((?:\*\*|[^\0])+?)\*(?!\*)/,
  code: /^(`+)([^\0]*?[^`])\1(?!`)/,
  br: /^ {2,}\n(?!\s*$)/,
  text: /^[^\0]+?(?=[\\<!\[_*`]| {2,}\n|$)/
};

inline._linkInside = /(?:\[[^\]]*\]|[^\]]|\](?=[^\[]*\]))*/;
inline._linkHref = /\s*<?([^\s]*?)>?(?:\s+['"]([^\0]*?)['"])?\s*/;

inline.link = replace(inline.link)
  ('inside', inline._linkInside)
  ('href', inline._linkHref)
  ();

inline.reflink = replace(inline.reflink)
  ('inside', inline._linkInside)
  ();

inline.normal = {
  url: inline.url,
  strong: inline.strong,
  em: inline.em,
  text: inline.text
};

inline.pedantic = {
  strong: /^__(?=\S)([^\0]*?\S)__(?!_)|^\*\*(?=\S)([^\0]*?\S)\*\*(?!\*)/,
  em: /^_(?=\S)([^\0]*?\S)_(?!_)|^\*(?=\S)([^\0]*?\S)\*(?!\*)/
};

inline.gfm = {
  url: /^(https?:\/\/[^\s]+[^.,:;"')\]\s])/,
  text: /^[^\0]+?(?=[\\<!\[_*`]|https?:\/\/| {2,}\n|$)/
};

/**
 * Inline Lexer
 */

inline.lexer = function(src) {
  var out = ''
    , links = tokens.links
    , link
    , text
    , href
    , cap;

  while (src) {
    // escape
    if (cap = inline.escape.exec(src)) {
      src = src.substring(cap[0].length);
      out += cap[1];
      continue;
    }

    // autolink
    if (cap = inline.autolink.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[2] === '@') {
        text = cap[1][6] === ':'
          ? mangle(cap[1].substring(7))
          : mangle(cap[1]);
        href = mangle('mailto:') + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      out += '<a href="'
        + href
        + '">'
        + text
        + '</a>';
      continue;
    }

    // url (gfm)
    if (cap = inline.url.exec(src)) {
      src = src.substring(cap[0].length);
      text = escape(cap[1]);
      href = text;
      out += '<a href="'
        + href
        + '">'
        + text
        + '</a>';
      continue;
    }

    // tag
    if (cap = inline.tag.exec(src)) {
      src = src.substring(cap[0].length);
      out += options.sanitize
        ? escape(cap[0])
        : cap[0];
      continue;
    }

    // link
    if (cap = inline.link.exec(src)) {
      src = src.substring(cap[0].length);
      out += outputLink(cap, {
        href: cap[2],
        title: cap[3]
      });
      continue;
    }

    // reflink, nolink
    if ((cap = inline.reflink.exec(src))
        || (cap = inline.nolink.exec(src))) {
      src = src.substring(cap[0].length);
      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = links[link.toLowerCase()];
      if (!link || !link.href) {
        out += cap[0][0];
        src = cap[0].substring(1) + src;
        continue;
      }
      out += outputLink(cap, link);
      continue;
    }

    // strong
    if (cap = inline.strong.exec(src)) {
      src = src.substring(cap[0].length);
      out += '<strong>'
        + inline.lexer(cap[2] || cap[1])
        + '</strong>';
      continue;
    }

    // em
    if (cap = inline.em.exec(src)) {
      src = src.substring(cap[0].length);
      out += '<em>'
        + inline.lexer(cap[2] || cap[1])
        + '</em>';
      continue;
    }

    // code
    if (cap = inline.code.exec(src)) {
      src = src.substring(cap[0].length);
      out += '<code>'
        + escape(cap[2], true)
        + '</code>';
      continue;
    }

    // br
    if (cap = inline.br.exec(src)) {
      src = src.substring(cap[0].length);
      out += '<br>';
      continue;
    }

    // text
    if (cap = inline.text.exec(src)) {
      src = src.substring(cap[0].length);
      out += escape(cap[0]);
      continue;
    }
  }

  return out;
};

function outputLink(cap, link) {
  if (cap[0][0] !== '!') {
    return '<a href="'
      + escape(link.href)
      + '"'
      + (link.title
      ? ' title="'
      + escape(link.title)
      + '"'
      : '')
      + '>'
      + inline.lexer(cap[1])
      + '</a>';
  } else {
    return '<img src="'
      + escape(link.href)
      + '" alt="'
      + escape(cap[1])
      + '"'
      + (link.title
      ? ' title="'
      + escape(link.title)
      + '"'
      : '')
      + '>';
  }
}

/**
 * Parsing
 */

var tokens
  , token;

function next() {
  return token = tokens.pop();
}

function tok() {
  switch (token.type) {
    case 'space': {
      return '';
    }
    case 'hr': {
      return '<hr>\n';
    }
    case 'heading': {
      return '<h'
        + token.depth
        + '>'
        + inline.lexer(token.text)
        + '</h'
        + token.depth
        + '>\n';
    }
    case 'code': {
      if (options.highlight) {
        token.code = options.highlight(token.text, token.lang);
        if (token.code != null && token.code !== token.text) {
          token.escaped = true;
          token.text = token.code;
        }
      }

      if (!token.escaped) {
        token.text = escape(token.text, true);
      }

      return '<pre><code'
        + (token.lang
        ? ' class="lang-'
        + token.lang
        + '"'
        : '')
        + '>'
        + token.text
        + '</code></pre>\n';
    }
    case 'blockquote_start': {
      var body = '';

      while (next().type !== 'blockquote_end') {
        body += tok();
      }

      return '<blockquote>\n'
        + body
        + '</blockquote>\n';
    }
    case 'list_start': {
      var type = token.ordered ? 'ol' : 'ul'
        , body = '';

      while (next().type !== 'list_end') {
        body += tok();
      }

      return '<'
        + type
        + '>\n'
        + body
        + '</'
        + type
        + '>\n';
    }
    case 'list_item_start': {
      var body = '';

      while (next().type !== 'list_item_end') {
        body += token.type === 'text'
          ? parseText()
          : tok();
      }

      return '<li>'
        + body
        + '</li>\n';
    }
    case 'loose_item_start': {
      var body = '';

      while (next().type !== 'list_item_end') {
        body += tok();
      }

      return '<li>'
        + body
        + '</li>\n';
    }
    case 'html': {
      return !token.pre && !options.pedantic
        ? inline.lexer(token.text)
        : token.text;
    }
    case 'paragraph': {
      return '<p>'
        + inline.lexer(token.text)
        + '</p>\n';
    }
    case 'text': {
      return '<p>'
        + parseText()
        + '</p>\n';
    }
  }
}

function parseText() {
  var body = token.text
    , top;

  while ((top = tokens[tokens.length-1])
         && top.type === 'text') {
    body += '\n' + next().text;
  }

  return inline.lexer(body);
}

function parse(src) {
  tokens = src.reverse();

  var out = '';
  while (next()) {
    out += tok();
  }

  tokens = null;
  token = null;

  return out;
}

/**
 * Helpers
 */

function escape(html, encode) {
  return html
    .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function mangle(text) {
  var out = ''
    , l = text.length
    , i = 0
    , ch;

  for (; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = 'x' + ch.toString(16);
    }
    out += '&#' + ch + ';';
  }

  return out;
}

function tag() {
  var tag = '(?!(?:'
    + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
    + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
    + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|@)\\b';

  return tag;
}

function replace(regex, opt) {
  regex = regex.source;
  opt = opt || '';
  return function self(name, val) {
    if (!name) return new RegExp(regex, opt);
    val = val.source || val;
    val = val.replace(/(^|[^\[])\^/g, '$1');
    regex = regex.replace(name, val);
    return self;
  };
}

function noop() {}
noop.exec = noop;

/**
 * Marked
 */

function marked(src, opt) {
  setOptions(opt);
  if (opt && opt.saveLex) {
    return [parse(block.lexer(src)), block.lexer(src)];
  } else {
    return parse(block.lexer(src));
  }
}

/**
 * Options
 */

var options
  , defaults;

function setOptions(opt) {
  if (!opt) opt = defaults;
  if (options === opt) return;
  options = opt;

  if (options.gfm) {
    block.fences = block.gfm.fences;
    block.paragraph = block.gfm.paragraph;
    inline.text = inline.gfm.text;
    inline.url = inline.gfm.url;
  } else {
    block.fences = block.normal.fences;
    block.paragraph = block.normal.paragraph;
    inline.text = inline.normal.text;
    inline.url = inline.normal.url;
  }

  if (options.pedantic) {
    inline.em = inline.pedantic.em;
    inline.strong = inline.pedantic.strong;
  } else {
    inline.em = inline.normal.em;
    inline.strong = inline.normal.strong;
  }
}

marked.options =
marked.setOptions = function(opt) {
  defaults = opt;
  setOptions(opt);
  return marked;
};

marked.setOptions({
  gfm: true,
  pedantic: false,
  sanitize: false,
  highlight: null
});

/**
 * Expose
 */

marked.parser = function(src, opt) {
  setOptions(opt);
  return parse(src);
};

marked.lexer = function(src, opt) {
  setOptions(opt);
  return block.lexer(src);
};

marked.parse = marked;

if (typeof module !== 'undefined') {
  module.exports = marked;
} else {
  this.marked = marked;
}

}).call(function() {
  return this || (typeof window !== 'undefined' ? window : global);
}());

})(self)
},{}],8:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var $, DOWN_ARROW, END, ENTER, ESC, HOME, LEFT_ARROW, Notebook, PAGE_DOWN, PAGE_UP, Q, RIGHT_ARROW, UP_ARROW, arrows, bindMarkupDiv, bindSlider, chooseSlide, cleanEmptyNodes, closeWindow, countSlide, createNode, delay, editingEnabled, enableEditing, enableSlideControls, firstSlide, getElementCode, handleInternalSections, hideSlide, insertControls, isLeisureCode, jQuery, lastSlide, makeMarkupDiv, makeSection, makeSlideDiv, markupButtons, markupElement, markupSlideContent, markupSlides, mergeLeisureCode, mergeUp, nextSibling, nextSlide, nthSlide, oldSlide, padSlide, presentLeisureCode, presentSlide, prevSlide, previousSibling, remove, showSlide, slideControls, slideControlsEnabled, slideKeyListener, slideName, slidePat, slides, sliding, textNode, unwrap, unwrapContent, _, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  jQuery = window.jQuery, $ = window.$, _ = window._;

  _ref = Notebook = require('./notebook'), ENTER = _ref.ENTER, delay = _ref.delay, textNode = _ref.textNode, createNode = _ref.createNode, remove = _ref.remove, unwrap = _ref.unwrap, insertControls = _ref.insertControls, cleanEmptyNodes = _ref.cleanEmptyNodes, isLeisureCode = _ref.isLeisureCode, getElementCode = _ref.getElementCode, previousSibling = _ref.previousSibling, nextSibling = _ref.nextSibling, presentLeisureCode = _ref.presentLeisureCode, mergeLeisureCode = _ref.mergeLeisureCode, closeWindow = _ref.closeWindow, markupButtons = _ref.markupButtons, ESC = _ref.ESC, HOME = _ref.HOME, END = _ref.END, PAGE_UP = _ref.PAGE_UP, PAGE_DOWN = _ref.PAGE_DOWN, LEFT_ARROW = _ref.LEFT_ARROW, RIGHT_ARROW = _ref.RIGHT_ARROW, UP_ARROW = _ref.UP_ARROW, DOWN_ARROW = _ref.DOWN_ARROW, arrows = _ref.arrows;

  Q = 81;

  window.markup = function(md) {
    var maindoc, nodes, _ref1;

    nodes = document.querySelectorAll('[maindoc]');
    if (nodes.length === 0) {
      maindoc = createNode("<div maindoc></div>");
      document.body.insertBefore(maindoc, document.body.firstChild);
      nodes = [maindoc];
    } else {
      maindoc = nodes[0];
    }
    md = ((_ref1 = md != null ? md.replace(/\r\n/mg, '\n') : void 0) != null ? _ref1 : maindoc.innerHTML.replace(/^\s*<!--*/, '').replace(/-->\s*\n*/m, '')).trim();
    document.body.classList.add('hideControls');
    markupSlides(maindoc, md);
    return insertControls(maindoc);
  };

  lastSlide = null;

  if (typeof console !== "undefined" && console !== null) {
    if (typeof console.error === "function") {
      console.error(new Error("REMINDER: Incompatibility: using -webkit-calc").stack);
    }
  }

  slidePat = /^(\*\*\*[^\n]*\n(?:--?\n)?)/m;

  slideName = /^\*\*\*([^\n]*)\n(?:--?\n)?/m;

  sliding = false;

  markupSlides = function(el, md) {
    var div, hasCode, slides;

    hasCode = markupSlideContent(el, md);
    slides = el.querySelectorAll('[leisureSection]');
    if (slides.length <= (el.querySelector('[leisureSection="Leisure Controls"]') ? 2 : 1)) {
      document.body.classList.add("oneSlide");
    }
    div = createNode("<div class='slide-controls'>\n  <div id='slide-killbutton' onclick='toggleSlideShow()' style='float: right'><button>Slides</button></div>\n  <div id='slide-num' style='float: right; margin-right: 10px'></div>\n</div>");
    markupButtons(div);
    el.appendChild(div);
    if (location.search && _.find(location.search.slice(1).split('&'), (function(p) {
      return p.match(/^slides=/);
    }))) {
      sliding = true;
      showSlide($(chooseSlide()));
    } else {
      document.body.classList.add('scroll');
    }
    return hasCode;
  };

  markupSlideContent = function(el, md, noMain) {
    var content, hasCode, i, m, p, pageType, pages, _i, _ref1, _ref2;

    pages = md.split(slidePat);
    hasCode = false;
    if (pages.length > 1) {
      document.body.classList.add('slide-container');
      el.innerHTML = '';
      bindSlider();
      el.removeAttribute('doc');
      if (pages.length === 3 && !pages[0] && !pages[2]) {
        pages[2] = '\n';
      }
      for (i = _i = 0, _ref1 = pages.length; _i < _ref1; i = _i += 2) {
        p = pages[i];
        if (p) {
          pageType = i > 0 ? (m = (_ref2 = pages[i - 1].match(slidePat)) != null ? _ref2[1] : void 0, m.match(/\n-\n/) ? ['continuation', 'hiddenPage'] : m.match(/\n--\n/) ? ['hiddenPage', 'secretPage'] : []) : [];
          content = makeSlideDiv(el, pageType, (i > 0 ? pages[i - 1].match(slideName)[1].trim() : 'Main'));
          if (i > 0) {
            hasCode = (markupElement(content, pages[i - 1] + p)) || hasCode;
          } else {
            hasCode = (markupElement(content, '***\n' + p)) || hasCode;
          }
          padSlide(content, (i > 0 ? pages[i - 1] : '***\n'));
        }
      }
    } else {
      content = makeSlideDiv(el, ['page'], 'Main');
      while (el.firstChild !== content.parentNode) {
        content.appendChild(el.firstChild);
      }
      hasCode = markupElement(content, md);
      padSlide(content, '***\n');
      if (noMain) {
        unwrapContent(content);
      }
    }
    return hasCode;
  };

  padSlide = function(content, header) {
    var div, range;

    if (!content.firstChild || isLeisureCode(content.firstChild)) {
      range = document.createRange();
      range.setStart(content, 0);
      range.setEnd(content, 0);
      div = makeMarkupDiv(range, header);
      div.appendChild(createNode('<br>'));
    }
    if (isLeisureCode(content.lastChild)) {
      range = document.createRange();
      range.setStartAfter(content.lastChild);
      range.setEndAfter(content.lastChild);
      div = makeMarkupDiv(range, '\n');
      return div.appendChild(createNode('<br>'));
    }
  };

  unwrapContent = function(content) {
    var el, section;

    section = content.parentNode;
    el = section.parentNode;
    el.insertBefore(content, section);
    remove(section);
    return unwrap(content);
  };

  makeSlideDiv = function(el, pageTypes, title) {
    var content, div, pageType, sectionTitle, _i, _len;

    lastSlide = div = createNode("<div class='leisure_page'></div>");
    div.setAttribute('leisureSection', title);
    div.setAttribute('doc', '');
    div.setAttribute('slide', '');
    div.classList.add('slide');
    div.classList.add('ui-corner-all');
    div.classList.add('ui-widget');
    div.classList.add('ui-widget-content');
    for (_i = 0, _len = pageTypes.length; _i < _len; _i++) {
      pageType = pageTypes[_i];
      div.classList.add(pageType);
    }
    el.appendChild(div);
    sectionTitle = createNode("<div class='pageTitle'>" + title + "</div>");
    sectionTitle.setAttribute('leisureoutput', '');
    div.appendChild(sectionTitle);
    content = createNode("<div class='pageContent'></div>");
    div.appendChild(content);
    return content;
  };

  chooseSlide = function() {
    var param;

    param = _.find(location.search.slice(1).split('&'), (function(p) {
      return p.match(/^slide=.*/);
    }));
    console.log(param);
    if (param) {
      return document.querySelector("[slide='" + (param.split('=')[1]) + "']");
    } else {
      return document.querySelector('[maindoc]').firstElementChild;
    }
  };

  oldSlide = 0;

  window.toggleSlideShow = function() {
    sliding = $(document.body).is('.scroll');
    enableSlideControls(true);
    enableEditing(true);
    if (sliding) {
      $(document.body).removeClass('scroll');
      return showSlide(nthSlide(oldSlide));
    } else {
      oldSlide = $('.slide.showing').attr('slide');
      hideSlide($('.slide.showing'));
      $(document.body).addClass('scroll');
      return $('#slide-num').html('');
    }
  };

  bindSlider = function() {
    return document.body.addEventListener('keydown', slideKeyListener);
  };

  slideControls = [Q, ESC, LEFT_ARROW, RIGHT_ARROW, HOME, END, PAGE_UP, PAGE_DOWN];

  slideControlsEnabled = true;

  enableSlideControls = function(state) {
    return slideControlsEnabled = state;
  };

  presentSlide = function(s) {
    hideSlide($('.slide.showing'));
    return showSlide(s);
  };

  firstSlide = function() {
    return slides();
  };

  lastSlide = function() {
    return slides().last();
  };

  prevSlide = function() {
    var n;

    n = $('.slide.showing').prevAll('[slide]').not('[leisureSection="Leisure Controls"]').not('.hiddenPage').not('.secretPage');
    if (n.length) {
      return n;
    } else {
      return slides();
    }
  };

  nextSlide = function() {
    var n;

    n = $('.slide.showing').nextAll('[slide]').not('[leisureSection="Leisure Controls"]').not('.hiddenPage').not('.secretPage');
    if (n.length) {
      return n;
    } else {
      return $('.slide.showing');
    }
  };

  slideKeyListener = function(e) {
    var c;

    if (sliding) {
      window.evt = e;
      c = e.charCode || e.keyCode || e.which;
      if ((__indexOf.call(slideControls, c) >= 0) && !$(e.target).is('[leisurenode=code],[leisurenode=code] *') && slideControlsEnabled) {
        e.preventDefault();
        if (c === ESC) {
          return toggleSlideShow();
        } else if (c === Q) {
          return closeWindow();
        } else {
          return presentSlide(((function() {
            switch (c) {
              case HOME:
                return firstSlide();
              case END:
                return lastSlide();
              case LEFT_ARROW:
              case PAGE_UP:
                return prevSlide();
              case RIGHT_ARROW:
              case PAGE_DOWN:
                return nextSlide();
            }
          })()));
        }
      }
    }
  };

  slides = function() {
    return $('[slide]').not('[leisureSection="Leisure Controls"]').not('.hiddenPage').not('.secretPage');
  };

  nthSlide = function(n) {
    return slides().slice(n);
  };

  countSlide = function(el) {
    var count, n, slide, _i, _len, _ref1;

    n = -1;
    count = 0;
    _ref1 = slides();
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      slide = _ref1[_i];
      count++;
      if (slide === el) {
        n = count;
      }
    }
    return [n, count];
  };

  showSlide = function(el) {
    var count, n, _ref1;

    _ref1 = countSlide(el[0]), n = _ref1[0], count = _ref1[1];
    oldSlide = n;
    $('#slide-num').html("" + n + " / " + count);
    return $(el).first().removeClass('hidden').addClass('showing');
  };

  hideSlide = function(el) {
    return $(el).first().addClass('hidden').removeClass('showing');
  };

  markupElement = function(el, md) {
    var code, codePos, len, lex, markup, node, prev, prevCodePos, range, slide, _i, _len, _ref1, _ref2, _ref3;

    len = md.length;
    slide = (_ref1 = md.match(slidePat)) != null ? _ref1 : '';
    _ref2 = window.marked((slide ? md.slice(slide[0].length) : md), {
      saveLex: true,
      gfm: true
    }), markup = _ref2[0], lex = _ref2[1];
    el.innerHTML = markup.trim() || '<br>';
    prev = null;
    range = document.createRange();
    prevCodePos = -1;
    codePos = 0;
    _ref3 = el.querySelectorAll('code');
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      node = _ref3[_i];
      while (lex[codePos].type !== 'code') {
        codePos++;
      }
      if (node.parentNode.tagName !== 'PRE') {
        code = node;
      } else {
        code = node.parentNode;
        code.innerHTML = node.innerHTML;
      }
      code.setAttribute('noLeisureBar', '');
      code.setAttribute('leisureNode', 'code');
      code.md = lex[codePos].text;
      if (code.parentNode.firstChild !== code) {
        if (prev === null || prev.parentNode !== code.parentNode) {
          range.setStart(code.parentNode, 0);
        } else {
          range.setStartAfter(prev);
        }
        range.setEndBefore(code);
        makeMarkupDiv(range, md.substring((prevCodePos === -1 ? 0 : len - lex[prevCodePos].remain), len - lex[codePos].remain - lex[codePos].textLen));
      }
      prevCodePos = codePos;
      codePos++;
      prev = code;
    }
    if (prevCodePos > -1) {
      if (lex[prevCodePos].remain > 0) {
        range.selectNodeContents(prev.parentNode);
        range.setStartAfter(prev);
        makeMarkupDiv(range, md.substring(len - lex[prevCodePos].remain));
      }
    } else {
      range.selectNodeContents(el);
      makeMarkupDiv(range, md);
    }
    return prevCodePos > -1;
  };

  handleInternalSections = function(content) {
    var before, innerSections, marker, node, nodeContent, nodeTitle, prev, section, sectionHolder, title, _i, _j, _len, _len1, _ref1;

    section = content.parentNode;
    sectionHolder = section.parentNode;
    innerSections = section.querySelectorAll('[leisureSection]');
    if (innerSections.length === 0) {
      if (!((_ref1 = content.firstChild.md) != null ? _ref1.match(/^\*\*\*/) : void 0)) {
        if (!section.previousSibling) {
          return section.setAttribute('leisureSection', 'Main');
        } else {
          prev = section.previousSibling.querySelector('.pageContent');
          while (content.firstChild) {
            mergeUp(content.firstChild, prev);
          }
          return remove(section);
        }
      }
    } else {
      title = section.getAttribute('leisureSection');
      before = false;
      for (_i = 0, _len = innerSections.length; _i < _len; _i++) {
        node = innerSections[_i];
        if (node.getAttribute('leisureSection') === title) {
          before = true;
          break;
        }
      }
      before = before || (!innerSections[0].previousSibling);
      marker = section;
      for (_j = 0, _len1 = innerSections.length; _j < _len1; _j++) {
        node = innerSections[_j];
        nodeTitle = node.getAttribute('leisureSection');
        nodeContent = node.querySelector('.pageContent');
        if (nodeTitle === title || (node.previousSibling && nodeTitle === 'Main')) {
          if (nodeTitle === title) {
            before = false;
          }
          while (nodeContent.firstChild) {
            content.insertBefore(nodeContent.firstChild, node);
            mergeLeisureCode(node.previousSibling, node);
          }
          remove(node);
        } else {
          while (node.nextSibling && !node.nextSibling.getAttribute('leisureSection')) {
            mergeUp(node.nextSibling, nodeContent);
          }
          padSlide(nodeContent, "***" + nodeTitle + "\n");
          if (before) {
            section.parentNode.insertBefore(node, section);
          } else {
            section.parentNode.insertBefore(node, marker.nextSibling);
            marker = node;
          }
        }
      }
      if (!content.firstChild) {
        return remove(section);
      } else {
        return padSlide(content, "***" + title + "\n");
      }
    }
  };

  mergeUp = function(el, newParent) {
    newParent.appendChild(el);
    return mergeLeisureCode(newParent.lastChild.previousSibling, newParent.lastChild);
  };

  makeSection = function(title, node, next) {
    var div;

    div = createNode("<div leisureSection='" + title + "'></div>");
    node.parentNode.insertBefore(div, node);
    while (div.nextSibling && div.nextSibling !== next) {
      div.appendChild(div.nextSibling);
    }
    return div;
  };

  makeMarkupDiv = function(range, md) {
    var div;

    div = document.createElement('div');
    range.surroundContents(div);
    div.md = md;
    bindMarkupDiv(div);
    return div;
  };

  editingEnabled = true;

  enableEditing = function(state) {
    return editingEnabled = state;
  };

  bindMarkupDiv = function(div) {
    var editing;

    div.bound = true;
    div.setAttribute('leisureNode', 'markdown');
    div.setAttribute('contenteditable', 'false');
    editing = false;
    div.addEventListener('dblclick', function(e) {
      if (!editing && editingEnabled) {
        div.innerHTML = '';
        div.appendChild(textNode(div.md));
        div.style.whiteSpace = 'pre-wrap';
        div.setAttribute('contenteditable', 'true');
        editing = true;
        div.parentNode.setAttribute('editing', 'true');
        return div.focus();
      }
    });
    div.addEventListener('keypress', function(e) {
      var br, r, s;

      if (editing) {
        s = window.getSelection();
        r = s.getRangeAt(0);
        if ((e.charCode || e.keyCode || e.which) === ENTER) {
          br = textNode('\n');
          r.insertNode(br);
          r = document.createRange();
          r.setStart(br, 1);
          s.removeAllRanges();
          s.addRange(r);
          return e.preventDefault();
        }
      }
    });
    return div.addEventListener('blur', function(e) {
      var first, frag, last, node, parent, prevSection, r, scroll, _i, _len, _ref1, _ref2;

      if (editing) {
        scroll = document.body.scrollTop;
        div.style.whiteSpace = '';
        editing = false;
        div.parentNode.removeAttribute('editing');
        div.setAttribute('contenteditable', 'false');
        prevSection = (_ref1 = div.parentNode.parentNode.previousSibling) != null ? _ref1.getAttribute('leisureSection') : void 0;
        parent = div.parentNode;
        if (markupSlideContent(div, div.textContent, prevSection && prevSection !== 'Leisure Controls')) {
          _ref2 = div.querySelectorAll("[leisurenode='code']");
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            node = _ref2[_i];
            presentLeisureCode(node, true);
          }
        } else if (div.textContent.trim() === '') {
          cleanEmptyNodes(div);
        }
        r = document.createRange();
        r.selectNodeContents(div);
        frag = r.extractContents();
        first = frag.childNodes[0];
        last = frag.childNodes[frag.childNodes.length - 1];
        parent.replaceChild(frag, div);
        mergeLeisureCode(previousSibling(first), first);
        mergeLeisureCode(last, nextSibling(last));
        handleInternalSections(parent);
        return delay(function() {
          return document.body.scrollTop = scroll;
        });
      }
    });
  };

  Notebook.markupElement = markupElement;

  Notebook.enableSlideControls = enableSlideControls;

  Notebook.enableEditing = enableEditing;

  Notebook.presentSlide = presentSlide;

  Notebook.firstSlide = firstSlide;

  Notebook.lastSlide = lastSlide;

  Notebook.prevSlide = prevSlide;

  Notebook.nextSlide = nextSlide;

}).call(this);

/*
*/

},{"./notebook":9}],9:[function(require,module,exports){
(function(global){// Generated by CoffeeScript 1.6.2
/*
# use an element as a Leisure notebook
# Only runs in the context of a browser
*/


(function() {
  var $, BS, DEL, DOWN_ARROW, END, ENTER, ESC, HOME, LEFT_ARROW, Leisure_anno, Nil, PAGE_DOWN, PAGE_UP, RIGHT_ARROW, TAB, UP_ARROW, URI, Xus, acceptCode, addBoxClasses, addDefControls, addsLine, allowEvents, arrows, autoRun, baseElements, baseStrokeWidth, basicCall, bindAll, bindNotebook, bootNotebook, box, boxClasses, buttonClasses, c, chainEvalNodes, changeTheme, changeView, checkDeleteExpr, checkHideSource, checkMutateFromModification, cleanEmptyNodes, cleanOutput, clearAst, clearOutputBox, clearUpdates, clickTest, closeWindow, codeBox, codeFocus, codeSpan, configureSaveLink, continueRangePosition, createFragment, createNode, createPeer, createSlider, debug, defaultEnv, define, delay, docFocus, envFor, errString, escapeHtml, evalBox, evalDoc, evalDocCode, evalNodes, evalOutput, evaluating, evaluationQueue, event, filename, findCurrentCodeHolder, findDefs, findUpdateSelector, focusBox, foldLeft, gen, getAnnoBody, getAnnoData, getAnnoName, getAst, getBox, getDefName, getElementCode, getElements, getExprSource, getHtml, getMDDocument, getMaxStrokeWidth, getParseErr, getRangePosition, getRangeText, getRanges, getRefName, getSvgElement, getType, grp, handleKey, hasFunc, hasMonadOutput, head, hiddenPat, hideControlSection, hideOutputSource, hideSlider, highlightNotebookFunction, highlightPosition, id, identity, ignoreDeleteOutputBox, init, initNotebook, insertControls, isDef, isLeisureCode, isMonad, isOutput, isSlider, lazy, leisureContextString, linePat, linkSource, loadProgram, loaded, lz, makeId, makeLabel, makeMonad, makeOption, makeOutputBox, makeOutputControls, makeRange, makeSyncMonad, makeTestBox, makeTestCase, markPartialApplies, markupButton, markupButtons, markupDefs, mergeLeisureCode, nameSub, nextId, nextSibling, nodeEnd, nodeFor, nonprintable, numberEnd, numberStart, oldBrackets, owner, patchFuncAst, peer, peerGetDocument, peerGetFunctions, peerNotifySelection, postLoadQueue, prepExpr, presentLeisureCode, presentValue, previousBoxRangeInternal, previousBoxRangeStart, previousSibling, primSvgMeasure, primconcatNodes, printable, printableControlCharacters, processLine, psgn, queueAfterLoad, remove, removeBoxClasses, removeOldDefs, replaceContents, replaceRange, replicate, req, resolve, root, runAuto, runMonad, runTest, runTests, rz, saveProgram, setAst, setFilename, setMinMax, setSnapper, setUpdate, showAst, showError, showFilename, showFilenames, showOutputSource, showResult, showSliderButton, showSource, skipLeftOverOutputBox, slider, snapshot, svgBetterMeasure, svgMeasure, svgMeasureText, tail, testPat, textNode, toDefBox, toExprBox, toggleEdit, transformStrokeWidth, transformedPoint, unwrap, update, updatePat, wrapRange, xusEnv, _, _ref, _ref1, _ref2,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  console.log("LOADING NOTEBOOK");

  _ref = root = module.exports = require('./base'), resolve = _ref.resolve, lazy = _ref.lazy;

  rz = resolve;

  lz = lazy;

  _ref1 = root = module.exports = require('./ast'), nameSub = _ref1.nameSub, getRefName = _ref1.getRefName, define = _ref1.define, foldLeft = _ref1.foldLeft, Nil = _ref1.Nil, getType = _ref1.getType, getAnnoName = _ref1.getAnnoName, getAnnoData = _ref1.getAnnoData, getAnnoBody = _ref1.getAnnoBody, Leisure_anno = _ref1.Leisure_anno;

  _ref2 = require('./runtime'), isMonad = _ref2.isMonad, runMonad = _ref2.runMonad, makeMonad = _ref2.makeMonad, makeSyncMonad = _ref2.makeSyncMonad, identity = _ref2.identity, defaultEnv = _ref2.defaultEnv, basicCall = _ref2.basicCall;

  gen = require('./gen').gen;

  URI = window.URI;

  Xus = window.Xus;

  $ = window.$;

  _ = require('./lodash.min');

  window.global = window;

  debug = false;

  BS = 8;

  TAB = 9;

  ENTER = 13;

  ESC = 27;

  PAGE_UP = 33;

  PAGE_DOWN = 34;

  END = 35;

  HOME = 36;

  LEFT_ARROW = 37;

  UP_ARROW = 38;

  RIGHT_ARROW = 39;

  DOWN_ARROW = 40;

  DEL = 46;

  arrows = [37, 38, 39, 40];

  updatePat = /(^|\n)(#@update )([^\n]+)(?:^|\n)/;

  peer = null;

  nextId = 0;

  filename = null;

  event = function() {
    var args, widget;

    widget = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return basicCall(args, envFor(widget), identity);
  };

  defaultEnv.readFile = function(fileName, cont) {
    var uri;

    uri = new URI(document.location.href, fileName);
    console.log("\n\n@@@@READ FILE: " + uri + "\n\n");
    return $.get(String(uri)).done(function(data) {
      return cont(null, data);
    }).fail(function(err) {
      return cont(err, null);
    });
  };

  defaultEnv.writeFile = function(fileName, data, cont) {};

  snapshot = function(el, pgm) {};

  setSnapper = function(snapFunc) {
    return snapshot = snapFunc;
  };

  delay = function(func) {
    return window.setTimeout(func, 1);
  };

  getParseErr = getHtml = function(x) {
    return x(lz(function(value) {
      return rz(value);
    }));
  };

  escapeHtml = function(str) {
    if (typeof str === 'string') {
      return str.replace(/[<>]/g, function(c) {
        switch (c) {
          case '<':
            return '&lt;';
          case '>':
            return '&gt;';
        }
      });
    } else {
      return str;
    }
  };

  presentValue = function(v) {
    var content;

    if ((getType(v)) === 'svgNode') {
      content = v(function() {
        return id;
      });
      return _svgPresent()(function() {
        return content;
      })(function() {
        return id;
      });
    } else if ((getType(v)) === 'html') {
      return getHtml(v);
    } else if ((getType(v)) === 'parseErr') {
      return "PARSE ERROR: " + (getParseErr(v));
    } else {
      return escapeHtml(String(v));
    }
  };

  bootNotebook = function(el) {
    if ((document.getElementById('channelList')) == null) {
      document.body.appendChild(createNode("<datalist id='channelList'>\n   <option value=''></option>\n   <option value='app'>app</option>\n   <option value='compile'>compile</option>\n   <option value='editorFocus'>editorFocus</option>\n</datalist>"));
    }
    return createPeer();
  };

  closeWindow = function() {
    console.log("CLOSING WINDOW");
    window.open('', '_self', '');
    return window.close();
  };

  createPeer = function() {
    var k, param, params, server, v, _i, _len, _ref3, _ref4;

    root.xusServer = server = new Xus.Server();
    server.exit = function() {
      return closeWindow();
    };
    peer = root.peer = Xus.createDirectPeer(server);
    peer.server = server;
    peer.listen('leisure/selection/contents', true, function(key, value) {
      var node, r, s;

      if (key === 'leisure/selection/contents') {
        s = window.getSelection();
        if (s.rangeCount && s.toString() !== value) {
          r = s.getRangeAt(0);
          r.deleteContents();
          node = textNode(value.toString());
          r.insertNode(node);
          s.removeAllRanges();
          r.selectNode(node);
          return s.addRange(r);
        }
      }
    });
    peer.set('leisure/evalExpr', null, 'transient');
    peer.listen('leisure/evalExpr', false, function(key, value) {
      var env, expr, result;

      if (key === 'leisure/evalExpr' && (value != null)) {
        expr = value[0], result = value[1];
        console.log("EVAL: " + expr + ", RESULT: " + result);
        env = xusEnv(result, expr);
        return processLine(expr, env, function() {
          return typeof env.cleanup === "function" ? env.cleanup() : void 0;
        });
      }
    });
    peer.set('leisure/document', peerGetDocument);
    peer.set('leisure/functions', peerGetFunctions);
    peer.set('leisure/storage', []);
    if (Boot.documentFragment) {
      params = {};
      _ref3 = Boot.documentFragment.substring(1).split('&');
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        param = _ref3[_i];
        _ref4 = param.split('='), k = _ref4[0], v = _ref4[1];
        params[k.toLowerCase()] = decodeURIComponent(v);
      }
      if (params.xusproxy != null) {
        return Xus.xusToProxy(server, params.xusproxy);
      }
    }
  };

  replaceContents = function(uri, contents) {
    if (!contents) {
      contents = uri;
      uri = null;
    }
    if (uri) {
      setFilename(uri.toString());
    }
    document.body.setAttribute('doc', '');
    window.leisureAutoRunAll = true;
    window.markup(contents);
    return bindAll();
  };

  bindAll = function() {
    var node, _i, _len, _ref3;

    _ref3 = document.querySelectorAll("[leisurenode='code']");
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      node = _ref3[_i];
      node.setAttribute('contentEditable', 'true');
      bindNotebook(node);
      changeTheme(node, 'thin');
      evalDoc(node);
    }
    return showFilenames();
  };

  xusEnv = function(resultVar, expr) {
    var env, result;

    result = '';
    env = {
      debug: debug,
      finishedEvent: function() {},
      owner: null,
      require: req,
      write: function(msg) {
        return result += "" + msg + "\n";
      },
      prompt: function(msg, cont) {
        return result += "Attempt to prompt with " + msg;
      },
      processResult: function(res, ast) {
        result += res;
        return peer.set(resultVar, JSON.stringify(result));
      },
      presentValue: function(x) {
        return x;
      },
      fileSettings: {
        uri: new URI(document.location.href)
      },
      err: function(err) {
        result += err.leisureContext ? "ERROR: " + err + ":\n" + (leisureContextString(err)) + "\n" + err.stack : "Couldn't parse: " + expr;
        return peer.set(resultVar, result);
      }
    };
    env.__proto__ = root.defaultEnv;
    return env;
  };

  peerGetDocument = function() {
    var nodes;

    nodes = document.querySelectorAll("[leisurenode='code']");
    if (nodes.length > 1 || Notebook.md) {
      return getMDDocument();
    } else {
      return getSimpleDocument();
    }
  };

  peerGetFunctions = function() {
    return (_.uniq(window.leisureFuncNames.toArray().sort(), true)).sort();
  };

  getMDDocument = function() {
    var md, node, _i, _len, _ref3, _ref4;

    md = '';
    _ref3 = document.querySelectorAll('[doc] [leisureNode]');
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      node = _ref3[_i];
      md += isLeisureCode(node) ? "```\n" + (getElementCode(node)) + "\n```\n" : (_ref4 = node.md) != null ? _ref4 : '';
    }
    return md;
  };

  makeId = function(el) {
    if (!el.id) {
      return el.id = "Leisure-" + (nextId++);
    }
  };

  allowEvents = true;

  init = false;

  bindNotebook = function(el) {
    if (!init) {
      init = true;
      defaultEnv.presentValue = presentValue;
      defaultEnv.write = function(msg) {
        return console.log(msg);
      };
      defaultEnv.owner = document.body;
      defaultEnv.finishedEvent = function(evt, channel) {
        return update(channel != null ? channel : 'app', defaultEnv);
      };
      defaultEnv.debug = debug;
    }
    if (el.bound == null) {
      makeId(el);
      el.bound = true;
      el.addEventListener('DOMCharacterDataModified', (function(evt) {
        if (allowEvents && !el.replacing) {
          return delay(function() {
            return checkMutateFromModification(evt);
          });
        }
      }), true);
      el.addEventListener('DOMSubtreeModified', (function(evt) {
        if (allowEvents && !el.replacing) {
          return delay(function() {
            return checkMutateFromModification(evt);
          });
        }
      }), true);
      el.addEventListener('mousedown', (function(e) {
        if (!isSlider(e.srcElement)) {
          return delay(function() {
            return highlightPosition(e);
          });
        }
      }), true);
      el.addEventListener('mousemove', (function(e) {
        if (!isSlider(e.srcElement)) {
          return delay(function() {
            return highlightPosition(e);
          });
        }
      }), true);
      el.addEventListener('mouseup', (function(e) {
        if (!isSlider(e.srcElement)) {
          return delay(function() {
            return highlightPosition(e);
          });
        }
      }), true);
      el.addEventListener('keydown', function(e) {
        var c, r, s;

        c = e.charCode || e.keyCode || e.which;
        if (c === DEL || c === BS) {
          s = window.getSelection();
          r = s.getRangeAt(0);
          if (c === BS) {
            checkDeleteExpr(getBox(r.startContainer));
            if (skipLeftOverOutputBox(el, r)) {
              return e.preventDefault();
            }
          } else if (c === DEL) {
            checkDeleteExpr(getBox(r.startContainer));
            if (ignoreDeleteOutputBox(el, r)) {
              return e.preventDefault();
            }
          }
        }
        if (printable(c)) {
          clearAst(getBox(window.getSelection().focusNode));
        }
        if ((__indexOf.call(arrows, c) >= 0) || printable(c)) {
          delay(function() {
            return highlightPosition(e);
          });
        }
        if (e.ctrlKey && c === ENTER) {
          return handleKey("C-ENTER");
        } else if (e.altKey && c === ENTER) {
          return handleKey("M-ENTER");
        } else if (c === TAB) {
          handleKey("TAB");
          return e.preventDefault();
        }
      });
      el.addEventListener('keypress', function(e) {
        var br, bx, r, s, sp;

        s = window.getSelection();
        r = s.getRangeAt(0);
        if ((e.charCode || e.keyCode || e.which) === ENTER) {
          br = textNode('\n');
          r.insertNode(br);
          r = document.createRange();
          r.setStart(br, 1);
          s.removeAllRanges();
          s.addRange(r);
          return e.preventDefault();
        } else if (r.startContainer.parentNode === el) {
          sp = codeSpan('\n', 'codeExpr');
          sp.setAttribute('generatedNL', '');
          bx = box(s.getRangeAt(0), 'codeMainExpr', true);
          bx.appendChild(sp);
          makeOutputBox(bx);
          r = document.createRange();
          r.setStart(sp, 0);
          s.removeAllRanges();
          return s.addRange(r);
        }
      });
      el.addEventListener('focus', (function() {
        if (allowEvents) {
          return findCurrentCodeHolder();
        }
      }), true);
      el.addEventListener('blur', (function() {
        if (allowEvents) {
          return findCurrentCodeHolder();
        }
      }), true);
      if (window.leisureAutoRunAll) {
        autoRun(el, true);
        return window.setTimeout((function() {
          return runTests(el);
        }), 1);
      } else {
        return el.autorunState = false;
      }
    }
  };

  checkDeleteExpr = function(node) {
    var out;

    if (isOutput(node && node.output)) {
      out = node.output;
      return window.setTimeout((function() {
        if (!node.textContent.trim()) {
          node.parentNode.removeChild(node);
        }
        if ((node.parentNode == null) && ((out != null ? out.parentNode : void 0) != null)) {
          return out.parentNode.removeChild(out);
        }
      }), 1);
    }
  };

  skipLeftOverOutputBox = function(el, r) {
    var box, s;

    el.normalize();
    box = previousBoxRangeInternal(r) || previousBoxRangeStart(r);
    if (isOutput(box)) {
      s = window.getSelection();
      r.selectNode(box);
      r.collapse(true);
      s.removeAllRanges();
      s.addRange(r);
      return true;
    } else {
      return false;
    }
  };

  previousBoxRangeInternal = function(r) {
    return r.startContainer.nodeType === 1 && r.startOffset > 0 && r.startContainer.childNodes[r.startOffset - 1];
  };

  previousBoxRangeStart = function(r) {
    return r.startContainer.nodeType === 3 && r.startOffset === 0 && previousSibling(r.startContainer);
  };

  ignoreDeleteOutputBox = function(el, r) {
    var n;

    el.normalize();
    if (r.startContainer.nodeType === 3 && r.startOffset === r.startContainer.length) {
      n = r.startContainer;
      while (n && n.nextSibling === null) {
        n = n.parentNode;
      }
      return isOutput(n != null ? n.nextSibling : void 0);
    } else {
      return false;
    }
  };

  isOutput = function(el) {
    return (el != null ? el.nodeType : void 0) === 1 && el.hasAttribute('LeisureOutput');
  };

  isLeisureCode = function(el) {
    return (el != null ? el.nodeType : void 0) === 1 && el.getAttribute('leisureNode') === 'code';
  };

  peerNotifySelection = function(el, str) {};

  printableControlCharacters = (function() {
    var _i, _len, _ref3, _results;

    _ref3 = "\r\i\n\b";
    _results = [];
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      c = _ref3[_i];
      _results.push(c.charCodeAt(0));
    }
    return _results;
  })();

  printable = function(code) {
    return (code > 0xf && code < 37) || code > 40 || __indexOf.call(printableControlCharacters, code) >= 0;
  };

  nonprintable = null;

  (function() {
    var i, s, _i;

    s = '';
    for (i = _i = 0; 0 <= 0xf ? _i <= 0xf : _i >= 0xf; i = 0 <= 0xf ? ++_i : --_i) {
      s += String.fromCharCode(i);
    }
    s.replace(/[\i\r\f]/g, '');
    return nonprintable = new RegExp("[" + s + "]");
  })();

  handleKey = function(key) {
    var box;

    switch (key) {
      case "C-ENTER":
      case "TAB":
        box = getBox(window.getSelection().focusNode);
        if ((box.getAttribute('codeMainExpr')) != null) {
          return evalOutput(box.output);
        } else if ((box.getAttribute('codeMain')) != null) {
          return acceptCode(box);
        }
        break;
      case "M-ENTER":
        box = getBox(window.getSelection().focusNode);
        if ((box.getAttribute('codeMainExpr')) != null) {
          return clearOutputBox(box.output);
        }
    }
  };

  clearAst = function(box) {
    var cbox;

    cbox = getBox(box);
    return cbox != null ? cbox.ast = null : void 0;
  };

  oldBrackets = [null, Nil];

  cleanEmptyNodes = function(el) {
    var next, prev, _ref3;

    if (el.nodeType === 3 && (el.parentNode != null)) {
      return cleanEmptyNodes(el.parentNode);
    } else {
      prev = el.previousSibling;
      next = el.nextSibling;
      if (el.nodeType === 1 && el.textContent.trim() === '' && ((_ref3 = el.parentNode) != null ? _ref3.hasAttribute('doc') : void 0)) {
        el.parentNode.removeChild(el);
      }
      if (next === nextSibling(prev)) {
        return mergeLeisureCode(prev, next);
      }
    }
  };

  presentLeisureCode = function(node, doEval) {
    node.setAttribute('contentEditable', 'true');
    Notebook.bindNotebook(node);
    Notebook.changeTheme(node, 'thin');
    if (doEval) {
      return evalDoc(node);
    } else {
      return initNotebook(node);
    }
  };

  mergeLeisureCode = function(el1, el2) {
    var newCode, r;

    if (el1 && el2) {
      if (el1.nodeType === 1 && el2.nodeType === 3) {
        el1.appendChild(el2);
        return el1.normalize();
      } else if (el1.nodeType === 3 && el2.nodeType === 1) {
        el2.insertBefore(el1, el2.firstChild);
        return el2.normalize();
      } else if (el1.hasAttribute('leisureNode') && el1.getAttribute('leisureNode') === el2.getAttribute('leisureNode')) {
        newCode = textNode(el1.md = el1.getAttribute('leisureNode') === 'code' ? "" + (getElementCode(el1)) + "\n" + (getElementCode(el2)) : "" + el1.md + "\n" + el2.md);
        r = document.createRange();
        r.selectNodeContents(el2);
        el1.appendChild(textNode('\n'));
        el1.appendChild(r.extractContents());
        return el2.parentNode.removeChild(el2);
      }
    }
  };

  highlightPosition = function(e) {
    var ast, b, brackets, changed, i, node, parent, pos, r, ranges, s, span, _i, _j, _k, _len, _len1, _len2, _ref3, _ref4, _ref5;

    parent = null;
    s = window.getSelection();
    if (s.rangeCount) {
      if (cleanEmptyNodes(s.getRangeAt(0).startContainer)) {
        return;
      }
      focusBox(s.focusNode);
      parent = getBox(s.focusNode);
      if ((_ref3 = s.getRangeAt(0)) != null ? _ref3.collapsed : void 0) {
        if (!parent || isOutput(parent)) {
          return;
        }
        if (parent.parentNode && (ast = getAst(parent))) {
          r = s.getRangeAt(0);
          r.setStart(parent, 0);
          pos = getRangeText(r).length;
          changed = false;
          if (false) {
            brackets = Leisure.bracket(ast.leisureBase, pos);
            if (oldBrackets[0] !== parent || !oldBrackets[1].equals(brackets)) {
              oldBrackets = [parent, brackets];
              _ref4 = document.querySelectorAll("[LeisureBrackets]");
              for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
                node = _ref4[_i];
                unwrap(node);
              }
              _ref5 = parent.querySelectorAll(".partialApply");
              for (_j = 0, _len1 = _ref5.length; _j < _len1; _j++) {
                node = _ref5[_j];
                unwrap(node);
              }
              parent.normalize();
              markPartialApplies(parent);
              b = brackets;
              ranges = [];
              while (b !== Nil) {
                ranges.push(makeRange(parent, b.head().head(), b.head().tail().head()));
                b = b.tail();
              }
              for (i = _k = 0, _len2 = ranges.length; _k < _len2; i = ++_k) {
                r = ranges[i];
                span = document.createElement('span');
                span.setAttribute('LeisureBrackets', '');
                span.setAttribute('class', i === 0 ? 'LeisureFunc' : 'LeisureArg');
                wrapRange(r, span);
              }
              changed = true;
            }
          }
          if (e instanceof KeyboardEvent) {
            if (hideSlider()) {
              pos += 1;
            }
          } else if (e instanceof MouseEvent && e.type === 'mousedown' && (e.target === parent || parent.contains(e.target)) && showSliderButton(parent, pos, e)) {
            changed = true;
            pos += 1;
          }
          if (changed) {
            window.EVT = e;
            s.removeAllRanges();
            s.addRange(makeRange(parent, pos));
          }
        }
      }
      return peerNotifySelection(parent, s.toString());
    }
  };

  numberEnd = /(?:^|.*[^0-9.])([0-9]+\.?[0-9]*|\.[0-9]*)$/;

  numberStart = /^([0-9]+\.[0-9]+|[0-9]+|\.[0-9]+)/;

  slider = [];

  showSliderButton = function(parent, pos, e) {
    var changed, len, m, oldPos, r, sParent, sPos, sValue, span, text;

    if (slider.length) {
      hideSlider();
      return false;
    } else {
      text = parent.textContent;
      oldPos = pos;
      changed = 0;
      if (m = text.substring(0, pos).match(numberEnd)) {
        pos -= m[1].length;
      }
      if (m = text.substring(pos).match(numberStart)) {
        len = m[1].length;
        if (oldPos <= pos + len) {
          sParent = slider[0], sPos = slider[1], sValue = slider[2];
          if (parent !== sParent || pos !== sPos || m[1] !== sValue) {
            hideSlider();
            r = makeRange(parent, pos, pos + m[1].length);
            span = createNode("<span class='leisureRangeNumber ui-widget-content'></span>");
            wrapRange(r, span);
            changed = 1;
            span.normalize();
            slider = [parent, pos, m[1], span];
            createSlider();
          }
        }
        return changed;
      } else {
        return hideSlider();
      }
    }
  };

  isSlider = function(el) {
    while (el !== document) {
      if (el.hasAttribute('slider')) {
        return true;
      }
      el = el.parentNode;
    }
    return false;
  };

  createSlider = function() {
    var d, div, inside, max, min, parent, pos, sl, sliding, span, value;

    parent = slider[0], pos = slider[1], value = slider[2], span = slider[3], div = slider[4];
    if (div) {
      return;
    }
    inside = false;
    sliding = false;
    d = createNode("<div style='z-index: 1; position: absolute; width: 200px; background: white; border: solid green 1px' slider contentEditable='false'></div>");
    slider.push(d);
    d.style.top = "" + (span.offsetTop + span.offsetHeight + 5) + "px";
    d.style.minTop = '0px';
    d.style.left = "" + (Math.max(0, (span.offsetLeft + span.offsetWidth) / 2 - 100)) + "px";
    d.addEventListener('mouseover', function(e) {
      if (!inside) {
        return inside = true;
      }
    });
    d.addEventListener('mouseout', function(e) {
      if (e.toElement !== d && !d.contains(e.toElement)) {
        inside = false;
        if (!sliding) {
          return hideSlider();
        }
      }
    });
    value = Number(value);
    min = value < 0 ? value * 2 : value / 2;
    max = value === 0 ? 10 : value * 2;
    sl = $(d).slider({
      animate: 'fast',
      start: function() {
        sliding = true;
        return delay(function() {
          return allowEvents = false;
        });
      },
      stop: function(event, ui) {
        setMinMax(sl);
        allowEvents = true;
        sliding = false;
        if (!inside) {
          return hideSlider();
        }
      },
      slide: function(event, ui) {
        var ast, _ref3;

        if (span.firstChild) {
          span.firstChild.nodeValue = String(ui.value);
        }
        if (isDef(parent)) {
          parent.ast = null;
          acceptCode(parent);
          ast = getAst(parent);
          if ((_ref3 = parent.ast) != null ? _ref3.leisureName : void 0) {
            return update("sel-" + parent.ast.leisureName);
          }
        } else {
          makeId(parent);
          if (!parent.getAttribute(parent.output, 'leisureUpdate')) {
            setUpdate(parent.output, "id-" + parent.id + " compile", true);
          }
          update("id-" + parent.id);
          return update("compile");
        }
      },
      value: value
    });
    setMinMax(sl, value);
    parent.insertBefore(d, parent.firstChild);
    return d.focus();
  };

  psgn = function(x) {
    if (x < 0) {
      return -1;
    } else {
      return 1;
    }
  };

  setMinMax = function(sl, value) {
    var max, min, step, _ref3;

    value = value || sl.slider("value");
    min = 0;
    max = (1 <= (_ref3 = Math.abs(value)) && _ref3 < 50) || value === 0 ? 100 * psgn(value) : value * 2;
    if (Math.round(value) === value) {
      step = Math.round((max - min) / 100);
      step = step - step % (max - min);
    } else {
      step = (max - min) / 100;
    }
    sl.slider("option", "min", min);
    sl.slider("option", "max", max);
    return sl.slider("option", "step", step);
  };

  hideSlider = function() {
    var div, parent, sPos, sValue, span;

    if (slider.length) {
      parent = slider[0], sPos = slider[1], sValue = slider[2], span = slider[3], div = slider[4];
      unwrap(span);
      if (div) {
        remove(div);
      }
      parent.normalize();
      slider = [];
      return 2;
    } else {
      return 0;
    }
  };

  wrapRange = function(range, node) {
    var contents, err;

    try {
      return range.surroundContents(node);
    } catch (_error) {
      err = _error;
      contents = range.cloneContents();
      replaceRange(range, node);
      return node.appendChild(contents);
    }
  };

  replaceRange = function(range, node) {
    range.deleteContents();
    return range.insertNode(node);
  };

  getRangeText = function(r) {
    return r.cloneContents().textContent;
  };

  getBox = function(node) {
    while ((node != null) && ((typeof node.getAttribute === "function" ? node.getAttribute('LeisureBox') : void 0) == null)) {
      node = node.parentElement;
    }
    return node;
  };

  checkMutateFromModification = function(evt) {
    var b, b2;

    b = getBox(evt.target);
    b2 = getBox(window.getSelection().focusNode);
    if (b && b === b2) {
      if ((isDef(b)) && b.classList.contains('codeMainExpr')) {
        toDefBox(b);
      } else if (!(isDef(b)) && b.classList.contains('codeMain')) {
        toExprBox(b);
      }
      return replicate(b);
    }
  };

  replicate = function(b) {
    if (b.replicator) {
      return delay(function() {
        return b.replicator.replicate(b);
      });
    }
  };

  buttonClasses = 'ui-button ui-widget ui-state-default ui-corner-all ui-button-text-only'.split(' ');

  boxClasses = {
    codeMainExpr: ['codeMainExpr', 'ui-widget', 'ui-widget-content', 'ui-corner-all'],
    codeMain: ['codeMain', 'ui-widget', 'ui-widget-content', 'ui-corner-all'],
    codeMainTest: ['codeMainTest'],
    output: ['output', 'ui-corner-all']
  };

  addBoxClasses = function(box, type) {
    var cl, _i, _len, _ref3, _results;

    box.setAttribute(type, '');
    _ref3 = boxClasses[type];
    _results = [];
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      cl = _ref3[_i];
      _results.push(box.classList.add(cl));
    }
    return _results;
  };

  removeBoxClasses = function(box, type) {
    var cl, _i, _len, _ref3, _results;

    box.removeAttribute(type);
    _ref3 = boxClasses[type];
    _results = [];
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      cl = _ref3[_i];
      _results.push(box.classList.remove(cl));
    }
    return _results;
  };

  toExprBox = function(b) {
    var node, _i, _j, _len, _len1, _ref3, _ref4;

    removeBoxClasses(b, 'codeMain');
    addBoxClasses(b, 'codeMainExpr');
    _ref3 = b.querySelectorAll('[codename]');
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      node = _ref3[_i];
      unwrap(node);
    }
    _ref4 = b.querySelectorAll('.astbutton');
    for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
      node = _ref4[_j];
      remove(node);
    }
    return makeOutputBox(b);
  };

  toDefBox = function(b) {
    if (b.output) {
      remove(b.output);
    }
    removeBoxClasses(b, 'codeMainExpr');
    addBoxClasses(b, 'codeMain');
    return addDefControls(b);
  };

  addDefControls = function(box) {
    var btn;

    btn = createNode("<button onclick='Notebook.showAst(this.parentNode)' class='astbutton' title='Show AST'></button>");
    markupButton(btn);
    return box.appendChild(btn);
  };

  remove = function(node) {
    var _ref3;

    return (_ref3 = node.parentNode) != null ? _ref3.removeChild(node) : void 0;
  };

  showAst = function(box) {
    var name, node, output;

    name = (getAst(box)).leisureName;
    if (box.astOut != null) {
      remove(box.astOut.output);
      remove(box.astOut);
      return box.astOut = null;
    } else if (name != null) {
      node = codeBox('codeMainExpr');
      box.astOut = node;
      node.setAttribute('leisureOutput', '');
      box.parentNode.insertBefore(node, box.nextSibling);
      node.textContent = "#@update sel-" + name + "\ntreeForNotebook " + name;
      output = makeOutputBox(node);
      toggleEdit(output);
      return evalOutput(output, true);
    }
  };

  highlightNotebookFunction = function(funcName, start, stop) {
    var box, offset, sel;

    box = document.body.querySelector("[leisurefunc=" + funcName + "]");
    offset = 0;
    sel = window.getSelection();
    sel.removeAllRanges();
    return sel.addRange(makeRange(box, start + offset, stop + offset));
  };

  isDef = function(box) {
    var defType, leading, m, matched, name, txt;

    txt = box.textContent;
    if ((m = txt.match(L_defPat()))) {
      matched = m[0], leading = m[1], name = m[2], defType = m[3];
      return (defType != null ? defType.length : void 0) > 0;
    }
    return false;
  };

  initNotebook = function(el) {
    var pgm;

    el.replacing = true;
    removeOldDefs(el);
    pgm = markupDefs(el, findDefs(el));
    el.normalize();
    el.replacing = false;
    if (!el.hasAttribute('noLeisureBar')) {
      insertControls(el);
      el.testResults.innerHTML = pgm[2];
    }
    snapshot(el, pgm);
    return pgm;
  };

  makeLabel = function(text, c) {
    var node;

    node = document.createElement('SPAN');
    node.innerHTML = text;
    node.setAttribute('class', c);
    return node;
  };

  makeOption = function(name) {
    var opt;

    opt = document.createElement('OPTION');
    opt.text = name;
    return opt;
  };

  createNode = function(txt) {
    var scratch;

    scratch = document.createElement('DIV');
    scratch.innerHTML = txt;
    return scratch.firstChild;
  };

  createFragment = function(txt) {
    var frag, scratch;

    scratch = document.createElement('DIV');
    scratch.innerHTML = txt;
    frag = document.createDocumentFragment();
    while (scratch.firstChild) {
      frag.appendChild(scratch.firstChild);
    }
    return frag;
  };

  insertControls = function(el) {
    var controlDiv, saveButton, spacer, testButton, themeSelect, viewSelect, _ref3, _ref4;

    controlDiv = createNode("<div LeisureOutput contentEditable='false' class='leisure_bar'><div class=\"leisure_bar_contents\">\n  <button leisureId='saveButton' class=\"leisure_start\">Save</button>\n  <button leisureId='testButton'>Run Tests</button> <span leisureId='testResults' class=\"notrun\"></span>\n  <input type='checkbox' leisureId='autorunTests'><b>Auto</b></input>\n  <span class=\"leisure_theme\">Theme: </span>\n  <select leisureId='themeSelect'>\n    <option value=thin>Thin</option>\n    <option value=gaudy>Gaudy</option>\n    <option value=cthulhu>Cthulhu</option>\n  </select>\n  <span>View: </span>\n  <select leisureId='viewSelect'>\n    <option value=coding>Coding</option>\n    <option value=debugging>Debugging</option>\n    <option value=testing>Testing</option>\n    <option value=running>Running</option>\n  </select>\n</div>");
    spacer = createNode("<div LeisureOutput  contentEditable='false' class='leisure_space'></div>");
    el.insertBefore(spacer, el.firstChild);
    el.insertBefore(controlDiv, el.firstChild);
    _ref3 = getElements(el, ['downloadLink', 'viewLink', 'saveButton', 'testButton', 'testResults', 'autorunTests', 'themeSelect', 'viewSelect']), el.leisureDownloadLink = _ref3[0], el.leisureViewLink = _ref3[1], saveButton = _ref3[2], testButton = _ref3[3], el.testResults = _ref3[4], el.autorun = _ref3[5], themeSelect = _ref3[6], viewSelect = _ref3[7];
    controlDiv.addEventListener('click', function(evt) {
      if (document.body.classList.contains('hideControls')) {
        return document.body.classList.remove('hideControls');
      } else {
        return document.body.classList.add('hideControls');
      }
    });
    saveButton.addEventListener('click', function(evt) {
      return saveProgram(el);
    });
    testButton.addEventListener('click', function() {
      return runTests(el);
    });
    themeSelect.value = (_ref4 = el.leisureTheme) != null ? _ref4 : 'thin';
    themeSelect.addEventListener('change', function(evt) {
      return changeTheme(el, evt.target.value);
    });
    viewSelect.addEventListener('change', function(evt) {
      return changeView(el, evt.target.value);
    });
    el.autorun.checked = el.autorunState;
    el.autorun.addEventListener('change', function(evt) {
      el.autorunState = el.autorun.checked;
      if (el.autorunState) {
        return runTests(el);
      }
    });
    return markupButtons(controlDiv);
  };

  saveProgram = function() {
    return write(filename, getMDDocument(), (function() {
      return alert("Saving " + filename);
    }), function(err) {
      console.log(err);
      alert(err.stack);
      throw err;
    });
  };

  showFilename = function(el) {
    if (el && filename) {
      el.innerHTML = "Save: " + (filename.pathName());
      return el.title = filename.toString();
    }
  };

  showFilenames = function() {
    var node, _i, _len, _ref3, _results;

    _ref3 = document.body.querySelectorAll('[leisureId=saveButton]');
    _results = [];
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      node = _ref3[_i];
      _results.push(showFilename(node));
    }
    return _results;
  };

  setFilename = function(newName) {
    console.log("SET FILENAME: " + newName);
    filename = newName instanceof URI ? newName : new URI(document.location.href, newName);
    return showFilenames();
  };

  markupButtons = function(el) {
    var btn, _i, _len, _ref3, _results;

    _ref3 = el.querySelectorAll('button');
    _results = [];
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      btn = _ref3[_i];
      _results.push(markupButton(btn));
    }
    return _results;
  };

  markupButton = function(btn) {
    var cl, _i, _len, _results;

    _results = [];
    for (_i = 0, _len = buttonClasses.length; _i < _len; _i++) {
      cl = buttonClasses[_i];
      _results.push(btn.classList.add(cl));
    }
    return _results;
  };

  getElements = function(el, ids) {
    var els, id, node, _i, _j, _len, _len1, _ref3, _results;

    els = {};
    _ref3 = el.querySelectorAll('[leisureId]');
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      node = _ref3[_i];
      els[node.getAttribute('leisureId')] = node;
    }
    _results = [];
    for (_j = 0, _len1 = ids.length; _j < _len1; _j++) {
      id = ids[_j];
      _results.push(els[id]);
    }
    return _results;
  };

  escapeHtml = function(str) {
    if (typeof str === 'string') {
      return str.replace(/[<>]/g, function(c) {
        switch (c) {
          case '<':
            return '&lt;';
          case '>':
            return '&gt;';
        }
      });
    } else {
      return str;
    }
  };

  loadProgram = function(el, files) {
    var fr;

    el = getBox;
    fr = new FileReader();
    fr.onloadend = function(evt) {
      el.innerHTML = escapeHtml(fr.result);
      return initNotebook(el);
    };
    return fr.readAsBinaryString(files.item(0));
  };

  configureSaveLink = function(el) {
    var blob, builder;

    window.URL = window.URL || window.webkitURL;
    builder = new WebKitBlobBuilder();
    builder.append(getElementCode(el));
    blob = builder.getBlob('text/plain');
    el.leisureDownloadLink.href = window.URL.createObjectURL(blob);
    return el.leisureViewLink.href = window.URL.createObjectURL(blob);
  };

  getElementCode = function(el) {
    var r;

    r = document.createRange();
    r.selectNode(el);
    c = r.cloneContents().firstChild;
    removeOldDefs(c);
    return c.textContent;
  };

  runTests = function(el) {
    var failed, passed, resultsClass, test, _i, _len, _ref3;

    passed = 0;
    failed = 0;
    _ref3 = el.querySelectorAll('.codeMainTest');
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      test = _ref3[_i];
      if (runTest(test)) {
        passed++;
      } else {
        failed++;
      }
    }
    if (el.testResults) {
      resultsClass = el.testResults.classList;
      resultsClass.remove('notrun');
      if (!failed) {
        resultsClass.remove('failed');
        resultsClass.add('passed');
        return el.testResults.innerHTML = passed;
      } else {
        resultsClass.remove('passed');
        resultsClass.add('failed');
        return el.testResults.innerHTML = "" + passed + "/" + failed;
      }
    }
  };

  changeTheme = function(el, value) {
    var theme;

    theme = value;
    el.leisureTheme = theme;
    return el.className = theme;
  };

  changeView = function(el, value) {
    debug = value === 'debugging';
    return alert('new view: ' + value + ", debug: " + debug);
  };

  unwrap = function(node) {
    var parent;

    parent = node.parentNode;
    if (parent) {
      while (node.firstChild != null) {
        parent.insertBefore(node.firstChild, node);
      }
      return parent.removeChild(node);
    }
  };

  removeOldDefs = function(el) {
    var extracted, m, node, txt, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref3, _ref4, _ref5;

    el.leisureDownloadLink = null;
    el.leisureViewLink = null;
    extracted = [];
    _ref3 = el.querySelectorAll("[LeisureOutput]");
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      node = _ref3[_i];
      remove(node);
    }
    _ref4 = el.querySelectorAll("[generatednl]");
    for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
      node = _ref4[_j];
      txt = node.lastChild;
      if (txt.nodeType === 3 && txt.data[txt.data.length - 1] === '\n') {
        txt.data = txt.data.substring(0, txt.data.length - 1);
      }
    }
    _ref5 = el.querySelectorAll("[Leisure]");
    for (_k = 0, _len2 = _ref5.length; _k < _len2; _k++) {
      node = _ref5[_k];
      if (addsLine(node) && (node.firstChild != null)) {
        extracted.push(node.firstChild);
      }
      unwrap(node);
    }
    for (_l = 0, _len3 = extracted.length; _l < _len3; _l++) {
      node = extracted[_l];
      if ((node.parentNode != null) && !addsLine(node) && (node.previousSibling != null) && !addsLine(node.previousSibling)) {
        node.parentNode.insertBefore(text('\n'), node);
      }
    }
    el.textContent = el.textContent.replace(/\uFEFF/g, '');
    txt = el.lastChild;
    if ((txt != null ? txt.nodeType : void 0) === 3 && (m = txt.data.match(/(^|[^\n])(\n+)$/))) {
      return txt.data = txt.data.substring(0, txt.data.length - m[2].length);
    }
  };

  markupDefs = function(el, defs) {
    var auto, bod, body, bx, def, i, main, name, notebookAutoNodes, pgm, s, test, tests, totalTests, _i, _j, _len, _len1, _ref3, _ref4;

    pgm = '';
    auto = '';
    totalTests = 0;
    notebookAutoNodes = [];
    for (_i = 0, _len = defs.length; _i < _len; _i++) {
      i = defs[_i];
      main = i.main, name = i.name, def = i.def, body = i.body, tests = i.tests;
      if (name) {
        bx = box(main, 'codeMain', true);
        bx.appendChild(codeSpan(name, 'codeName'));
        bx.appendChild(textNode(def));
        bod = codeSpan(textNode(body), 'codeBody');
        bod.appendChild(textNode('\n'));
        bod.setAttribute('generatedNL', '');
        bx.appendChild(bod);
        bx.addEventListener('blur', (function() {
          return evalDoc(el);
        }), true);
        markPartialApplies(bx);
        addDefControls(bx);
        pgm += "" + name + " " + def + " " + body + "\n";
      } else if (main != null) {
        bx = box(main, 'codeMainExpr', true);
        s = codeSpan(textNode(body), 'codeExpr');
        s.setAttribute('generatedNL', '');
        s.appendChild(textNode('\n'));
        bx.appendChild(s);
        markPartialApplies(bx);
        if (((_ref3 = main.leisureAuto) != null ? _ref3.mode : void 0) === 'silent') {
          auto += "" + body + "\n";
        } else {
          if (((_ref4 = main.leisureAuto) != null ? _ref4.mode : void 0) === 'notebook') {
            notebookAutoNodes.push(bx);
          }
          makeOutputBox(bx);
        }
      }
      for (_j = 0, _len1 = tests.length; _j < _len1; _j++) {
        test = tests[_j];
        replaceRange(test, makeTestBox(test.leisureTest));
        totalTests++;
      }
    }
    return [pgm, auto, totalTests, notebookAutoNodes];
  };

  getDefName = function(ast) {
    if (ast instanceof Leisure_anno && getAnnoName(ast) === 'definition') {
      return getAnnoData(ast);
    } else {
      return null;
    }
  };

  getAst = function(bx, def) {
    var defName, _ref3;

    if (bx.ast != null) {
      patchFuncAst(bx.ast);
      bx.setAttribute('leisureFunc', (_ref3 = bx.ast.leisureName) != null ? _ref3 : '');
      return bx.ast;
    } else {
      def = def || bx.textContent;
      defName = getDefName(runMonad(rz(L_newParseLine)(lz(Nil))(lz(def))));
      setAst(bx, (defName ? {
        leisureName: defName,
        leisureSource: def
      } : {}));
      return bx.ast;
    }
  };

  setAst = function(bx, ast) {
    bx.ast = ast;
    return patchFuncAst(ast);
  };

  patchFuncAst = function(ast) {
    var parent;

    if ((ast != null ? ast.leisureName : void 0) != null) {
      parent = window[nameSub(ast.leisureName)];
      if (parent != null) {
        parent.ast = ast;
        parent.src = ast.leisureSource;
        return update("ast-" + ast.leisureName);
      }
    }
  };

  markPartialApplies = function(bx, def) {};

  textNode = function(text) {
    return document.createTextNode(text);
  };

  nodeFor = function(text) {
    if (typeof text === 'string') {
      return textNode(text);
    } else {
      return text;
    }
  };

  evalOutput = function(exBox, nofocus, cont) {
    var selector, stopUpdates, updateSelector, _ref3;

    exBox = getBox(exBox);
    if (!nofocus) {
      focusBox(exBox);
    }
    cleanOutput(exBox, true);
    selector = findUpdateSelector(exBox.source);
    if (selector) {
      exBox.setAttribute('leisureUpdate', selector);
    }
    makeOutputControls(exBox);
    _ref3 = getElements(exBox.firstChild, ['chooseUpdate', 'stopUpdates']), updateSelector = _ref3[0], stopUpdates = _ref3[1];
    updateSelector.addEventListener('change', function(evt) {
      return setUpdate(exBox, evt.target.value, true);
    });
    updateSelector.addEventListener('keydown', function(e) {
      c = e.charCode || e.keyCode || e.which;
      if (c === ENTER) {
        e.preventDefault();
        return updateSelector.blur();
      }
    });
    updateSelector.value = (exBox.getAttribute('leisureUpdate')) || '';
    exBox.updateSelector = updateSelector;
    return evalBox(exBox.source, exBox, cont);
  };

  findUpdateSelector = function(box) {
    var def, defType, leading, matched, name, u;

    if (def = box.textContent.match(rz(L_defPat))) {
      matched = def[0], leading = def[1], name = def[2], defType = def[3];
      if (u = leading.match(updatePat)) {
        return u[3];
      }
    }
  };

  getExprSource = function(box) {
    var b, s;

    s = window.getSelection();
    b = getBox(s.focusNode);
    if (b !== box || !s.rangeCount || s.getRangeAt(0).collapsed) {
      return box.textContent;
    } else {
      return getRangeText(s.getRangeAt(0));
    }
  };

  setUpdate = function(el, channel, preserveSource) {
    var ast, def, defType, index, leading, matched, name, r, txt, u;

    el.setAttribute('leisureUpdate', channel);
    if (channel) {
      el.classList.add('ui-state-highlight');
    } else {
      el.classList.remove('ui-state-highlight');
    }
    ast = getAst(el.source);
    txt = el.source.textContent;
    if (!preserveSource && (def = txt.match(rz(L_defPat)))) {
      matched = def[0], leading = def[1], name = def[2], defType = def[3];
      index = def.index;
      if (u = leading.match(updatePat)) {
        index += u.index + u[1].length + u[2].length;
        r = makeRange(el.source, index, index + u[3].length);
        r.deleteContents();
      } else {
        r = makeRange(el.source, index + leading.length, index + leading.length);
      }
      r.insertNode(textNode(channel));
      return el.source.normalize();
    }
  };

  hasMonadOutput = function(box) {
    var _ref3, _ref4;

    return ((_ref3 = box.firstElementChild) != null ? (_ref4 = _ref3.nextElementSibling) != null ? _ref4.nextElementSibling : void 0 : void 0) != null;
  };

  checkHideSource = function(box) {
    var hs;

    if (!box.hideOutputSource && hasMonadOutput(box)) {
      box.hideOutputSource = true;
      hs = createNode("<button class='editToggle' style='float:right'></button>");
      markupButton(hs);
      hs.addEventListener('click', function() {
        return toggleEdit(hs);
      });
      return box.firstElementChild.appendChild(hs);
    }
  };

  makeOutputControls = function(exBox) {
    if (exBox.firstChild.firstChild === exBox.firstChild.lastChild) {
      exBox.firstChild.insertBefore(createFragment("<button onclick='Notebook.clearOutputBox(this)'>X</button>"), exBox.firstChild.firstChild);
      exBox.firstChild.appendChild(createFragment("<button onclick='Notebook.makeTestCase(this)' leisureId='makeTestCase'>Make test\ncase</button><b>Update: </b><input type='text'\nplaceholder='Click for updating' list='channelList' leisureId='chooseUpdate'></input><button\nonclick='Notebook.clearUpdates(this)' leisureId='stopUpdates'>Stop Updates</button>"));
      markupButtons(exBox);
      return exBox.classList.add('fatControls');
    }
  };

  showOutputSource = function(output) {
    output.classList.remove('hidingSource');
    return output.source.style.display = '';
  };

  hideOutputSource = function(output) {
    console.log("HIDE: " + output);
    output.classList.add('hidingSource');
    return output.source.style.display = 'none';
  };

  toggleEdit = function(toggleButton) {
    var output;

    output = getBox(toggleButton);
    if (output.classList.contains('hidingSource')) {
      return showOutputSource(output);
    } else {
      return hideOutputSource(output);
    }
  };

  clearUpdates = function(widget, preserveSource) {
    var exBox;

    exBox = getBox(widget);
    exBox.updateSelector.value = '';
    return setUpdate(exBox, '', preserveSource);
  };

  update = function(type, env) {
    var node, _i, _len, _ref3, _results;

    env = env != null ? env : defaultEnv;
    _ref3 = env.owner.querySelectorAll("[leisureUpdate~='" + type + "']");
    _results = [];
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      node = _ref3[_i];
      _results.push(evalOutput(node, true));
    }
    return _results;
  };

  clearOutputBox = function(exBox) {
    clearUpdates(exBox, true);
    return cleanOutput(exBox);
  };

  cleanOutput = function(exBox, preserveControls) {
    var fc, _results;

    exBox = getBox(exBox);
    exBox.classList.remove('fatControls');
    if (!preserveControls) {
      exBox.hideOutputSource = null;
      fc = exBox.firstChild;
      fc.removeChild(fc.firstChild);
      while (fc.firstChild !== fc.lastChild) {
        fc.removeChild(fc.lastChild);
      }
    }
    _results = [];
    while (exBox.firstChild !== exBox.lastChild) {
      _results.push(exBox.removeChild(exBox.lastChild));
    }
    return _results;
  };

  makeTestCase = function(exBox) {
    var box, output, source, test;

    output = getBox(exBox);
    source = output.source;
    test = {
      expr: source.textContent.trim(),
      expected: escapeHtml(Parse.print(output.result))
    };
    box = makeTestBox(test, owner(exBox));
    source.parentNode.insertBefore(box, source);
    remove(source);
    remove(output);
    box.parentNode.insertBefore(textNode('\uFEFF'), box);
    box.parentNode.insertBefore(textNode('\uFEFF'), box.nextSibling);
    if (owner(box).autorunState) {
      return clickTest(box);
    }
  };

  makeTestBox = function(test, owner, src) {
    var bx, s;

    src = src != null ? src : "#@test " + (JSON.stringify(test.expr)) + "\n#@expected " + (JSON.stringify(test.expected));
    s = codeSpan(src, 'codeTest');
    s.appendChild(textNode('\n'));
    s.setAttribute('generatedNL', '');
    bx = codeBox('codeMainTest');
    bx.testSrc = s;
    bx.setAttribute('class', 'codeMainTest notrun');
    bx.setAttribute('contenteditable', 'false');
    bx.appendChild(s);
    bx.addEventListener('click', (function() {
      return clickTest(bx);
    }), true);
    bx.test = test;
    return bx;
  };

  clickTest = function(bx) {
    var exprBox, r, sp;

    if (bx.classList.contains('notrun')) {
      return runTest(bx);
    } else {
      r = document.createRange();
      r.setStartBefore(bx);
      r.setEndAfter(bx);
      r.deleteContents();
      sp = codeSpan(bx.test.expr, 'codeExpr');
      sp.setAttribute('generatedNL', '');
      exprBox = box(r, 'codeMainExpr', true);
      exprBox.appendChild(sp);
      return makeOutputBox(exprBox);
    }
  };

  runTest = function(bx) {
    var passed, test;

    test = bx.test;
    passed = true;
    processLine(prepExpr(test.expr), {
      values: {},
      require: req,
      write: function(str) {
        return console.log(str);
      },
      debug: debug,
      prompt: function(msg, cont) {
        return cont(null);
      },
      processResult: function(result, ast) {
        return passed = showResult(bx, escapeHtml(String(result)), escapeHtml(test.expected));
      },
      err: function() {
        return passed = false;
      },
      presentValue: function(x) {
        return x;
      }
    }, identity);
    return passed;
  };

  showResult = function(bx, actual, expected) {
    var cl;

    cl = bx.classList;
    cl.remove('notrun');
    if (actual === expected) {
      cl.remove('failed');
      cl.add('passed');
      bx.testSrc.innerHTML = "#@test " + (JSON.stringify(bx.test.expr)) + "\n#@expected " + (JSON.stringify(bx.test.expected));
    } else {
      cl.remove('passed');
      cl.add('failed');
      bx.testSrc.innerHTML = "#@test " + (JSON.stringify(bx.test.expr)) + "\n#@expected " + (JSON.stringify(bx.test.expected)) + "\n#@result " + (JSON.stringify(actual));
      console.log("expected <" + expected + "> but got <" + actual + ">");
    }
    return actual === expected;
  };

  prepExpr = function(txt) {
    return txt;
  };

  envFor = function(box) {
    var env, exBox, widget;

    exBox = getBox(box);
    widget = null;
    env = {
      fileSettings: {},
      debug: debug,
      finishedEvent: function(evt, channel) {
        return update(channel != null ? channel : 'app', this);
      },
      owner: owner(box),
      box: box,
      require: req,
      write: function(msg) {
        var div;

        div = document.createElement('div');
        div.classList.add('outputDiv');
        div.innerHTML = "" + msg + "\n";
        exBox.appendChild(div);
        checkHideSource(exBox);
        return markupButtons(exBox);
      },
      getWidget: function() {
        if (!widget) {
          widget = document.createElement("DIV");
          exBox.appendChild(widget);
        }
        return widget;
      },
      destroyWidget: function() {
        if (widget) {
          return remove(widget);
        }
      },
      prompt: function(msg, cont) {
        return cont(window.prompt(msg));
      },
      processResult: function(result, ast) {
        box.result = result;
        return setAst(box, ast);
      },
      presentValue: presentValue,
      err: function(err) {
        var btn, _ref3;

        btn = box.querySelector('[leisureId="makeTestCase"]');
        if (btn) {
          remove(btn);
        }
        return this.write("<div class='errorDiv'>" + escapeHtml("ERROR: " + (err.leisureContext ? "" + err + ":\n" + (leisureContextString(err)) + "\n" : '') + ((_ref3 = err.stack) != null ? _ref3 : err)) + "</div>");
      },
      cleanup: function() {
        this.destroyWidget();
        if (root.lastEnv === env) {
          return root.lastEnv = null;
        }
      }
    };
    env.__proto__ = defaultEnv;
    env.fileSettings.uri = new URI(document.location.href);
    root.lastEnv = env;
    return env;
  };

  leisureContextString = function(err) {
    var func, offset;

    return ((function() {
      var _i, _len, _ref3, _ref4, _results;

      _ref3 = err.leisureContext.toArray();
      _results = [];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        _ref4 = _ref3[_i], func = _ref4[0], offset = _ref4[1];
        _results.push(linkSource(func, offset));
      }
      return _results;
    })()).join('\n');
  };

  linkSource = function(funcName, offset) {};

  showSource = function(funcName, offset) {};

  makeOutputBox = function(source) {
    var cl, node, _i, _len, _ref3;

    node = document.createElement('div');
    node.setAttribute('LeisureOutput', '');
    node.setAttribute('Leisure', '');
    node.setAttribute('LeisureBox', '');
    _ref3 = boxClasses.output;
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      cl = _ref3[_i];
      node.classList.add(cl);
    }
    node.setAttribute('contentEditable', 'false');
    node.source = source;
    source.output = node;
    node.innerHTML = "<div class='controls'><button onclick='Notebook.evalOutput(this)'>-&gt;</button></div>";
    markupButtons(node);
    source.parentNode.insertBefore(node, source.nextSibling);
    return node;
  };

  codeSpan = function(text, boxType) {
    var node;

    node = document.createElement('span');
    node.setAttribute(boxType, '');
    node.setAttribute('Leisure', '');
    node.setAttribute('class', boxType);
    if (text) {
      node.appendChild(nodeFor(text));
    }
    return node;
  };

  codeBox = function(boxType) {
    var node;

    node = document.createElement('div');
    addBoxClasses(node, boxType);
    node.setAttribute('LeisureBox', '');
    node.setAttribute('Leisure', '');
    node.addEventListener('compositionstart', function(e) {
      return checkMutateFromModification(e);
    });
    return node;
  };

  box = function(range, boxType, empty) {
    var node;

    node = codeBox(boxType);
    if (empty) {
      range.deleteContents();
    } else {
      node.appendChild(range.extractContents());
    }
    range.insertNode(node);
    return node;
  };

  linePat = new RegExp("(" + (rz(L_linePat).source) + ")");

  findDefs = function(el) {
    var def, ranges, rest, rng, txt;

    txt = el.textContent;
    rest = txt;
    ranges = [];
    while ((def = rest.match(rz(L_unanchoredDefPat))) && def[1].length !== rest.length) {
      rng = getRanges(el, txt, rest, def, txt.length - rest.length);
      if (rng) {
        rest = rng.next;
        if (rng) {
          ranges.push(rng);
        } else {
          break;
        }
      } else {
        break;
      }
    }
    return ranges;
  };

  testPat = /(#@test([^\n]*)\n#@expected([^\n]*))\n/m;

  getRanges = function(el, txt, rest, def, restOff) {
    var body, bodyStart, defType, endPat, ex, exEnd, leadOff, leading, leadingSpaces, lm, m, m2, mainEnd, mainStart, matchStart, matched, name, nameEnd, nameRaw, next, outerRange, r, rest1, t, tOff, tests, textStart, _ref3, _ref4, _ref5, _ref6;

    _ref3 = m = def, matched = _ref3[0], leading = _ref3[1], nameRaw = _ref3[2], defType = _ref3[3];
    if (!rest.trim()) {
      return null;
    } else if (m == null) {
      return [makeRange(el, restOff, txt.length), null, null, [], ''];
    } else {
      tests = [];
      matchStart = restOff + m.index;
      if (defType == null) {
        name = null;
      } else if (nameRaw[0] === ' ') {
        name = null;
        defType = null;
      } else {
        name = nameRaw.trim() || null;
      }
      rest1 = rest.substring((defType ? matched : leading).length);
      endPat = rest1.match(/\n+[^\s]|\n?$/);
      next = endPat ? rest1.substring(endPat.index) : rest1;
      mainEnd = txt.length - next.length;
      t = leading;
      leadOff = tOff = restOff;
      while (m2 = t.match(testPat)) {
        r = makeRange(el, tOff + m2.index, tOff + m2.index + m2[1].length);
        r.leisureTest = {
          expr: JSON.parse(m2[2]),
          expected: JSON.parse(m2[3])
        };
        tests.push(r);
        tOff += m2.index + m2[1].length;
        t = leading.substring(tOff - leadOff);
      }
      if (name) {
        mainStart = matchStart + ((_ref4 = leading != null ? leading.length : void 0) != null ? _ref4 : 0);
        nameEnd = mainStart + name.length;
        leadingSpaces = (rest1.match(/^\s*/))[0].length;
        bodyStart = txt.length - (rest1.length - leadingSpaces);
        outerRange = makeRange(el, mainStart, mainEnd);
        return {
          main: outerRange,
          name: txt.substring(mainStart, nameEnd),
          def: defType,
          body: txt.substring(bodyStart, mainEnd),
          tests: tests,
          next: next
        };
      } else {
        mainStart = defType === '=' ? restOff + m.index + m[0].length : matchStart + ((_ref5 = leading != null ? leading.length : void 0) != null ? _ref5 : 0);
        ex = txt.substring(mainStart, mainEnd).match(/^(.*[^ \n])[ \n]*$/);
        exEnd = ex ? mainStart + ex[1].length : mainEnd;
        body = txt.substring(mainStart, exEnd);
        if (body.trim()) {
          textStart = restOff + m.index + (t ? leading.length - t.length : 0);
          if ((t != null) && (lm = t.match(/^[ \n]+/))) {
            textStart += lm[0].length;
          }
          if (m = t.match(/(?:^|\n)#@auto( +[^\n]*)?(\n|$)/)) {
            outerRange = makeRange(el, textStart, exEnd);
            outerRange.leisureAuto = JSON.parse("{" + ((_ref6 = m[1]) != null ? _ref6 : '') + "}");
            if (outerRange.leisureAuto.mode === 'notebook') {
              outerRange.leisureNode = el;
              outerRange.leisureStart = textStart;
            }
            return {
              main: outerRange,
              name: null,
              def: null,
              body: txt.substring(textStart, exEnd),
              tests: tests,
              fullText: txt.substring(textStart, exEnd),
              next: next
            };
          } else {
            outerRange = makeRange(el, textStart, exEnd);
            return {
              main: outerRange,
              name: null,
              def: null,
              body: txt.substring(textStart, exEnd),
              tests: tests,
              next: next
            };
          }
        } else {
          return {
            main: null,
            name: null,
            def: null,
            body: null,
            tests: tests,
            next: next
          };
        }
      }
    }
  };

  makeRange = function(el, off1, off2) {
    var node, offset, range, _ref3, _ref4;

    range = document.createRange();
    _ref3 = grp(el, off1, false), node = _ref3[0], offset = _ref3[1];
    if ((offset != null) && offset > 0) {
      range.setStart(node, offset);
    } else {
      range.setStartBefore(node);
    }
    if (off2 != null) {
      _ref4 = grp(el, off2, true), node = _ref4[0], offset = _ref4[1];
      if (offset != null) {
        range.setEnd(node, offset);
      } else {
        range.setEndAfter(node);
      }
    }
    return range;
  };

  grp = function(node, charOffset, end) {
    var child, offset, ret, _ref3;

    _ref3 = ret = getRangePosition(node.firstChild, charOffset, end), child = _ref3[0], offset = _ref3[1];
    if (child) {
      return ret;
    } else if (node.lastChild) {
      return nodeEnd(node.lastChild);
    } else {
      return [node, end ? 1 : 0];
    }
  };

  getRangePosition = function(node, charOffset, end) {
    var newNode, newOff, ret, _ref3;

    if (!node) {
      return [null, charOffset];
    } else if (node.nodeType === 3) {
      if (node.length > (end ? charOffset - 1 : charOffset)) {
        return [node, charOffset];
      } else {
        ret = continueRangePosition(node, charOffset - node.length, end);
        return ret;
      }
    } else if (node.nodeName === 'BR') {
      if (charOffset === (end ? 1 : 0)) {
        return [node];
      } else {
        return continueRangePosition(node, charOffset, end);
      }
    } else if (node.firstChild != null) {
      _ref3 = getRangePosition(node.firstChild, charOffset, end), newNode = _ref3[0], newOff = _ref3[1];
      if (newNode != null) {
        return [newNode, newOff];
      } else {
        return continueRangePosition(node, newOff, end);
      }
    } else {
      return continueRangePosition(node, charOffset, end);
    }
  };

  continueRangePosition = function(node, charOffset, end) {
    var newOff;

    newOff = charOffset - ((addsLine(node)) || ((node.nextSibling != null) && (addsLine(node.nextSibling))) ? 1 : 0);
    if (end && (newOff === 1 || charOffset === 1)) {
      return nodeEnd(node);
    } else if (node.nextSibling != null) {
      return getRangePosition(node.nextSibling, newOff, end);
    } else {
      return continueRangePosition(node.parentNode, newOff, end);
    }
  };

  nodeEnd = function(node) {
    return [node, node.nodeType === 3 ? node.length : node.childNodes.length - 1];
  };

  addsLine = function(node) {
    return (node != null ? node.nodeType : void 0) === 1 && (node.nodeName === 'BR' || (getComputedStyle(node, null).display === 'block' && node.childNodes.length > 0));
  };

  req = function(file, cont) {
    var name, s;

    if (!(file.match(/\.js$/))) {
      file = "" + file + ".js";
    }
    name = file.substring(0, file.length - 3);
    s = document.createElement('script');
    s.setAttribute('src', file);
    s.addEventListener('load', function() {
      Leisure.processDefs(global[name], global);
      if (cont) {
        return cont(rz(L_false));
      }
    });
    return document.head.appendChild(s);
  };

  postLoadQueue = [];

  loaded = false;

  queueAfterLoad = function(func) {
    if (loaded) {
      return func();
    } else {
      return postLoadQueue.push(func);
    }
  };

  /*
  # handle focus manually, because grabbing focus and blur events doesn't seem to work for the parent
  */


  docFocus = null;

  codeFocus = null;

  findCurrentCodeHolder = function() {
    var _ref3;

    return focusBox((_ref3 = window.getSelection()) != null ? _ref3.focusNode : void 0);
  };

  focusBox = function(box) {
    var newCode, old, _ref3;

    newCode = null;
    while (box && (box.nodeType !== 1 || !isLeisureCode(box))) {
      if (box.nodeType === 1 && ((box.getAttribute('LeisureBox')) != null)) {
        newCode = box;
      }
      box = box.parentNode;
    }
    if (box !== docFocus) {
      if (docFocus != null) {
        docFocus.classList.remove('focused');
      }
      docFocus = box;
      if (box != null) {
        if ((_ref3 = box.classList) != null) {
          _ref3.add('focused');
        }
      }
    }
    if (newCode !== codeFocus) {
      old = codeFocus;
      codeFocus = newCode;
      if (old) {
        return acceptCode(old);
      }
    }
  };

  owner = function(box) {
    while (box && (box.nodeType !== 1 || !isLeisureCode(box))) {
      box = box.parentNode;
    }
    return box;
  };

  hiddenPat = /(^|\n)#@hidden *(\n|$)/;

  evalBox = function(box, envBox, cont) {
    var env;

    env = envBox != null ? envFor(envBox) : null;
    processLine(box.textContent, env, function(result) {
      if (env != null) {
        if (typeof env.cleanup === "function") {
          env.cleanup();
        }
      }
      return (cont != null ? cont : function(x) {
        return x;
      })(result);
    });
    getAst(box);
    if (box.output && hasMonadOutput(box.output) && box.textContent.match(hiddenPat)) {
      return hideOutputSource(box.output);
    } else if (box.textContent.match(hiddenPat)) {
      return console.log("NO MONAD, BUT MATCHES HIDDEN");
    }
  };

  acceptCode = function(box) {
    if ((box.getAttribute('codemain')) != null) {
      evalBox(box);
      update('compile');
      if (owner(box).autorunState) {
        return runTests(owner(box));
      }
    }
  };

  errString = function(err) {
    return err.stack;
  };

  evaluating = false;

  evaluationQueue = [];

  evalNodes = function(nodes) {
    if (evaluating) {
      return evaluationQueue.push(nodes);
    } else {
      return chainEvalNodes(nodes);
    }
  };

  chainEvalNodes = function(nodes) {
    evaluating = true;
    return runAuto(nodes, 0, function() {
      if (evaluationQueue.length) {
        return chainEvalNodes(evaluationQueue.shift());
      } else {
        return evaluating = false;
      }
    });
  };

  evalDoc = function(el) {
    var auto, autoNodes, e, err, pgm, x, _ref3;

    _ref3 = initNotebook(el), pgm = _ref3[0], auto = _ref3[1], x = _ref3[2], autoNodes = _ref3[3];
    try {
      if (auto || autoNodes) {
        auto = "do\n  " + ((auto != null ? auto : '#').trim().replace(/\n/g, '\n  ')) + "\n  delay\n  finishLoading";
        global.noredefs = false;
        Notebook.queueAfterLoad(function() {
          evalDocCode(el, pgm);
          if (el.autorunState) {
            runTests(el);
          }
          return evalNodes(autoNodes);
        });
        e = envFor(el);
        e.write = function() {};
        e.err = function(err) {
          return alert('bubba ' + errString(err));
        };
        return processLine(auto, e, identity);
      } else {
        return evalDocCode(el, pgm);
      }
    } catch (_error) {
      err = _error;
      return showError(err, "Error compiling " + pgm);
    }
  };

  runAuto = function(nodes, index, cont) {
    var node;

    if (index < nodes.length) {
      console.log("RUNNING AUTO: " + index);
      node = nodes[index];
      console.log("evalOutput", node, node.output);
      return evalOutput(node.output, false, function() {
        return runAuto(nodes, index + 1, cont);
      });
    } else {
      return (cont != null ? cont : function() {})();
    }
  };

  processLine = function(text, env, cont) {
    var err;

    if (text) {
      try {
        return runMonad(rz(L_newParseLine)(lz(Nil))(lz(text)), env, function(ast) {
          var err, result;

          try {
            if (getType(ast) === 'parseErr') {
              env.write(env.presentValue(ast));
              if (typeof env.processResult === "function") {
                env.processResult(ast);
              }
              return cont(ast);
            } else {
              result = eval("(" + (gen(ast)) + ")");
              env.write(env.presentValue(result));
              if (isMonad(result)) {
                return runMonad(result, env, function(result) {
                  env.processResult(result);
                  return cont(result);
                });
              } else {
                if (typeof env.processResult === "function") {
                  env.processResult(result);
                }
                return cont(result);
              }
            }
          } catch (_error) {
            err = _error;
            console.log("ERROR: " + err.stack);
            env.write(env.presentValue(err.stack));
            if (typeof env.processResult === "function") {
              env.processResult(err.stack);
            }
            return cont(err.stack);
          }
        });
      } catch (_error) {
        err = _error;
        console.log("ERROR: " + err.stack);
        env.write(env.presentValue(err.stack));
        if (typeof env.processResult === "function") {
          env.processResult(err.stack);
        }
        return cont(err.stack);
      }
    } else {
      return cont('');
    }
  };

  showError = function(e, msg) {
    console.log(msg);
    console.log(e);
    console.log(e.stack);
    return alert(e.stack);
  };

  evalDocCode = function(el, pgm) {
    return runMonad(rz(L_runFile)(lz(pgm)), defaultEnv, function(result) {
      var node, _i, _len, _ref3, _results;

      _ref3 = el.querySelectorAll('[codeMain]');
      _results = [];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        node = _ref3[_i];
        _results.push(getAst(node));
      }
      return _results;
    });
  };

  define('getDocument', lz(makeSyncMonad(function(env, cont) {
    return cont(peerGetDocument());
  })));

  define('getLink', function() {
    return 0;
  });

  define('replaceDocument', lz(function(str) {
    return makeSyncMonad(function(env, cont) {
      replaceContents(rz(str));
      return cont(rz(L_true));
    });
  }));

  define('gdriveOpen', lz(makeMonad(function(env, cont) {
    return GdriveStorage.runOpen(function(json) {
      var _ref3;

      if ((json != null ? json.action : void 0) === 'picked' && ((_ref3 = json.docs) != null ? _ref3.length : void 0) > 0) {
        return GdriveStorage.loadFile(json.docs[0].id, function() {
          return cont(rz(_some)(lz(json.docs[0].title)));
        });
      } else {
        return cont(rz(_none));
      }
    });
  })));

  define('getFilename', lz(makeSyncMonad(function(env, cont) {
    var _ref3;

    return cont((_ref3 = filename != null ? filename.pathName() : void 0) != null ? _ref3 : '');
  })));

  define('setURI', lz(function(uri) {
    return makeSyncMonad(function(env, cont) {
      setFilename(rz(uri));
      return cont(rz(L_true));
    });
  }));

  define('getURI', lz(makeSyncMonad(function(env, cont) {
    var _ref3;

    return cont((_ref3 = filename != null ? filename.toString() : void 0) != null ? _ref3 : '');
  })));

  define('finishLoading', lz(makeMonad(function(env, cont) {
    var i, _i, _len;

    loaded = true;
    for (_i = 0, _len = postLoadQueue.length; _i < _len; _i++) {
      i = postLoadQueue[_i];
      rz(i);
    }
    postLoadQueue = [];
    return cont(rz(L_false));
  })));

  define('markupButtons', lz(makeSyncMonad(function(env, cont) {
    if (env.box) {
      markupButtons(env.box);
    }
    return cont(rz(L_false));
  })));

  define('alert', lz(function(str) {
    return makeSyncMonad(function(env, cont) {
      window.alert(rz(str));
      return cont(rz(L_false));
    });
  }));

  define('bindEvent', lz(function(selector) {
    return function(eventName) {
      return function(func) {
        return makeSyncMonad(function(env, cont) {
          var node;

          node = env.box.querySelector(rz(selector));
          if (!node) {
            node = document.body.querySelector(rz(selector));
          }
          console.log("ADDING EVENT: " + (rz(selector)) + " " + (rz(eventName)) + " NODE: " + node);
          if (node) {
            node.addEventListener(eventName(), function(e) {
              console.log("EVENT: " + (rz(selector)) + " " + (rz(eventName)) + " " + (rz(func)));
              return runMonad(rz(func)(lz(e)), envFor(e.target), function() {});
            });
          }
          return cont(rz(L_false));
        });
      };
    };
  }));

  define('quit', lz(window.close()));

  define('config', lz(function(expr) {
    return makeSyncMonad(function(env, cont) {
      switch (rz(expr)) {
        case 'autoTest':
          autoRun(env.owner, true);
      }
      return cont(rz(L_false));
    });
  }));

  define('notebookSelection', lz(function(func) {
    return makeSyncMonad(function(env, cont) {
      var bx, offset, p1, p2, r, r2, sel;

      sel = window.getSelection();
      bx = getBox(sel.focusNode);
      if ((bx != null) && hasFunc(bx, func)) {
        offset = 0;
        r = sel.getRangeAt(0);
        window.r = r;
        r2 = document.createRange();
        r2.setStart(bx, 0);
        r2.setEnd(r.startContainer, r.startOffset);
        p1 = r2.cloneContents().textContent.length - offset;
        if (!r.collapsed) {
          r2.setEnd(r.endContainer, r.endOffset);
        }
        p2 = r2.cloneContents().textContent.length - offset;
        return cont(rz(_some2)(lz(p1))(lz(p2)));
      } else {
        return cont(rz(_none));
      }
    });
  }));

  hasFunc = function(bx, func) {
    var ast;

    ast = getAst(bx);
    return ast === func().ast || ast === func.ast;
  };

  define('notebookAst', lz(function(func) {
    return makeSyncMonad(function(env, cont) {
      var ast, node;

      if (func.leisureName != null) {
        node = document.querySelector("[LeisureFunc=" + func.leisureName + "]");
        if (node != null) {
          ast = getAst(node);
          return cont(rz(_some)(lz(ast)));
        }
      }
      return cont(rz(_none));
    });
  }));

  autoRun = function(el, state) {
    var _ref3;

    el.autorunState = state;
    return (_ref3 = el.autorun) != null ? _ref3.checked = state : void 0;
  };

  head = function(l) {
    return l(lz(function(hh) {
      return function(tt) {
        return rz(hh);
      };
    }));
  };

  tail = function(l) {
    return l(lz(function(hh) {
      return function(tt) {
        return rz(tt);
      };
    }));
  };

  id = function(v) {
    return rz(v);
  };

  getSvgElement = function(id) {
    var el, svg;

    if ((el = document.getElementById(id))) {
      return el;
    } else {
      svg = createNode("<svg id='HIDDEN_SVG' xmlns='http://www.w3.org/2000/svg' version='1.1' style='top: -100000; position: absolute'><text id='HIDDEN_TEXT'>bubba</text></svg>");
      document.body.appendChild(svg);
      return document.getElementById(id);
    }
  };

  svgMeasureText = function(text) {
    return function(style) {
      return function(f) {
        var bx, txt;

        txt = getSvgElement('HIDDEN_TEXT');
        if (rz(style)) {
          txt.setAttribute('style', rz(style));
        }
        txt.lastChild.textContent = rz(text);
        bx = txt.getBBox();
        return rz(f)(lz(bx.width))(lz(bx.height));
      };
    };
  };

  primconcatNodes = function(nodes) {
    if (nodes === rz(_nil)) {
      return "";
    } else {
      return (head(nodes))(id) + concatNodes(tail(nodes));
    }
  };

  transformedPoint = function(pt, x, y, ctm, ictm) {
    pt.x = x;
    pt.y = y;
    return pt.matrixTransform(ctm).matrixTransform(ictm);
  };

  svgMeasure = function(content) {
    return primSvgMeasure(content, baseStrokeWidth);
  };

  svgBetterMeasure = function(content) {
    return primSvgMeasure(content, transformStrokeWidth);
  };

  primSvgMeasure = function(content, transformFunc) {
    return function(f) {
      var bbox, g, pad, svg;

      svg = createNode("<svg xmlns='http://www.w3.org/2000/svg' version='1.1' style='top: -100000'><g>" + (content()) + "</g></svg>");
      document.body.appendChild(svg);
      g = svg.firstChild;
      bbox = g.getBBox();
      pad = getMaxStrokeWidth(g, g, svg, transformFunc);
      document.body.removeChild(svg);
      return rz(f)(lz(bbox.x - Math.ceil(pad / 2)))(lz(bbox.y - Math.ceil(pad / 2)))(lz(bbox.width + pad))(lz(bbox.height + pad));
    };
  };

  baseElements = ['path', 'rect', 'circle', 'ellipse', 'line', 'polyline', 'polygon'];

  getMaxStrokeWidth = function(el, base, svg, transformFunc) {
    var _ref3, _ref4;

    if (_ref3 = base.nodeName, __indexOf.call(baseElements, _ref3) >= 0) {
      svg.setAttribute('width', (_ref4 = getComputedStyle(base).strokeWidth) != null ? _ref4 : '0', svg);
      return transformFunc(el, svg.width.baseVal.value);
    } else if (base.nodeName === 'use') {
      return getMaxStrokeWidth(base, base.instanceRoot.correspondingElement, svg, transformFunc);
    } else if (base.nodeName === 'g') {
      return foldLeft((function(v, n) {
        return Math.max(v, getMaxStrokeWidth(n, n, svg, transformFunc));
      }), 0, el.childNodes);
    } else {
      return 0;
    }
  };

  baseStrokeWidth = function(el, w) {
    return w;
  };

  transformStrokeWidth = function(el, w) {
    var ctm, tp1, tp2, x, y;

    if (w === 0) {
      return 0;
    } else {
      ctm = el.getScreenCTM();
      tp1 = transformedPoint(pt, bx.x - Math.ceil(w), bx.y - Math.ceil(w), ctm, isctm);
      tp2 = transformedPoint(pt, bx.x + bx.width + Math.ceil(w), bx.y + bx.height + Math.ceil(w), ctm, isctm);
      x = tp2.x - tp1.x;
      y = tp2.y - tp1.y;
      return Math.sqrt(x * x + y * y);
    }
  };

  previousSibling = function(node) {
    while ((node != null ? node.parentNode : void 0) && !node.previousSibling) {
      node = node.parentNode;
    }
    return node != null ? node.previousSibling : void 0;
  };

  nextSibling = function(node) {
    while ((node != null ? node.parentNode : void 0) && !node.nextSibling) {
      node = node.parentNode;
    }
    return node != null ? node.nextSibling : void 0;
  };

  hideControlSection = function() {
    var controlSection;

    controlSection = document.body.querySelector('[leisureSection="Leisure Controls"]');
    if (!controlSection) {
      controlSection = document.createElement('DIV');
      document.body.insertBefore(controlSection, document.body.firstChild);
      root.markupElement(controlSection, "# Leisure Controls\n\n## File Save and Load\n```\nsaveFile\n\nsaveAs 'filename'\n\nsaveAs pickFile\n\nloadFile\n\nemptyFile\n```");
      unwrap(controlSection);
    }
    controlSection.classList.add(leisure_controls);
    return controlSection.classList.add(hidden);
  };

  define('printValue', lz(function(value) {
    return makeMonad(function(env, cont) {
      if (rz(value) !== rz(L_nil)) {
        env.write("" + (env.presentValue(rz(value))) + "\n");
      }
      return cont(L_false());
    });
  }));

  defaultEnv.require = req;

  root.svgMeasureText = svgMeasureText;

  root.svgMeasure = svgMeasure;

  root.initNotebook = initNotebook;

  root.bindNotebook = bindNotebook;

  root.bindAll = bindAll;

  root.evalOutput = evalOutput;

  root.makeTestCase = makeTestCase;

  root.cleanOutput = cleanOutput;

  root.clearOutputBox = clearOutputBox;

  root.envFor = envFor;

  root.queueAfterLoad = queueAfterLoad;

  root.evalDoc = evalDoc;

  root.getBox = getBox;

  root.makeRange = makeRange;

  root.grp = grp;

  root.changeTheme = changeTheme;

  root.setSnapper = setSnapper;

  root.update = update;

  root.clearUpdates = clearUpdates;

  root.showAst = showAst;

  root.toggleEdit = toggleEdit;

  root.showSource = showSource;

  root.bootNotebook = bootNotebook;

  root.createNode = createNode;

  root.ENTER = ENTER;

  root.textNode = textNode;

  root.cleanEmptyNodes = cleanEmptyNodes;

  root.isLeisureCode = isLeisureCode;

  root.getElementCode = getElementCode;

  root.runTests = runTests;

  root.previousSibling = previousSibling;

  root.nextSibling = nextSibling;

  root.presentLeisureCode = presentLeisureCode;

  root.mergeLeisureCode = mergeLeisureCode;

  root.highlightNotebookFunction = highlightNotebookFunction;

  root.ESC = ESC;

  root.HOME = HOME;

  root.END = END;

  root.PAGE_UP = PAGE_UP;

  root.PAGE_DOWN = PAGE_DOWN;

  root.LEFT_ARROW = LEFT_ARROW;

  root.UP_ARROW = UP_ARROW;

  root.RIGHT_ARROW = RIGHT_ARROW;

  root.DOWN_ARROW = DOWN_ARROW;

  root.arrows = arrows;

  root.closeWindow = closeWindow;

  root.markupButton = markupButton;

  root.markupButtons = markupButtons;

  root.getAst = getAst;

  root.insertControls = insertControls;

  root.delay = delay;

  root.setFilename = setFilename;

  root.unwrap = unwrap;

  root.remove = remove;

  root.wrapRange = wrapRange;

  root.replaceContents = replaceContents;

  root.event = event;

}).call(this);

/*
*/

})(self)
},{"./ast":1,"./base":2,"./gen":4,"./lodash.min":6,"./runtime":10}],10:[function(require,module,exports){
(function(process,global){// Generated by CoffeeScript 1.6.2
/*
Copyright (C) 2013, Bill Burdick, Tiny Concepts: https://github.com/zot/Leisure

(licensed with ZLIB license)

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software
in a product, an acknowledgment in the product documentation would be
appreciated but is not required.

2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.

3. This notice may not be removed or altered from any source distribution.
*/


(function() {
  var Monad, Nil, SimpyCons, actors, amt, ast2Json, asyncMonad, basicCall, booleanFor, call, callMonad, cons, consFrom, continueMonads, curry, defaultEnv, define, ensureLeisureClass, functionInfo, getDataType, getMonadSyncMode, getType, getValue, hamt, head, identity, isMonad, lazy, left, lz, makeHamt, makeMonad, makeSyncMonad, memo, monadModeSync, nameSub, newRunMonad, nextMonad, nextNode, none, parensContent, parensEnd, parensStart, readDir, readFile, replaceErr, resolve, right, root, runMonad, rz, setDataType, setType, setValue, setWarnAsync, simpyCons, some, statFile, strCoord, strFromList, strToList, subcurry, tail, tokenPos, tokenString, trampCurry, values, warnAsync, withSyncModeDo, writeFile, _, _false, _identity, _ref, _ref1, _true,
    __slice = [].slice;

  _ref = root = module.exports = require('./base'), readFile = _ref.readFile, statFile = _ref.statFile, readDir = _ref.readDir, writeFile = _ref.writeFile, defaultEnv = _ref.defaultEnv, SimpyCons = _ref.SimpyCons, simpyCons = _ref.simpyCons, resolve = _ref.resolve, lazy = _ref.lazy;

  _ref1 = require('./ast'), define = _ref1.define, cons = _ref1.cons, Nil = _ref1.Nil, head = _ref1.head, tail = _ref1.tail, getType = _ref1.getType, getDataType = _ref1.getDataType, ast2Json = _ref1.ast2Json, ensureLeisureClass = _ref1.ensureLeisureClass, setType = _ref1.setType, setDataType = _ref1.setDataType, functionInfo = _ref1.functionInfo, nameSub = _ref1.nameSub;

  _ = require('./lodash.min');

  amt = require('persistent-hash-trie');

  rz = resolve;

  lz = lazy;

  call = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return basicCall(args, defaultEnv, identity);
  };

  callMonad = function() {
    var args, cont, env, _i;

    args = 3 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 2) : (_i = 0, []), env = arguments[_i++], cont = arguments[_i++];
    return basicCall(args, env, cont);
  };

  basicCall = function(args, env, cont) {
    var arg, res, _i, _len, _ref2;

    res = global["L_" + args[0]]();
    _ref2 = args.slice(1);
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      arg = _ref2[_i];
      res = (function(arg) {
        return res(lz(arg));
      })(arg);
    }
    return runMonad(res, env, cont);
  };

  consFrom = function(array, i) {
    i = i || 0;
    if (i < array.length) {
      return cons(array[i], consFrom(array, i + 1));
    } else {
      return L_nil();
    }
  };

  identity = function(x) {
    return x;
  };

  _identity = function(x) {
    return rz(x);
  };

  _true = setType((function(a) {
    return function(b) {
      return rz(a);
    };
  }), 'true');

  _false = setType((function(a) {
    return function(b) {
      return rz(b);
    };
  }), 'false');

  left = function(x) {
    return setType((function(lCase) {
      return function(rCase) {
        return rz(lCase)(lz(x));
      };
    }), 'left');
  };

  right = function(x) {
    return setType((function(lCase) {
      return function(rCase) {
        return rz(rCase)(lz(x));
      };
    }), 'right');
  };

  some = function(x) {
    return setType((function(someCase) {
      return function(noneCase) {
        return rz(someCase)(lz(x));
      };
    }), 'some');
  };

  none = setType((function(someCase) {
    return function(noneCase) {
      return rz(noneCase);
    };
  }), 'none');

  booleanFor = function(bool) {
    if (bool) {
      return rz(L_true);
    } else {
      return rz(L_false);
    }
  };

  define('eq', lz(function(a) {
    return function(b) {
      return booleanFor(rz(a) === rz(b));
    };
  }));

  define('==', lz(function(a) {
    return function(b) {
      return booleanFor(rz(a) === rz(b));
    };
  }));

  define('hasType', lz(function(data) {
    return function(func) {
      if (typeof rz(func) === 'string') {
        return booleanFor(getType(rz(data)) === rz(func));
      } else {
        return booleanFor(getType(rz(data)) === getDataType(rz(func)));
      }
    };
  }));

  define('getDataType', lz(function(func) {
    if (typeof rz(func) === 'string') {
      return rz(func);
    } else {
      return getDataType(rz(func));
    }
  }));

  define('assert', lz(function(bool) {
    return function(msg) {
      return function(expr) {
        return rz(bool)(expr)(function() {
          throw new Error(rz(msg));
        });
      };
    };
  }));

  define('assertLog', lz(function(bool) {
    return function(msg) {
      return function(expr) {
        return rz(bool)(expr)(function() {
          console.log(new Error(rz(msg)).stack);
          console.log("LOGGED ERROR -- RESUMING EXECUTION...");
          return rz(expr);
        });
      };
    };
  }));

  define('+', lz(function(x) {
    return function(y) {
      return rz(x) + rz(y);
    };
  }));

  define('-', lz(function(x) {
    return function(y) {
      return rz(x) - rz(y);
    };
  }));

  define('*', lz(function(x) {
    return function(y) {
      return rz(x) * rz(y);
    };
  }));

  define('/', lz(function(x) {
    return function(y) {
      return rz(x) / rz(y);
    };
  }));

  define('%', lz(function(x) {
    return function(y) {
      return rz(x) % rz(y);
    };
  }));

  define('<', lz(function(x) {
    return function(y) {
      return booleanFor(rz(x) < rz(y));
    };
  }));

  define('<=', lz(function(x) {
    return function(y) {
      return booleanFor(rz(x) <= rz(y));
    };
  }));

  define('>', lz(function(x) {
    return function(y) {
      return booleanFor(rz(x) > rz(y));
    };
  }));

  define('>=', lz(function(x) {
    return function(y) {
      return booleanFor(rz(x) >= rz(y));
    };
  }));

  define('floor', lz(function(x) {
    return Math.floor(rz(x));
  }));

  define('ceil', lz(function(x) {
    return Math.ceil(rz(x));
  }));

  define('min', lz(function(x) {
    return function(y) {
      return Math.min(rz(x), rz(y));
    };
  }));

  define('max', lz(function(x) {
    return function(y) {
      return Math.max(rz(x), rz(y));
    };
  }));

  define('round', lz(function(x) {
    return Math.round(rz(x));
  }));

  define('abs', lz(function(x) {
    return Math.abs(rz(x));
  }));

  define('sqrt', lz(function(x) {
    return Math.sqrt(rz(x));
  }));

  define('acos', lz(function(x) {
    return Math.acos(rz(x));
  }));

  define('asin', lz(function(x) {
    return Math.asin(rz(x));
  }));

  define('atan', lz(function(x) {
    return Math.atan(rz(x));
  }));

  define('atan2', lz(function(x) {
    return function(y) {
      return Math.atan2(rz(x), rz(y));
    };
  }));

  define('cos', lz(function(x) {
    return Math.cos(rz(x));
  }));

  define('log', lz(function(x) {
    return Math.log(rz(x));
  }));

  define('sin', lz(function(x) {
    return Math.sin(rz(x));
  }));

  define('tan', lz(function(x) {
    return Math.tan(rz(x));
  }));

  define('rand', function() {
    return makeSyncMonad(function(env, cont) {
      return cont(Math.random());
    });
  });

  define('randInt', lz(function(low) {
    return function(high) {
      return makeSyncMonad(function(env, cont) {
        return cont(Math.floor(rz(low) + Math.random() * rz(high)));
      });
    };
  }));

  define('^', lz(function(x) {
    return function(y) {
      return Math.pow(rz(x), rz(y));
    };
  }));

  define('_show', lz(function(data) {
    var _ref2;

    if ((_ref2 = typeof rz(data)) === 'string' || _ref2 === 'number' || _ref2 === 'boolean') {
      return JSON.stringify(rz(data));
    } else {
      return String(rz(data));
    }
  }));

  define('strString', lz(function(data) {
    return String(rz(data));
  }));

  define('_strAsc', lz(function(str) {
    return rz(str).charCodeAt(0);
  }));

  define('_strChr', lz(function(i) {
    return String.fromCharCode(rz(i));
  }));

  define('_strAt', lz(function(str) {
    return function(index) {
      return rz(str)[strCoord(rz(str), rz(index))];
    };
  }));

  define('_strStartsWith', lz(function(str) {
    return function(prefix) {
      return booleanFor(rz(str).substring(0, rz(prefix).length) === rz(prefix));
    };
  }));

  define('_strLen', lz(function(str) {
    return rz(str).length;
  }));

  define('_strToLowerCase', lz(function(str) {
    return rz(str).toLowerCase();
  }));

  define('_strToUpperCase', lz(function(str) {
    return rz(str).toUpperCase();
  }));

  define('_strReplace', lz(function(str) {
    return function(pat) {
      return function(repl) {
        return rz(str).replace(rz(pat), rz(repl));
      };
    };
  }));

  strCoord = function(str, coord) {
    if (coord < 0) {
      return str.length + coord;
    } else {
      return coord;
    }
  };

  define('_strSubstring', lz(function(str) {
    return function(start) {
      return function(end) {
        var a, b;

        a = strCoord(rz(str), rz(start));
        b = strCoord(rz(str), rz(end));
        if (b < a && rz(end) === 0) {
          b = rz(str).length;
        }
        return rz(str).substring(a, b);
      };
    };
  }));

  define('_strSplit', lz(function(str) {
    return function(pat) {
      return consFrom(rz(str).split(rz(pat) instanceof RegExp ? rz(pat) : new RegExp(rz(pat))));
    };
  }));

  define('_strCat', lz(function(list) {
    return _.map(rz(list).toArray(), function(el) {
      if (typeof el === 'string') {
        return el;
      } else {
        return rz(L_show)(lz(el));
      }
    }).join('');
  }));

  define('_strAdd', lz(function(s1) {
    return function(s2) {
      return rz(s1) + rz(s2);
    };
  }));

  define('_strMatch', lz(function(str) {
    return function(pat) {
      var groups, m, pos;

      m = rz(str).match((rz(pat) instanceof RegExp ? rz(pat) : new RegExp(rz(pat))));
      if (m) {
        groups = [];
        pos = 1;
        while (m[pos]) {
          groups.push(m[pos++]);
        }
        if (typeof m.index !== 'undefined') {
          return consFrom([m[0], consFrom(groups), m.index, m.input]);
        } else {
          return consFrom([m[0], consFrom(groups)]);
        }
      } else {
        return Nil;
      }
    };
  }));

  define('_strToList', lz(function(str) {
    return strToList(rz(str));
  }));

  strToList = function(str) {
    if (str === '') {
      return Nil;
    } else {
      return cons(str[0], strToList(str.substring(1)));
    }
  };

  define('_strFromList', lz(function(list) {
    return strFromList(rz(list));
  }));

  strFromList = function(list) {
    if (list instanceof Leisure_nil) {
      return '';
    } else {
      return head(list) + strFromList(tail(list));
    }
  };

  define('_regexp', lz(function(str) {
    return new RegExp(rz(str));
  }));

  define('_regexpFlags', lz(function(str) {
    return function(flags) {
      return new RegExp(rz(str), rz(flags));
    };
  }));

  define('_jsonParse', lz(function(str) {
    return function(failCont) {
      return function(successCont) {
        var err, p;

        try {
          p = JSON.parse(rz(str));
          return rz(successCont)(lz(p));
        } catch (_error) {
          err = _error;
          return rz(failCont)(lz(err));
        }
      };
    };
  }));

  define('jsonStringify', lz(function(obj) {
    return function(failCont) {
      return function(successCont) {
        var err, s;

        try {
          s = JSON.stringify(rz(obj));
          return rz(successCont)(lz(s));
        } catch (_error) {
          err = _error;
          return rz(failCont)(lz(err));
        }
      };
    };
  }));

  define('getProperties', lz(function(func) {
    var _ref2;

    if ((_ref2 = rz(func)) != null ? _ref2.properties : void 0) {
      return rz(L_some)(lz(rz(func).properties));
    } else {
      return rz(L_none);
    }
  }));

  define('log', lz(function(str) {
    return function(res) {
      console.log(String(rz(str)));
      return rz(res);
    };
  }));

  makeMonad = function(guts) {
    var m;

    m = function() {};
    m.__proto__ = Monad.prototype;
    m.cmd = guts;
    m.type = 'monad';
    return m;
  };

  makeSyncMonad = function(guts) {
    var m;

    m = makeMonad(guts);
    m.sync = true;
    return m;
  };

  nextMonad = function(cont) {
    return cont;
  };

  replaceErr = function(err, msg) {
    err.message = msg;
    return err;
  };

  defaultEnv.write = function(str) {
    return process.stdout.write(str);
  };

  defaultEnv.err = function(err) {
    var _ref2;

    return this.write("ENV Error: " + ((_ref2 = err.stack) != null ? _ref2 : err));
  };

  defaultEnv.prompt = function() {
    throw new Error("Environment does not support prompting!");
  };

  monadModeSync = false;

  getMonadSyncMode = function() {
    return monadModeSync;
  };

  withSyncModeDo = function(newMode, block) {
    var err, oldMode, _ref2;

    oldMode = monadModeSync;
    monadModeSync = newMode;
    try {
      return block();
    } catch (_error) {
      err = _error;
      return console.log("ERR: " + ((_ref2 = err.stack) != null ? _ref2 : err));
    } finally {

    }
  };

  runMonad = function(monad, env, cont) {
    env = env != null ? env : root.defaultEnv;
    return withSyncModeDo(true, function() {
      return newRunMonad(monad, env, cont, []);
    });
  };

  isMonad = function(m) {
    return typeof m === 'function' && (m.cmd != null);
  };

  continueMonads = function(contStack, env) {
    return function(result) {
      return withSyncModeDo(false, function() {
        return newRunMonad(result, env, null, contStack);
      });
    };
  };

  asyncMonad = {
    toString: function() {
      return "<asyncMonadResult>";
    }
  };

  warnAsync = false;

  setWarnAsync = function(state) {
    return warnAsync = state;
  };

  newRunMonad = function(monad, env, cont, contStack) {
    var err, result, _ref2;

    if (cont) {
      contStack.push(cont);
    }
    try {
      while (true) {
        if (isMonad(monad)) {
          if (monad.binding) {
            contStack.push((function(bnd) {
              return function(x) {
                return bnd(lz(x));
              };
            })(rz(monad.binding)));
            monad = rz(monad.monad);
            continue;
          } else if (!monad.sync) {
            monadModeSync = false;
            if (warnAsync) {
              console.log("async monad");
            }
            monad.cmd(env, continueMonads(contStack, env));
            return asyncMonad;
          }
          result = monad.cmd(env, identity);
        } else {
          monadModeSync = true;
          result = monad;
        }
        if (!contStack.length) {
          return result;
        }
        monad = contStack.pop()(result);
      }
    } catch (_error) {
      err = _error;
      err = replaceErr(err, "\nERROR RUNNING MONAD, MONAD: " + monad + ", ENV: " + env + "...\n" + err.message);
      console.log((_ref2 = err.stack) != null ? _ref2 : err);
      if (env.errorHandlers.length) {
        return env.errorHandlers.pop()(err);
      }
    }
  };

  Monad = (function() {
    function Monad() {}

    Monad.prototype.toString = function() {
      return "Monad: " + (this.cmd.toString());
    };

    return Monad;

  })();

  global.L_runMonads = function(monadArray) {
    monadArray.reverse();
    return newRunMonad(0, defaultEnv, null, monadArray);
  };

  define('define', lz(function(name) {
    return function(arity) {
      return function(src) {
        return function(def) {
          return makeSyncMonad(function(env, cont) {
            define(rz(name), def, rz(arity), rz(src));
            return cont((typeof L_true !== "undefined" && L_true !== null ? rz(L_true) : _true));
          });
        };
      };
    };
  }));

  define('bind', lz(function(m) {
    return function(binding) {
      var bindMonad;

      bindMonad = makeMonad(function(env, cont) {});
      bindMonad.monad = m;
      bindMonad.binding = binding;
      return bindMonad;
    };
  }));

  values = {};

  define('protect', lz(function(value) {
    return makeMonad(function(env, cont) {
      var hnd;

      hnd = function(err) {
        var _ref2, _ref3;

        console.log("PROTECTED ERROR: " + ((_ref2 = err.stack) != null ? _ref2 : err));
        return cont(left((_ref3 = err.stack) != null ? _ref3 : err));
      };
      env.errorHandlers.push(hnd);
      return runMonad(rz(value), env, (function(result) {
        if (env.errorHandlers.length) {
          if (env.errorHandlers[env.errorHandlers.length - 1] === hnd) {
            env.errorHandlers.pop();
          } else if (_.contains(env.errorHandlers, hnd)) {
            while (env.errorHandlers[env.errorHandlers.length - 1] !== hnd) {
              env.errorHandlers.pop();
            }
          }
        }
        return cont(right(result));
      }), []);
    });
  }));

  actors = {};

  define('actor', lz(function(name) {
    return function(func) {
      actors[name] = func;
      func.env = {
        values: {}
      };
      return func.env.__proto__ = defaultEnv;
    };
  }));

  define('send', lz(function(name) {
    return function(msg) {
      return setTimeout((function() {
        return runMonad(rz(actors[name])(msg), rz(actors[name]).env);
      }), 1);
    };
  }));

  define('hasValue', lz(function(name) {
    return makeSyncMonad(function(env, cont) {
      return cont(booleanFor(values[rz(name)] != null));
    });
  }));

  define('getValueOr', lz(function(name) {
    return function(defaultValue) {
      return makeSyncMonad(function(env, cont) {
        var _ref2;

        return cont((_ref2 = values[rz(name)]) != null ? _ref2 : rz(defaultValue));
      });
    };
  }));

  define('getValue', lz(function(name) {
    return makeSyncMonad(function(env, cont) {
      if (!(rz(name) in values)) {
        throw new Error("No value named '" + (rz(name)) + "'");
      }
      return cont(values[rz(name)]);
    });
  }));

  define('setValue', lz(function(name) {
    return function(value) {
      return makeSyncMonad(function(env, cont) {
        values[rz(name)] = rz(value);
        return cont(_true);
      });
    };
  }));

  define('deleteValue', lz(function(name) {
    return makeSyncMonad(function(env, cont) {
      delete values[rz(name)];
      return cont(_true);
    });
  }));

  setValue = function(key, value) {
    return values[key] = value;
  };

  getValue = function(key) {
    return values[key];
  };

  define('envHas', lz(function(name) {
    return makeSyncMonad(function(env, cont) {
      return cont(booleanFor(env.values[rz(name)] != null));
    });
  }));

  define('envGetOr', lz(function(name) {
    return function(defaultValue) {
      return makeSyncMonad(function(env, cont) {
        var _ref2;

        return cont((_ref2 = env.values[rz(name)]) != null ? _ref2 : rz(defaultValue));
      });
    };
  }));

  define('envGet', lz(function(name) {
    return makeSyncMonad(function(env, cont) {
      if (!(rz(name) in env.values)) {
        throw new Error("No value named '" + (rz(name)) + "'");
      }
      return cont(env.values[rz(name)]);
    });
  }));

  define('envSet', lz(function(name) {
    return function(value) {
      return makeSyncMonad(function(env, cont) {
        env.values[rz(name)] = rz(value);
        return cont(_true);
      });
    };
  }));

  define('envDelete', lz(function(name) {
    return makeSyncMonad(function(env, cont) {
      delete env.values[rz(name)];
      return cont(_true);
    });
  }));

  setValue('macros', Nil);

  define('defMacro', lz(function(name) {
    return function(def) {
      return makeSyncMonad(function(env, cont) {
        values.macros = cons(cons(rz(name), rz(def)), values.macros);
        return cont(_true);
      });
    };
  }));

  define('funcs', lz(makeSyncMonad(function(env, cont) {
    console.log("Leisure functions:\n" + (_(global.leisureFuncNames.toArray()).sort().join('\n')));
    return cont(_true);
  })));

  define('funcSrc', lz(function(func) {
    if (typeof rz(func) === 'function' && rz(func).src) {
      return some(rz(func).src);
    } else {
      return none;
    }
  }));

  define('ast2Json', lz(function(ast) {
    return JSON.stringify(ast2Json(rz(ast)));
  }));

  define('override', lz(function(name) {
    return function(newFunc) {
      return makeSyncMonad(function(env, cont) {
        var n, oldDef;

        n = "L_" + (nameSub(rz(name)));
        oldDef = global[n];
        if (!oldDef) {
          throw new Error("No definition for " + (rz(name)));
        }
        global[n] = function() {
          return rz(newFunc)(oldDef);
        };
        return cont(_true);
      });
    };
  }));

  define('print', lz(function(msg) {
    return makeSyncMonad(function(env, cont) {
      var m;

      m = rz(msg);
      env.write("" + (env.presentValue(m)) + "\n");
      return cont(_true);
    });
  }));

  define('write', lz(function(msg) {
    return makeSyncMonad(function(env, cont) {
      env.write(env.presentValue(rz(msg)));
      return cont(_true);
    });
  }));

  define('readFile', lz(function(name) {
    return makeMonad(function(env, cont) {
      return readFile(rz(name), function(err, contents) {
        var _ref2;

        return cont((err ? left((_ref2 = err.stack) != null ? _ref2 : err) : right(contents)));
      });
    });
  }));

  define('readDir', lz(function(dir) {
    return makeMonad(function(env, cont) {
      return readDir(rz(dir), function(err, files) {
        var _ref2;

        return cont((err ? left((_ref2 = err.stack) != null ? _ref2 : err) : right(files)));
      });
    });
  }));

  define('writeFile', lz(function(name) {
    return function(data) {
      return makeMonad(function(env, cont) {
        return writeFile(rz(name), rz(data), function(err, contents) {
          var _ref2;

          return cont((err ? left((_ref2 = err.stack) != null ? _ref2 : err) : right(contents)));
        });
      });
    };
  }));

  define('statFile', lz(function(file) {
    return makeMonad(function(env, cont) {
      return statFile(rz(file), function(err, stats) {
        var _ref2;

        return cont((err ? left((_ref2 = err.stack) != null ? _ref2 : err) : right(stats)));
      });
    });
  }));

  define('prompt', lz(function(msg) {
    return makeMonad(function(env, cont) {
      return env.prompt(String(rz(msg)), function(input) {
        return cont(input);
      });
    });
  }));

  define('rand', lz(makeSyncMonad(function(env, cont) {
    return cont(Math.random());
  })));

  define('js', lz(function(str) {
    return makeSyncMonad(function(env, cont) {
      var err, result;

      try {
        result = eval(rz(str));
        return cont(right(result));
      } catch (_error) {
        err = _error;
        return cont(left(err));
      }
    });
  }));

  define('delay', lz(function(timeout) {
    return makeMonad(function(env, cont) {
      return setTimeout((function() {
        return cont(_true);
      }), rz(timeout));
    });
  }));

  define('altDef', lz(function(name) {
    return function(alt) {
      return function(arity) {
        return function(def) {
          return makeMonad(function(env, cont) {
            var alts, i, info, newDef, nm;

            info = functionInfo[rz(name)];
            if (!info) {
              info = functionInfo[rz(name)] = {
                src: '',
                arity: -1,
                alts: {},
                altList: []
              };
            }
            if (!info.alts[rz(alt)]) {
              info.altList.push(rz(alt));
            }
            info.alts[rz(alt)] = rz(def);
            alts = (function() {
              var _i, _len, _ref2, _results;

              _ref2 = info.altList;
              _results = [];
              for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                i = _ref2[_i];
                _results.push(info.alts[i]);
              }
              return _results;
            })();
            newDef = curry(rz(arity), function(args) {
              var arg, opt, res, _i, _j, _k, _len, _len1, _len2;

              for (_i = 0, _len = alts.length; _i < _len; _i++) {
                alt = alts[_i];
                opt = alt;
                for (_j = 0, _len1 = args.length; _j < _len1; _j++) {
                  arg = args[_j];
                  opt = opt(arg);
                }
                if (getType(opt) === 'some') {
                  return opt(lz(function(x) {
                    return rz(x);
                  }))(lz(_false));
                }
              }
              if (info.mainDef) {
                res = rz(info.mainDef);
                for (_k = 0, _len2 = args.length; _k < _len2; _k++) {
                  arg = args[_k];
                  res = res(arg);
                }
                return res;
              }
              throw new Error("No default definition for " + (rz(name)));
            });
            nm = "L_" + (nameSub(rz(name)));
            global[nm] = global.leisureFuncNames[nm] = newDef;
            return cont(def);
          });
        };
      };
    };
  }));

  curry = function(arity, func) {
    return function() {
      return function(arg) {
        return (subcurry(arity, func, []))(arg);
      };
    };
  };

  subcurry = function(arity, func, args) {
    return function(arg) {
      args = args != null ? args : [];
      args.push(arg);
      if (arity === 1) {
        return func(args);
      } else {
        return subcurry(arity - 1, func, args);
      }
    };
  };

  makeHamt = function(hamt) {
    var t;

    t = setDataType((function() {}), 'hamt');
    t.hamt = hamt;
    t.type = 'hamt';
    return t;
  };

  hamt = makeHamt(amt.Trie());

  define('hamt', lz(hamt));

  define('hamtWith', lz(function(key) {
    return function(value) {
      return function(hamt) {
        return makeHamt(amt.assoc(rz(hamt).hamt, rz(key), rz(value)));
      };
    };
  }));

  define('hamtFetch', lz(function(key) {
    return function(hamt) {
      return amt.get(rz(hamt).hamt, rz(key));
    };
  }));

  define('hamtGet', lz(function(key) {
    return function(hamt) {
      var v;

      v = amt.get(rz(hamt).hamt, rz(key));
      if (v !== void 0) {
        return some(v);
      } else {
        return none;
      }
    };
  }));

  define('hamtWithout', lz(function(key) {
    return function(hamt) {
      return makeHamt(amt.dissoc(rz(hamt).hamt, rz(key)));
    };
  }));

  memo = function(func) {
    return function() {
      return func.memo || (func.memo = func());
    };
  };

  define('hamtPairs', lz(function(hamt) {
    return nextNode(simpyCons(rz(hamt).hamt, null));
  }));

  nextNode = function(stack) {
    var child, k, key, node, value, _ref2, _ref3;

    if (stack === null) {
      return rz(L_nil);
    }
    node = stack.head;
    stack = stack.tail;
    switch (node.type) {
      case 'trie':
        _ref2 = node.children;
        for (k in _ref2) {
          child = _ref2[k];
          stack = simpyCons(child, stack);
        }
        return nextNode(stack);
      case 'value':
        return rz(L_acons)(lz(node.key))(lz(node.value))(memo(function() {
          return nextNode(stack);
        }));
      case 'hashmap':
        _ref3 = node.values;
        for (key in _ref3) {
          value = _ref3[key];
          stack = simpyCons(value, stack);
        }
        return nextNode(stack);
      default:
        return console.log("UNKNOWN HAMT NODE TYPE: " + node.type);
    }
  };

  define('trampolineCall', lz(function(func) {
    var ret;

    ret = rz(func);
    while (true) {
      if (typeof ret === 'function' && ret.trampoline) {
        ret = ret();
      } else {
        return ret;
      }
    }
  }));

  define('trampoline', lz(function(func) {
    var arity, f;

    f = rz(func);
    arity = functionInfo[f.leisureName].arity;
    return trampCurry(f, arity);
  }));

  trampCurry = function(func, arity) {
    return function(arg) {
      var a, result;

      a = rz(arg);
      if (arity > 1) {
        return trampCurry(func(function() {
          return a;
        }), arity - 1);
      } else {
        result = function() {
          return func(function() {
            return a;
          });
        };
        result.trampoline = true;
        return result;
      }
    };
  };

  ensureLeisureClass('token');

  Leisure_token.prototype.toString = function() {
    return "Token(" + (JSON.stringify(tokenString(this))) + ", " + (tokenPos(this)) + ")";
  };

  tokenString = function(t) {
    return t(lz(function(txt) {
      return function(pos) {
        return rz(txt);
      };
    }));
  };

  tokenPos = function(t) {
    return t(lz(function(txt) {
      return function(pos) {
        return rz(pos);
      };
    }));
  };

  ensureLeisureClass('parens');

  Leisure_parens.prototype.toString = function() {
    return "Parens(" + (parensStart(this)) + ", " + (parensEnd(this)) + ", " + (parensContent(this)) + ")";
  };

  parensStart = function(p) {
    return p(lz(function(s) {
      return function(e) {
        return function(l) {
          return rz(s);
        };
      };
    }));
  };

  parensEnd = function(p) {
    return p(lz(function(s) {
      return function(e) {
        return function(l) {
          return rz(e);
        };
      };
    }));
  };

  parensContent = function(p) {
    return p(lz(function(s) {
      return function(e) {
        return function(l) {
          return rz(l);
        };
      };
    }));
  };

  ensureLeisureClass('true');

  Leisure_true.prototype.toString = function() {
    return "true";
  };

  ensureLeisureClass('false');

  Leisure_false.prototype.toString = function() {
    return "false";
  };

  ensureLeisureClass('left');

  Leisure_left.prototype.toString = function() {
    return "Left(" + (this(lz(_identity))(lz(_identity))) + ")";
  };

  ensureLeisureClass('right');

  Leisure_right.prototype.toString = function() {
    return "Right(" + (this(lz(_identity))(lz(_identity))) + ")";
  };

  root._true = _true;

  root._false = _false;

  root.stateValues = values;

  root.runMonad = runMonad;

  root.newRunMonad = newRunMonad;

  root.isMonad = isMonad;

  root.identity = identity;

  root.setValue = setValue;

  root.getValue = getValue;

  root.makeMonad = makeMonad;

  root.makeSyncMonad = makeSyncMonad;

  root.replaceErr = replaceErr;

  root.left = left;

  root.right = right;

  root.getMonadSyncMode = getMonadSyncMode;

  root.asyncMonad = asyncMonad;

  root.setWarnAsync = setWarnAsync;

  root.call = call;

  root.callMonad = callMonad;

  root.basicCall = basicCall;

  root.booleanFor = booleanFor;

  root.newConsFrom = consFrom;

  if (typeof window !== "undefined" && window !== null) {
    window.runMonad = runMonad;
    window.setType = setType;
    window.setDataType = setDataType;
    window.defaultEnv = defaultEnv;
    window.identity = identity;
  }

}).call(this);

/*
*/

})(require("__browserify_process"),self)
},{"./ast":1,"./base":2,"./lodash.min":6,"__browserify_process":12,"persistent-hash-trie":15}],11:[function(require,module,exports){
L_runMonads([
  function(){return resolve(L_define)(lazy("if"))(lazy(0))(lazy("if = id"))(L_id)},
  function(){return resolve(L_define)(lazy("afetch"))(lazy(2))(lazy("afetch k alist  = alist (\\h t D . h \\key value . eq key k value (afetch k t)) nil"))(lazy(function(L_k){return function(L_alist){return resolve(L_alist)(lazy(function(L_h){return function(L_t){return function(L_D){return resolve(L_h)(lazy(function(L_key){return function(L_value){return resolve(L_eq)(L_key)(L_k)(L_value)(function(){return resolve(L_afetch)(L_k)(L_t)})}}))}}}))(L_nil)}}))},
  function(){return resolve(L_define)(lazy("aconsf"))(lazy(3))(lazy("aconsf key value list = acons key value (aremove key list)"))(lazy(function(L_key){return function(L_value){return function(L_list){return resolve(L_acons)(L_key)(L_value)(function(){return resolve(L_aremove)(L_key)(L_list)})}}}))},
  function(){return resolve(L_define)(lazy("aremove"))(lazy(2))(lazy("aremove key list = isNil list\n  nil\n  eq (head (head list)) key\n    aremove key (tail list)\n    aconsPair (head list) (aremove key (tail list))"))(lazy(function(L_key){return function(L_list){return resolve(L_isNil)(L_list)(L_nil)(function(){return resolve(L_eq)(function(){return resolve(L_head)(function(){return resolve(L_head)(L_list)})})(L_key)(function(){return resolve(L_aremove)(L_key)(function(){return resolve(L_tail)(L_list)})})(function(){return resolve(L_aconsPair)(function(){return resolve(L_head)(L_list)})(function(){return resolve(L_aremove)(L_key)(function(){return resolve(L_tail)(L_list)})})})})}}))},
  function(){return resolve(L_defMacro)(lazy("when"))(lazy(function(L_line){return resolve(L_line)(lazy(function(L_cond){return function(L_rest){return resolve(L_cons)(L_cond)(function(){return resolve(L_cons)(function(){return resolve(L_cons)(lazy("do"))(L_rest)})(function(){return resolve(L_cons)(lazy("nil"))(L_nil)})})}}))}))},
  function(){return resolve(L_addTokenGroup)(lazy("js["))(lazy("]"))},
  function(){return resolve(L_defMacro)(lazy("js["))(lazy(function(L_list){return resolve(L_cons)(lazy("js"))(function(){return resolve(L_cons)(function(){return resolve(L_cons)(lazy("strCat"))(function(){return resolve(L_cons)(function(){return resolve(L_cons)(lazy("flatten"))(function(){return resolve(L_cons)(function(){return resolve(L_cons)(function(){return resolve(L_listify)(function(){return resolve(L_head)(L_list)})})(L_nil)})(L_nil)})})(L_nil)})})(L_nil)})}))},
  function(){return resolve(L_define)(lazy("html"))(lazy(1))(lazy("html x = \\f . f x"))(lazy(setDataType(function(L_x){return setType(function(L_f){return resolve(L_f)(L_x)}, 'html')}, 'html')))},
  function(){return resolve(L_define)(lazy("iszero"))(lazy(0))(lazy("iszero = eq 0"))(function(){return resolve(L_eq)(lazy(0))})},
  function(){return resolve(L_define)(lazy("positive"))(lazy(0))(lazy("positive = 0 <"))(function(){return resolve(L_$y)(lazy(0))})},
  function(){return resolve(L_addToken)(lazy("--"))},
  function(){return resolve(L_addToken)(lazy("++"))},
  function(){return resolve(L_define)(lazy("--"))(lazy(0))(lazy("-- = (flip (-)) 1"))(function(){return resolve(L_flip)(L_$_)(lazy(1))})},
  function(){return resolve(L_define)(lazy("++"))(lazy(0))(lazy("++ = (1 +)"))(function(){return resolve(L_$o)(lazy(1))})},
  function(){return resolve(L_define)(lazy("intercalate"))(lazy(2))(lazy("intercalate x l = concat (intersperse x l)"))(lazy(function(L_x){return function(L_l){return resolve(L_concat)(function(){return resolve(L_intersperse)(L_x)(L_l)})}}))},
  function(){return resolve(L_define)(lazy("visit"))(lazy(2))(lazy("visit func l = \\\\\n  result = func func l\n  .\n  isCons result\n    result \\h t . cons (visit func h) (visit func t)\n    result"))(lazy(function(L_func){return function(L_l){return (function(){

var L_result;

L_result = function(){return resolve(L_func)(L_func)(L_l)};
return resolve(L_isCons)(L_result)(function(){return resolve(L_result)(lazy(function(L_h){return function(L_t){return resolve(L_cons)(function(){return resolve(L_visit)(L_func)(L_h)})(function(){return resolve(L_visit)(L_func)(L_t)})}}))})(L_result)})()}}))},
  function(){return resolve(L_define)(lazy("simplify"))(lazy(1))(lazy("simplify exprString = do\n  list <- scanLineM exprString\n  visit (\\func x . isToken x (tokenString x) ((isParens x) (visit func (parensContent x)) x)) list"))(lazy(function(L_exprString){return resolve(L_bind)(function(){return resolve(L_scanLineM)(L_exprString)})(lazy(function(L_list){return resolve(L_visit)(lazy(function(L_func){return function(L_x){return resolve(L_isToken)(L_x)(function(){return resolve(L_tokenString)(L_x)})(function(){return resolve(L_isParens)(L_x)(function(){return resolve(L_visit)(L_func)(function(){return resolve(L_parensContent)(L_x)})})(L_x)})}}))(L_list)}))}))},
  function(){return resolve(L_define)(lazy("doall"))(lazy(0))(lazy("doall = foldr1 (\\el res . bind el \\_ . res)"))(function(){return resolve(L_foldr1)(lazy(function(L_el){return function(L_res){return resolve(L_bind)(L_el)(lazy(function(L__){return resolve(L_res)}))}}))})},
  function(){return resolve(L_define)(lazy("requireJS"))(lazy(1))(lazy("requireJS file = bind (getValue 'requiredFiles')\n  \\files . contains files file\n    false\n    bind (loadJS file)\n      \\result . result\n        \\x . left x\n        \\_ . bind (setValue 'requiredFiles' (cons file files))\n          \\_ . right true"))(lazy(function(L_file){return resolve(L_bind)(function(){return resolve(L_getValue)(lazy("requiredFiles"))})(lazy(function(L_files){return resolve(L_contains)(L_files)(L_file)(L_false)(function(){return resolve(L_bind)(function(){return resolve(L_loadJS)(L_file)})(lazy(function(L_result){return resolve(L_result)(lazy(function(L_x){return resolve(L_left)(L_x)}))(lazy(function(L__){return resolve(L_bind)(function(){return resolve(L_setValue)(lazy("requiredFiles"))(function(){return resolve(L_cons)(L_file)(L_files)})})(lazy(function(L___0){return resolve(L_right)(L_true)}))}))}))})}))}))},
  function(){return resolve(L_define)(lazy("loadJS"))(lazy(1))(lazy("loadJS file = bind (readFile file)\n  \\result . result\n    \\err . err\n    \\contents . js contents"))(lazy(function(L_file){return resolve(L_bind)(function(){return resolve(L_readFile)(L_file)})(lazy(function(L_result){return resolve(L_result)(lazy(function(L_err){return resolve(L_err)}))(lazy(function(L_contents){return resolve(L_js)(L_contents)}))}))}))},
  function(){return resolve(L_define)(lazy("findOption"))(lazy(2))(lazy("findOption func list = do\n  result = func (head list)\n  isNil list\n    none\n    isNone result\n      findOption func (tail list)\n      result"))(lazy(function(L_func){return function(L_list){return (function(){

var L_result;

L_result = function(){return resolve(L_func)(function(){return resolve(L_head)(L_list)})};
return resolve(L_isNil)(L_list)(L_none)(function(){return resolve(L_isNone)(L_result)(function(){return resolve(L_findOption)(L_func)(function(){return resolve(L_tail)(L_list)})})(L_result)})})()}}))},
  function(){return resolve(L_define)(lazy("dlempty"))(lazy(0))(lazy("dlempty = id"))(L_id)},
  function(){return resolve(L_define)(lazy("dl"))(lazy(1))(lazy("dl item = \\rest . item:rest"))(lazy(setDataType(function(L_item){return setType(function(L_rest){return resolve(L_cons)(L_item)(L_rest)}, 'dl')}, 'dl')))},
  function(){return resolve(L_define)(lazy("dlPush"))(lazy(2))(lazy("dlPush list item = dlAppend list (dl item)"))(lazy(function(L_list){return function(L_item){return resolve(L_dlAppend)(L_list)(function(){return resolve(L_dl)(L_item)})}}))},
  function(){return resolve(L_define)(lazy("dlAppend"))(lazy(2))(lazy("dlAppend a b = \\rest . a (b rest)"))(lazy(setDataType(function(L_a){return function(L_b){return setType(function(L_rest){return resolve(L_a)(function(){return resolve(L_b)(L_rest)})}, 'dlAppend')}}, 'dlAppend')))},
  function(){return resolve(L_define)(lazy("remove"))(lazy(2))(lazy("remove x l = removeIf (eq x) l"))(lazy(function(L_x){return function(L_l){return resolve(L_removeIf)(function(){return resolve(L_eq)(L_x)})(L_l)}}))},
  function(){return resolve(L_define)(lazy("removeIf"))(lazy(2))(lazy("removeIf f l = filter (compose not f) l"))(lazy(function(L_f){return function(L_l){return resolve(L_filter)(function(){return resolve(L_compose)(L_not)(L_f)})(L_l)}}))},
  function(){return resolve(L_define)(lazy("any"))(lazy(2))(lazy("any f l = find f l (\\el . true) false"))(lazy(function(L_f){return function(L_l){return resolve(L_find)(L_f)(L_l)(lazy(function(L_el){return resolve(L_true)}))(L_false)}}))},
  function(){return resolve(L_define)(lazy("all"))(lazy(2))(lazy("all f l = not any (compose not f) l"))(lazy(function(L_f){return function(L_l){return resolve(L_not)(L_any)(function(){return resolve(L_compose)(L_not)(L_f)})(L_l)}}))},
  function(){return resolve(L_define)(lazy("take"))(lazy(2))(lazy("take n list = positive n\n  list\n    \\h t D . cons h (take (-- n) t)\n    nil\n  nil"))(lazy(function(L_n){return function(L_list){return resolve(L_positive)(L_n)(function(){return resolve(L_list)(lazy(function(L_h){return function(L_t){return function(L_D){return resolve(L_cons)(L_h)(function(){return resolve(L_take)(function(){return resolve(L_$_$_)(L_n)})(L_t)})}}}))(L_nil)})(L_nil)}}))},
  function(){return resolve(L_define)(lazy("takeWhile"))(lazy(2))(lazy("takeWhile predicate list = list\n  \\h t D . predicate (head list)\n    cons h (takeWhile predicate t)\n    nil\n  nil"))(lazy(function(L_predicate){return function(L_list){return resolve(L_list)(lazy(function(L_h){return function(L_t){return function(L_D){return resolve(L_predicate)(function(){return resolve(L_head)(L_list)})(function(){return resolve(L_cons)(L_h)(function(){return resolve(L_takeWhile)(L_predicate)(L_t)})})(L_nil)}}}))(L_nil)}}))},
  function(){return resolve(L_define)(lazy("drop"))(lazy(2))(lazy("drop x list = positive x\n  list\n    \\h t D . drop (-- x) t\n    nil\n  list"))(lazy(function(L_x){return function(L_list){return resolve(L_positive)(L_x)(function(){return resolve(L_list)(lazy(function(L_h){return function(L_t){return function(L_D){return resolve(L_drop)(function(){return resolve(L_$_$_)(L_x)})(L_t)}}}))(L_nil)})(L_list)}}))},
  function(){return resolve(L_define)(lazy("dropWhile"))(lazy(2))(lazy("dropWhile predicate list = list\n  \\h t D . predicate h\n    dropWhile predicate t\n    list\n  nil"))(lazy(function(L_predicate){return function(L_list){return resolve(L_list)(lazy(function(L_h){return function(L_t){return function(L_D){return resolve(L_predicate)(L_h)(function(){return resolve(L_dropWhile)(L_predicate)(L_t)})(L_list)}}}))(L_nil)}}))},
  function(){return resolve(L_define)(lazy("dropLast"))(lazy(2))(lazy("dropLast n list = reverse (drop n (reverse list))"))(lazy(function(L_n){return function(L_list){return resolve(L_reverse)(function(){return resolve(L_drop)(L_n)(function(){return resolve(L_reverse)(L_list)})})}}))},
  function(){return resolve(L_define)(lazy("box"))(lazy(2))(lazy("box n list = list == nil\n  nil\n  [(take n list) | box n (drop n list)]"))(lazy(function(L_n){return function(L_list){return resolve(L_$p$p)(L_list)(L_nil)(L_nil)(function(){return resolve(L_cons)(function(){return resolve(L_take)(L_n)(L_list)})(function(){return resolve(L_box)(L_n)(function(){return resolve(L_drop)(L_n)(L_list)})})})}}))},
  function(){return resolve(L_define)(lazy("at"))(lazy(2))(lazy("at l x = (x == 0) (head l) (at (tail l) (-- (x) ) )"))(lazy(function(L_l){return function(L_x){return resolve(L_$p$p)(L_x)(lazy(0))(function(){return resolve(L_head)(L_l)})(function(){return resolve(L_at)(function(){return resolve(L_tail)(L_l)})(function(){return resolve(L_$_$_)(L_x)})})}}))},
  function(){return resolve(L_define)(lazy("series"))(lazy(2))(lazy("series func n = n:(series func (func n))"))(lazy(function(L_func){return function(L_n){return resolve(L_cons)(L_n)(function(){return resolve(L_series)(L_func)(function(){return resolve(L_func)(L_n)})})}}))},
  function(){return resolve(L_define)(lazy("from"))(lazy(1))(lazy("from n = series ++ n"))(lazy(function(L_n){return resolve(L_series)(L_$o$o)(L_n)}))},
  function(){return resolve(L_define)(lazy("fromBy"))(lazy(2))(lazy("fromBy n inc = series ((+) inc) n"))(lazy(function(L_n){return function(L_inc){return resolve(L_series)(function(){return resolve(L_$o)(L_inc)})(L_n)}}))},
  function(){return resolve(L_define)(lazy("fromTo"))(lazy(2))(lazy("fromTo n m = takeWhile ((>) m) (from n)"))(lazy(function(L_n){return function(L_m){return resolve(L_takeWhile)(function(){return resolve(L_$z)(L_m)})(function(){return resolve(L_from)(L_n)})}}))},
  function(){return resolve(L_define)(lazy("fromToBy"))(lazy(3))(lazy("fromToBy n m inc = takeWhile ((>) m) (fromBy n inc)"))(lazy(function(L_n){return function(L_m){return function(L_inc){return resolve(L_takeWhile)(function(){return resolve(L_$z)(L_m)})(function(){return resolve(L_fromBy)(L_n)(L_inc)})}}}))},
  function(){return resolve(L_define)(lazy("count"))(lazy(2))(lazy("count x l = countIf (eq x) l"))(lazy(function(L_x){return function(L_l){return resolve(L_countIf)(function(){return resolve(L_eq)(L_x)})(L_l)}}))},
  function(){return resolve(L_define)(lazy("countIf"))(lazy(2))(lazy("countIf f l = (eq l nil) 0\n  + (f (head l) 1 0) (countIf f (tail l))"))(lazy(function(L_f){return function(L_l){return resolve(L_eq)(L_l)(L_nil)(lazy(0))(function(){return resolve(L_$o)(function(){return resolve(L_f)(function(){return resolve(L_head)(L_l)})(lazy(1))(lazy(0))})(function(){return resolve(L_countIf)(L_f)(function(){return resolve(L_tail)(L_l)})})})}}))},
  function(){return resolve(L_define)(lazy("countIfNot"))(lazy(2))(lazy("countIfNot f l = countIf (\\x. not (f x)) l"))(lazy(function(L_f){return function(L_l){return resolve(L_countIf)(lazy(function(L_x){return resolve(L_not)(function(){return resolve(L_f)(L_x)})}))(L_l)}}))},
  function(){return resolve(L_define)(lazy("odds"))(lazy(1))(lazy("odds l = l\n  \\h t D . [h | evens t]\n  nil"))(lazy(function(L_l){return resolve(L_l)(lazy(function(L_h){return function(L_t){return function(L_D){return resolve(L_cons)(L_h)(function(){return resolve(L_evens)(L_t)})}}}))(L_nil)}))},
  function(){return resolve(L_define)(lazy("evens"))(lazy(1))(lazy("evens l = l\n  \\h t D . odds t\n  nil"))(lazy(function(L_l){return resolve(L_l)(lazy(function(L_h){return function(L_t){return function(L_D){return resolve(L_odds)(L_t)}}}))(L_nil)}))},
  function(){return resolve(L_define)(lazy("cleave"))(lazy(1))(lazy("cleave l = [(evens l) | (odds l)]"))(lazy(function(L_l){return resolve(L_cons)(function(){return resolve(L_evens)(L_l)})(function(){return resolve(L_odds)(L_l)})}))},
  function(){return resolve(L_define)(lazy("merge"))(lazy(3))(lazy("merge cmp a b = a\n  \\ah at D . b\n    \\bh bt D . cmp ah bh\n      [ah | (merge cmp at b)]\n      [bh | (merge cmp a bt)]\n    a\n  b"))(lazy(function(L_cmp){return function(L_a){return function(L_b){return resolve(L_a)(lazy(function(L_ah){return function(L_at){return function(L_D){return resolve(L_b)(lazy(function(L_bh){return function(L_bt){return function(L_D_0){return resolve(L_cmp)(L_ah)(L_bh)(function(){return resolve(L_cons)(L_ah)(function(){return resolve(L_merge)(L_cmp)(L_at)(L_b)})})(function(){return resolve(L_cons)(L_bh)(function(){return resolve(L_merge)(L_cmp)(L_a)(L_bt)})})}}}))(L_a)}}}))(L_b)}}}))},
  function(){return resolve(L_define)(lazy("mergeSort"))(lazy(2))(lazy("mergeSort cmp l = l\n  \\h t D . eq (tail l) nil\n    l\n    do\n      cl = cleave l\n      e = head cl\n      o = tail cl\n      merge cmp (mergeSort cmp e) (mergeSort cmp o)\n  nil"))(lazy(function(L_cmp){return function(L_l){return resolve(L_l)(lazy(function(L_h){return function(L_t){return function(L_D){return resolve(L_eq)(function(){return resolve(L_tail)(L_l)})(L_nil)(L_l)(function(){
var L_o, L_e, L_cl;

L_o = function(){return resolve(L_tail)(L_cl)};

L_e = function(){return resolve(L_head)(L_cl)};

L_cl = function(){return resolve(L_cleave)(L_l)};
return resolve(L_merge)(L_cmp)(function(){return resolve(L_mergeSort)(L_cmp)(L_e)})(function(){return resolve(L_mergeSort)(L_cmp)(L_o)})})}}}))(L_nil)}}))},
  function(){return resolve(L_define)(lazy("sort"))(lazy(1))(lazy("sort l = sortBy (<=) l"))(lazy(function(L_l){return resolve(L_sortBy)(L_$y$p)(L_l)}))},
  function(){return resolve(L_define)(lazy("sortBy"))(lazy(2))(lazy("sortBy cmp l = mergeSort cmp l"))(lazy(function(L_cmp){return function(L_l){return resolve(L_mergeSort)(L_cmp)(L_l)}}))},
  function(){return resolve(L_addToken)(lazy("->"))},
  function(){return resolve(L_define)(lazy("mkStr"))(lazy(1))(lazy("mkStr tok = concat['\"' (tokenString tok) '\"']"))(lazy(function(L_tok){return resolve(L_strCat)(function(){return resolve(L_cons)(lazy("\""))(function(){return resolve(L_cons)(function(){return resolve(L_tokenString)(L_tok)})(function(){return resolve(L_cons)(lazy("\""))(L_nil)})})})}))},
  function(){return resolve(L_defMacro)(lazy("defCase"))(lazy(function(L_list){return (function(){

var L_t3, L_h3, L_t2, L_h2, L_t1, L_h1;

L_t3 = function(){return resolve(L_tail)(L_t2)};

L_h3 = function(){return resolve(L_head)(L_t2)};

L_t2 = function(){return resolve(L_tail)(L_t1)};

L_h2 = function(){return resolve(L_head)(L_t1)};

L_t1 = function(){return resolve(L_tail)(L_list)};

L_h1 = function(){return resolve(L_head)(L_list)};
return resolve(L_and)(function(){return resolve(L_isCons)(L_list)})(function(){return resolve(L_and)(function(){return resolve(L_isCons)(L_t1)})(function(){return resolve(L_and)(function(){return resolve(L_isCons)(L_t2)})(function(){return resolve(L_and)(function(){return resolve(L_isTokenString)(L_h2)(lazy("."))})(L_true)})})})(function(){return resolve(L_makeCaseArgs)(L_list)(function(){return resolve(L_mkStr)(L_h1)})(function(){return resolve(L_mkStr)(L_h3)})(L_t3)(L_id)})(function(){return resolve(L_parseErr)(lazy("Error in case definition -- expected func.name args | condition -> action, but got "))(L_list)})})()}))},
  function(){return resolve(L_define)(lazy("makeCaseArgs"))(lazy(5))(lazy("makeCaseArgs orig funcName altName rest args = rest\n  \\h t D . isTokenString h '|'\n    makeCaseCondition orig funcName altName (args nil) t id\n    makeCaseArgs orig funcName altName t (dlPush args h)\n  parseErr \"Error in case definition -- expected func.name args | condition -> action, but got \" orig"))(lazy(function(L_orig){return function(L_funcName){return function(L_altName){return function(L_rest){return function(L_args){return resolve(L_rest)(lazy(function(L_h){return function(L_t){return function(L_D){return resolve(L_isTokenString)(L_h)(lazy("|"))(function(){return resolve(L_makeCaseCondition)(L_orig)(L_funcName)(L_altName)(function(){return resolve(L_args)(L_nil)})(L_t)(L_id)})(function(){return resolve(L_makeCaseArgs)(L_orig)(L_funcName)(L_altName)(L_t)(function(){return resolve(L_dlPush)(L_args)(L_h)})})}}}))(function(){return resolve(L_parseErr)(lazy("Error in case definition -- expected func.name args | condition -> action, but got "))(L_orig)})}}}}}))},
  function(){return resolve(L_define)(lazy("makeCaseCondition"))(lazy(6))(lazy("makeCaseCondition orig funcName altName args rest cond = rest\n  \\h t D . isTokenString h '->'\n    foldr1 append [['altDef' funcName altName (length args) '\\\\'] args ['.' (cond nil) ['some' t] 'none']]\n    makeCaseCondition orig funcName altName args t (dlPush cond h)\n parseErr \"Error in case definition -- expected func.name args | condition -> action, but got \" orig"))(lazy(function(L_orig){return function(L_funcName){return function(L_altName){return function(L_args){return function(L_rest){return function(L_cond){return resolve(L_rest)(lazy(function(L_h){return function(L_t){return function(L_D){return resolve(L_isTokenString)(L_h)(lazy("->"))(function(){return resolve(L_foldr1)(L_append)(function(){return resolve(L_cons)(function(){return resolve(L_cons)(lazy("altDef"))(function(){return resolve(L_cons)(L_funcName)(function(){return resolve(L_cons)(L_altName)(function(){return resolve(L_cons)(function(){return resolve(L_length)(L_args)})(function(){return resolve(L_cons)(lazy("\\"))(L_nil)})})})})})(function(){return resolve(L_cons)(L_args)(function(){return resolve(L_cons)(function(){return resolve(L_cons)(lazy("."))(function(){return resolve(L_cons)(function(){return resolve(L_cond)(L_nil)})(function(){return resolve(L_cons)(function(){return resolve(L_cons)(lazy("some"))(function(){return resolve(L_cons)(L_t)(L_nil)})})(function(){return resolve(L_cons)(lazy("none"))(L_nil)})})})})(L_nil)})})})})(function(){return resolve(L_makeCaseCondition)(L_orig)(L_funcName)(L_altName)(L_args)(L_t)(function(){return resolve(L_dlPush)(L_cond)(L_h)})})}}}))(function(){return resolve(L_parseErr)(lazy("Error in case definition -- expected func.name args | condition -> action, but got "))(L_orig)})}}}}}}))},
  function(){return resolve(L_altDef)(lazy("show"))(lazy("some"))(lazy(1))(lazy(function(L_obj){return resolve(L_hasType)(L_obj)(L_some)(function(){return resolve(L_some)(function(){return resolve(L_strCat)(function(){return resolve(L_cons)(lazy("Some("))(function(){return resolve(L_cons)(function(){return resolve(L_obj)(L_id)(L_false)})(function(){return resolve(L_cons)(lazy(")"))(L_nil)})})})})})(L_none)}))},
  function(){return resolve(L_altDef)(lazy("show"))(lazy("some2"))(lazy(1))(lazy(function(L_obj){return resolve(L_hasType)(L_obj)(L_some2)(function(){return resolve(L_some)(function(){return resolve(L_strCat)(function(){return resolve(L_cons)(lazy("Some2("))(function(){return resolve(L_cons)(function(){return resolve(L_obj)(lazy(function(L_a){return function(L_b){return resolve(L_cons)(L_a)(function(){return resolve(L_cons)(lazy(", "))(function(){return resolve(L_cons)(L_b)(L_nil)})})}}))(L_false)})(function(){return resolve(L_cons)(lazy(")"))(L_nil)})})})})})(L_none)}))},
  function(){return resolve(L_altDef)(lazy("show"))(lazy("none"))(lazy(1))(lazy(function(L_obj){return resolve(L_hasType)(L_obj)(L_none)(function(){return resolve(L_some)(lazy("None"))})(L_none)}))},
  function(){return resolve(L_altDef)(lazy("show"))(lazy("left"))(lazy(1))(lazy(function(L_obj){return resolve(L_hasType)(L_obj)(L_left)(function(){return resolve(L_some)(function(){return resolve(L_strCat)(function(){return resolve(L_cons)(lazy("Left("))(function(){return resolve(L_cons)(function(){return resolve(L_obj)(L_id)(L_id)})(function(){return resolve(L_cons)(lazy(")"))(L_nil)})})})})})(L_none)}))},
  function(){return resolve(L_altDef)(lazy("show"))(lazy("right"))(lazy(1))(lazy(function(L_obj){return resolve(L_hasType)(L_obj)(L_right)(function(){return resolve(L_some)(function(){return resolve(L_strCat)(function(){return resolve(L_cons)(lazy("Right("))(function(){return resolve(L_cons)(function(){return resolve(L_obj)(L_id)(L_id)})(function(){return resolve(L_cons)(lazy(")"))(L_nil)})})})})})(L_none)}))},
  function(){return resolve(L_altDef)(lazy("show"))(lazy("nil"))(lazy(1))(lazy(function(L_obj){return resolve(L_hasType)(L_obj)(L_nil)(function(){return resolve(L_some)(lazy("nil"))})(L_none)}))},
  function(){return resolve(L_altDef)(lazy("show"))(lazy("assoc"))(lazy(1))(lazy(function(L_obj){return resolve(L_isAlist)(L_obj)(function(){return resolve(L_some)(function(){return resolve(L_strCat)(function(){return resolve(L_flatten)(function(){return resolve(L_cons)(lazy("{"))(function(){return resolve(L_cons)(function(){return resolve(L_intersperse)(function(){return resolve(L_map)(lazy(function(L_item){return resolve(L_cons)(function(){return resolve(L_show)(function(){return resolve(L_head)(L_item)})})(function(){return resolve(L_cons)(lazy(":"))(function(){return resolve(L_cons)(function(){return resolve(L_show)(function(){return resolve(L_tail)(L_item)})})(L_nil)})})}))(L_obj)})(lazy(" "))})(function(){return resolve(L_cons)(lazy("}"))(L_nil)})})})})})})(L_none)}))},
  function(){return resolve(L_altDef)(lazy("show"))(lazy("hamt"))(lazy(1))(lazy(function(L_obj){return resolve(L_hasType)(L_obj)(L_hamt)(function(){return resolve(L_some)(function(){return resolve(L_strCat)(function(){return resolve(L_flatten)(function(){return resolve(L_cons)(lazy("hamt{"))(function(){return resolve(L_cons)(function(){return resolve(L_intersperse)(function(){return resolve(L_map)(lazy(function(L_item){return resolve(L_cons)(function(){return resolve(L_show)(function(){return resolve(L_head)(L_item)})})(function(){return resolve(L_cons)(lazy(":"))(function(){return resolve(L_cons)(function(){return resolve(L_show)(function(){return resolve(L_tail)(L_item)})})(L_nil)})})}))(function(){return resolve(L_hamtPairs)(L_obj)})})(lazy(" "))})(function(){return resolve(L_cons)(lazy("}"))(L_nil)})})})})})})(L_none)}))},
  function(){return resolve(L_altDef)(lazy("show"))(lazy("cons"))(lazy(1))(lazy(function(L_obj){return resolve(L_hasType)(L_obj)(L_cons)(function(){return resolve(L_some)(function(){return resolve(L_strCat)(function(){return resolve(L_flatten)(function(){return resolve(L_cons)(lazy("["))(function(){return resolve(L_cons)(function(){return resolve(L_show)(function(){return resolve(L_head)(L_obj)})})(function(){return resolve(L_cons)(function(){return resolve(L_showConsElements)(function(){return resolve(L_tail)(L_obj)})})(function(){return resolve(L_cons)(lazy("]"))(L_nil)})})})})})})})(L_none)}))},
  function(){return resolve(L_define)(lazy("showConsElements"))(lazy(1))(lazy("showConsElements list = isCons list\n  [' ' (show (head list)) (showConsElements (tail list))]\n  isNil list\n    ''\n    [' | ' (show list)]"))(lazy(function(L_list){return resolve(L_isCons)(L_list)(function(){return resolve(L_cons)(lazy(" "))(function(){return resolve(L_cons)(function(){return resolve(L_show)(function(){return resolve(L_head)(L_list)})})(function(){return resolve(L_cons)(function(){return resolve(L_showConsElements)(function(){return resolve(L_tail)(L_list)})})(L_nil)})})})(function(){return resolve(L_isNil)(L_list)(lazy(""))(function(){return resolve(L_cons)(lazy(" | "))(function(){return resolve(L_cons)(function(){return resolve(L_show)(L_list)})(L_nil)})})})}))},
  function(){return resolve(L_altDef)(lazy("bind"))(lazy("option"))(lazy(2))(lazy(function(L_opt){return function(L_cont){return resolve(L_or)(function(){return resolve(L_hasType)(L_opt)(L_some)})(function(){return resolve(L_hasType)(L_opt)(L_none)})(function(){return resolve(L_some)(function(){return resolve(L_opt)(lazy(function(L_value){return resolve(L_cont)(L_value)}))(L_none)})})(L_none)}}))},
  function(){return resolve(L_altDef)(lazy("bind"))(lazy("either"))(lazy(2))(lazy(function(L_either){return function(L_cont){return resolve(L_or)(function(){return resolve(L_hasType)(L_either)(L_left)})(function(){return resolve(L_hasType)(L_either)(L_right)})(function(){return resolve(L_some)(function(){return resolve(L_either)(lazy(function(L__){return resolve(L_either)}))(lazy(function(L_value){return resolve(L_cont)(L_value)}))})})(L_none)}}))},
  function(){return resolve(L_defMacro)(lazy("defWrapper"))(lazy(function(L_list){return resolve(L_grabLeftOfArrow)(L_list)(L_nil)(lazy(function(L_left){return function(L_right){return resolve(L_cons)(lazy("override"))(function(){return resolve(L_cons)(function(){return resolve(L_strCat)(function(){return resolve(L_cons)(lazy("'"))(function(){return resolve(L_cons)(function(){return resolve(L_strTokenString)(function(){return resolve(L_head)(L_left)})})(function(){return resolve(L_cons)(lazy("'"))(L_nil)})})})})(function(){return resolve(L_cons)(function(){return resolve(L_append)(function(){return resolve(L_cons)(lazy("\\"))(function(){return resolve(L_tail)(L_left)})})(function(){return resolve(L_cons)(lazy("."))(L_right)})})(L_nil)})})}}))}))},
  function(){return resolve(L_define)(lazy("grabLeftOfArrow"))(lazy(3))(lazy("grabLeftOfArrow list left cont = isTokenString (head list) '->'\n  cont (reverse left) (tail list)\n  grabLeftOfArrow (tail list) (head list) : left cont"))(lazy(function(L_list){return function(L_left){return function(L_cont){return resolve(L_isTokenString)(function(){return resolve(L_head)(L_list)})(lazy("->"))(function(){return resolve(L_cont)(function(){return resolve(L_reverse)(L_left)})(function(){return resolve(L_tail)(L_list)})})(function(){return resolve(L_grabLeftOfArrow)(function(){return resolve(L_tail)(L_list)})(function(){return resolve(L_cons)(function(){return resolve(L_head)(L_list)})(L_left)})(L_cont)})}}}))},
  function(){return resolve(L_override)(lazy("head"))(lazy(function(L_oldHead){return function(L_list){return resolve(L_assertType)(lazy("head argument"))(L_cons)(L_list)(lazy(function(L_h){return function(L_t){return resolve(L_h)}}))}}))},
  function(){return resolve(L_override)(lazy("tail"))(lazy(function(L_oldTail){return function(L_list){return resolve(L_assertType)(lazy("tail argument"))(L_cons)(L_list)(lazy(function(L_h){return function(L_t){return resolve(L_t)}}))}}))},
  function(){return resolve(L_override)(lazy("hamtWith"))(lazy(function(L_oldHamtWith){return function(L_key){return function(L_value){return function(L_hamt){return resolve(L_oldHamtWith)(function(){return resolve(L_assertType)(lazy("hamtWith key"))(lazy("*string"))(L_key)})(L_value)(L_hamt)}}}}))},
  function(){return resolve(L_define)(lazy("html"))(lazy(1))(lazy("html x = \\f . f x"))(lazy(setDataType(function(L_x){return setType(function(L_f){return resolve(L_f)(L_x)}, 'html')}, 'html')))},
  function(){return resolve(L_defTokenPack)(lazy("util"))(function(){return resolve(L_cons)(function(){return resolve(L_cons)(lazy("->"))(function(){return resolve(L_cons)(lazy("--"))(function(){return resolve(L_cons)(lazy("++"))(L_nil)})})})(function(){return resolve(L_cons)(function(){return resolve(L_cons)(function(){return resolve(L_cons)(lazy("js["))(lazy("]"))})(L_nil)})(function(){return resolve(L_cons)(L_nil)(L_nil)})})})},
  function(){return resolve(L_addStdTokenPacks)(function(){return resolve(L_cons)(lazy("util"))(L_nil)})}]);

},{}],12:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],13:[function(require,module,exports){
module.exports = function(str) {
  var hash = 5381,
      i    = str.length

  while(i)
    hash = (hash * 33) ^ str.charCodeAt(--i)

  /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed
   * integers. Since we want the results to be always positive, if the high bit
   * is set, unset it and add it back in through (64-bit IEEE) addition. */
  return hash >= 0 ? hash : (hash & 0x7FFFFFFF) + 0x80000000
}

},{}],14:[function(require,module,exports){
//# Hashing functions

// Int, Int -> Int
// gets a <= 5 bit section of a hash, shifted from the left position
// in practice, a 32 bit splits into 7 chunks - 6 of 5 bits, one of 2
var mask = function(hash, from){ return (hash >>> from) & 0x01f }

// String, Int, Function -> Int
// gets a chunk of a hash, given a string and a hashing function
// the hashing function should return a 32 bit hash.
var hashMask = function(str, from, hash){
    return mask(hash(str), from)
}

module.exports = {
	hash: require('string-hash'),
	mask: hashMask
}

},{"string-hash":13}],15:[function(require,module,exports){
'use strict';

var util = require('./util')
var hash = require('./hash')
var lib = module.exports

//# persistent Hash Trie

// A Trie is a specialised version of a Tree, in which nodes can be found by navigating a 'path'.
// For instance, a dictionary Trie may start with a root node, have A-Z as the child nodes.
// Those child nodes may also be Tries (commonly referred to as sub-Tries).  Therefore, if
// you want to look up 'ANT', you can see if it's in the Trie by navigating to node A, then to
// node A's child node N, then to that node's child node T.  i.e. the path for ANT is A->N->T

// A Hash Trie forms its path by taking a hash of the string that is being looked up, and
// splitting that into parts:
// ANT = 01101101101110111010111011000011 = 01101->10110->11101->11010->11101->10000->11
// In this scheme, a 32-bit hash is taken, and split into path parts that are maximally
// 5 bits long.  Each Trie therefore has children from 00000-11111 (or 0-31 in decimal).

// Hash Tries allow us to store nodes at a shallow depth.  For instance, if there is only
// one member of the Trie whose key's first path part is 01101, then we can store the value
// directly as the root Trie's 01101 child node.  Why go deeper?  It just costs more to retrieve.

// It also allows us to keep the Trie fairly balanced; since a hash function should be
// have an even distribution of hashes, even if the inputs share common prefixes.
// If we used the first 2 letters of a word, for instance, we'd end up with lots of
// nodes in the 'un' and 'th' paths, and not many in the 'tx' path.

// An persistent Hash Trie is a Hash Trie in which any commonly updating actions - removing,
// setting or adding values - produce an entirely new Hash Trie, and *don't* affect the
// original in any way.  This means that the Hash Tries can be shared safely; without fear
// that updating them will result in a value changing in multiple places in a program.

// To make this distinction clearer, the verbs 'set' and 'remove/delete' have been replaced
// with assoc (associate a new value with an persistent Hash Trie), and dissoc (dissociate
// an existing value with an persistent Hash Trie).



// to allow hooks for other implementations/tests to override the default
// hash and equality functions (which are the necessary ones for creating
// hash-table-like behaviour, as the hash-trie has), they can be passed in
// as opts to assoc/dissoc/get/has.

// These defaults cover the ~80% use case of unordered string:val pairs.
var defaultOpts = {
    eq   : function(a, b){ return a === b },
    hash : hash.hash
}

//# Node Types

// Object -> Trie
// a Trie is a store of children values; the most basic type of non-leaf node.
var Trie = lib.Trie = function(children){
    return { type: 'trie', children: children || {} }
}

// String, JSValue -> Value
// Node that represents a specific value
var Value = lib.Value = function(key, value){
    return { type: 'value', key: key, value: value }
}

// { JSValue } -> Hashmap
// a Trie will have a max depth of 7 (6, if 0 indexed).  After that, additional
// values will just slung into a hashmap node
var Hashmap = lib.Hashmap = function(values){
    return { type: 'hashmap', values: values }
}


//# Basic manipulation functions - has/get/assoc/dissoc

// Object, String, JSValue -> Object

// creates a shallow clone of an object, adding or replacing a key:val pair
// with the one provided

// necessary for updating nodes in `assoc`
var copyAdd = function(obj, key, val){
    obj = util.clone(obj)
    obj[key] = val
    return obj
}


//  Node, String, JSValue, (Int) -> Trie

// assoc 'associates' a new value with a Trie.  It does so by finding the
// appropriate place for the new node, then creating a copy of the parent
// nodes, adding in a reference to the newly created child node each time.

// This is called path-copying, since the path from the root node to the new
// node is copied form one datastructure to the other.  Since the vast majority
// of data will lie in nodes beneathe these in sizable datastructures, this sharing
// of data allows for persistent values to be updated relatively effeciently at large
// size.

// The algorithm is also aware of 'specificity'; i.e. that a value need only be stored
// at a depth where it can be distinguished uniquely from other values by virtue of its
// path.  If both 'foo' and 'bar's first 5 bits are 011011, and both are present in the
// Trie, then they most be stored in a sub-Trie, and use the following 5 bits to differenciate
// themselves.  If the Trie gets deeper than there are bits in the hash (i.e. a total hash collision)
// then it simply stores the objects in a Hashmap node.
lib.assoc = function(node, key, val, opts){
    return assoc(node, key, val, opts || defaultOpts, 0)
}

var assoc = function(node, key, val, opts, depth){
    return assocFns[node.type](node, key, val, opts, depth)
}

var assocFns = {
    trie: function(node, key, val, opts, depth){
        var path = hash.mask(key, depth, opts.hash)
        var child = node.children[path]

        if ( child === undefined  ) return Trie(copyAdd(node.children, path, Value(key, val)))
        else                        return Trie(copyAdd(node.children, path, assoc(child, key, val, opts, depth + 1)))
    },
    value: function(node, key, val, opts, depth){
        var nodePath = hash.mask(node.key, depth, opts.hash)
        var keyPath  = hash.mask(key, depth, opts.hash)

        var makeHashmap = function(){
            var children = {}
            children[key] = Value(key, val)
            children[node.key] = node
            return Hashmap(children)
        }

        var resolveShallowConflict = function(){
            var children = {}
            children[nodePath] = node
            children[keyPath]  = Value(key, val)

            return Trie(children)
        }

        var resolveDeepConflict = function(){
            var children = {}
            children[keyPath] = assoc(node, key, val, opts, depth + 1)
            return Trie(children)
        }

        var makeTrie = function(){
            if ( nodePath !== keyPath ) return resolveShallowConflict()
            else                        return resolveDeepConflict()
        }

        if ( opts.eq(node.key, key) ) return Value(key, val)
        else if ( depth > 6 )         return makeHashmap()
        else                          return makeTrie()
    },
    hashmap: function(node, key, val, opts, depth){
        var v = copyAdd(node.values, key, Value(key, val))
        return Hashmap(v)
    }
}

// Object, String -> Object

// creates a new object, but without a key.
// Used in `dissoc`
var copyDissoc = function(obj, key){
    obj = util.clone(obj)
    delete obj[key]
    return obj
}


// Node, String, (Int) -> Trie

// dissoc (disassociate) returns a new Trie, but without a specified key

// As with assoc, it recurses down the Trie.  If it fails to find a key, then
// it returns the original Trie, since that is conceptually the same as removing
// a non-existant key from an object.

// If it finds a Value associated with a key, however, it will create
// a parent node to that Value that copies all *other* values, but omits
// the value with the key in question.  As with assoc, it will also produce a
// copy of *its* parent.  This occurs recursively, and is exactly the same concept
// as the 'path copying' technique used in assoc.

// If removing a value removes a hash collision, then the Trie node that contained
// those values can be replaced with just a Value node, which results in a shallower
// Trie.
lib.dissoc = function(node, key, opts){
    return dissoc(node, key, opts || defaultOpts, 0)
}

var dissoc = function(node, key, opts, depth){
    return dissocFns[node.type](node, key, opts, depth)
}

var dissocFns = {
    trie: function(node, key, opts, depth){
        var path = hash.mask(key, depth, opts.hash)
        var child = node.children[path]

        // handle the 'present key' cases.  If it's a Value, remove it.  If it's a sub-Trie or Hashmap
        // recurse to prevent other values from being lost
        var dissocKey = function(){
            if ( child.type === 'value' && opts.eq(child.key, key) )
                return Trie(copyDissoc(node.children, path))
            else
                return Trie(copyDissoc(node.children, path, dissoc(child, key, opts, depth + 1)))
        }

        // if there's only a single value in a Trie node left, then it can be replaced by its value,
        // allowing us to make the Trie more shallow, and therefore more effecient.
        var collapseTrie = function(trie){
            var names = util.keys(trie.children)
            var child = trie.children[names[0]]

            // don't collapse an empty root trie
            if ( depth === 0 )                                       return trie
            else if ( child === undefined )                          return trie
            else if ( names.length === 1 && child.type === 'value' ) return Value(child.key, child.value)
            else                                                     return trie
        }

        var handleTrie = function(){
            return collapseTrie(dissocKey(node))
        }

        // if there's no child, return the node
        if ( child === undefined )  return node;
        else                        return handleTrie();
    },
    value: function(){},
    hashmap: function(node, key, opts, depth){
        var ret = copyDissoc(node.values, key)
        var names = util.keys(ret)
        var child = ret[names[0]]

        if ( names.length === 1 ) return Value(child.key, child.value)
        else                      return Hashmap(ret)
    }
}


// Node, String, (Int), (Object)-> Bool

// Trie-equivalent of the 'in' operator.

// Has recurses down a node, using hash.mask to navigate a 'path' down branches.
// If a value node is found, if its key is equal to the key provided, then the
// Trie contains the key, and true is returned.

// Hashmaps store values in the outermost leaves when necessary.  If they contain
// a key, it also means that the key is in the trie,.
lib.has = function(trie, key, opts){
    return has(trie, key, opts || defaultOpts, 0)
}

var has = function(trie, key, opts, depth){
    return hasFns[trie.type](trie, key, opts, depth)
}

var hasFns = {
    trie: function(node, key, opts, depth){
        var child = node.children[hash.mask(key, depth, opts.hash)]
        if ( child === undefined )    return false
        else                          return has(child, key, opts, depth + 1)
    },
    value: function(node, key, opts){
        return opts.eq(node.key, key)
    },
    hashmap: function(node, key, opts){
        return key in node.values
    }
}

// Node, String, (Int), (Object) -> Value

// Trie-equivalent of dot or bracket syntax - retrieves a value assocaited with a key
// or undefined.

// get recurses down the Trie, similarly to has.  If it finds a matching key, instead
// of returning true or false, however, it unpacks the value associated with the key
// and returns that instead.
lib.get = function(trie, key, opts){
    return get(trie, key, opts || defaultOpts, 0)
}

var get = function(trie, key, opts, depth){
    return getFns[trie.type](trie, key, opts, depth)
}

var getFns = {
    trie: function(node, key, opts, depth){
        var child = node.children[hash.mask(key, depth, opts.hash)]
        if ( child === undefined )    return undefined
        else                          return get(child, key, opts, depth + 1)
    },
    value: function(node, key, opts, depth){
        if ( opts.eq(node.key, key) ) return node.value
    },
    hashmap: function(node, key, opts, depth){
        var value = node.values[key]
        return  value ? value.value : undefined

    }
}



// Node, (Any, Any, String), Any -> Any

// given a node, function and seed, reduce to produce results.
lib.reduce = function(node, callback, initial){
    var state = reduce(node, callback, initial)
    return state instanceof Break ? state.value : state
}

var reduce = function(node, callback, initial) {
    return reduceFns[node.type](node, callback, initial)
}

var reduceFns = {
    trie: function(node, callback, state) {
        for ( var path in node.children ) {
            if ( node.children.hasOwnProperty(path) ) {
                state = reduce(node.children[path], callback, state)
            }
            if (state instanceof Break) break
        }
        return state
    },
    value: function(node, callback, state){
        return callback(state, node.value, node.key)
    },
    hashmap: function(node, callback, state){
        for ( var key in node.values ) {
            if ( node.values.hasOwnProperty(key) ) {
                state = reduce(node.values[key], callback, state)
            }
            if (state instanceof Break) break
        }
        return state
    }
}


var Break = lib.reduce.Break = function(v) {
    if (!(this instanceof Break)) return new Break(v)
    this.value = v
}



// Node -> Object

// mutable returns a mutable version of a Trie.

// It achieves this by recursing down the Trie, finding all the Value nodes
// (whether stored in a Trie directly, or in a Hashmap node), and adding
// the values to a return value.

//  (yay abusing mutability in small pieces, but keeping the function
// pure from an API perspective)
lib.mutable = function(node){
    return lib.reduce(node, addKeyVal, {})
}

var addKeyVal = function(o, val, key){
    o[key] = val
    return o
}

// Node -> [String]

// keys returns the keys stored in the array, like Object.keys
lib.keys = function(node){
    return lib.reduce(node, addKey, [])
}

var addKey = function(arr, val, key){
    arr.push(key)
    return arr
}

},{"./hash":14,"./util":16}],16:[function(require,module,exports){
'use strict'

// Internal
var extend   = function(t, f) { for ( var p in f ) t[p] = f[p]; return t }
var clone    = function(o){ return extend({}, o) }
var slice    = function(a, f, n){ return [].slice.call(a, f, n) }

var mapObj = function(o, fn){
    var r = {}
    for ( var p in o ) r[p] = fn(o[p], p, o)
    return r
}

var map = function(arr, fn){
    var a = []
    for ( var i = 0, l = arr.length; i < l; i += 1 ) a.push(fn(arr[i], i, arr))
    return a
}

var reduce = function(arr, fn){
    var seed = arr[0]
    arr = arr.slice(1)
    for ( var i = 0, l = arr.length; i < l; i += 1) seed = fn(seed, arr[i])
    return seed
}

var pick = function(o){
    var names = slice(arguments, 1),
        r     = {}

    for ( var i = 0, l = names.length; i < l; i += 1 )
        r[names[i]] = o[names[i]]
    return r
}

// Object -> [String]

// get the keys of an object
var keys = Object.keys || function(o){
    var a = []
    for ( var key in o ) a.push(key)
    return a
}


module.exports = {
    extend    : extend,
    clone     : clone,
    slice     : slice,
    mapObj    : mapObj,
    pick      : pick,
    map       : map,
    reduce    : reduce,
    keys      : keys
}

},{}]},{},[3])
//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvaG9tZS9iaWxsL2xjL2xhbWJkYUNhbGN1bHVzL2xpYi9hc3QuanMiLCIvaG9tZS9iaWxsL2xjL2xhbWJkYUNhbGN1bHVzL2xpYi9iYXNlLmpzIiwiL2hvbWUvYmlsbC9sYy9sYW1iZGFDYWxjdWx1cy9saWIvYnJvd3Nlck1haW4uanMiLCIvaG9tZS9iaWxsL2xjL2xhbWJkYUNhbGN1bHVzL2xpYi9nZW4uanMiLCIvaG9tZS9iaWxsL2xjL2xhbWJkYUNhbGN1bHVzL2xpYi9nZW5lcmF0ZWRQcmVsdWRlLmpzIiwiL2hvbWUvYmlsbC9sYy9sYW1iZGFDYWxjdWx1cy9saWIvbG9kYXNoLm1pbi5qcyIsIi9ob21lL2JpbGwvbGMvbGFtYmRhQ2FsY3VsdXMvbGliL21hcmtlZC5qcyIsIi9ob21lL2JpbGwvbGMvbGFtYmRhQ2FsY3VsdXMvbGliL21kLmpzIiwiL2hvbWUvYmlsbC9sYy9sYW1iZGFDYWxjdWx1cy9saWIvbm90ZWJvb2suanMiLCIvaG9tZS9iaWxsL2xjL2xhbWJkYUNhbGN1bHVzL2xpYi9ydW50aW1lLmpzIiwiL2hvbWUvYmlsbC9sYy9sYW1iZGFDYWxjdWx1cy9saWIvc3RkLmpzIiwiL2hvbWUvYmlsbC9sYy9sYW1iZGFDYWxjdWx1cy9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5zZXJ0LW1vZHVsZS1nbG9iYWxzL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCIvaG9tZS9iaWxsL2xjL2xhbWJkYUNhbGN1bHVzL25vZGVfbW9kdWxlcy9wZXJzaXN0ZW50LWhhc2gtdHJpZS9ub2RlX21vZHVsZXMvc3RyaW5nLWhhc2gvaW5kZXguanMiLCIvaG9tZS9iaWxsL2xjL2xhbWJkYUNhbGN1bHVzL25vZGVfbW9kdWxlcy9wZXJzaXN0ZW50LWhhc2gtdHJpZS9zcmMvaGFzaC5qcyIsIi9ob21lL2JpbGwvbGMvbGFtYmRhQ2FsY3VsdXMvbm9kZV9tb2R1bGVzL3BlcnNpc3RlbnQtaGFzaC10cmllL3NyYy9wZXJzaXN0ZW50LWhhc2gtdHJpZS5qcyIsIi9ob21lL2JpbGwvbGMvbGFtYmRhQ2FsY3VsdXMvbm9kZV9tb2R1bGVzL3BlcnNpc3RlbnQtaGFzaC10cmllL3NyYy91dGlsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RnQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4eEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbmlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0dUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2gwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbihnbG9iYWwpey8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS42LjJcbi8qXG5Db3B5cmlnaHQgKEMpIDIwMTIsIEJpbGwgQnVyZGljaywgVGlueSBDb25jZXB0czogaHR0cHM6Ly9naXRodWIuY29tL3pvdC9MZWlzdXJlXG5cbihsaWNlbnNlZCB3aXRoIFpMSUIgbGljZW5zZSlcblxuVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbndhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cblxuUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG5pbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG5mcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG5cbjEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG5jbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG5hcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuXG4yLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxubWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuXG4zLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuKi9cblxuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBMX2Fubm8sIExfYXBwbHksIExfbGFtYmRhLCBMX2xldCwgTF9saXQsIExfcmVmLCBMZWlzdXJlT2JqZWN0LCBMZWlzdXJlX0Jhc2VDb25zLCBMZWlzdXJlX2NvbnMsIExlaXN1cmVfbmlsLCBOaWwsIGFubm8sIGFwcGx5LCBhc3QySnNvbiwgYXN0Mkpzb25FbmNvZGluZ3MsIGFzdFN0cmluZywgY2hhckNvZGVzLCBjaGVja1R5cGUsIGNvbnMsIGNvbnNFcSwgY29uc0Zyb20sIGRlZmluZSwgZW5zdXJlTGVpc3VyZUNsYXNzLCBldmFsRnVuYywgZm9sZExlZnQsIGZ1bmN0aW9uSW5mbywgZ2V0QW5ub0JvZHksIGdldEFubm9EYXRhLCBnZXRBbm5vTmFtZSwgZ2V0QXBwbHlBcmcsIGdldEFwcGx5RnVuYywgZ2V0RGF0YVR5cGUsIGdldExhbWJkYUJvZHksIGdldExhbWJkYVZhciwgZ2V0TGV0Qm9keSwgZ2V0TGV0TmFtZSwgZ2V0TGV0VmFsdWUsIGdldExpdFZhbCwgZ2V0UmVmTmFtZSwgZ2V0VHlwZSwgaGVhZCwganNUeXBlLCBqc29uMkFzdCwganNvbjJBc3RFbmNvZGluZ3MsIGxhbWJkYSwgbGF6eSwgbGVpc3VyZUFkZEZ1bmMsIGxldFN0ciwgbGl0LCBsbGV0LCBseiwgbWFrZVN1cGVyLCBta1Byb3RvLCBuYW1lRnVuYywgbmFtZVN1YiwgcHJpbUNvbnMsIHByaW1Gb2xkTGVmdCwgcmVmLCByZXNvbHZlLCByb290LCByeiwgc2F2ZSwgc2V0RGF0YVR5cGUsIHNldFR5cGUsIHN1cGVydHlwZXMsIHRhaWwsIHRocm93RXJyb3IsIF8sIF9yZWYsIF9yZWYxLCBfcmVmMiwgX3JlZjMsXG4gICAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH07XG5cbiAgX3JlZiA9IHJvb3QgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vYmFzZScpLCByZXNvbHZlID0gX3JlZi5yZXNvbHZlLCBsYXp5ID0gX3JlZi5sYXp5O1xuXG4gIF8gPSByZXF1aXJlKCcuL2xvZGFzaC5taW4nKTtcblxuICByeiA9IHJlc29sdmU7XG5cbiAgbHogPSBsYXp5O1xuXG4gIGNoYXJDb2RlcyA9IHtcbiAgICBcIidcIjogJyRhJyxcbiAgICAnLCc6ICckYicsXG4gICAgJyQnOiAnJCQnLFxuICAgICdAJzogJyRkJyxcbiAgICAnPyc6ICckZScsXG4gICAgJy8nOiAnJGYnLFxuICAgICcqJzogJyRnJyxcbiAgICAnJic6ICckaCcsXG4gICAgJ14nOiAnJGknLFxuICAgICchJzogJyRrJyxcbiAgICAnYCc6ICckbCcsXG4gICAgJ34nOiAnJG0nLFxuICAgICctJzogJyRfJyxcbiAgICAnKyc6ICckbycsXG4gICAgJz0nOiAnJHAnLFxuICAgICd8JzogJyRxJyxcbiAgICAnWyc6ICckcicsXG4gICAgJ10nOiAnJHMnLFxuICAgICd7JzogJyR0JyxcbiAgICAnfSc6ICckdScsXG4gICAgJ1wiJzogJyR2JyxcbiAgICAnOic6ICckdycsXG4gICAgJzsnOiAnJHgnLFxuICAgICc8JzogJyR5JyxcbiAgICAnPic6ICckeicsXG4gICAgJyUnOiAnJEEnLFxuICAgICcuJzogJyRCJ1xuICB9O1xuXG4gIG5hbWVTdWIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGNvZGUsIGksIHMsIF9pLCBfcmVmMTtcblxuICAgIHMgPSAnJztcbiAgICBmb3IgKGkgPSBfaSA9IDAsIF9yZWYxID0gbmFtZS5sZW5ndGg7IDAgPD0gX3JlZjEgPyBfaSA8IF9yZWYxIDogX2kgPiBfcmVmMTsgaSA9IDAgPD0gX3JlZjEgPyArK19pIDogLS1faSkge1xuICAgICAgY29kZSA9IGNoYXJDb2Rlc1tuYW1lW2ldXTtcbiAgICAgIHMgKz0gY29kZSAhPSBudWxsID8gY29kZSA6IG5hbWVbaV07XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9O1xuXG4gIHNldERhdGFUeXBlID0gZnVuY3Rpb24oZnVuYywgZGF0YVR5cGUpIHtcbiAgICBpZiAoZGF0YVR5cGUpIHtcbiAgICAgIGZ1bmMuZGF0YVR5cGUgPSBkYXRhVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH07XG5cbiAgc2V0VHlwZSA9IGZ1bmN0aW9uKGZ1bmMsIHR5cGUpIHtcbiAgICBpZiAodHlwZSkge1xuICAgICAgZnVuYy50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgZnVuYy5fX3Byb3RvX18gPSAoZW5zdXJlTGVpc3VyZUNsYXNzKHR5cGUpKS5wcm90b3R5cGU7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH07XG5cbiAgTGVpc3VyZU9iamVjdCA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBMZWlzdXJlT2JqZWN0KCkge31cblxuICAgIHJldHVybiBMZWlzdXJlT2JqZWN0O1xuXG4gIH0pKCk7XG5cbiAgTGVpc3VyZU9iamVjdC5wcm90b3R5cGUuX19wcm90b19fID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4gIExlaXN1cmVPYmplY3QucHJvdG90eXBlLmNsYXNzTmFtZSA9ICdMZWlzdXJlT2JqZWN0JztcblxuICBnbG9iYWwuTGVpc3VyZV9PYmplY3QgPSBMZWlzdXJlT2JqZWN0O1xuXG4gIHN1cGVydHlwZXMgPSB7fTtcblxuICByb290LmxlaXN1cmVDbGFzc0NoYW5nZSA9IDA7XG5cbiAgZW5zdXJlTGVpc3VyZUNsYXNzID0gZnVuY3Rpb24obGVpc3VyZUNsYXNzKSB7XG4gICAgdmFyIGNsO1xuXG4gICAgY2wgPSBcIkxlaXN1cmVfXCIgKyAobmFtZVN1YihsZWlzdXJlQ2xhc3MpKTtcbiAgICBpZiAoZ2xvYmFsW2NsXSA9PSBudWxsKSB7XG4gICAgICBnbG9iYWxbY2xdID0gZXZhbChcIihmdW5jdGlvbiBcIiArIGNsICsgXCIoKXt9KVwiKTtcbiAgICAgIHN1cGVydHlwZXNbY2xdID0gJ0xlaXN1cmVfT2JqZWN0JztcbiAgICAgIGdsb2JhbFtjbF0ucHJvdG90eXBlLl9fcHJvdG9fXyA9IExlaXN1cmVPYmplY3QucHJvdG90eXBlO1xuICAgICAgcm9vdC5sZWlzdXJlQ2xhc3NDaGFuZ2UrKztcbiAgICB9XG4gICAgcmV0dXJuIGdsb2JhbFtjbF07XG4gIH07XG5cbiAgbWFrZVN1cGVyID0gZnVuY3Rpb24odHlwZSwgc3VwZXJ0eXBlKSB7XG4gICAgc3VwZXJ0eXBlc1tcIkxlaXN1cmVfXCIgKyAobmFtZVN1Yih0eXBlKSldID0gXCJMZWlzdXJlX1wiICsgKG5hbWVTdWIoc3VwZXJ0eXBlKSk7XG4gICAgcmV0dXJuIHJvb3QubGVpc3VyZUNsYXNzQ2hhbmdlKys7XG4gIH07XG5cbiAgZW5zdXJlTGVpc3VyZUNsYXNzKCdjb25zJyk7XG5cbiAgZW5zdXJlTGVpc3VyZUNsYXNzKCduaWwnKTtcblxuICBzdXBlcnR5cGVzLkxlaXN1cmVfY29ucyA9ICdMZWlzdXJlX09iamVjdCc7XG5cbiAgc3VwZXJ0eXBlcy5MZWlzdXJlX25pbCA9ICdMZWlzdXJlX09iamVjdCc7XG5cbiAgZW5zdXJlTGVpc3VyZUNsYXNzKCdhc3QnKTtcblxuICBlbnN1cmVMZWlzdXJlQ2xhc3MoJ2xpdCcpO1xuXG4gIExlaXN1cmVfbGl0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcImxpdChcIiArIChnZXRMaXRWYWwodGhpcykpICsgXCIpXCI7XG4gIH07XG5cbiAgZW5zdXJlTGVpc3VyZUNsYXNzKCdyZWYnKTtcblxuICBMZWlzdXJlX3JlZi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJyZWYoXCIgKyAoZ2V0UmVmTmFtZSh0aGlzKSkgKyBcIilcIjtcbiAgfTtcblxuICBlbnN1cmVMZWlzdXJlQ2xhc3MoJ2xhbWJkYScpO1xuXG4gIExlaXN1cmVfbGFtYmRhLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcImxhbWJkYShcIiArIChhc3RTdHJpbmcodGhpcykpICsgXCIpXCI7XG4gIH07XG5cbiAgZW5zdXJlTGVpc3VyZUNsYXNzKCdhcHBseScpO1xuXG4gIExlaXN1cmVfYXBwbHkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiYXBwbHkoXCIgKyAoYXN0U3RyaW5nKHRoaXMpKSArIFwiKVwiO1xuICB9O1xuXG4gIGVuc3VyZUxlaXN1cmVDbGFzcygnbGV0Jyk7XG5cbiAgTGVpc3VyZV9sZXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwibGV0KFwiICsgKGFzdFN0cmluZyh0aGlzKSkgKyBcIilcIjtcbiAgfTtcblxuICBlbnN1cmVMZWlzdXJlQ2xhc3MoJ2Fubm8nKTtcblxuICBMZWlzdXJlX2Fubm8ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiYW5ubyhcIiArIChhc3RTdHJpbmcodGhpcykpICsgXCIpXCI7XG4gIH07XG5cbiAgZW5zdXJlTGVpc3VyZUNsYXNzKCdkb2MnKTtcblxuICBlbnN1cmVMZWlzdXJlQ2xhc3MoJ3NyY0xvY2F0aW9uJyk7XG5cbiAgZW5zdXJlTGVpc3VyZUNsYXNzKCdwYXR0ZXJuJyk7XG5cbiAgbWFrZVN1cGVyKCdsaXQnLCAnYXN0Jyk7XG5cbiAgbWFrZVN1cGVyKCdyZWYnLCAnYXN0Jyk7XG5cbiAgbWFrZVN1cGVyKCdsYW1iZGEnLCAnYXN0Jyk7XG5cbiAgbWFrZVN1cGVyKCdhcHBseScsICdhc3QnKTtcblxuICBtYWtlU3VwZXIoJ2xldCcsICdhc3QnKTtcblxuICBtYWtlU3VwZXIoJ2Fubm8nLCAnYXN0Jyk7XG5cbiAgYXN0U3RyaW5nID0gZnVuY3Rpb24oYXN0KSB7XG4gICAgdmFyIGFyZ1N0ciwgZnVuY1N0ciwgX3JlZjE7XG5cbiAgICBzd2l0Y2ggKGdldFR5cGUoYXN0KSkge1xuICAgICAgY2FzZSAnbGl0JzpcbiAgICAgICAgcmV0dXJuIGdldExpdFZhbChhc3QpO1xuICAgICAgY2FzZSAncmVmJzpcbiAgICAgICAgcmV0dXJuIGdldFJlZk5hbWUoYXN0KTtcbiAgICAgIGNhc2UgJ2FwcGx5JzpcbiAgICAgICAgZnVuY1N0ciA9IGFzdFN0cmluZyhnZXRBcHBseUZ1bmMoYXN0KSk7XG4gICAgICAgIGlmICgoX3JlZjEgPSBnZXRUeXBlKGdldEFwcGx5RnVuYyhhc3QpKSkgPT09ICdsYW1iZGEnIHx8IF9yZWYxID09PSAnbGV0Jykge1xuICAgICAgICAgIGZ1bmNTdHIgPSBcIihcIiArIGZ1bmNTdHIgKyBcIilcIjtcbiAgICAgICAgfVxuICAgICAgICBhcmdTdHIgPSBhc3RTdHJpbmcoZ2V0QXBwbHlBcmcoYXN0KSk7XG4gICAgICAgIGlmIChnZXRUeXBlKGdldEFwcGx5QXJnKGFzdCkpID09PSAnYXBwbHknKSB7XG4gICAgICAgICAgYXJnU3RyID0gXCIoXCIgKyBhcmdTdHIgKyBcIilcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIiArIGZ1bmNTdHIgKyBcIiBcIiArIGFyZ1N0cjtcbiAgICAgIGNhc2UgJ2xhbWJkYSc6XG4gICAgICAgIHJldHVybiBcIlxcXFxcIiArIChnZXRMYW1iZGFWYXIoYXN0KSkgKyBcIiAuIFwiICsgKGFzdFN0cmluZyhnZXRMYW1iZGFCb2R5KGFzdCkpKTtcbiAgICAgIGNhc2UgJ2xldCc6XG4gICAgICAgIHJldHVybiBcIlxcXFxcXFxcXCIgKyAobGV0U3RyKGFzdCkpO1xuICAgICAgY2FzZSAnYW5ubyc6XG4gICAgICAgIHJldHVybiBcIlxcXFxAXCIgKyAoZ2V0QW5ub05hbWUoYXN0KSkgKyBcIiBcIiArIChnZXRBbm5vRGF0YShhc3QpKSArIFwiIC4gXCIgKyAoYXN0U3RyaW5nKGdldEFubm9Cb2R5KGFzdCkpKTtcbiAgICB9XG4gIH07XG5cbiAgbGV0U3RyID0gZnVuY3Rpb24oYXN0KSB7XG4gICAgdmFyIGJpbmRpbmcsIGJvZHk7XG5cbiAgICBib2R5ID0gZ2V0TGV0Qm9keShhc3QpO1xuICAgIGJpbmRpbmcgPSBcIihcIiArIChnZXRMZXROYW1lKGFzdCkpICsgXCIgPSBcIiArIChhc3RTdHJpbmcoZ2V0TGV0VmFsdWUoYXN0KSkpICsgXCIpXCI7XG4gICAgaWYgKGJvZHkgaW5zdGFuY2VvZiBMZWlzdXJlX2xldCkge1xuICAgICAgcmV0dXJuIFwiXCIgKyBiaW5kaW5nICsgXCIgXCIgKyAobGV0U3RyKGJvZHkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwiXCIgKyBiaW5kaW5nICsgXCIgLiBcIiArIChhc3RTdHJpbmcoYm9keSkpO1xuICAgIH1cbiAgfTtcblxuICBMZWlzdXJlX0Jhc2VDb25zID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMZWlzdXJlX0Jhc2VDb25zLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gTGVpc3VyZV9CYXNlQ29ucygpIHtcbiAgICAgIF9yZWYxID0gTGVpc3VyZV9CYXNlQ29ucy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmMTtcbiAgICB9XG5cbiAgICBMZWlzdXJlX0Jhc2VDb25zLnByb3RvdHlwZS5oZWFkID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgSW1wbGVtZW50ZWRcIik7XG4gICAgfTtcblxuICAgIExlaXN1cmVfQmFzZUNvbnMucHJvdG90eXBlLnRhaWwgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBJbXBsZW1lbnRlZFwiKTtcbiAgICB9O1xuXG4gICAgTGVpc3VyZV9CYXNlQ29ucy5wcm90b3R5cGUuaXNOaWwgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgTGVpc3VyZV9CYXNlQ29ucy5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgIGlmIChmdW5jKHRoaXMuaGVhZCgpKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy50YWlsKCkuZmluZChmdW5jKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgTGVpc3VyZV9CYXNlQ29ucy5wcm90b3R5cGUucmVtb3ZlQWxsID0gZnVuY3Rpb24oZnVuYykge1xuICAgICAgdmFyIHQ7XG5cbiAgICAgIHQgPSB0aGlzLnRhaWwoKS5yZW1vdmVBbGwoZnVuYyk7XG4gICAgICBpZiAoZnVuYyh0aGlzLmhlYWQoKSkpIHtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9IGVsc2UgaWYgKHQgPT09IHRoaXMudGFpbCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbnModGhpcy5oZWFkKCksIHQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBMZWlzdXJlX0Jhc2VDb25zLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgICByZXR1cm4gY29ucyhmdW5jKHRoaXMuaGVhZCgpKSwgdGhpcy50YWlsKCkubWFwKGZ1bmMpKTtcbiAgICB9O1xuXG4gICAgTGVpc3VyZV9CYXNlQ29ucy5wcm90b3R5cGUuZm9sZGwgPSBmdW5jdGlvbihmdW5jLCBhcmcpIHtcbiAgICAgIHJldHVybiB0aGlzLnRhaWwoKS5mb2xkbChmdW5jLCBmdW5jKGFyZywgdGhpcy5oZWFkKCkpKTtcbiAgICB9O1xuXG4gICAgTGVpc3VyZV9CYXNlQ29ucy5wcm90b3R5cGUuZm9sZGwxID0gZnVuY3Rpb24oZnVuYykge1xuICAgICAgcmV0dXJuIHRoaXMudGFpbCgpLmZvbGRsKGZ1bmMsIHRoaXMuaGVhZCgpKTtcbiAgICB9O1xuXG4gICAgTGVpc3VyZV9CYXNlQ29ucy5wcm90b3R5cGUuZm9sZHIgPSBmdW5jdGlvbihmdW5jLCBhcmcpIHtcbiAgICAgIHJldHVybiBmdW5jKHRoaXMuaGVhZCgpLCB0aGlzLnRhaWwoKS5mb2xkcihmdW5jLCBhcmcpKTtcbiAgICB9O1xuXG4gICAgTGVpc3VyZV9CYXNlQ29ucy5wcm90b3R5cGUuZm9sZHIxID0gZnVuY3Rpb24oZnVuYykge1xuICAgICAgaWYgKHRoaXMudGFpbCgpID09PSBOaWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZ1bmModGhpcy5oZWFkKCksIHRoaXMudGFpbCgpLmZvbGRyMShmdW5jKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIExlaXN1cmVfQmFzZUNvbnMucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZvbGRsKChmdW5jdGlvbihpLCBlbCkge1xuICAgICAgICBpLnB1c2goZWwpO1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH0pLCBbXSk7XG4gICAgfTtcblxuICAgIExlaXN1cmVfQmFzZUNvbnMucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5qb2luKHN0cik7XG4gICAgfTtcblxuICAgIExlaXN1cmVfQmFzZUNvbnMucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnJldihOaWwpO1xuICAgIH07XG5cbiAgICBMZWlzdXJlX0Jhc2VDb25zLnByb3RvdHlwZS5yZXYgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRhaWwoKS5yZXYoY29ucyh0aGlzLmhlYWQoKSwgcmVzdWx0KSk7XG4gICAgfTtcblxuICAgIExlaXN1cmVfQmFzZUNvbnMucHJvdG90eXBlLmVsZW1lbnRTdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfcmVmMjtcblxuICAgICAgcmV0dXJuIFwiXCIgKyAoKChfcmVmMiA9IHRoaXMuaGVhZCgpKSAhPSBudWxsID8gX3JlZjIuY29uc3RydWN0b3IgOiB2b2lkIDApID09PSB0aGlzLmNvbnN0cnVjdG9yIHx8IHRoaXMuaGVhZCgpIGluc3RhbmNlb2YgTGVpc3VyZV9uaWwgPyAnWycgKyB0aGlzLmhlYWQoKS5lbGVtZW50U3RyaW5nKCkgKyAnXScgOiB0aGlzLmhlYWQoKSkgKyAodGhpcy50YWlsKCkgaW5zdGFuY2VvZiBMZWlzdXJlX25pbCA/ICcnIDogdGhpcy50YWlsKCkgaW5zdGFuY2VvZiBMZWlzdXJlX0Jhc2VDb25zID8gXCIgXCIgKyAodGhpcy50YWlsKCkuZWxlbWVudFN0cmluZygpKSA6IFwiIHwgXCIgKyAodGhpcy50YWlsKCkpKTtcbiAgICB9O1xuXG4gICAgTGVpc3VyZV9CYXNlQ29ucy5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzID09PSBvdGhlciB8fCAob3RoZXIgaW5zdGFuY2VvZiBMZWlzdXJlX0Jhc2VDb25zICYmIGNvbnNFcSh0aGlzLmhlYWQoKSwgb3RoZXIuaGVhZCgpKSAmJiBjb25zRXEodGhpcy50YWlsKCksIG90aGVyLnRhaWwoKSkpO1xuICAgIH07XG5cbiAgICBMZWlzdXJlX0Jhc2VDb25zLnByb3RvdHlwZS5lYWNoID0gZnVuY3Rpb24oYmxvY2spIHtcbiAgICAgIGJsb2NrKHRoaXMuaGVhZCgpKTtcbiAgICAgIHJldHVybiB0aGlzLnRhaWwoKS5lYWNoKGJsb2NrKTtcbiAgICB9O1xuXG4gICAgTGVpc3VyZV9CYXNlQ29ucy5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5mb2xkbCgoZnVuY3Rpb24oaSwgZWwpIHtcbiAgICAgICAgcmV0dXJuIGkgKyAxO1xuICAgICAgfSksIDApO1xuICAgIH07XG5cbiAgICBMZWlzdXJlX0Jhc2VDb25zLnByb3RvdHlwZS5sYXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdDtcblxuICAgICAgdCA9IHRoaXMudGFpbCgpO1xuICAgICAgaWYgKHQgPT09IE5pbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdC5sYXN0KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIExlaXN1cmVfQmFzZUNvbnMucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKGwpIHtcbiAgICAgIHJldHVybiBjb25zKHRoaXMuaGVhZCgpLCB0aGlzLnRhaWwoKS5hcHBlbmQobCkpO1xuICAgIH07XG5cbiAgICBMZWlzdXJlX0Jhc2VDb25zLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFwiXCIgKyAodGhpcy5zdHJpbmdOYW1lKCkpICsgXCJbXCIgKyAodGhpcy5lbGVtZW50U3RyaW5nKCkpICsgXCJdXCI7XG4gICAgfTtcblxuICAgIExlaXN1cmVfQmFzZUNvbnMucHJvdG90eXBlLnN0cmluZ05hbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBcIkJhc2VDb25zXCI7XG4gICAgfTtcblxuICAgIHJldHVybiBMZWlzdXJlX0Jhc2VDb25zO1xuXG4gIH0pKExlaXN1cmVPYmplY3QpO1xuXG4gIGNvbnNFcSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYSA9PT0gYiB8fCAoYSBpbnN0YW5jZW9mIExlaXN1cmVfQmFzZUNvbnMgJiYgYS5lcXVhbHMoYikpO1xuICB9O1xuXG4gIExlaXN1cmVfY29ucyA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGVpc3VyZV9jb25zLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gTGVpc3VyZV9jb25zKCkge1xuICAgICAgX3JlZjIgPSBMZWlzdXJlX2NvbnMuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjI7XG4gICAgfVxuXG4gICAgTGVpc3VyZV9jb25zLnByb3RvdHlwZS5oZWFkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcyhmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oYikge1xuICAgICAgICAgICAgcmV0dXJuIHJ6KGEpO1xuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgTGVpc3VyZV9jb25zLnByb3RvdHlwZS50YWlsID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcyhmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oYikge1xuICAgICAgICAgICAgcmV0dXJuIHJ6KGIpO1xuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgTGVpc3VyZV9jb25zLnByb3RvdHlwZS5zdHJpbmdOYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXCJDb25zXCI7XG4gICAgfTtcblxuICAgIHJldHVybiBMZWlzdXJlX2NvbnM7XG5cbiAgfSkoTGVpc3VyZV9CYXNlQ29ucyk7XG5cbiAgZ2xvYmFsLkxlaXN1cmVfY29ucyA9IExlaXN1cmVfY29ucztcblxuICBMZWlzdXJlX25pbCA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGVpc3VyZV9uaWwsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBMZWlzdXJlX25pbCgpIHtcbiAgICAgIF9yZWYzID0gTGVpc3VyZV9uaWwuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjM7XG4gICAgfVxuXG4gICAgTGVpc3VyZV9uaWwucHJvdG90eXBlLmlzTmlsID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgTGVpc3VyZV9uaWwucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBMZWlzdXJlX25pbC5wcm90b3R5cGUucmVtb3ZlQWxsID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgTGVpc3VyZV9uaWwucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgIHJldHVybiBOaWw7XG4gICAgfTtcblxuICAgIExlaXN1cmVfbmlsLnByb3RvdHlwZS5mb2xkbCA9IGZ1bmN0aW9uKGZ1bmMsIGFyZykge1xuICAgICAgcmV0dXJuIGFyZztcbiAgICB9O1xuXG4gICAgTGVpc3VyZV9uaWwucHJvdG90eXBlLmZvbGRyID0gZnVuY3Rpb24oZnVuYywgYXJnKSB7XG4gICAgICByZXR1cm4gYXJnO1xuICAgIH07XG5cbiAgICBMZWlzdXJlX25pbC5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIExlaXN1cmVfbmlsLnByb3RvdHlwZS5yZXYgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIExlaXN1cmVfbmlsLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xuICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgTGVpc3VyZV9uaWw7XG4gICAgfTtcblxuICAgIExlaXN1cmVfbmlsLnByb3RvdHlwZS5lYWNoID0gZnVuY3Rpb24oKSB7fTtcblxuICAgIExlaXN1cmVfbmlsLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfTtcblxuICAgIExlaXN1cmVfbmlsLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfTtcblxuICAgIExlaXN1cmVfbmlsLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihsKSB7XG4gICAgICByZXR1cm4gbDtcbiAgICB9O1xuXG4gICAgTGVpc3VyZV9uaWwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXCJDb25zW11cIjtcbiAgICB9O1xuXG4gICAgTGVpc3VyZV9uaWwucHJvdG90eXBlLmVsZW1lbnRTdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9O1xuXG4gICAgcmV0dXJuIExlaXN1cmVfbmlsO1xuXG4gIH0pKExlaXN1cmVPYmplY3QpO1xuXG4gIGdsb2JhbC5MZWlzdXJlX25pbCA9IExlaXN1cmVfbmlsO1xuXG4gIGpzVHlwZSA9IGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgdDtcblxuICAgIHQgPSB0eXBlb2YgdjtcbiAgICBpZiAodCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB2LmNvbnN0cnVjdG9yIHx8IHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0O1xuICAgIH1cbiAgfTtcblxuICBta1Byb3RvID0gZnVuY3Rpb24ocHJvdG9GdW5jLCB2YWx1ZSkge1xuICAgIHZhbHVlLl9fcHJvdG9fXyA9IHByb3RvRnVuYy5wcm90b3R5cGU7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIHRocm93RXJyb3IgPSBmdW5jdGlvbihtc2cpIHtcbiAgICB0aHJvdyAobXNnIGluc3RhbmNlb2YgRXJyb3IgPyBtc2cgOiBuZXcgRXJyb3IoU3RyaW5nKG1zZykpKTtcbiAgfTtcblxuICBjaGVja1R5cGUgPSBmdW5jdGlvbih2YWx1ZSwgdHlwZSkge1xuICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgdHlwZSkpIHtcbiAgICAgIHJldHVybiB0aHJvd0Vycm9yKFwiVHlwZSBlcnJvcjogZXhwZWN0ZWQgdHlwZTogXCIgKyB0eXBlICsgXCIsIGJ1dCBnb3Q6IFwiICsgKGpzVHlwZSh2YWx1ZSkpKTtcbiAgICB9XG4gIH07XG5cbiAgcHJpbUNvbnMgPSBzZXREYXRhVHlwZSgoZnVuY3Rpb24oYSkge1xuICAgIHJldHVybiBmdW5jdGlvbihiKSB7XG4gICAgICByZXR1cm4gbWtQcm90byhMZWlzdXJlX2NvbnMsIHNldFR5cGUoKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgcmV0dXJuIHJ6KGYpKGEpKGIpO1xuICAgICAgfSksICdjb25zJykpO1xuICAgIH07XG4gIH0pLCAnY29ucycpO1xuXG4gIE5pbCA9IG1rUHJvdG8oTGVpc3VyZV9uaWwsIHNldERhdGFUeXBlKHNldFR5cGUoKGZ1bmN0aW9uKGEpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYikge1xuICAgICAgcmV0dXJuIHJ6KGIpO1xuICAgIH07XG4gIH0pLCAnbmlsJyksICduaWwnKSk7XG5cbiAgY29ucyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gcHJpbUNvbnMobHooYSkpKGx6KGIpKTtcbiAgfTtcblxuICBmb2xkTGVmdCA9IGZ1bmN0aW9uKGZ1bmMsIHZhbCwgdGhpbmcpIHtcbiAgICBpZiAodGhpbmcgaW5zdGFuY2VvZiBMZWlzdXJlX2NvbnMpIHtcbiAgICAgIHJldHVybiB0aGluZy5mb2xkbChmdW5jLCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcHJpbUZvbGRMZWZ0KGZ1bmMsIHZhbCwgdGhpbmcsIDApO1xuICAgIH1cbiAgfTtcblxuICBwcmltRm9sZExlZnQgPSBmdW5jdGlvbihmdW5jLCB2YWwsIGFycmF5LCBpbmRleCkge1xuICAgIGlmIChpbmRleCA8IGFycmF5Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHByaW1Gb2xkTGVmdChmdW5jLCBmdW5jKHZhbCwgYXJyYXlbaW5kZXhdKSwgYXJyYXksIGluZGV4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICB9O1xuXG4gIGdsb2JhbC5sZWlzdXJlRnVuY3MgPSB7fTtcblxuICBnbG9iYWwubGVpc3VyZUZ1bmNOYW1lcyA9IE5pbDtcblxuICBsZWlzdXJlQWRkRnVuYyA9IGdsb2JhbC5sZWlzdXJlQWRkRnVuYyA9IGZ1bmN0aW9uKG5tKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5sZWlzdXJlRnVuY05hbWVzID0gY29ucyhubSwgZ2xvYmFsLmxlaXN1cmVGdW5jTmFtZXMpO1xuICB9O1xuXG4gIHJvb3QuZXZhbEZ1bmMgPSBldmFsRnVuYyA9IGV2YWw7XG5cbiAgcm9vdC5mdW5jdGlvbkNvdW50ID0gMDtcblxuICBmdW5jdGlvbkluZm8gPSB7fTtcblxuICBuYW1lRnVuYyA9IGZ1bmN0aW9uKGZ1bmMsIG5hbWUpIHtcbiAgICB2YXIgZjtcblxuICAgIGYgPSBudWxsO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChmID09PSBudWxsKSB7XG4gICAgICAgIGYgPSByeihmdW5jKTtcbiAgICAgICAgaWYgKHR5cGVvZiBmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZi5sZWlzdXJlTmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZjtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIGRlZmluZSA9IGZ1bmN0aW9uKG5hbWUsIGZ1bmMsIGFyaXR5LCBzcmMsIG1ldGhvZCkge1xuICAgIHZhciBubTtcblxuICAgIGZ1bmN0aW9uSW5mb1tuYW1lXSA9IHtcbiAgICAgIHNyYzogc3JjLFxuICAgICAgYXJpdHk6IGFyaXR5LFxuICAgICAgbGVpc3VyZU5hbWU6IG5hbWUsXG4gICAgICBhbHRzOiB7fSxcbiAgICAgIGFsdExpc3Q6IFtdXG4gICAgfTtcbiAgICBubSA9ICdMXycgKyBuYW1lU3ViKG5hbWUpO1xuICAgIGlmICghbWV0aG9kICYmIGdsb2JhbC5ub3JlZGVmcyAmJiAoZ2xvYmFsW25tXSAhPSBudWxsKSkge1xuICAgICAgdGhyb3dFcnJvcihcIltERUZdIEF0dGVtcHQgdG8gcmVkZWZpbmUgZGVmaW5pdGlvbjogXCIgKyBuYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb25JbmZvW25hbWVdLm1haW5EZWYgPSBnbG9iYWxbbm1dID0gZ2xvYmFsLmxlaXN1cmVGdW5jc1tubV0gPSBuYW1lRnVuYyhmdW5jLCBuYW1lKTtcbiAgICBsZWlzdXJlQWRkRnVuYyhuYW1lKTtcbiAgICByb290LmZ1bmN0aW9uQ291bnQrKztcbiAgICByZXR1cm4gZnVuYztcbiAgfTtcblxuICBMX2xpdCA9IHNldERhdGFUeXBlKChmdW5jdGlvbihfeCkge1xuICAgIHJldHVybiBzZXRUeXBlKChmdW5jdGlvbihfZikge1xuICAgICAgcmV0dXJuIHJ6KF9mKShfeCk7XG4gICAgfSksICdsaXQnKTtcbiAgfSksICdsaXQnKTtcblxuICBMX3JlZiA9IHNldERhdGFUeXBlKChmdW5jdGlvbihfeCkge1xuICAgIHJldHVybiBzZXRUeXBlKChmdW5jdGlvbihfZikge1xuICAgICAgcmV0dXJuIHJ6KF9mKShfeCk7XG4gICAgfSksICdyZWYnKTtcbiAgfSksICdyZWYnKTtcblxuICBMX2xhbWJkYSA9IHNldERhdGFUeXBlKChmdW5jdGlvbihfdikge1xuICAgIHJldHVybiBmdW5jdGlvbihfZikge1xuICAgICAgcmV0dXJuIHNldFR5cGUoKGZ1bmN0aW9uKF9nKSB7XG4gICAgICAgIHJldHVybiByeihfZykoX3YpKF9mKTtcbiAgICAgIH0pLCAnbGFtYmRhJyk7XG4gICAgfTtcbiAgfSksICdsYW1iZGEnKTtcblxuICBMX2FwcGx5ID0gc2V0RGF0YVR5cGUoKGZ1bmN0aW9uKF9mdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKF9hcmcpIHtcbiAgICAgIHJldHVybiBzZXRUeXBlKChmdW5jdGlvbihfZikge1xuICAgICAgICByZXR1cm4gcnooX2YpKF9mdW5jKShfYXJnKTtcbiAgICAgIH0pLCAnYXBwbHknKTtcbiAgICB9O1xuICB9KSwgJ2FwcGx5Jyk7XG5cbiAgTF9sZXQgPSBzZXREYXRhVHlwZSgoZnVuY3Rpb24oX24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oX3YpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihfYikge1xuICAgICAgICByZXR1cm4gc2V0VHlwZSgoZnVuY3Rpb24oX2YpIHtcbiAgICAgICAgICByZXR1cm4gcnooX2YpKF9uKShfdikoX2IpO1xuICAgICAgICB9KSwgJ2xldCcpO1xuICAgICAgfTtcbiAgICB9O1xuICB9KSwgJ2xldCcpO1xuXG4gIExfYW5ubyA9IHNldERhdGFUeXBlKChmdW5jdGlvbihfbmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihfZGF0YSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKF9ib2R5KSB7XG4gICAgICAgIHJldHVybiBzZXRUeXBlKChmdW5jdGlvbihfZikge1xuICAgICAgICAgIHJldHVybiByeihfZikoX25hbWUpKF9kYXRhKShfYm9keSk7XG4gICAgICAgIH0pLCAnYW5ubycpO1xuICAgICAgfTtcbiAgICB9O1xuICB9KSwgJ2Fubm8nKTtcblxuICBnZXRUeXBlID0gZnVuY3Rpb24oZikge1xuICAgIHZhciB0LCBfcmVmNDtcblxuICAgIHQgPSB0eXBlb2YgZjtcbiAgICByZXR1cm4gKHQgPT09ICdmdW5jdGlvbicgJiYgKGYgIT0gbnVsbCA/IGYudHlwZSA6IHZvaWQgMCkpIHx8IChcIipcIiArICgodCA9PT0gJ29iamVjdCcgJiYgKChfcmVmNCA9IGYuY29uc3RydWN0b3IpICE9IG51bGwgPyBfcmVmNC5uYW1lIDogdm9pZCAwKSkgfHwgdCkpO1xuICB9O1xuXG4gIGRlZmluZSgnZ2V0VHlwZScsIGx6KGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGdldFR5cGUocnoodmFsdWUpKTtcbiAgfSksIDEpO1xuXG4gIGdldERhdGFUeXBlID0gZnVuY3Rpb24oZikge1xuICAgIHJldHVybiAodHlwZW9mIGYgPT09ICdmdW5jdGlvbicgJiYgZi5kYXRhVHlwZSkgfHwgJyc7XG4gIH07XG5cbiAgZGVmaW5lKCdnZXREYXRhVHlwZScsIGx6KGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGdldERhdGFUeXBlKHJ6KHZhbHVlKSk7XG4gIH0pLCAxKTtcblxuICBzYXZlID0ge307XG5cbiAgc2F2ZS5saXQgPSBsaXQgPSBmdW5jdGlvbihsKSB7XG4gICAgcmV0dXJuIExfbGl0KGx6KGwpKTtcbiAgfTtcblxuICBzYXZlLnJlZiA9IHJlZiA9IGZ1bmN0aW9uKHIpIHtcbiAgICByZXR1cm4gTF9yZWYobHoocikpO1xuICB9O1xuXG4gIHNhdmUubGFtYmRhID0gbGFtYmRhID0gZnVuY3Rpb24odiwgYm9keSkge1xuICAgIHJldHVybiBMX2xhbWJkYShseih2KSkobHooYm9keSkpO1xuICB9O1xuXG4gIHNhdmUuYXBwbHkgPSBhcHBseSA9IGZ1bmN0aW9uKGYsIGEpIHtcbiAgICByZXR1cm4gTF9hcHBseShseihmKSkobHooYSkpO1xuICB9O1xuXG4gIHNhdmUubGxldCA9IGxsZXQgPSBmdW5jdGlvbihuLCB2LCBiKSB7XG4gICAgcmV0dXJuIExfbGV0KGx6KG4pKShseih2KSkobHooYikpO1xuICB9O1xuXG4gIHNhdmUuYW5ubyA9IGFubm8gPSBmdW5jdGlvbihuYW1lLCBkYXRhLCBib2R5KSB7XG4gICAgcmV0dXJuIExfYW5ubyhseihuYW1lKSkobHooZGF0YSkpKGx6KGJvZHkpKTtcbiAgfTtcblxuICBzYXZlLmNvbnMgPSBjb25zO1xuXG4gIGdldExpdFZhbCA9IGZ1bmN0aW9uKGx0KSB7XG4gICAgcmV0dXJuIGx0KGx6KGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiByeih2KTtcbiAgICB9KSk7XG4gIH07XG5cbiAgZ2V0UmVmTmFtZSA9IGZ1bmN0aW9uKHJmKSB7XG4gICAgcmV0dXJuIHJmKGx6KGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiByeih2KTtcbiAgICB9KSk7XG4gIH07XG5cbiAgZ2V0TGFtYmRhVmFyID0gZnVuY3Rpb24obGFtKSB7XG4gICAgcmV0dXJuIGxhbShseihmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYikge1xuICAgICAgICByZXR1cm4gcnoodik7XG4gICAgICB9O1xuICAgIH0pKTtcbiAgfTtcblxuICBnZXRMYW1iZGFCb2R5ID0gZnVuY3Rpb24obGFtKSB7XG4gICAgcmV0dXJuIGxhbShseihmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYikge1xuICAgICAgICByZXR1cm4gcnooYik7XG4gICAgICB9O1xuICAgIH0pKTtcbiAgfTtcblxuICBnZXRBcHBseUZ1bmMgPSBmdW5jdGlvbihhcGwpIHtcbiAgICByZXR1cm4gYXBsKGx6KGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihiKSB7XG4gICAgICAgIHJldHVybiByeihhKTtcbiAgICAgIH07XG4gICAgfSkpO1xuICB9O1xuXG4gIGdldEFwcGx5QXJnID0gZnVuY3Rpb24oYXBsKSB7XG4gICAgcmV0dXJuIGFwbChseihmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYikge1xuICAgICAgICByZXR1cm4gcnooYik7XG4gICAgICB9O1xuICAgIH0pKTtcbiAgfTtcblxuICBnZXRMZXROYW1lID0gZnVuY3Rpb24obHQpIHtcbiAgICByZXR1cm4gbHQobHooZnVuY3Rpb24obikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICByZXR1cm4gcnoobik7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH0pKTtcbiAgfTtcblxuICBnZXRMZXRWYWx1ZSA9IGZ1bmN0aW9uKGx0KSB7XG4gICAgcmV0dXJuIGx0KGx6KGZ1bmN0aW9uKG4pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihiKSB7XG4gICAgICAgICAgcmV0dXJuIHJ6KHYpO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9KSk7XG4gIH07XG5cbiAgZ2V0TGV0Qm9keSA9IGZ1bmN0aW9uKGx0KSB7XG4gICAgcmV0dXJuIGx0KGx6KGZ1bmN0aW9uKG4pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihiKSB7XG4gICAgICAgICAgcmV0dXJuIHJ6KGIpO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9KSk7XG4gIH07XG5cbiAgZ2V0QW5ub05hbWUgPSBmdW5jdGlvbihhbm5vKSB7XG4gICAgcmV0dXJuIGFubm8obHooZnVuY3Rpb24obmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgICAgICByZXR1cm4gcnoobmFtZSk7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH0pKTtcbiAgfTtcblxuICBnZXRBbm5vRGF0YSA9IGZ1bmN0aW9uKGFubm8pIHtcbiAgICByZXR1cm4gYW5ubyhseihmdW5jdGlvbihuYW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oYm9keSkge1xuICAgICAgICAgIHJldHVybiByeihkYXRhKTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfSkpO1xuICB9O1xuXG4gIGdldEFubm9Cb2R5ID0gZnVuY3Rpb24oYW5ubykge1xuICAgIHJldHVybiBhbm5vKGx6KGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihib2R5KSB7XG4gICAgICAgICAgcmV0dXJuIHJ6KGJvZHkpO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9KSk7XG4gIH07XG5cbiAganNvbjJBc3RFbmNvZGluZ3MgPSB7XG4gICAgbGl0OiBmdW5jdGlvbihqc29uKSB7XG4gICAgICByZXR1cm4gTF9saXQobHooanNvbi52YWx1ZSkpO1xuICAgIH0sXG4gICAgcmVmOiBmdW5jdGlvbihqc29uKSB7XG4gICAgICByZXR1cm4gTF9yZWYobHooanNvbi52YXJOYW1lKSk7XG4gICAgfSxcbiAgICBsYW1iZGE6IGZ1bmN0aW9uKGpzb24pIHtcbiAgICAgIHJldHVybiBMX2xhbWJkYShseihqc29uLnZhck5hbWUpKShseihqc29uMkFzdChqc29uLmJvZHkpKSk7XG4gICAgfSxcbiAgICBhcHBseTogZnVuY3Rpb24oanNvbikge1xuICAgICAgcmV0dXJuIExfYXBwbHkobHooanNvbjJBc3QoanNvbi5mdW5jKSkpKGx6KGpzb24yQXN0KGpzb24uYXJnKSkpO1xuICAgIH0sXG4gICAgXCJsZXRcIjogZnVuY3Rpb24oanNvbikge1xuICAgICAgcmV0dXJuIExfbGV0KGx6KGpzb24udmFyTmFtZSkpKGx6KGpzb24yQXN0KGpzb24udmFsdWUpKSkobHooanNvbjJBc3QoanNvbi5ib2R5KSkpO1xuICAgIH0sXG4gICAgYW5ubzogZnVuY3Rpb24oanNvbikge1xuICAgICAgcmV0dXJuIExfYW5ubyhseihqc29uLm5hbWUpKShseihqc29uMkFzdChqc29uLmRhdGEpKSkobHooanNvbjJBc3QoanNvbi5ib2R5KSkpO1xuICAgIH0sXG4gICAgY29uczogZnVuY3Rpb24oanNvbikge1xuICAgICAgcmV0dXJuIHNhdmUuY29ucyhqc29uMkFzdChqc29uLmhlYWQpLCBqc29uMkFzdChqc29uLnRhaWwpKTtcbiAgICB9LFxuICAgIG5pbDogZnVuY3Rpb24oanNvbikge1xuICAgICAgcmV0dXJuIE5pbDtcbiAgICB9XG4gIH07XG5cbiAgbGl0ID0gc2F2ZS5saXQ7XG5cbiAgcmVmID0gc2F2ZS5yZWY7XG5cbiAgbGFtYmRhID0gc2F2ZS5sYW1iZGE7XG5cbiAgYXBwbHkgPSBzYXZlLmFwcGx5O1xuXG4gIGxsZXQgPSBzYXZlLmxsZXQ7XG5cbiAgYW5ubyA9IHNhdmUuYW5ubztcblxuICBjb25zID0gc2F2ZS5jb25zO1xuXG4gIGpzb24yQXN0ID0gZnVuY3Rpb24oanNvbikge1xuICAgIGlmICh0eXBlb2YganNvbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBqc29uMkFzdEVuY29kaW5nc1tqc29uLl90eXBlXShqc29uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICB9O1xuXG4gIGFzdDJKc29uRW5jb2RpbmdzID0ge1xuICAgIExlaXN1cmVfbGl0OiBmdW5jdGlvbihhc3QpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIF90eXBlOiAnbGl0JyxcbiAgICAgICAgdmFsdWU6IGdldExpdFZhbChhc3QpXG4gICAgICB9O1xuICAgIH0sXG4gICAgTGVpc3VyZV9yZWY6IGZ1bmN0aW9uKGFzdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgX3R5cGU6ICdyZWYnLFxuICAgICAgICB2YXJOYW1lOiBnZXRSZWZOYW1lKGFzdClcbiAgICAgIH07XG4gICAgfSxcbiAgICBMZWlzdXJlX2xhbWJkYTogZnVuY3Rpb24oYXN0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBfdHlwZTogJ2xhbWJkYScsXG4gICAgICAgIHZhck5hbWU6IGdldExhbWJkYVZhcihhc3QpLFxuICAgICAgICBib2R5OiBhc3QySnNvbihnZXRMYW1iZGFCb2R5KGFzdCkpXG4gICAgICB9O1xuICAgIH0sXG4gICAgTGVpc3VyZV9hcHBseTogZnVuY3Rpb24oYXN0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBfdHlwZTogJ2FwcGx5JyxcbiAgICAgICAgZnVuYzogYXN0Mkpzb24oZ2V0QXBwbHlGdW5jKGFzdCkpLFxuICAgICAgICBhcmc6IGFzdDJKc29uKGdldEFwcGx5QXJnKGFzdCkpXG4gICAgICB9O1xuICAgIH0sXG4gICAgTGVpc3VyZV9sZXQ6IGZ1bmN0aW9uKGFzdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgX3R5cGU6ICdsZXQnLFxuICAgICAgICB2YXJOYW1lOiBnZXRMZXROYW1lKGFzdCksXG4gICAgICAgIHZhbHVlOiBhc3QySnNvbihnZXRMZXRWYWx1ZShhc3QpKSxcbiAgICAgICAgYm9keTogYXN0Mkpzb24oZ2V0TGV0Qm9keShhc3QpKVxuICAgICAgfTtcbiAgICB9LFxuICAgIExlaXN1cmVfYW5ubzogZnVuY3Rpb24oYXN0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBfdHlwZTogJ2Fubm8nLFxuICAgICAgICBuYW1lOiBnZXRBbm5vTmFtZShhc3QpLFxuICAgICAgICBkYXRhOiBhc3QySnNvbihnZXRBbm5vRGF0YShhc3QpKSxcbiAgICAgICAgYm9keTogYXN0Mkpzb24oZ2V0QW5ub0JvZHkoYXN0KSlcbiAgICAgIH07XG4gICAgfSxcbiAgICBMZWlzdXJlX2NvbnM6IGZ1bmN0aW9uKGFzdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgX3R5cGU6ICdjb25zJyxcbiAgICAgICAgaGVhZDogYXN0Mkpzb24oYXN0LmhlYWQoKSksXG4gICAgICAgIHRhaWw6IGFzdDJKc29uKGFzdC50YWlsKCkpXG4gICAgICB9O1xuICAgIH0sXG4gICAgTGVpc3VyZV9uaWw6IGZ1bmN0aW9uKGFzdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgX3R5cGU6ICduaWwnXG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICBhc3QySnNvbiA9IGZ1bmN0aW9uKGFzdCkge1xuICAgIHZhciBfcmVmNDtcblxuICAgIGlmIChhc3QySnNvbkVuY29kaW5nc1soX3JlZjQgPSBhc3QuY29uc3RydWN0b3IpICE9IG51bGwgPyBfcmVmNC5uYW1lIDogdm9pZCAwXSkge1xuICAgICAgcmV0dXJuIGFzdDJKc29uRW5jb2RpbmdzW2FzdC5jb25zdHJ1Y3Rvci5uYW1lXShhc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXN0O1xuICAgIH1cbiAgfTtcblxuICBkZWZpbmUoJ2pzb24yQXN0JywgbHooZnVuY3Rpb24oanNvbikge1xuICAgIHJldHVybiBqc29uMkFzdChKU09OLnBhcnNlKHJ6KGpzb24pKSk7XG4gIH0pKTtcblxuICBkZWZpbmUoJ2FzdDJKc29uJywgbHooZnVuY3Rpb24oYXN0KSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFzdDJKc29uKHJ6KGFzdCkpKTtcbiAgfSkpO1xuXG4gIGNvbnNGcm9tID0gZnVuY3Rpb24oYXJyYXksIGkpIHtcbiAgICBpID0gaSB8fCAwO1xuICAgIGlmIChpIDwgYXJyYXkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gY29ucyhhcnJheVtpXSwgY29uc0Zyb20oYXJyYXksIGkgKyAxKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBOaWw7XG4gICAgfVxuICB9O1xuXG4gIGhlYWQgPSBmdW5jdGlvbihsKSB7XG4gICAgcmV0dXJuIGwuaGVhZCgpO1xuICB9O1xuXG4gIHRhaWwgPSBmdW5jdGlvbihsKSB7XG4gICAgcmV0dXJuIGwudGFpbCgpO1xuICB9O1xuXG4gIHJvb3QuaGVhZCA9IGhlYWQ7XG5cbiAgcm9vdC50YWlsID0gdGFpbDtcblxuICByb290LmNvbnNGcm9tID0gY29uc0Zyb207XG5cbiAgcm9vdC5uYW1lU3ViID0gbmFtZVN1YjtcblxuICByb290LnNldERhdGFUeXBlID0gc2V0RGF0YVR5cGU7XG5cbiAgcm9vdC5zZXRUeXBlID0gc2V0VHlwZTtcblxuICByb290Lm1rUHJvdG8gPSBta1Byb3RvO1xuXG4gIHJvb3QuTmlsID0gTmlsO1xuXG4gIHJvb3QuY29ucyA9IGNvbnM7XG5cbiAgcm9vdC5wcmltQ29ucyA9IHByaW1Db25zO1xuXG4gIHJvb3QuZGVmaW5lID0gZGVmaW5lO1xuXG4gIHJvb3QuZ2V0VHlwZSA9IGdldFR5cGU7XG5cbiAgcm9vdC5nZXREYXRhVHlwZSA9IGdldERhdGFUeXBlO1xuXG4gIHJvb3QubGl0ID0gbGl0O1xuXG4gIHJvb3QucmVmID0gcmVmO1xuXG4gIHJvb3QubGFtYmRhID0gbGFtYmRhO1xuXG4gIHJvb3QuYXBwbHkgPSBhcHBseTtcblxuICByb290LmFubm8gPSBhbm5vO1xuXG4gIHJvb3QubGxldCA9IGxsZXQ7XG5cbiAgcm9vdC5nZXRSZWZOYW1lID0gZ2V0UmVmTmFtZTtcblxuICByb290LmdldExpdFZhbCA9IGdldExpdFZhbDtcblxuICByb290LmdldExhbWJkYUJvZHkgPSBnZXRMYW1iZGFCb2R5O1xuXG4gIHJvb3QuZ2V0TGFtYmRhVmFyID0gZ2V0TGFtYmRhVmFyO1xuXG4gIHJvb3QuZ2V0QXBwbHlGdW5jID0gZ2V0QXBwbHlGdW5jO1xuXG4gIHJvb3QuZ2V0QXBwbHlBcmcgPSBnZXRBcHBseUFyZztcblxuICByb290LmdldExldE5hbWUgPSBnZXRMZXROYW1lO1xuXG4gIHJvb3QuZ2V0TGV0VmFsdWUgPSBnZXRMZXRWYWx1ZTtcblxuICByb290LmdldExldEJvZHkgPSBnZXRMZXRCb2R5O1xuXG4gIHJvb3QuZ2V0QW5ub05hbWUgPSBnZXRBbm5vTmFtZTtcblxuICByb290LmdldEFubm9EYXRhID0gZ2V0QW5ub0RhdGE7XG5cbiAgcm9vdC5nZXRBbm5vQm9keSA9IGdldEFubm9Cb2R5O1xuXG4gIHJvb3QudGhyb3dFcnJvciA9IHRocm93RXJyb3I7XG5cbiAgcm9vdC5mb2xkTGVmdCA9IGZvbGRMZWZ0O1xuXG4gIHJvb3QuTGVpc3VyZU9iamVjdCA9IExlaXN1cmVPYmplY3Q7XG5cbiAgcm9vdC5ldmFsRnVuYyA9IGV2YWxGdW5jO1xuXG4gIHJvb3QuanNvbjJBc3QgPSBqc29uMkFzdDtcblxuICByb290LmFzdDJKc29uID0gYXN0Mkpzb247XG5cbiAgcm9vdC5MZWlzdXJlX2xpdCA9IExlaXN1cmVfbGl0O1xuXG4gIHJvb3QuTGVpc3VyZV9yZWYgPSBMZWlzdXJlX3JlZjtcblxuICByb290LkxlaXN1cmVfbGFtYmRhID0gTGVpc3VyZV9sYW1iZGE7XG5cbiAgcm9vdC5MZWlzdXJlX2FwcGx5ID0gTGVpc3VyZV9hcHBseTtcblxuICByb290LkxlaXN1cmVfbGV0ID0gTGVpc3VyZV9sZXQ7XG5cbiAgcm9vdC5MZWlzdXJlX2Fubm8gPSBMZWlzdXJlX2Fubm87XG5cbiAgcm9vdC5lbnN1cmVMZWlzdXJlQ2xhc3MgPSBlbnN1cmVMZWlzdXJlQ2xhc3M7XG5cbiAgcm9vdC5tYWtlU3VwZXIgPSBtYWtlU3VwZXI7XG5cbiAgcm9vdC5zdXBlcnR5cGVzID0gc3VwZXJ0eXBlcztcblxuICByb290LmZ1bmN0aW9uSW5mbyA9IGZ1bmN0aW9uSW5mbztcblxufSkuY2FsbCh0aGlzKTtcblxuLypcbi8vQCBzb3VyY2VNYXBwaW5nVVJMPWFzdC5tYXBcbiovXG5cbn0pKHNlbGYpIiwiKGZ1bmN0aW9uKGdsb2JhbCl7Ly8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjYuMlxuLypcbkNvcHlyaWdodCAoQykgMjAxMywgQmlsbCBCdXJkaWNrLCBUaW55IENvbmNlcHRzOiBodHRwczovL2dpdGh1Yi5jb20vem90L0xlaXN1cmVcblxuKGxpY2Vuc2VkIHdpdGggWkxJQiBsaWNlbnNlKVxuXG5UaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxud2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG5hcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuXG5QZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbmluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbmZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcblxuMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3RcbmNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG5pbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbmFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG5cbjIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG5taXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG5cbjMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG4qL1xuXG5cbihmdW5jdGlvbigpIHtcbiAgdmFyIFNpbXB5Q29ucywgZGVmYXVsdEVudiwgcmVhZERpciwgcmVhZEZpbGUsIHJvb3QsIHNpbXB5Q29ucywgc3RhdEZpbGUsIHdyaXRlRmlsZTtcblxuICByb290ID0gbW9kdWxlLmV4cG9ydHM7XG5cbiAgZGVmYXVsdEVudiA9IHtcbiAgICBwcmVzZW50VmFsdWU6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH0sXG4gICAgdmFsdWVzOiB7fSxcbiAgICBlcnJvckhhbmRsZXJzOiBbXVxuICB9O1xuXG4gIGdsb2JhbC5yZXNvbHZlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdmFsdWUubWVtbyB8fCAodmFsdWUubWVtbyA9IHZhbHVlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIGdsb2JhbC5sYXp5ID0gZnVuY3Rpb24obCkge1xuICAgIGlmICh0eXBlb2YgbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbDtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBsO1xuICAgIH1cbiAgfTtcblxuICByZWFkRmlsZSA9IGZ1bmN0aW9uKGZpbGVOYW1lLCBjb250KSB7XG4gICAgcmV0dXJuIGRlZmF1bHRFbnYucmVhZEZpbGUoZmlsZU5hbWUsIGNvbnQpO1xuICB9O1xuXG4gIHdyaXRlRmlsZSA9IGZ1bmN0aW9uKGZpbGVOYW1lLCBkYXRhLCBjb250KSB7XG4gICAgcmV0dXJuIGRlZmF1bHRFbnYud3JpdGVGaWxlKGZpbGVOYW1lLCBkYXRhLCBjb250KTtcbiAgfTtcblxuICByZWFkRGlyID0gZnVuY3Rpb24oZmlsZU5hbWUsIGNvbnQpIHtcbiAgICByZXR1cm4gZGVmYXVsdEVudi5yZWFkRGlyKGZpbGVOYW1lLCBjb250KTtcbiAgfTtcblxuICBzdGF0RmlsZSA9IGZ1bmN0aW9uKGZpbGVOYW1lLCBjb250KSB7XG4gICAgcmV0dXJuIGRlZmF1bHRFbnYuc3RhdEZpbGUoZmlsZU5hbWUsIGNvbnQpO1xuICB9O1xuXG4gIFNpbXB5Q29ucyA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBTaW1weUNvbnMoaGVhZCwgdGFpbCkge1xuICAgICAgdGhpcy5oZWFkID0gaGVhZDtcbiAgICAgIHRoaXMudGFpbCA9IHRhaWw7XG4gICAgfVxuXG4gICAgU2ltcHlDb25zLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJyYXksIGg7XG5cbiAgICAgIGggPSB0aGlzO1xuICAgICAgYXJyYXkgPSBbXTtcbiAgICAgIHdoaWxlIChoICE9PSBudWxsKSB7XG4gICAgICAgIGFycmF5LnB1c2goaC5oZWFkKTtcbiAgICAgICAgaCA9IGgudGFpbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNpbXB5Q29ucztcblxuICB9KSgpO1xuXG4gIHNpbXB5Q29ucyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gbmV3IFNpbXB5Q29ucyhhLCBiKTtcbiAgfTtcblxuICByb290LmRlZmF1bHRFbnYgPSBkZWZhdWx0RW52O1xuXG4gIHJvb3QucmVhZEZpbGUgPSByZWFkRmlsZTtcblxuICByb290LnJlYWREaXIgPSByZWFkRGlyO1xuXG4gIHJvb3Qud3JpdGVGaWxlID0gd3JpdGVGaWxlO1xuXG4gIHJvb3Quc3RhdEZpbGUgPSBzdGF0RmlsZTtcblxuICByb290LlNpbXB5Q29ucyA9IFNpbXB5Q29ucztcblxuICByb290LnNpbXB5Q29ucyA9IHNpbXB5Q29ucztcblxuICByb290LnJlc29sdmUgPSBnbG9iYWwucmVzb2x2ZTtcblxuICByb290LmxhenkgPSBnbG9iYWwubGF6eTtcblxufSkuY2FsbCh0aGlzKTtcblxuLypcbi8vQCBzb3VyY2VNYXBwaW5nVVJMPWJhc2UubWFwXG4qL1xuXG59KShzZWxmKSIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS42LjJcbihmdW5jdGlvbigpIHtcbiAgdmFyIExlaXN1cmUsIGV4cG9ydHMsIGssIG5iLCB2LCBfcmVmO1xuXG4gIHdpbmRvdy5tYXJrZWQgPSByZXF1aXJlKCcuL21hcmtlZCcpO1xuXG4gIExlaXN1cmUgPSBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Jhc2UnKTtcblxuICByZXF1aXJlKCcuL2FzdCcpO1xuXG4gIHJlcXVpcmUoJy4vZ2VuJyk7XG5cbiAgcmVxdWlyZSgnLi9ydW50aW1lJyk7XG5cbiAgcmVxdWlyZSgnLi9nZW5lcmF0ZWRQcmVsdWRlJyk7XG5cbiAgcmVxdWlyZSgnLi9zdGQnKTtcblxuICByZXF1aXJlKCcuL21kJyk7XG5cbiAgd2luZG93Lk5vdGVib29rID0gbmIgPSByZXF1aXJlKCcuL25vdGVib29rJyk7XG5cbiAgX3JlZiA9IHdpbmRvdy5MZWlzdXJlO1xuICBmb3IgKGsgaW4gX3JlZikge1xuICAgIHYgPSBfcmVmW2tdO1xuICAgIExlaXN1cmVba10gPSB2O1xuICB9XG5cbiAgd2luZG93LkxlaXN1cmUgPSBMZWlzdXJlO1xuXG59KS5jYWxsKHRoaXMpO1xuXG4vKlxuLy9AIHNvdXJjZU1hcHBpbmdVUkw9YnJvd3Nlck1haW4ubWFwXG4qL1xuIiwiKGZ1bmN0aW9uKGdsb2JhbCl7Ly8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjYuMlxuLypcbkNvcHlyaWdodCAoQykgMjAxMywgQmlsbCBCdXJkaWNrLCBUaW55IENvbmNlcHRzOiBodHRwczovL2dpdGh1Yi5jb20vem90L0xlaXN1cmVcblxuKGxpY2Vuc2VkIHdpdGggWkxJQiBsaWNlbnNlKVxuXG5UaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxud2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG5hcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuXG5QZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbmluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbmZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcblxuMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3RcbmNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG5pbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbmFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG5cbjIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG5taXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG5cbjMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG4qL1xuXG5cbihmdW5jdGlvbigpIHtcbiAgdmFyIExlaXN1cmVfYW5ubywgTGVpc3VyZV9hcHBseSwgTGVpc3VyZV9sYW1iZGEsIExlaXN1cmVfbGV0LCBMZWlzdXJlX2xpdCwgTGVpc3VyZV9yZWYsIE5pbCwgYWRkTGFtYmRhUHJvcGVydGllcywgYWRkVW5pcSwgYXJyYXlpZnksIGFzc29jTGlzdFByb3BzLCBjb25zLCBjb25zRnJvbSwgY3VycnksIGRlZmluZSwgZHVtcEFubm8sIGdlbiwgZ2VuQXBwbHksIGdlbkFwcGx5QXJnLCBnZW5MYW1iZGEsIGdlbkxldHMsIGdlblVuaXEsIGdldEFubm9Cb2R5LCBnZXRBbm5vRGF0YSwgZ2V0QW5ub05hbWUsIGdldEFwcGx5QXJnLCBnZXRBcHBseUZ1bmMsIGdldEFzc29jTGlzdFByb3BzLCBnZXRMYW1iZGFCb2R5LCBnZXRMYW1iZGFQcm9wZXJ0aWVzLCBnZXRMYW1iZGFWYXIsIGdldExhc3RMZXRCb2R5LCBnZXRMZXRCb2R5LCBnZXRMZXROYW1lLCBnZXRMZXRWYWx1ZSwgZ2V0TGl0VmFsLCBnZXRSZWZOYW1lLCBsYWNvbnMsIGxhenksIGxjb25zLCBsY29uc0Zyb20sIGxlZnQsIGxldExpc3QsIGx6LCBtYWtlU3luY01vbmFkLCBtZW1vaXplLCBuYW1lU3ViLCByZXNvbHZlLCByaWdodCwgcm9vdCwgcnVuTW9uYWQsIHJ6LCBzZXREYXRhVHlwZSwgc2V0VHlwZSwgc2ltcHlDb25zLCBzcGVjaWFsQW5ub3RhdGlvbnMsIHVuaXFOYW1lLCB2YXJOYW1lU3ViLCBfLCBfZmFsc2UsIF9yZWYsIF9yZWYxLCBfcmVmMixcbiAgICBfX3NsaWNlID0gW10uc2xpY2U7XG5cbiAgX3JlZiA9IHJlcXVpcmUoJy4vYmFzZScpLCBzaW1weUNvbnMgPSBfcmVmLnNpbXB5Q29ucywgcmVzb2x2ZSA9IF9yZWYucmVzb2x2ZSwgbGF6eSA9IF9yZWYubGF6eTtcblxuICByeiA9IHJlc29sdmU7XG5cbiAgbHogPSBsYXp5O1xuXG4gIF9yZWYxID0gcm9vdCA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9hc3QnKSwgbmFtZVN1YiA9IF9yZWYxLm5hbWVTdWIsIGdldExpdFZhbCA9IF9yZWYxLmdldExpdFZhbCwgZ2V0UmVmTmFtZSA9IF9yZWYxLmdldFJlZk5hbWUsIGdldExhbWJkYVZhciA9IF9yZWYxLmdldExhbWJkYVZhciwgZ2V0TGFtYmRhQm9keSA9IF9yZWYxLmdldExhbWJkYUJvZHksIGdldEFwcGx5RnVuYyA9IF9yZWYxLmdldEFwcGx5RnVuYywgZ2V0QXBwbHlBcmcgPSBfcmVmMS5nZXRBcHBseUFyZywgZ2V0QW5ub05hbWUgPSBfcmVmMS5nZXRBbm5vTmFtZSwgZ2V0QW5ub0RhdGEgPSBfcmVmMS5nZXRBbm5vRGF0YSwgZ2V0QW5ub0JvZHkgPSBfcmVmMS5nZXRBbm5vQm9keSwgZ2V0TGV0TmFtZSA9IF9yZWYxLmdldExldE5hbWUsIGdldExldFZhbHVlID0gX3JlZjEuZ2V0TGV0VmFsdWUsIGdldExldEJvZHkgPSBfcmVmMS5nZXRMZXRCb2R5LCBMZWlzdXJlX2xpdCA9IF9yZWYxLkxlaXN1cmVfbGl0LCBMZWlzdXJlX3JlZiA9IF9yZWYxLkxlaXN1cmVfcmVmLCBMZWlzdXJlX2xhbWJkYSA9IF9yZWYxLkxlaXN1cmVfbGFtYmRhLCBMZWlzdXJlX2FwcGx5ID0gX3JlZjEuTGVpc3VyZV9hcHBseSwgTGVpc3VyZV9sZXQgPSBfcmVmMS5MZWlzdXJlX2xldCwgTGVpc3VyZV9hbm5vID0gX3JlZjEuTGVpc3VyZV9hbm5vLCBzZXRUeXBlID0gX3JlZjEuc2V0VHlwZSwgc2V0RGF0YVR5cGUgPSBfcmVmMS5zZXREYXRhVHlwZSwgY29ucyA9IF9yZWYxLmNvbnMsIE5pbCA9IF9yZWYxLk5pbCwgY29uc0Zyb20gPSBfcmVmMS5jb25zRnJvbSwgZGVmaW5lID0gX3JlZjEuZGVmaW5lO1xuXG4gIF9yZWYyID0gcmVxdWlyZSgnLi9ydW50aW1lJyksIG1ha2VTeW5jTW9uYWQgPSBfcmVmMi5tYWtlU3luY01vbmFkLCBydW5Nb25hZCA9IF9yZWYyLnJ1bk1vbmFkLCBfZmFsc2UgPSBfcmVmMi5fZmFsc2UsIGxlZnQgPSBfcmVmMi5sZWZ0LCByaWdodCA9IF9yZWYyLnJpZ2h0O1xuXG4gIF8gPSByZXF1aXJlKCcuL2xvZGFzaC5taW4nKTtcblxuICB2YXJOYW1lU3ViID0gZnVuY3Rpb24obikge1xuICAgIHJldHVybiBcIkxfXCIgKyAobmFtZVN1YihuKSk7XG4gIH07XG5cbiAgZ2VuID0gZnVuY3Rpb24oYXN0KSB7XG4gICAgcmV0dXJuIGdlblVuaXEoYXN0LCBOaWwsIFtOaWwsIDBdKTtcbiAgfTtcblxuICBnZW5VbmlxID0gZnVuY3Rpb24oYXN0LCBuYW1lcywgdW5pcSkge1xuICAgIHZhciBhcml0eSwgZGF0YSwgZnVuY05hbWUsIGdlbm5lZCwgbmFtZSwgc3JjLCBfcmVmMztcblxuICAgIHN3aXRjaCAoYXN0LmNvbnN0cnVjdG9yKSB7XG4gICAgICBjYXNlIExlaXN1cmVfbGl0OlxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZ2V0TGl0VmFsKGFzdCkpO1xuICAgICAgY2FzZSBMZWlzdXJlX3JlZjpcbiAgICAgICAgcmV0dXJuIFwicmVzb2x2ZShcIiArICh1bmlxTmFtZShnZXRSZWZOYW1lKGFzdCksIHVuaXEpKSArIFwiKVwiO1xuICAgICAgY2FzZSBMZWlzdXJlX2xhbWJkYTpcbiAgICAgICAgcmV0dXJuIGdlbkxhbWJkYShhc3QsIG5hbWVzLCB1bmlxLCAwKTtcbiAgICAgIGNhc2UgTGVpc3VyZV9hcHBseTpcbiAgICAgICAgcmV0dXJuIFwiXCIgKyAoZ2VuVW5pcShnZXRBcHBseUZ1bmMoYXN0KSwgbmFtZXMsIHVuaXEpKSArIFwiKFwiICsgKGdlbkFwcGx5QXJnKGdldEFwcGx5QXJnKGFzdCksIG5hbWVzLCB1bmlxKSkgKyBcIilcIjtcbiAgICAgIGNhc2UgTGVpc3VyZV9sZXQ6XG4gICAgICAgIHJldHVybiBcIihmdW5jdGlvbigpe1xcblwiICsgKGdlbkxldHMoYXN0LCBuYW1lcywgdW5pcSkpICsgXCJ9KSgpXCI7XG4gICAgICBjYXNlIExlaXN1cmVfYW5ubzpcbiAgICAgICAgbmFtZSA9IGdldEFubm9OYW1lKGFzdCk7XG4gICAgICAgIGRhdGEgPSBnZXRBbm5vRGF0YShhc3QpO1xuICAgICAgICBnZW5uZWQgPSBnZW5VbmlxKGdldEFubm9Cb2R5KGFzdCksIG5hbWVzLCB1bmlxKTtcbiAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgY2FzZSAndHlwZSc6XG4gICAgICAgICAgICByZXR1cm4gXCJzZXRUeXBlKFwiICsgZ2VubmVkICsgXCIsICdcIiArIGRhdGEgKyBcIicpXCI7XG4gICAgICAgICAgY2FzZSAnZGF0YVR5cGUnOlxuICAgICAgICAgICAgcmV0dXJuIFwic2V0RGF0YVR5cGUoXCIgKyBnZW5uZWQgKyBcIiwgJ1wiICsgZGF0YSArIFwiJylcIjtcbiAgICAgICAgICBjYXNlICdkZWZpbmUnOlxuICAgICAgICAgICAgX3JlZjMgPSBkYXRhLnRvQXJyYXkoKSwgZnVuY05hbWUgPSBfcmVmM1swXSwgYXJpdHkgPSBfcmVmM1sxXSwgc3JjID0gX3JlZjNbMl07XG4gICAgICAgICAgICByZXR1cm4gXCJkZWZpbmUoJ1wiICsgZnVuY05hbWUgKyBcIicsIChmdW5jdGlvbigpe3JldHVybiBcIiArIGdlbm5lZCArIFwifSksIFwiICsgYXJpdHkgKyBcIiwgXCIgKyAoSlNPTi5zdHJpbmdpZnkoc3JjKSkgKyBcIilcIjtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGdlbm5lZDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBcIkRVUj8gXCIgKyBhc3QgKyBcIiwgXCIgKyBhc3QuY29uc3RydWN0b3IgKyBcIiBcIiArIExlaXN1cmVfbGFtYmRhO1xuICAgIH1cbiAgfTtcblxuICBnZW5MYW1iZGEgPSBmdW5jdGlvbihhc3QsIG5hbWVzLCB1bmlxLCBjb3VudCkge1xuICAgIHZhciBuLCBuYW1lLCB1O1xuXG4gICAgbmFtZSA9IGdldExhbWJkYVZhcihhc3QpO1xuICAgIHUgPSBhZGRVbmlxKG5hbWUsIG5hbWVzLCB1bmlxKTtcbiAgICBuID0gY29ucyhuYW1lLCBuYW1lcyk7XG4gICAgcmV0dXJuIGFkZExhbWJkYVByb3BlcnRpZXMoYXN0LCBcImZ1bmN0aW9uKFwiICsgKHVuaXFOYW1lKG5hbWUsIHUpKSArIFwiKXtyZXR1cm4gXCIgKyAoZ2VuVW5pcShnZXRMYW1iZGFCb2R5KGFzdCksIG4sIHUpKSArIFwifVwiKTtcbiAgfTtcblxuICBzcGVjaWFsQW5ub3RhdGlvbnMgPSBbJ3R5cGUnLCAnZGF0YVR5cGUnLCAnZGVmaW5lJ107XG5cbiAgYXJyYXlpZnkgPSBmdW5jdGlvbihjb25zKSB7XG4gICAgaWYgKGNvbnMgaW5zdGFuY2VvZiBMZWlzdXJlX2NvbnMpIHtcbiAgICAgIHJldHVybiBjb25zLm1hcChmdW5jdGlvbihlbCkge1xuICAgICAgICByZXR1cm4gYXJyYXlpZnkoZWwpO1xuICAgICAgfSkudG9BcnJheSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY29ucztcbiAgICB9XG4gIH07XG5cbiAgZ2V0TGFtYmRhUHJvcGVydGllcyA9IGZ1bmN0aW9uKGJvZHksIHByb3BzKSB7XG4gICAgdmFyIHZhbHVlO1xuXG4gICAgaWYgKGJvZHkgaW5zdGFuY2VvZiBMZWlzdXJlX2Fubm8pIHtcbiAgICAgIGlmICghXy5jb250YWlucyhzcGVjaWFsQW5ub3RhdGlvbnMsIGdldEFubm9OYW1lKGJvZHkpKSkge1xuICAgICAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgICAgcHJvcHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IGdldEFubm9EYXRhKGJvZHkpO1xuICAgICAgICBwcm9wc1tnZXRBbm5vTmFtZShib2R5KV0gPSBhcnJheWlmeSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBnZXRMYW1iZGFQcm9wZXJ0aWVzKGdldEFubm9Cb2R5KGJvZHkpLCBwcm9wcyk7XG4gICAgfVxuICAgIHJldHVybiBwcm9wcztcbiAgfTtcblxuICBhZGRMYW1iZGFQcm9wZXJ0aWVzID0gZnVuY3Rpb24oYXN0LCBkZWYpIHtcbiAgICB2YXIgcHJvcHM7XG5cbiAgICBwcm9wcyA9IGdldExhbWJkYVByb3BlcnRpZXMoZ2V0TGFtYmRhQm9keShhc3QpKTtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIHJldHVybiBcInNldExhbWJkYVByb3BlcnRpZXMoXCIgKyBkZWYgKyBcIiwgXCIgKyAoSlNPTi5zdHJpbmdpZnkocHJvcHMpKSArIFwiKVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGVmO1xuICAgIH1cbiAgfTtcblxuICBsY29ucyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gcnooTF9jb25zKShseihhKSkobHooYikpO1xuICB9O1xuXG4gIGxjb25zRnJvbSA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIGVsLCBwLCBfaSwgX2xlbiwgX3JlZjM7XG5cbiAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgcCA9IHJ6KExfbmlsKTtcbiAgICAgIF9yZWYzID0gYXJyYXkucmV2ZXJzZSgpO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBlbCA9IF9yZWYzW19pXTtcbiAgICAgICAgcCA9IGxjb25zKGxjb25zRnJvbShlbCksIHApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG4gIH07XG5cbiAgYXNzb2NMaXN0UHJvcHMgPSBudWxsO1xuXG4gIGdldEFzc29jTGlzdFByb3BzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFhc3NvY0xpc3RQcm9wcykge1xuICAgICAgYXNzb2NMaXN0UHJvcHMgPSBsY29ucyhsY29ucygnYXNzb2MnLCAndHJ1ZScpLCByeihMX25pbCkpO1xuICAgICAgYXNzb2NMaXN0UHJvcHMucHJvcGVydGllcyA9IGFzc29jTGlzdFByb3BzO1xuICAgIH1cbiAgICByZXR1cm4gYXNzb2NMaXN0UHJvcHM7XG4gIH07XG5cbiAgbGFjb25zID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSwgbGlzdCkge1xuICAgIHZhciBhbGlzdDtcblxuICAgIGFsaXN0ID0gbGNvbnMobGNvbnMoa2V5LCB2YWx1ZSksIGxpc3QpO1xuICAgIGFsaXN0LnByb3BlcnRpZXMgPSBnZXRBc3NvY0xpc3RQcm9wcygpO1xuICAgIHJldHVybiBhbGlzdDtcbiAgfTtcblxuICBnbG9iYWwuc2V0TGFtYmRhUHJvcGVydGllcyA9IGZ1bmN0aW9uKGRlZiwgcHJvcHMpIHtcbiAgICB2YXIgaywgcCwgdjtcblxuICAgIHAgPSByeihMX25pbCk7XG4gICAgZm9yIChrIGluIHByb3BzKSB7XG4gICAgICB2ID0gcHJvcHNba107XG4gICAgICBwID0gbGFjb25zKGssIGxjb25zRnJvbSh2KSwgcCk7XG4gICAgfVxuICAgIGRlZi5wcm9wZXJ0aWVzID0gcDtcbiAgICByZXR1cm4gZGVmO1xuICB9O1xuXG4gIG1lbW9pemUgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgcmV0dXJuIFwiZnVuY3Rpb24oKXtyZXR1cm4gXCIgKyBmdW5jICsgXCJ9XCI7XG4gIH07XG5cbiAgZHVtcEFubm8gPSBmdW5jdGlvbihhc3QpIHtcbiAgICBpZiAoYXN0IGluc3RhbmNlb2YgTGVpc3VyZV9hbm5vKSB7XG4gICAgICByZXR1cm4gZHVtcEFubm8oZ2V0QW5ub0JvZHkoYXN0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuICB9O1xuXG4gIGdlbkFwcGx5ID0gZnVuY3Rpb24oYXN0LCBuYW1lcywgdW5pcSkge1xuICAgIHZhciBhcmdzO1xuXG4gICAgYXJncyA9IFtdO1xuICAgIHdoaWxlIChkdW1wQW5ubyhhc3QpIGluc3RhbmNlb2YgTGVpc3VyZV9hcHBseSkge1xuICAgICAgYXJncy5wdXNoKFwiKFwiICsgKGdlbkFwcGx5QXJnKGdldEFwcGx5QXJnKGR1bXBBbm5vKGFzdCkpLCBuYW1lcywgdW5pcSkpICsgXCIpXCIpO1xuICAgICAgYXN0ID0gZ2V0QXBwbHlGdW5jKGR1bXBBbm5vKGFzdCkpO1xuICAgIH1cbiAgICBhcmdzLnJldmVyc2UoKTtcbiAgICByZXR1cm4gXCJcIiArIChnZW5VbmlxKGFzdCwgbmFtZXMsIHVuaXEpKSArIFwiLmxlaXN1cmVDYWxsKFwiICsgKGFyZ3Muam9pbignLCAnKSkgKyBcIilcIjtcbiAgfTtcblxuICBnZW5BcHBseUFyZyA9IGZ1bmN0aW9uKGFyZywgbmFtZXMsIHVuaXEpIHtcbiAgICBpZiAoZHVtcEFubm8oYXJnKSBpbnN0YW5jZW9mIExlaXN1cmVfYXBwbHkpIHtcbiAgICAgIHJldHVybiBtZW1vaXplKGdlblVuaXEoYXJnLCBuYW1lcywgdW5pcSkpO1xuICAgIH0gZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgTGVpc3VyZV9yZWYpIHtcbiAgICAgIHJldHVybiB1bmlxTmFtZShnZXRSZWZOYW1lKGFyZyksIHVuaXEpO1xuICAgIH0gZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgTGVpc3VyZV9saXQpIHtcbiAgICAgIHJldHVybiBcIlwiICsgKEpTT04uc3RyaW5naWZ5KGdldExpdFZhbChhcmcpKSk7XG4gICAgfSBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBMZWlzdXJlX2xldCkge1xuICAgICAgcmV0dXJuIFwiZnVuY3Rpb24oKXtcIiArIChnZW5MZXRzKGFyZywgbmFtZXMsIHVuaXEpKSArIFwifVwiO1xuICAgIH0gZWxzZSBpZiAoZHVtcEFubm8oYXJnKSBpbnN0YW5jZW9mIExlaXN1cmVfbGFtYmRhKSB7XG4gICAgICByZXR1cm4gXCJsYXp5KFwiICsgKGdlblVuaXEoYXJnLCBuYW1lcywgdW5pcSkpICsgXCIpXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcImZ1bmN0aW9uKCl7cmV0dXJuIFwiICsgKGdlblVuaXEoYXJnLCBuYW1lcywgdW5pcSkpICsgXCJ9XCI7XG4gICAgfVxuICB9O1xuXG4gIGdlbkxldHMgPSBmdW5jdGlvbihhc3QsIG5hbWVzLCB1bmlxKSB7XG4gICAgdmFyIGFzc2lnbnMsIGRlY3MsIF9yZWYzO1xuXG4gICAgX3JlZjMgPSBfLmZvbGRsKGxldExpc3QoYXN0LCBbXSksIChmdW5jdGlvbihyZXN1bHQsIGwpIHtcbiAgICAgIHZhciBjb2RlLCBsZXROYW1lLCBsZXROYW1lcywgbiwgbmV3VSwgdTtcblxuICAgICAgbiA9IHJlc3VsdFswXSwgdSA9IHJlc3VsdFsxXSwgbGV0TmFtZXMgPSByZXN1bHRbMl0sIGNvZGUgPSByZXN1bHRbM107XG4gICAgICBuZXdVID0gYWRkVW5pcShnZXRMZXROYW1lKGwpLCBuLCB1KTtcbiAgICAgIGxldE5hbWUgPSB1bmlxTmFtZShnZXRMZXROYW1lKGwpLCBuZXdVKTtcbiAgICAgIHJldHVybiBbY29ucyhnZXRMZXROYW1lKGwpLCBuKSwgbmV3VSwgY29ucyhsZXROYW1lLCBsZXROYW1lcyksIGNvbnMoJ1xcbicgKyBsZXROYW1lICsgJyA9ICcgKyBnZW5BcHBseUFyZyhnZXRMZXRWYWx1ZShsKSwgbiwgdSksIGNvZGUpXTtcbiAgICB9KSwgW25hbWVzLCB1bmlxLCBOaWwsIE5pbF0pLCBuYW1lcyA9IF9yZWYzWzBdLCB1bmlxID0gX3JlZjNbMV0sIGRlY3MgPSBfcmVmM1syXSwgYXNzaWducyA9IF9yZWYzWzNdO1xuICAgIHJldHVybiBcIlxcbnZhciBcIiArIChkZWNzLmpvaW4oJywgJykpICsgXCI7XFxuXCIgKyAoYXNzaWducy5qb2luKCc7XFxuJykpICsgXCI7XFxucmV0dXJuIFwiICsgKGdlblVuaXEoZ2V0TGFzdExldEJvZHkoYXN0KSwgbmFtZXMsIHVuaXEpKTtcbiAgfTtcblxuICBhZGRVbmlxID0gZnVuY3Rpb24obmFtZSwgbmFtZXMsIHVuaXEpIHtcbiAgICB2YXIgbnVtLCBvdmVycmlkZXM7XG5cbiAgICBpZiAoKG5hbWVzLmZpbmQoZnVuY3Rpb24oZWwpIHtcbiAgICAgIHJldHVybiBlbCA9PT0gbmFtZTtcbiAgICB9KSkgIT09IE5pbCkge1xuICAgICAgb3ZlcnJpZGVzID0gdW5pcVswXSwgbnVtID0gdW5pcVsxXTtcbiAgICAgIHJldHVybiBbY29ucyhjb25zKG5hbWUsIFwiXCIgKyBuYW1lICsgXCJfXCIgKyBudW0pLCBvdmVycmlkZXMpLCBudW0gKyAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuaXE7XG4gICAgfVxuICB9O1xuXG4gIHVuaXFOYW1lID0gZnVuY3Rpb24obmFtZSwgdW5pcSkge1xuICAgIHZhciBrdjtcblxuICAgIHVuaXEgPSB1bmlxWzBdO1xuICAgIGt2ID0gdW5pcS5maW5kKChmdW5jdGlvbihlbCkge1xuICAgICAgcmV0dXJuIGVsLmhlYWQoKSA9PT0gbmFtZTtcbiAgICB9KSwgdW5pcSk7XG4gICAgcmV0dXJuIHZhck5hbWVTdWIoKGt2ICE9PSBOaWwgPyBrdi50YWlsKCkgOiBuYW1lKSk7XG4gIH07XG5cbiAgbGV0TGlzdCA9IGZ1bmN0aW9uKGFzdCwgYnVmKSB7XG4gICAgaWYgKGFzdCBpbnN0YW5jZW9mIExlaXN1cmVfbGV0KSB7XG4gICAgICBidWYucHVzaChhc3QpO1xuICAgICAgcmV0dXJuIGxldExpc3QoZ2V0TGV0Qm9keShhc3QpLCBidWYpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgfTtcblxuICBnZXRMYXN0TGV0Qm9keSA9IGZ1bmN0aW9uKGFzdCkge1xuICAgIGlmIChhc3QgaW5zdGFuY2VvZiBMZWlzdXJlX2xldCkge1xuICAgICAgcmV0dXJuIGdldExhc3RMZXRCb2R5KGdldExldEJvZHkoYXN0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuICB9O1xuXG4gIGRlZmluZSgncnVuQXN0JywgbHooZnVuY3Rpb24oYXN0KSB7XG4gICAgdmFyIGVycjtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZXZhbChcIihcIiArIChnZW4ocnooYXN0KSkpICsgXCIpXCIpO1xuICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgZXJyID0gX2Vycm9yO1xuICAgICAgcmV0dXJuIHJ6KExfcGFyc2VFcnIpKGx6KFwiXFxuXFxuUGFyc2UgZXJyb3I6IFwiICsgZXJyLnRvU3RyaW5nKCkgKyBcIlxcbkFTVDogXCIpKShhc3QpO1xuICAgIH1cbiAgfSkpO1xuXG4gIGN1cnJ5ID0gZnVuY3Rpb24oZnVuYywgYXJncywgcG9zKSB7XG4gICAgaWYgKHBvcyA9PT0gZnVuYy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGFyZ3MudG9BcnJheShmdW5jLmxlbmd0aCAtIDEsIFtdKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJ5KGZ1bmMsIHNpbXB5Q29ucyhhcmcsIGFyZ3MpLCBwb3MgKyAxKTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIEZ1bmN0aW9uLnByb3RvdHlwZS5sZWlzdXJlQ2FsbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhLCBhcmdzLCBmLCBuZXh0LCBwb3M7XG5cbiAgICBhcmdzID0gMSA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkgOiBbXTtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IHRoaXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9zID0gMDtcbiAgICAgIGYgPSB0aGlzO1xuICAgICAgd2hpbGUgKHBvcyA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIG5leHQgPSBwb3MgKyBmLmxlbmd0aDtcbiAgICAgICAgaWYgKG5leHQgPD0gYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICBmID0gZi5hcHBseShudWxsLCBhcmdzLnNsaWNlKHBvcywgbmV4dCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGEgPSBhcmdzLnNsaWNlKHBvcyk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG5ld0FyZ3M7XG5cbiAgICAgICAgICAgIG5ld0FyZ3MgPSAxIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBfX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSA6IFtdO1xuICAgICAgICAgICAgcmV0dXJuIGYubGVpc3VyZUNhbGwuYXBwbHkoZiwgYS5jb25jYXQobmV3QXJncykpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmO1xuICAgIH1cbiAgfTtcblxuICByb290LmdlbiA9IGdlbjtcblxuICByb290LmN1cnJ5ID0gY3Vycnk7XG5cbn0pLmNhbGwodGhpcyk7XG5cbi8qXG4vL0Agc291cmNlTWFwcGluZ1VSTD1nZW4ubWFwXG4qL1xuXG59KShzZWxmKSIsIkxfcnVuTW9uYWRzKFtcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJ0cnVlXCIpKDApKFwidHJ1ZSA9IFxcXFxhIGIgLiBhXCIpKGxhenkoc2V0RGF0YVR5cGUoc2V0VHlwZShmdW5jdGlvbihMX2Epe3JldHVybiBmdW5jdGlvbihMX2Ipe3JldHVybiByZXNvbHZlKExfYSl9fSwgJ3RydWUnKSwgJ3RydWUnKSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJmYWxzZVwiKSgwKShcImZhbHNlID0gXFxcXGEgYiAuIGJcIikobGF6eShzZXREYXRhVHlwZShzZXRUeXBlKGZ1bmN0aW9uKExfYSl7cmV0dXJuIGZ1bmN0aW9uKExfYil7cmV0dXJuIHJlc29sdmUoTF9iKX19LCAnZmFsc2UnKSwgJ2ZhbHNlJykpKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwibm90XCIpKDEpKFwibm90IGIgPSBiIGZhbHNlIHRydWVcIikobGF6eShmdW5jdGlvbihMX2Ipe3JldHVybiByZXNvbHZlKExfYikoTF9mYWxzZSkoTF90cnVlKX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwiYW5kXCIpKDIpKFwiYW5kIGEgYiA9IGEgYiBmYWxzZVwiKShsYXp5KGZ1bmN0aW9uKExfYSl7cmV0dXJuIGZ1bmN0aW9uKExfYil7cmV0dXJuIHJlc29sdmUoTF9hKShMX2IpKExfZmFsc2UpfX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwib3JcIikoMikoXCJvciBhIGIgPSBhIHRydWUgYlwiKShsYXp5KGZ1bmN0aW9uKExfYSl7cmV0dXJuIGZ1bmN0aW9uKExfYil7cmV0dXJuIHJlc29sdmUoTF9hKShMX3RydWUpKExfYil9fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJzb21lXCIpKDEpKFwic29tZSB4ID0gXFxcXHNvbWVDYXNlIG5vbmVDYXNlIC4gc29tZUNhc2UgeFwiKShsYXp5KHNldERhdGFUeXBlKGZ1bmN0aW9uKExfeCl7cmV0dXJuIHNldFR5cGUoZnVuY3Rpb24oTF9zb21lQ2FzZSl7cmV0dXJuIGZ1bmN0aW9uKExfbm9uZUNhc2Upe3JldHVybiByZXNvbHZlKExfc29tZUNhc2UpKExfeCl9fSwgJ3NvbWUnKX0sICdzb21lJykpKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwic29tZTJcIikoMikoXCJzb21lMiBhIGIgPSBcXFxcc29tZUNhc2Ugbm9uZUNhc2UgLiBzb21lQ2FzZSBhIGJcIikobGF6eShzZXREYXRhVHlwZShmdW5jdGlvbihMX2Epe3JldHVybiBmdW5jdGlvbihMX2Ipe3JldHVybiBzZXRUeXBlKGZ1bmN0aW9uKExfc29tZUNhc2Upe3JldHVybiBmdW5jdGlvbihMX25vbmVDYXNlKXtyZXR1cm4gcmVzb2x2ZShMX3NvbWVDYXNlKShMX2EpKExfYil9fSwgJ3NvbWUyJyl9fSwgJ3NvbWUyJykpKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwibm9uZVwiKSgwKShcIm5vbmUgPSBcXFxcc29tZUNhc2Ugbm9uZUNhc2UgLiBub25lQ2FzZVwiKShsYXp5KHNldERhdGFUeXBlKHNldFR5cGUoZnVuY3Rpb24oTF9zb21lQ2FzZSl7cmV0dXJuIGZ1bmN0aW9uKExfbm9uZUNhc2Upe3JldHVybiByZXNvbHZlKExfbm9uZUNhc2UpfX0sICdub25lJyksICdub25lJykpKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwiaXNOb25lXCIpKDEpKFwiaXNOb25lIG9iaiA9IGhhc1R5cGUgb2JqIG5vbmVcIikobGF6eShmdW5jdGlvbihMX29iail7cmV0dXJuIHJlc29sdmUoTF9oYXNUeXBlKShMX29iaikoTF9ub25lKX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwiaXNTb21lXCIpKDEpKFwiaXNTb21lIG9iaiA9IGhhc1R5cGUgb2JqIHNvbWVcIikobGF6eShmdW5jdGlvbihMX29iail7cmV0dXJuIHJlc29sdmUoTF9oYXNUeXBlKShMX29iaikoTF9zb21lKX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwiaXNTb21lMlwiKSgxKShcImlzU29tZTIgb2JqID0gaGFzVHlwZSBvYmogc29tZTJcIikobGF6eShmdW5jdGlvbihMX29iail7cmV0dXJuIHJlc29sdmUoTF9oYXNUeXBlKShMX29iaikoTF9zb21lMil9KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcIm5lcVwiKSgyKShcIm5lcSBhIGIgPSBub3QgKGVxIGEgYilcIikobGF6eShmdW5jdGlvbihMX2Epe3JldHVybiBmdW5jdGlvbihMX2Ipe3JldHVybiByZXNvbHZlKExfbm90KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZXEpKExfYSkoTF9iKX0pfX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwibGVmdFwiKSgxKShcImxlZnQgeCA9IFxcXFxsQ2FzZSByQ2FzZSAuIGxDYXNlIHhcIikobGF6eShzZXREYXRhVHlwZShmdW5jdGlvbihMX3gpe3JldHVybiBzZXRUeXBlKGZ1bmN0aW9uKExfbENhc2Upe3JldHVybiBmdW5jdGlvbihMX3JDYXNlKXtyZXR1cm4gcmVzb2x2ZShMX2xDYXNlKShMX3gpfX0sICdsZWZ0Jyl9LCAnbGVmdCcpKSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcInJpZ2h0XCIpKDEpKFwicmlnaHQgeCA9IFxcXFxsQ2FzZSByQ2FzZSAuIHJDYXNlIHhcIikobGF6eShzZXREYXRhVHlwZShmdW5jdGlvbihMX3gpe3JldHVybiBzZXRUeXBlKGZ1bmN0aW9uKExfbENhc2Upe3JldHVybiBmdW5jdGlvbihMX3JDYXNlKXtyZXR1cm4gcmVzb2x2ZShMX3JDYXNlKShMX3gpfX0sICdyaWdodCcpfSwgJ3JpZ2h0JykpKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwic3RyQXNjXCIpKDEpKFwic3RyQXNjIHN0cmluZyA9IF9zdHJBc2MgKGFzc2VydFR5cGUgJ3N0ckFzYyBzdHJpbmcnICcqc3RyaW5nJyBzdHJpbmcpXCIpKGxhenkoZnVuY3Rpb24oTF9zdHJpbmcpe3JldHVybiByZXNvbHZlKExfX3N0ckFzYykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2Fzc2VydFR5cGUpKFwic3RyQXNjIHN0cmluZ1wiKShcIipzdHJpbmdcIikoTF9zdHJpbmcpfSl9KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcInN0ckNoclwiKSgxKShcInN0ckNociBhc2NpaSA9IF9zdHJDaHIgKGFzc2VydFR5cGUgJ3N0ckNociBzdHJpbmcnICcqbnVtYmVyJyBhc2NpaSlcIikobGF6eShmdW5jdGlvbihMX2FzY2lpKXtyZXR1cm4gcmVzb2x2ZShMX19zdHJDaHIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hc3NlcnRUeXBlKShcInN0ckNociBzdHJpbmdcIikoXCIqbnVtYmVyXCIpKExfYXNjaWkpfSl9KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcInN0ckF0XCIpKDIpKFwic3RyQXQgc3RyaW5nIGluZGV4ID0gX3N0ckF0XFxuICBhc3NlcnRUeXBlICdzdHJBdCBzdHJpbmcnICcqc3RyaW5nJyBzdHJpbmdcXG4gIGFzc2VydFR5cGUgJ3N0ckF0IGluZGV4JyAnKm51bWJlcicgaW5kZXhcIikobGF6eShmdW5jdGlvbihMX3N0cmluZyl7cmV0dXJuIGZ1bmN0aW9uKExfaW5kZXgpe3JldHVybiByZXNvbHZlKExfX3N0ckF0KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYXNzZXJ0VHlwZSkoXCJzdHJBdCBzdHJpbmdcIikoXCIqc3RyaW5nXCIpKExfc3RyaW5nKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hc3NlcnRUeXBlKShcInN0ckF0IGluZGV4XCIpKFwiKm51bWJlclwiKShMX2luZGV4KX0pfX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwic3RyU3RhcnRzV2l0aFwiKSgyKShcInN0clN0YXJ0c1dpdGggc3RyaW5nIHByZWZpeCA9IF9zdHJTdGFydHNXaXRoXFxuICBhc3NlcnRUeXBlICdzdHJTdGFydHNXaXRoIHN0cmluZycgJypzdHJpbmcnIHN0cmluZ1xcbiAgYXNzZXJ0VHlwZSAnc3RyU3RhcnRzV2l0aCBwcmVmaXgnICcqc3RyaW5nJyBwcmVmaXhcIikobGF6eShmdW5jdGlvbihMX3N0cmluZyl7cmV0dXJuIGZ1bmN0aW9uKExfcHJlZml4KXtyZXR1cm4gcmVzb2x2ZShMX19zdHJTdGFydHNXaXRoKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYXNzZXJ0VHlwZSkoXCJzdHJTdGFydHNXaXRoIHN0cmluZ1wiKShcIipzdHJpbmdcIikoTF9zdHJpbmcpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2Fzc2VydFR5cGUpKFwic3RyU3RhcnRzV2l0aCBwcmVmaXhcIikoXCIqc3RyaW5nXCIpKExfcHJlZml4KX0pfX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwic3RyTGVuXCIpKDEpKFwic3RyTGVuIHN0cmluZyA9IF9zdHJMZW4gKGFzc2VydFR5cGUgJ3N0ckxlbiBzdHJpbmcnICcqc3RyaW5nJyBzdHJpbmcpXCIpKGxhenkoZnVuY3Rpb24oTF9zdHJpbmcpe3JldHVybiByZXNvbHZlKExfX3N0ckxlbikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2Fzc2VydFR5cGUpKFwic3RyTGVuIHN0cmluZ1wiKShcIipzdHJpbmdcIikoTF9zdHJpbmcpfSl9KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcInN0clRvTG93ZXJDYXNlXCIpKDEpKFwic3RyVG9Mb3dlckNhc2Ugc3RyaW5nID0gX3N0clRvTG93ZXJDYXNlIChhc3NlcnRUeXBlICdzdHJUb0xvd2VyQ2FzZSBzdHJpbmcnICcqc3RyaW5nJyBzdHJpbmcpXCIpKGxhenkoZnVuY3Rpb24oTF9zdHJpbmcpe3JldHVybiByZXNvbHZlKExfX3N0clRvTG93ZXJDYXNlKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYXNzZXJ0VHlwZSkoXCJzdHJUb0xvd2VyQ2FzZSBzdHJpbmdcIikoXCIqc3RyaW5nXCIpKExfc3RyaW5nKX0pfSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJzdHJUb1VwcGVyQ2FzZVwiKSgxKShcInN0clRvVXBwZXJDYXNlIHN0cmluZyA9IF9zdHJUb1VwcGVyQ2FzZSAoYXNzZXJ0VHlwZSAnc3RyVG9VcHBlckNhc2Ugc3RyaW5nJyAnKnN0cmluZycgc3RyaW5nKVwiKShsYXp5KGZ1bmN0aW9uKExfc3RyaW5nKXtyZXR1cm4gcmVzb2x2ZShMX19zdHJUb1VwcGVyQ2FzZSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2Fzc2VydFR5cGUpKFwic3RyVG9VcHBlckNhc2Ugc3RyaW5nXCIpKFwiKnN0cmluZ1wiKShMX3N0cmluZyl9KX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwic3RyUmVwbGFjZVwiKSgzKShcInN0clJlcGxhY2Ugc3RyaW5nIHBhdCByZXBsID0gX3N0clJlcGxhY2VcXG4gIGFzc2VydFR5cGUgJ3N0clJlcGxhY2Ugc3RyaW5nJyAnKnN0cmluZycgc3RyaW5nXFxuICBhc3NlcnQgKG9yIChoYXNUeXBlIHBhdCAnKnN0cmluZycpIChoYXNUeXBlIHBhdCAnKlJlZ0V4cCcpKSAoc3RyQ2F0IChjb25zICdzdHJTdGFydHNXaXRoIHBhdCBzaG91bGQgYmUgdHlwZSBzdHJpbmcgb3IgUmVnRXhwIGJ1dCBpdCBpcyB0eXBlICcgKGNvbnMgKGdldFR5cGUgcGF0KSAoY29ucyAnOiAnIChjb25zIChzaG93IHBhdCkgbmlsKSkpKSkgcGF0XFxuICBhc3NlcnRUeXBlICdzdHJSZXBsYWNlIHJlcGwnICcqc3RyaW5nJyByZXBsXCIpKGxhenkoZnVuY3Rpb24oTF9zdHJpbmcpe3JldHVybiBmdW5jdGlvbihMX3BhdCl7cmV0dXJuIGZ1bmN0aW9uKExfcmVwbCl7cmV0dXJuIHJlc29sdmUoTF9fc3RyUmVwbGFjZSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2Fzc2VydFR5cGUpKFwic3RyUmVwbGFjZSBzdHJpbmdcIikoXCIqc3RyaW5nXCIpKExfc3RyaW5nKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hc3NlcnQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9vcikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2hhc1R5cGUpKExfcGF0KShcIipzdHJpbmdcIil9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaGFzVHlwZSkoTF9wYXQpKFwiKlJlZ0V4cFwiKX0pfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3N0ckNhdCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKFwic3RyU3RhcnRzV2l0aCBwYXQgc2hvdWxkIGJlIHR5cGUgc3RyaW5nIG9yIFJlZ0V4cCBidXQgaXQgaXMgdHlwZSBcIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9nZXRUeXBlKShMX3BhdCl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoXCI6IFwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3Nob3cpKExfcGF0KX0pKExfbmlsKX0pfSl9KX0pfSkoTF9wYXQpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2Fzc2VydFR5cGUpKFwic3RyUmVwbGFjZSByZXBsXCIpKFwiKnN0cmluZ1wiKShMX3JlcGwpfSl9fX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwic3RyU3Vic3RyaW5nXCIpKDMpKFwic3RyU3Vic3RyaW5nIHN0ciBzdGFydCBlbmQgPSBfc3RyU3Vic3RyaW5nXFxuICBhc3NlcnRUeXBlICdzdHJTdWJzdHJpbmcgc3RyJyAnKnN0cmluZycgc3RyXFxuICBhc3NlcnRUeXBlICdzdHJTdWJzdHJpbmcgc3RhcnQnICcqbnVtYmVyJyBzdGFydFxcbiAgYXNzZXJ0VHlwZSAnc3RyU3Vic3RyaW5nIGVuZCcgJypudW1iZXInIGVuZFwiKShsYXp5KGZ1bmN0aW9uKExfc3RyKXtyZXR1cm4gZnVuY3Rpb24oTF9zdGFydCl7cmV0dXJuIGZ1bmN0aW9uKExfZW5kKXtyZXR1cm4gcmVzb2x2ZShMX19zdHJTdWJzdHJpbmcpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hc3NlcnRUeXBlKShcInN0clN1YnN0cmluZyBzdHJcIikoXCIqc3RyaW5nXCIpKExfc3RyKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hc3NlcnRUeXBlKShcInN0clN1YnN0cmluZyBzdGFydFwiKShcIipudW1iZXJcIikoTF9zdGFydCl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYXNzZXJ0VHlwZSkoXCJzdHJTdWJzdHJpbmcgZW5kXCIpKFwiKm51bWJlclwiKShMX2VuZCl9KX19fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJzdHJTcGxpdFwiKSgyKShcInN0clNwbGl0IHN0ciBwYXQgPSBfc3RyU3BsaXRcXG4gIGFzc2VydFR5cGUgJ3N0clNwbGl0IHN0cicgJypzdHJpbmcnIHN0clxcbiAgYXNzZXJ0IChvciAoaGFzVHlwZSBwYXQgJypzdHJpbmcnKSAoaGFzVHlwZSBwYXQgJypSZWdFeHAnKSkgKHN0ckNhdCAoY29ucyAnc3RyU3BsaXQgcGF0IHNob3VsZCBiZSB0eXBlIHN0cmluZyBvciBSZWdFeHAgYnV0IGl0IGlzIHR5cGUgJyAoY29ucyAoZ2V0VHlwZSBwYXQpIChjb25zICc6ICcgKGNvbnMgKHNob3cgcGF0KSBuaWwpKSkpKSBwYXRcIikobGF6eShmdW5jdGlvbihMX3N0cil7cmV0dXJuIGZ1bmN0aW9uKExfcGF0KXtyZXR1cm4gcmVzb2x2ZShMX19zdHJTcGxpdCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2Fzc2VydFR5cGUpKFwic3RyU3BsaXQgc3RyXCIpKFwiKnN0cmluZ1wiKShMX3N0cil9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYXNzZXJ0KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfb3IpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9oYXNUeXBlKShMX3BhdCkoXCIqc3RyaW5nXCIpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2hhc1R5cGUpKExfcGF0KShcIipSZWdFeHBcIil9KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zdHJDYXQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShcInN0clNwbGl0IHBhdCBzaG91bGQgYmUgdHlwZSBzdHJpbmcgb3IgUmVnRXhwIGJ1dCBpdCBpcyB0eXBlIFwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2dldFR5cGUpKExfcGF0KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShcIjogXCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc2hvdykoTF9wYXQpfSkoTF9uaWwpfSl9KX0pfSl9KShMX3BhdCl9KX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcInN0ckNhdFwiKSgxKShcInN0ckNhdCBsaXN0ID0gX3N0ckNhdFxcbiAgYXNzZXJ0IChpc0xpc3QgbGlzdCkgKHN0ckNhdCAoY29ucyAnc3RyQ2F0IGxpc3Qgc2hvdWxkIGJlIHR5cGUgY29ucyBvciBuaWwgYnV0IGl0IGlzIHR5cGUgJyAoY29ucyAoZ2V0VHlwZSBsaXN0KSAoY29ucyAnOiAnIChjb25zIGxpc3QpKSkpKSBsaXN0XCIpKGxhenkoZnVuY3Rpb24oTF9saXN0KXtyZXR1cm4gcmVzb2x2ZShMX19zdHJDYXQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hc3NlcnQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pc0xpc3QpKExfbGlzdCl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc3RyQ2F0KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoXCJzdHJDYXQgbGlzdCBzaG91bGQgYmUgdHlwZSBjb25zIG9yIG5pbCBidXQgaXQgaXMgdHlwZSBcIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9nZXRUeXBlKShMX2xpc3QpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKFwiOiBcIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKExfbGlzdCl9KX0pfSl9KX0pKExfbGlzdCl9KX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwic3RyQWRkXCIpKDIpKFwic3RyQWRkIHN0cjEgc3RyMiA9IF9zdHJBZGQgKGFzc2VydFR5cGUgJ3N0ckFkZCBzdHIxJyAnKnN0cmluZycgc3RyMSkgKGFzc2VydFR5cGUgJ3N0ckFkZCBzdHIyJyAnKnN0cmluZycgc3RyMilcIikobGF6eShmdW5jdGlvbihMX3N0cjEpe3JldHVybiBmdW5jdGlvbihMX3N0cjIpe3JldHVybiByZXNvbHZlKExfX3N0ckFkZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2Fzc2VydFR5cGUpKFwic3RyQWRkIHN0cjFcIikoXCIqc3RyaW5nXCIpKExfc3RyMSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYXNzZXJ0VHlwZSkoXCJzdHJBZGQgc3RyMlwiKShcIipzdHJpbmdcIikoTF9zdHIyKX0pfX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwic3RyTWF0Y2hcIikoMikoXCJzdHJNYXRjaCBzdHIgcGF0ID0gX3N0ck1hdGNoXFxuICBhc3NlcnRUeXBlICdzdHJNYXRjaCBzdHInICcqc3RyaW5nJyBzdHJcXG4gIGFzc2VydCAob3IgKGhhc1R5cGUgcGF0ICcqc3RyaW5nJykgKGhhc1R5cGUgcGF0ICcqUmVnRXhwJykpIChzdHJDYXQgKGNvbnMgJ3N0ck1hdGNoIHBhdCBzaG91bGQgYmUgdHlwZSBzdHJpbmcgb3IgUmVnRXhwIGJ1dCBpdCBpcyB0eXBlICcgKGNvbnMgKGdldFR5cGUgcGF0KSAoY29ucyAnOiAnIChjb25zIChzaG93IHBhdCkgbmlsKSkpKSkgcGF0XCIpKGxhenkoZnVuY3Rpb24oTF9zdHIpe3JldHVybiBmdW5jdGlvbihMX3BhdCl7cmV0dXJuIHJlc29sdmUoTF9fc3RyTWF0Y2gpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hc3NlcnRUeXBlKShcInN0ck1hdGNoIHN0clwiKShcIipzdHJpbmdcIikoTF9zdHIpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2Fzc2VydCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX29yKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaGFzVHlwZSkoTF9wYXQpKFwiKnN0cmluZ1wiKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9oYXNUeXBlKShMX3BhdCkoXCIqUmVnRXhwXCIpfSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc3RyQ2F0KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoXCJzdHJNYXRjaCBwYXQgc2hvdWxkIGJlIHR5cGUgc3RyaW5nIG9yIFJlZ0V4cCBidXQgaXQgaXMgdHlwZSBcIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9nZXRUeXBlKShMX3BhdCl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoXCI6IFwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3Nob3cpKExfcGF0KX0pKExfbmlsKX0pfSl9KX0pfSkoTF9wYXQpfSl9fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJzdHJUb0xpc3RcIikoMSkoXCJzdHJUb0xpc3Qgc3RyID0gX3N0clRvTGlzdCAoYXNzZXJ0VHlwZSAnc3RyVG9MaXN0IHN0cicgJypzdHJpbmcnIHN0cilcIikobGF6eShmdW5jdGlvbihMX3N0cil7cmV0dXJuIHJlc29sdmUoTF9fc3RyVG9MaXN0KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYXNzZXJ0VHlwZSkoXCJzdHJUb0xpc3Qgc3RyXCIpKFwiKnN0cmluZ1wiKShMX3N0cil9KX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwic3RyRnJvbUxpc3RcIikoMSkoXCJzdHJGcm9tTGlzdCBsaXN0ID0gX3N0ckZyb21MaXN0XFxuICBhc3NlcnQgKGlzTGlzdCBsaXN0KSAoc3RyQ2F0IChjb25zICdzdHJGcm9tTGlzdCBsaXN0IHNob3VsZCBiZSB0eXBlIGNvbnMgb3IgbmlsIGJ1dCBpdCBpcyB0eXBlICcgKGNvbnMgKGdldFR5cGUgbGlzdCkgKGNvbnMgJzogJyAoY29ucyBsaXN0KSkpKSkgbGlzdFwiKShsYXp5KGZ1bmN0aW9uKExfbGlzdCl7cmV0dXJuIHJlc29sdmUoTF9fc3RyRnJvbUxpc3QpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hc3NlcnQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pc0xpc3QpKExfbGlzdCl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc3RyQ2F0KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoXCJzdHJGcm9tTGlzdCBsaXN0IHNob3VsZCBiZSB0eXBlIGNvbnMgb3IgbmlsIGJ1dCBpdCBpcyB0eXBlIFwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2dldFR5cGUpKExfbGlzdCl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoXCI6IFwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF9saXN0KX0pfSl9KX0pfSkoTF9saXN0KX0pfSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJyZWdleHBcIikoMSkoXCJyZWdleHAgc3RyID0gX3JlZ2V4cCAoYXNzZXJ0VHlwZSAncmVnZXhwIHN0cicgJypzdHJpbmcnIHN0cilcIikobGF6eShmdW5jdGlvbihMX3N0cil7cmV0dXJuIHJlc29sdmUoTF9fcmVnZXhwKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYXNzZXJ0VHlwZSkoXCJyZWdleHAgc3RyXCIpKFwiKnN0cmluZ1wiKShMX3N0cil9KX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwicmVnZXhwRmxhZ3NcIikoMikoXCJyZWdleHBGbGFncyBzdHIgZmxhZ3MgPSBfcmVnZXhwRmxhZ3NcXG4gIGFzc2VydFR5cGUgJ3JlZ2V4cCBzdHInICcqc3RyaW5nJyBzdHJcXG4gIGFzc2VydFR5cGUgJ3JlZ2V4cCBmbGFncycgJypzdHJpbmcnIGZsYWdzXCIpKGxhenkoZnVuY3Rpb24oTF9zdHIpe3JldHVybiBmdW5jdGlvbihMX2ZsYWdzKXtyZXR1cm4gcmVzb2x2ZShMX19yZWdleHBGbGFncykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2Fzc2VydFR5cGUpKFwicmVnZXhwIHN0clwiKShcIipzdHJpbmdcIikoTF9zdHIpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2Fzc2VydFR5cGUpKFwicmVnZXhwIGZsYWdzXCIpKFwiKnN0cmluZ1wiKShMX2ZsYWdzKX0pfX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwianNvblBhcnNlXCIpKDMpKFwianNvblBhcnNlIHN0ciBmYWlsdXJlIHN1Y2Nlc3MgPSBfanNvblBhcnNlXFxuICBhc3NlcnRUeXBlICdqc29uUGFyc2Ugc3RyJyAnKnN0cmluZycgc3RyXFxuICBmYWlsdXJlXFxuICBzdWNjZXNzXCIpKGxhenkoZnVuY3Rpb24oTF9zdHIpe3JldHVybiBmdW5jdGlvbihMX2ZhaWx1cmUpe3JldHVybiBmdW5jdGlvbihMX3N1Y2Nlc3Mpe3JldHVybiByZXNvbHZlKExfX2pzb25QYXJzZSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2Fzc2VydFR5cGUpKFwianNvblBhcnNlIHN0clwiKShcIipzdHJpbmdcIikoTF9zdHIpfSkoTF9mYWlsdXJlKShMX3N1Y2Nlc3MpfX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcInNob3dcIikoMSkoXCJzaG93IHggPSBfc2hvdyB4XCIpKGxhenkoZnVuY3Rpb24oTF94KXtyZXR1cm4gcmVzb2x2ZShMX19zaG93KShMX3gpfSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJpZFwiKSgxKShcImlkIHggPSB4XCIpKGxhenkoZnVuY3Rpb24oTF94KXtyZXR1cm4gcmVzb2x2ZShMX3gpfSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJjb21wb3NlXCIpKDIpKFwiY29tcG9zZSBmIGcgPSBcXFxceCAuIGYgKGcgeClcIikobGF6eShzZXREYXRhVHlwZShmdW5jdGlvbihMX2Ype3JldHVybiBmdW5jdGlvbihMX2cpe3JldHVybiBzZXRUeXBlKGZ1bmN0aW9uKExfeCl7cmV0dXJuIHJlc29sdmUoTF9mKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZykoTF94KX0pfSwgJ2NvbXBvc2UnKX19LCAnY29tcG9zZScpKSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImZsaXBcIikoMSkoXCJmbGlwIGZ1bmMgPSBcXFxceCB5IC4gZnVuYyB5IHhcIikobGF6eShzZXREYXRhVHlwZShmdW5jdGlvbihMX2Z1bmMpe3JldHVybiBzZXRUeXBlKGZ1bmN0aW9uKExfeCl7cmV0dXJuIGZ1bmN0aW9uKExfeSl7cmV0dXJuIHJlc29sdmUoTF9mdW5jKShMX3kpKExfeCl9fSwgJ2ZsaXAnKX0sICdmbGlwJykpKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwiY29uc1wiKSgyKShcImNvbnMgYSBiID0gXFxcXGYgLiBmIGEgYlwiKShsYXp5KHNldERhdGFUeXBlKGZ1bmN0aW9uKExfYSl7cmV0dXJuIGZ1bmN0aW9uKExfYil7cmV0dXJuIHNldFR5cGUoZnVuY3Rpb24oTF9mKXtyZXR1cm4gcmVzb2x2ZShMX2YpKExfYSkoTF9iKX0sICdjb25zJyl9fSwgJ2NvbnMnKSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJpc0NvbnNcIikoMSkoXCJpc0NvbnMgYyA9IGhhc1R5cGUgYyBjb25zXCIpKGxhenkoZnVuY3Rpb24oTF9jKXtyZXR1cm4gcmVzb2x2ZShMX2hhc1R5cGUpKExfYykoTF9jb25zKX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwiaXNMaXN0XCIpKDEpKFwiaXNMaXN0IGwgPSBvciAoaGFzVHlwZSBsIGNvbnMpIChoYXNUeXBlIGwgbmlsKVwiKShsYXp5KGZ1bmN0aW9uKExfbCl7cmV0dXJuIHJlc29sdmUoTF9vcikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2hhc1R5cGUpKExfbCkoTF9jb25zKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9oYXNUeXBlKShMX2wpKExfbmlsKX0pfSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJhc3NlcnRUeXBlXCIpKDMpKFwiYXNzZXJ0VHlwZSBtc2cgdHlwZSB2YWx1ZSA9IGFzc2VydCAoaGFzVHlwZSB2YWx1ZSB0eXBlKSAoc3RyQ2F0IChjb25zIG1zZyAoY29ucyAnIHNob3VsZCBiZSB0eXBlICcgKGNvbnMgKGdldERhdGFUeXBlIHR5cGUpIChjb25zICcsIGJ1dCBpdHMgdHlwZSBpcyAnIChjb25zIChnZXRUeXBlIHZhbHVlKSAoY29ucyAnOiAnIChjb25zIChzaG93IHZhbHVlKSBuaWwpKSkpKSkpKSB2YWx1ZVwiKShsYXp5KGZ1bmN0aW9uKExfbXNnKXtyZXR1cm4gZnVuY3Rpb24oTF90eXBlKXtyZXR1cm4gZnVuY3Rpb24oTF92YWx1ZSl7cmV0dXJuIHJlc29sdmUoTF9hc3NlcnQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9oYXNUeXBlKShMX3ZhbHVlKShMX3R5cGUpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3N0ckNhdCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKExfbXNnKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoXCIgc2hvdWxkIGJlIHR5cGUgXCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZ2V0RGF0YVR5cGUpKExfdHlwZSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoXCIsIGJ1dCBpdHMgdHlwZSBpcyBcIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9nZXRUeXBlKShMX3ZhbHVlKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShcIjogXCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc2hvdykoTF92YWx1ZSl9KShMX25pbCl9KX0pfSl9KX0pfSl9KX0pKExfdmFsdWUpfX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcIm5pbFwiKSgwKShcIm5pbCA9IFxcXFxhIGIgLiBiXCIpKGxhenkoc2V0RGF0YVR5cGUoc2V0VHlwZShmdW5jdGlvbihMX2Epe3JldHVybiBmdW5jdGlvbihMX2Ipe3JldHVybiByZXNvbHZlKExfYil9fSwgJ25pbCcpLCAnbmlsJykpKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwiaXNOaWxcIikoMSkoXCJpc05pbCBuID0gaGFzVHlwZSBuIG5pbFwiKShsYXp5KGZ1bmN0aW9uKExfbil7cmV0dXJuIHJlc29sdmUoTF9oYXNUeXBlKShMX24pKExfbmlsKX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwiaGVhZFwiKSgxKShcImhlYWQgbCA9IGwgXFxcXGggdCAuIGhcIikobGF6eShmdW5jdGlvbihMX2wpe3JldHVybiByZXNvbHZlKExfbCkobGF6eShmdW5jdGlvbihMX2gpe3JldHVybiBmdW5jdGlvbihMX3Qpe3JldHVybiByZXNvbHZlKExfaCl9fSkpfSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJ0YWlsXCIpKDEpKFwidGFpbCBsID0gbCBcXFxcaCB0IC4gdFwiKShsYXp5KGZ1bmN0aW9uKExfbCl7cmV0dXJuIHJlc29sdmUoTF9sKShsYXp5KGZ1bmN0aW9uKExfaCl7cmV0dXJuIGZ1bmN0aW9uKExfdCl7cmV0dXJuIHJlc29sdmUoTF90KX19KSl9KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImxhc3RcIikoMSkoXCJsYXN0IGwgPSBpc05pbCAodGFpbCBsKVxcbiAgaGVhZCBsXFxuICBsYXN0ICh0YWlsIGwpXCIpKGxhenkoZnVuY3Rpb24oTF9sKXtyZXR1cm4gcmVzb2x2ZShMX2lzTmlsKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdGFpbCkoTF9sKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9oZWFkKShMX2wpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2xhc3QpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90YWlsKShMX2wpfSl9KX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwicmVtb3ZlTGFzdFwiKSgxKShcInJlbW92ZUxhc3QgbCA9IGlzTmlsICh0YWlsIGwpXFxuICBuaWxcXG4gIGNvbnMgKGhlYWQgbCkgKHJlbW92ZUxhc3QgKHRhaWwgbCkpXCIpKGxhenkoZnVuY3Rpb24oTF9sKXtyZXR1cm4gcmVzb2x2ZShMX2lzTmlsKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdGFpbCkoTF9sKX0pKExfbmlsKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2hlYWQpKExfbCl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcmVtb3ZlTGFzdCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3RhaWwpKExfbCl9KX0pfSl9KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImxlbmd0aFwiKSgxKShcImxlbmd0aCBsaXN0ID0gaXNDb25zIGxpc3RcXG4gICsgMSAobGVuZ3RoICh0YWlsIGxpc3QpKVxcbiAgMFwiKShsYXp5KGZ1bmN0aW9uKExfbGlzdCl7cmV0dXJuIHJlc29sdmUoTF9pc0NvbnMpKExfbGlzdCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMXyRvKSgxKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfbGVuZ3RoKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdGFpbCkoTF9saXN0KX0pfSl9KSgwKX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwiYXBwZW5kXCIpKDIpKFwiYXBwZW5kIGEgYiA9IGlzTmlsIGFcXG4gIGJcXG4gIGNvbnMgKGhlYWQgYSkgKGFwcGVuZCAodGFpbCBhKSBiKVwiKShsYXp5KGZ1bmN0aW9uKExfYSl7cmV0dXJuIGZ1bmN0aW9uKExfYil7cmV0dXJuIHJlc29sdmUoTF9pc05pbCkoTF9hKShMX2IpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaGVhZCkoTF9hKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hcHBlbmQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90YWlsKShMX2EpfSkoTF9iKX0pfSl9fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJmbGF0dGVuXCIpKDEpKFwiZmxhdHRlbiBsaXN0ID0gaXNDb25zIGxpc3RcXG4gIHN1YmZsYXR0ZW4gbGlzdCBuaWxcXG4gIGxpc3RcIikobGF6eShmdW5jdGlvbihMX2xpc3Qpe3JldHVybiByZXNvbHZlKExfaXNDb25zKShMX2xpc3QpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zdWJmbGF0dGVuKShMX2xpc3QpKExfbmlsKX0pKExfbGlzdCl9KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcInN1YmZsYXR0ZW5cIikoMikoXCJzdWJmbGF0dGVuIGxpc3QgcmVzdWx0ID0gaXNOaWwgbGlzdFxcbiAgcmVzdWx0XFxuICBpc0NvbnMgbGlzdFxcbiAgICBzdWJmbGF0dGVuIChoZWFkIGxpc3QpIChzdWJmbGF0dGVuICh0YWlsIGxpc3QpIHJlc3VsdClcXG4gICAgY29ucyBsaXN0IHJlc3VsdFwiKShsYXp5KGZ1bmN0aW9uKExfbGlzdCl7cmV0dXJuIGZ1bmN0aW9uKExfcmVzdWx0KXtyZXR1cm4gcmVzb2x2ZShMX2lzTmlsKShMX2xpc3QpKExfcmVzdWx0KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaXNDb25zKShMX2xpc3QpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zdWJmbGF0dGVuKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaGVhZCkoTF9saXN0KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zdWJmbGF0dGVuKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdGFpbCkoTF9saXN0KX0pKExfcmVzdWx0KX0pfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKExfbGlzdCkoTF9yZXN1bHQpfSl9KX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcInJldmVyc2VcIikoMSkoXCJyZXZlcnNlIGwgPSByZXYgbCBuaWxcIikobGF6eShmdW5jdGlvbihMX2wpe3JldHVybiByZXNvbHZlKExfcmV2KShMX2wpKExfbmlsKX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwicmV2XCIpKDIpKFwicmV2IGwgcmVzdWx0ID0gaXNOaWwgbFxcbiAgcmVzdWx0XFxuICByZXYgKHRhaWwgbCkgKGNvbnMgKGhlYWQgbCkgcmVzdWx0KVwiKShsYXp5KGZ1bmN0aW9uKExfbCl7cmV0dXJuIGZ1bmN0aW9uKExfcmVzdWx0KXtyZXR1cm4gcmVzb2x2ZShMX2lzTmlsKShMX2wpKExfcmVzdWx0KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcmV2KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdGFpbCkoTF9sKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaGVhZCkoTF9sKX0pKExfcmVzdWx0KX0pfSl9fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJmaWx0ZXJcIikoMikoXCJmaWx0ZXIgZnVuYyBsaXN0ID0gaXNOaWwgbGlzdFxcbiAgbmlsXFxuICBmdW5jIChoZWFkIGxpc3QpIChjb25zIChoZWFkIGxpc3QpKSBpZCAoZmlsdGVyIGZ1bmMgKHRhaWwgbGlzdCkpXCIpKGxhenkoZnVuY3Rpb24oTF9mdW5jKXtyZXR1cm4gZnVuY3Rpb24oTF9saXN0KXtyZXR1cm4gcmVzb2x2ZShMX2lzTmlsKShMX2xpc3QpKExfbmlsKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZnVuYykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2hlYWQpKExfbGlzdCl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2hlYWQpKExfbGlzdCl9KX0pKExfaWQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9maWx0ZXIpKExfZnVuYykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3RhaWwpKExfbGlzdCl9KX0pfSl9fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJmaW5kXCIpKDIpKFwiZmluZCBwcmVkaWNhdGUgbGlzdCA9IGlzTmlsIGxpc3RcXG4gIG5vbmVcXG4gIHByZWRpY2F0ZSAoaGVhZCBsaXN0KSAoc29tZSAoaGVhZCBsaXN0KSkgKGZpbmQgcHJlZGljYXRlICh0YWlsIGxpc3QpKVwiKShsYXp5KGZ1bmN0aW9uKExfcHJlZGljYXRlKXtyZXR1cm4gZnVuY3Rpb24oTF9saXN0KXtyZXR1cm4gcmVzb2x2ZShMX2lzTmlsKShMX2xpc3QpKExfbm9uZSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3ByZWRpY2F0ZSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2hlYWQpKExfbGlzdCl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc29tZSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2hlYWQpKExfbGlzdCl9KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9maW5kKShMX3ByZWRpY2F0ZSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3RhaWwpKExfbGlzdCl9KX0pfSl9fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJjb250YWluc1wiKSgyKShcImNvbnRhaW5zIGxpc3QgaXRlbSA9IGZpbmQgKFxcXFxlbCAuIGVxIGVsIGl0ZW0pIGxpc3QgKFxcXFx4IC4gdHJ1ZSkgZmFsc2VcIikobGF6eShmdW5jdGlvbihMX2xpc3Qpe3JldHVybiBmdW5jdGlvbihMX2l0ZW0pe3JldHVybiByZXNvbHZlKExfZmluZCkobGF6eShmdW5jdGlvbihMX2VsKXtyZXR1cm4gcmVzb2x2ZShMX2VxKShMX2VsKShMX2l0ZW0pfSkpKExfbGlzdCkobGF6eShmdW5jdGlvbihMX3gpe3JldHVybiByZXNvbHZlKExfdHJ1ZSl9KSkoTF9mYWxzZSl9fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJtYXBcIikoMikoXCJtYXAgZnVuYyBsID0gaXNOaWwgbFxcbiAgbmlsXFxuICBjb25zIChmdW5jIChoZWFkIGwpKSAobWFwIGZ1bmMgKHRhaWwgbCkpXCIpKGxhenkoZnVuY3Rpb24oTF9mdW5jKXtyZXR1cm4gZnVuY3Rpb24oTF9sKXtyZXR1cm4gcmVzb2x2ZShMX2lzTmlsKShMX2wpKExfbmlsKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2Z1bmMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9oZWFkKShMX2wpfSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfbWFwKShMX2Z1bmMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90YWlsKShMX2wpfSl9KX0pfX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwibWFwU2F2ZVwiKSgyKShcIm1hcFNhdmUgZnVuYyBsID0gaXNOaWwgbFxcbiAgbmlsXFxuICBcXFxcXFxcXFxcbiAgICBuZXdIID0gZnVuYyAoaGVhZCBsKVxcbiAgICBuZXdUID0gbWFwU2F2ZSBmdW5jICh0YWlsIGwpXFxuICAgIC5cXG4gICAgYW5kIChlcSBuZXdIIChoZWFkIGwpKSAoZXEgbmV3VCAodGFpbCBsKSlcXG4gICAgICBsXFxuICAgICAgY29ucyBuZXdIIG5ld1RcIikobGF6eShmdW5jdGlvbihMX2Z1bmMpe3JldHVybiBmdW5jdGlvbihMX2wpe3JldHVybiByZXNvbHZlKExfaXNOaWwpKExfbCkoTF9uaWwpKGZ1bmN0aW9uKCl7XG52YXIgTF9uZXdULCBMX25ld0g7XG5cbkxfbmV3VCA9IGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9tYXBTYXZlKShMX2Z1bmMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90YWlsKShMX2wpfSl9O1xuXG5MX25ld0ggPSBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZnVuYykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2hlYWQpKExfbCl9KX07XG5yZXR1cm4gcmVzb2x2ZShMX2FuZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2VxKShMX25ld0gpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9oZWFkKShMX2wpfSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZXEpKExfbmV3VCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3RhaWwpKExfbCl9KX0pKExfbCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKExfbmV3SCkoTF9uZXdUKX0pfSl9fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJmb2xkbFwiKSgzKShcImZvbGRsIGZ1bmMgaW5pdGlhbFZhbHVlIGwgPSBsIChcXFxcaCB0IEQgLiBmb2xkbCBmdW5jIChmdW5jIGluaXRpYWxWYWx1ZSBoKSB0KSBpbml0aWFsVmFsdWVcIikobGF6eShmdW5jdGlvbihMX2Z1bmMpe3JldHVybiBmdW5jdGlvbihMX2luaXRpYWxWYWx1ZSl7cmV0dXJuIGZ1bmN0aW9uKExfbCl7cmV0dXJuIHJlc29sdmUoTF9sKShsYXp5KGZ1bmN0aW9uKExfaCl7cmV0dXJuIGZ1bmN0aW9uKExfdCl7cmV0dXJuIGZ1bmN0aW9uKExfRCl7cmV0dXJuIHJlc29sdmUoTF9mb2xkbCkoTF9mdW5jKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZnVuYykoTF9pbml0aWFsVmFsdWUpKExfaCl9KShMX3QpfX19KSkoTF9pbml0aWFsVmFsdWUpfX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImZvbGRsMVwiKSgyKShcImZvbGRsMSBmdW5jIGwgPSBsIFxcXFxoIHQgLiBmb2xkbCBmdW5jIGggdFwiKShsYXp5KGZ1bmN0aW9uKExfZnVuYyl7cmV0dXJuIGZ1bmN0aW9uKExfbCl7cmV0dXJuIHJlc29sdmUoTF9sKShsYXp5KGZ1bmN0aW9uKExfaCl7cmV0dXJuIGZ1bmN0aW9uKExfdCl7cmV0dXJuIHJlc29sdmUoTF9mb2xkbCkoTF9mdW5jKShMX2gpKExfdCl9fSkpfX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwiZm9sZHJcIikoMykoXCJmb2xkciBmdW5jIGluaXRpYWxWYWx1ZSBsaXN0ID0gbGlzdFxcbiAgXFxcXGggdCBEIC4gZnVuYyBoIChmb2xkciBmdW5jIGluaXRpYWxWYWx1ZSB0KVxcbiAgaW5pdGlhbFZhbHVlXCIpKGxhenkoZnVuY3Rpb24oTF9mdW5jKXtyZXR1cm4gZnVuY3Rpb24oTF9pbml0aWFsVmFsdWUpe3JldHVybiBmdW5jdGlvbihMX2xpc3Qpe3JldHVybiByZXNvbHZlKExfbGlzdCkobGF6eShmdW5jdGlvbihMX2gpe3JldHVybiBmdW5jdGlvbihMX3Qpe3JldHVybiBmdW5jdGlvbihMX0Qpe3JldHVybiByZXNvbHZlKExfZnVuYykoTF9oKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZm9sZHIpKExfZnVuYykoTF9pbml0aWFsVmFsdWUpKExfdCl9KX19fSkpKExfaW5pdGlhbFZhbHVlKX19fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJmb2xkcjFcIikoMikoXCJmb2xkcjEgZnVuYyBsaXN0ID0gbGlzdCBcXFxcaCB0IC4gaXNOaWwgdFxcbiAgaFxcbiAgZnVuYyBoIChmb2xkcjEgZnVuYyB0KVwiKShsYXp5KGZ1bmN0aW9uKExfZnVuYyl7cmV0dXJuIGZ1bmN0aW9uKExfbGlzdCl7cmV0dXJuIHJlc29sdmUoTF9saXN0KShsYXp5KGZ1bmN0aW9uKExfaCl7cmV0dXJuIGZ1bmN0aW9uKExfdCl7cmV0dXJuIHJlc29sdmUoTF9pc05pbCkoTF90KShMX2gpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9mdW5jKShMX2gpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9mb2xkcjEpKExfZnVuYykoTF90KX0pfSl9fSkpfX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwiaW50ZXJzcGVyc2VcIikoMikoXCJpbnRlcnNwZXJzZSBsaXN0IGVsZW1lbnQgPSBsaXN0IChcXFxcaCB0IEQgLlxcbiAgaXNOaWwgdFxcbiAgICBsaXN0XFxuICAgIGNvbnMgaCAoY29ucyBlbGVtZW50IChpbnRlcnNwZXJzZSB0IGVsZW1lbnQpKSkgbmlsXCIpKGxhenkoZnVuY3Rpb24oTF9saXN0KXtyZXR1cm4gZnVuY3Rpb24oTF9lbGVtZW50KXtyZXR1cm4gcmVzb2x2ZShMX2xpc3QpKGxhenkoZnVuY3Rpb24oTF9oKXtyZXR1cm4gZnVuY3Rpb24oTF90KXtyZXR1cm4gZnVuY3Rpb24oTF9EKXtyZXR1cm4gcmVzb2x2ZShMX2lzTmlsKShMX3QpKExfbGlzdCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKExfaCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKExfZWxlbWVudCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2ludGVyc3BlcnNlKShMX3QpKExfZWxlbWVudCl9KX0pfSl9fX0pKShMX25pbCl9fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJqb2luXCIpKDIpKFwiam9pbiBsaXN0IGVsID0gc3RyQ2F0IChpbnRlcnNwZXJzZSBsaXN0IGVsKVwiKShsYXp5KGZ1bmN0aW9uKExfbGlzdCl7cmV0dXJuIGZ1bmN0aW9uKExfZWwpe3JldHVybiByZXNvbHZlKExfc3RyQ2F0KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaW50ZXJzcGVyc2UpKExfbGlzdCkoTF9lbCl9KX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImZpbmRJbmRleFwiKSgyKShcImZpbmRJbmRleCBmdW5jIGxpc3QgPSBpZHggbGlzdCBmdW5jIDBcIikobGF6eShmdW5jdGlvbihMX2Z1bmMpe3JldHVybiBmdW5jdGlvbihMX2xpc3Qpe3JldHVybiByZXNvbHZlKExfaWR4KShMX2xpc3QpKExfZnVuYykoMCl9fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJpZHhcIikoMykoXCJpZHggbGlzdCBmdW5jIHBvcyA9IGxpc3RcXG4gIFxcXFxoIHQgRCAuIGZ1bmMgaFxcbiAgICBwb3NcXG4gICAgaWR4IHQgZnVuYyAoKyAxIHBvcylcXG4gIC0xXCIpKGxhenkoZnVuY3Rpb24oTF9saXN0KXtyZXR1cm4gZnVuY3Rpb24oTF9mdW5jKXtyZXR1cm4gZnVuY3Rpb24oTF9wb3Mpe3JldHVybiByZXNvbHZlKExfbGlzdCkobGF6eShmdW5jdGlvbihMX2gpe3JldHVybiBmdW5jdGlvbihMX3Qpe3JldHVybiBmdW5jdGlvbihMX0Qpe3JldHVybiByZXNvbHZlKExfZnVuYykoTF9oKShMX3BvcykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2lkeCkoTF90KShMX2Z1bmMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF8kbykoMSkoTF9wb3MpfSl9KX19fSkpKC0xKX19fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJpbmRleFwiKSgyKShcImluZGV4IGxpc3QgZWwgPSBmaW5kIChcXFxcaXRlbSAuID09IGVsIGl0ZW0pIGxpc3RcIikobGF6eShmdW5jdGlvbihMX2xpc3Qpe3JldHVybiBmdW5jdGlvbihMX2VsKXtyZXR1cm4gcmVzb2x2ZShMX2ZpbmQpKGxhenkoZnVuY3Rpb24oTF9pdGVtKXtyZXR1cm4gcmVzb2x2ZShMXyRwJHApKExfZWwpKExfaXRlbSl9KSkoTF9saXN0KX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImFzc2VydEFsaXN0XCIpKDMpKFwiYXNzZXJ0QWxpc3QgbXNnIHZhbHVlIHJlc3VsdCA9IGFzc2VydCAoaXNBbGlzdCB2YWx1ZSkgKHN0ckNhdCAoY29ucyBtc2cgKGNvbnMgJyBzaG91bGQgYmUgYSBhc3NvY2lhdGlvbiBsaXN0LCBidXQgaXQgaXMgbm90OyBpdHMgdHlwZSBpcyAnIChjb25zIChnZXRUeXBlIHZhbHVlKSAoY29ucyAnOiAnIChjb25zIChzaG93IHZhbHVlKSBuaWwpKSkpKSkgcmVzdWx0XCIpKGxhenkoZnVuY3Rpb24oTF9tc2cpe3JldHVybiBmdW5jdGlvbihMX3ZhbHVlKXtyZXR1cm4gZnVuY3Rpb24oTF9yZXN1bHQpe3JldHVybiByZXNvbHZlKExfYXNzZXJ0KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaXNBbGlzdCkoTF92YWx1ZSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc3RyQ2F0KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF9tc2cpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShcIiBzaG91bGQgYmUgYSBhc3NvY2lhdGlvbiBsaXN0LCBidXQgaXQgaXMgbm90OyBpdHMgdHlwZSBpcyBcIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9nZXRUeXBlKShMX3ZhbHVlKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShcIjogXCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc2hvdykoTF92YWx1ZSl9KShMX25pbCl9KX0pfSl9KX0pfSkoTF9yZXN1bHQpfX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImFjb25zXCIpKDMpKFwiYWNvbnMgayB2IGFsaXN0ID0gYXNzZXJ0QWxpc3QgXFxcImFjb25zIGFsaXN0XFxcIiBhbGlzdCAoXFxcXEAgdHlwZSBjb25zIC4gXFxcXGYgLiBcXFxcQCBhc3NvYyB0cnVlIC4gZiAoY29ucyBrIHYpIGFsaXN0KVwiKShsYXp5KGZ1bmN0aW9uKExfayl7cmV0dXJuIGZ1bmN0aW9uKExfdil7cmV0dXJuIGZ1bmN0aW9uKExfYWxpc3Qpe3JldHVybiByZXNvbHZlKExfYXNzZXJ0QWxpc3QpKFwiYWNvbnMgYWxpc3RcIikoTF9hbGlzdCkobGF6eShzZXRUeXBlKHNldExhbWJkYVByb3BlcnRpZXMoZnVuY3Rpb24oTF9mKXtyZXR1cm4gcmVzb2x2ZShMX2YpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShMX2spKExfdil9KShMX2FsaXN0KX0sIHtcImFzc29jXCI6XCJ0cnVlXCJ9KSwgJ2NvbnMnKSkpfX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImFzc29jXCIpKDIpKFwiYXNzb2MgayBhbGlzdCAgPSBmaW5kIChcXFxcZWwgLiBlcSBrIChoZWFkIGVsKSkgYWxpc3QgKFxcXFxjZWxsIC4gY2VsbCBcXFxcaGVhZCB0YWlsIC4gc29tZSB0YWlsKSBub25lXCIpKGxhenkoZnVuY3Rpb24oTF9rKXtyZXR1cm4gZnVuY3Rpb24oTF9hbGlzdCl7cmV0dXJuIHJlc29sdmUoTF9maW5kKShsYXp5KGZ1bmN0aW9uKExfZWwpe3JldHVybiByZXNvbHZlKExfZXEpKExfaykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2hlYWQpKExfZWwpfSl9KSkoTF9hbGlzdCkobGF6eShmdW5jdGlvbihMX2NlbGwpe3JldHVybiByZXNvbHZlKExfY2VsbCkobGF6eShmdW5jdGlvbihMX2hlYWQpe3JldHVybiBmdW5jdGlvbihMX3RhaWwpe3JldHVybiByZXNvbHZlKExfc29tZSkoTF90YWlsKX19KSl9KSkoTF9ub25lKX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcInJhc3NvY1wiKSgyKShcInJhc3NvYyB2IGFsaXN0ID0gZmluZCAoXFxcXGVsIC4gZXEgdiAodGFpbCBlbCkpIGFsaXN0IChcXFxcY2VsbCAuIGNlbGwgXFxcXGhlYWQgdGFpbCAuIHNvbWUgaGVhZCkgbm9uZVwiKShsYXp5KGZ1bmN0aW9uKExfdil7cmV0dXJuIGZ1bmN0aW9uKExfYWxpc3Qpe3JldHVybiByZXNvbHZlKExfZmluZCkobGF6eShmdW5jdGlvbihMX2VsKXtyZXR1cm4gcmVzb2x2ZShMX2VxKShMX3YpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90YWlsKShMX2VsKX0pfSkpKExfYWxpc3QpKGxhenkoZnVuY3Rpb24oTF9jZWxsKXtyZXR1cm4gcmVzb2x2ZShMX2NlbGwpKGxhenkoZnVuY3Rpb24oTF9oZWFkKXtyZXR1cm4gZnVuY3Rpb24oTF90YWlsKXtyZXR1cm4gcmVzb2x2ZShMX3NvbWUpKExfaGVhZCl9fSkpfSkpKExfbm9uZSl9fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJpc0FsaXN0XCIpKDEpKFwiaXNBbGlzdCBvYmogPSBvciAoaXNOaWwgb2JqKSAoaGFzUHJvcGVydHkgb2JqICdhc3NvYycpXCIpKGxhenkoZnVuY3Rpb24oTF9vYmope3JldHVybiByZXNvbHZlKExfb3IpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pc05pbCkoTF9vYmopfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2hhc1Byb3BlcnR5KShMX29iaikoXCJhc3NvY1wiKX0pfSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJhY29uc1BhaXJcIikoMikoXCJhY29uc1BhaXIga2V5VmFsdWUgbGlzdCA9IFxcXFxAIHR5cGUgY29ucyAuIFxcXFxmIC4gXFxcXEAgYXNzb2MgdHJ1ZSAuIGYga2V5VmFsdWUgbGlzdFwiKShsYXp5KGZ1bmN0aW9uKExfa2V5VmFsdWUpe3JldHVybiBmdW5jdGlvbihMX2xpc3Qpe3JldHVybiBzZXRUeXBlKHNldExhbWJkYVByb3BlcnRpZXMoZnVuY3Rpb24oTF9mKXtyZXR1cm4gcmVzb2x2ZShMX2YpKExfa2V5VmFsdWUpKExfbGlzdCl9LCB7XCJhc3NvY1wiOlwidHJ1ZVwifSksICdjb25zJyl9fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJhcHBlbmRBbGlzdFwiKSgyKShcImFwcGVuZEFsaXN0IGEgYiA9IGlzTmlsIGFcXG4gIGJcXG4gIGFjb25zUGFpciAoaGVhZCBhKSAoYXBwZW5kQWxpc3QgKHRhaWwgYSkgYilcIikobGF6eShmdW5jdGlvbihMX2Epe3JldHVybiBmdW5jdGlvbihMX2Ipe3JldHVybiByZXNvbHZlKExfaXNOaWwpKExfYSkoTF9iKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYWNvbnNQYWlyKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaGVhZCkoTF9hKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hcHBlbmRBbGlzdCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3RhaWwpKExfYSl9KShMX2IpfSl9KX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImtleXNcIikoMSkoXCJrZXlzIGxpc3QgPSBtYXAgKFxcXFxsIC4gaGVhZCBsKSBsaXN0XCIpKGxhenkoZnVuY3Rpb24oTF9saXN0KXtyZXR1cm4gcmVzb2x2ZShMX21hcCkobGF6eShmdW5jdGlvbihMX2wpe3JldHVybiByZXNvbHZlKExfaGVhZCkoTF9sKX0pKShMX2xpc3QpfSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJnZXRQcm9wZXJ0eVwiKSgyKShcImdldFByb3BlcnR5IGZ1bmMgcHJvcCA9IGdldFByb3BlcnRpZXMgZnVuY1xcbiAgXFxcXHByb3BzIC4gYXNzb2MgcHJvcCBwcm9wc1xcbiAgbm9uZVwiKShsYXp5KGZ1bmN0aW9uKExfZnVuYyl7cmV0dXJuIGZ1bmN0aW9uKExfcHJvcCl7cmV0dXJuIHJlc29sdmUoTF9nZXRQcm9wZXJ0aWVzKShMX2Z1bmMpKGxhenkoZnVuY3Rpb24oTF9wcm9wcyl7cmV0dXJuIHJlc29sdmUoTF9hc3NvYykoTF9wcm9wKShMX3Byb3BzKX0pKShMX25vbmUpfX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwiaGFzUHJvcGVydHlcIikoMikoXCJoYXNQcm9wZXJ0eSBmdW5jIHByb3AgPSBnZXRQcm9wZXJ0eSBmdW5jIHByb3BcXG4gIFxcXFxfIC4gdHJ1ZVxcbiAgZmFsc2VcIikobGF6eShmdW5jdGlvbihMX2Z1bmMpe3JldHVybiBmdW5jdGlvbihMX3Byb3Ape3JldHVybiByZXNvbHZlKExfZ2V0UHJvcGVydHkpKExfZnVuYykoTF9wcm9wKShsYXp5KGZ1bmN0aW9uKExfXyl7cmV0dXJuIHJlc29sdmUoTF90cnVlKX0pKShMX2ZhbHNlKX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcInF1aWNrc29ydFwiKSgyKShcInF1aWNrc29ydCBsZXNzIGxpc3QgPSAocXMgbGVzcyBsaXN0KSBuaWxcIikobGF6eShmdW5jdGlvbihMX2xlc3Mpe3JldHVybiBmdW5jdGlvbihMX2xpc3Qpe3JldHVybiByZXNvbHZlKExfcXMpKExfbGVzcykoTF9saXN0KShMX25pbCl9fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJxc1wiKSgyKShcInFzIHNvcnRlZEZ1bmMgbGlzdCA9IGxpc3RcXG4gIFxcXFxoIHQgRCAuIFxcXFxcXFxcXFxuICAgIGdyZWF0ZXIgPSBmaWx0ZXIgKHNvcnRlZEZ1bmMgaCkgdFxcbiAgICBsZXNzZXIgPSBmaWx0ZXIgKGNvbXBvc2Ugbm90IChzb3J0ZWRGdW5jIGgpKSB0XFxuICAgIC5cXG4gICAgXFxcXHJlc3QgLiAocXMgc29ydGVkRnVuYyBsZXNzZXIpIChjb25zIGggKChxcyBzb3J0ZWRGdW5jIGdyZWF0ZXIpIHJlc3QpKVxcbiAgaWRcIikobGF6eShmdW5jdGlvbihMX3NvcnRlZEZ1bmMpe3JldHVybiBmdW5jdGlvbihMX2xpc3Qpe3JldHVybiByZXNvbHZlKExfbGlzdCkobGF6eShmdW5jdGlvbihMX2gpe3JldHVybiBmdW5jdGlvbihMX3Qpe3JldHVybiBmdW5jdGlvbihMX0Qpe3JldHVybiAoZnVuY3Rpb24oKXtcblxudmFyIExfbGVzc2VyLCBMX2dyZWF0ZXI7XG5cbkxfbGVzc2VyID0gZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2ZpbHRlcikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbXBvc2UpKExfbm90KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc29ydGVkRnVuYykoTF9oKX0pfSkoTF90KX07XG5cbkxfZ3JlYXRlciA9IGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9maWx0ZXIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zb3J0ZWRGdW5jKShMX2gpfSkoTF90KX07XG5yZXR1cm4gZnVuY3Rpb24oTF9yZXN0KXtyZXR1cm4gcmVzb2x2ZShMX3FzKShMX3NvcnRlZEZ1bmMpKExfbGVzc2VyKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF9oKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcXMpKExfc29ydGVkRnVuYykoTF9ncmVhdGVyKShMX3Jlc3QpfSl9KX19KSgpfX19KSkoTF9pZCl9fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJpbnNlcnRTb3J0ZWRcIikoMykoXCJpbnNlcnRTb3J0ZWQgc29ydEZ1bmMgaXRlbSBsaXN0ID0gbGlzdFxcbiAgXFxcXGggdCBEIC4gc29ydEZ1bmMgaXRlbSBoIChjb25zIGl0ZW0gbGlzdCkgKGNvbnMgaCAoaW5zZXJ0U29ydGVkIHNvcnRGdW5jIGl0ZW0gdCkpXFxuICBjb25zIGl0ZW0gbmlsXCIpKGxhenkoZnVuY3Rpb24oTF9zb3J0RnVuYyl7cmV0dXJuIGZ1bmN0aW9uKExfaXRlbSl7cmV0dXJuIGZ1bmN0aW9uKExfbGlzdCl7cmV0dXJuIHJlc29sdmUoTF9saXN0KShsYXp5KGZ1bmN0aW9uKExfaCl7cmV0dXJuIGZ1bmN0aW9uKExfdCl7cmV0dXJuIGZ1bmN0aW9uKExfRCl7cmV0dXJuIHJlc29sdmUoTF9zb3J0RnVuYykoTF9pdGVtKShMX2gpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShMX2l0ZW0pKExfbGlzdCl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF9oKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaW5zZXJ0U29ydGVkKShMX3NvcnRGdW5jKShMX2l0ZW0pKExfdCl9KX0pfX19KSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKExfaXRlbSkoTF9uaWwpfSl9fX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwidG9rZW5cIikoMikoXCJ0b2tlbiB0eHQgcG9zID0gXFxcXGYgLiBmIHR4dCBwb3NcIikobGF6eShzZXREYXRhVHlwZShmdW5jdGlvbihMX3R4dCl7cmV0dXJuIGZ1bmN0aW9uKExfcG9zKXtyZXR1cm4gc2V0VHlwZShmdW5jdGlvbihMX2Ype3JldHVybiByZXNvbHZlKExfZikoTF90eHQpKExfcG9zKX0sICd0b2tlbicpfX0sICd0b2tlbicpKSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcInRva2VuU3RyaW5nXCIpKDEpKFwidG9rZW5TdHJpbmcgdG9rID0gdG9rIFxcXFx0IHAgLiB0XCIpKGxhenkoZnVuY3Rpb24oTF90b2spe3JldHVybiByZXNvbHZlKExfdG9rKShsYXp5KGZ1bmN0aW9uKExfdCl7cmV0dXJuIGZ1bmN0aW9uKExfcCl7cmV0dXJuIHJlc29sdmUoTF90KX19KSl9KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcInRva2VuUG9zXCIpKDEpKFwidG9rZW5Qb3MgdG9rID0gdG9rIFxcXFx0IHAgLiBwXCIpKGxhenkoZnVuY3Rpb24oTF90b2spe3JldHVybiByZXNvbHZlKExfdG9rKShsYXp5KGZ1bmN0aW9uKExfdCl7cmV0dXJuIGZ1bmN0aW9uKExfcCl7cmV0dXJuIHJlc29sdmUoTF9wKX19KSl9KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImlzVG9rZW5cIikoMSkoXCJpc1Rva2VuIHQgPSBoYXNUeXBlIHQgdG9rZW5cIikobGF6eShmdW5jdGlvbihMX3Qpe3JldHVybiByZXNvbHZlKExfaGFzVHlwZSkoTF90KShMX3Rva2VuKX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwicGFyZW5zXCIpKDMpKFwicGFyZW5zIHN0YXJ0IGVuZCBjb250ZW50ID0gXFxcXGYgLiBmIHN0YXJ0IGVuZCBjb250ZW50XCIpKGxhenkoc2V0RGF0YVR5cGUoZnVuY3Rpb24oTF9zdGFydCl7cmV0dXJuIGZ1bmN0aW9uKExfZW5kKXtyZXR1cm4gZnVuY3Rpb24oTF9jb250ZW50KXtyZXR1cm4gc2V0VHlwZShmdW5jdGlvbihMX2Ype3JldHVybiByZXNvbHZlKExfZikoTF9zdGFydCkoTF9lbmQpKExfY29udGVudCl9LCAncGFyZW5zJyl9fX0sICdwYXJlbnMnKSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJwYXJlbnNTdGFydFwiKSgxKShcInBhcmVuc1N0YXJ0IHAgPSBwIFxcXFxzIGUgYyAuIHNcIikobGF6eShmdW5jdGlvbihMX3Ape3JldHVybiByZXNvbHZlKExfcCkobGF6eShmdW5jdGlvbihMX3Mpe3JldHVybiBmdW5jdGlvbihMX2Upe3JldHVybiBmdW5jdGlvbihMX2Mpe3JldHVybiByZXNvbHZlKExfcyl9fX0pKX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwicGFyZW5zRW5kXCIpKDEpKFwicGFyZW5zRW5kIHAgPSBwIFxcXFxzIGUgYyAuIGVcIikobGF6eShmdW5jdGlvbihMX3Ape3JldHVybiByZXNvbHZlKExfcCkobGF6eShmdW5jdGlvbihMX3Mpe3JldHVybiBmdW5jdGlvbihMX2Upe3JldHVybiBmdW5jdGlvbihMX2Mpe3JldHVybiByZXNvbHZlKExfZSl9fX0pKX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwicGFyZW5zQ29udGVudFwiKSgxKShcInBhcmVuc0NvbnRlbnQgcCA9IHAgXFxcXHMgZSBjIC4gY1wiKShsYXp5KGZ1bmN0aW9uKExfcCl7cmV0dXJuIHJlc29sdmUoTF9wKShsYXp5KGZ1bmN0aW9uKExfcyl7cmV0dXJuIGZ1bmN0aW9uKExfZSl7cmV0dXJuIGZ1bmN0aW9uKExfYyl7cmV0dXJuIHJlc29sdmUoTF9jKX19fSkpfSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJpc1BhcmVuc1wiKSgxKShcImlzUGFyZW5zIHAgPSBoYXNUeXBlIHAgcGFyZW5zXCIpKGxhenkoZnVuY3Rpb24oTF9wKXtyZXR1cm4gcmVzb2x2ZShMX2hhc1R5cGUpKExfcCkoTF9wYXJlbnMpfSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJtYWtlUGFyZW5zXCIpKDMpKFwibWFrZVBhcmVucyBzdGFydCBlbmQgY29udGVudCA9XFxuICBhbmQgKGlzQ29ucyBjb250ZW50KSAoaXNOaWwgKHRhaWwgY29udGVudCkpXFxuICAgIG1ha2VQYXJlbnMgc3RhcnQgZW5kIChoZWFkIGNvbnRlbnQpXFxuICAgIG9yIChpc1Rva2VuIGNvbnRlbnQpIChpc1BhcmVucyBjb250ZW50KVxcbiAgICAgIGNvbnRlbnRcXG4gICAgICBwYXJlbnMgc3RhcnQgZW5kIGNvbnRlbnRcIikobGF6eShmdW5jdGlvbihMX3N0YXJ0KXtyZXR1cm4gZnVuY3Rpb24oTF9lbmQpe3JldHVybiBmdW5jdGlvbihMX2NvbnRlbnQpe3JldHVybiByZXNvbHZlKExfYW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaXNDb25zKShMX2NvbnRlbnQpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2lzTmlsKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdGFpbCkoTF9jb250ZW50KX0pfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX21ha2VQYXJlbnMpKExfc3RhcnQpKExfZW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaGVhZCkoTF9jb250ZW50KX0pfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX29yKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaXNUb2tlbikoTF9jb250ZW50KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pc1BhcmVucykoTF9jb250ZW50KX0pKExfY29udGVudCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3BhcmVucykoTF9zdGFydCkoTF9lbmQpKExfY29udGVudCl9KX0pfX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcInBhcmVuc0Zyb21Ub2tzXCIpKDMpKFwicGFyZW5zRnJvbVRva3MgbGVmdCByaWdodCBjb250ZW50ID0gXFxcXFxcXFxcXG4gIHN0YXJ0ID0gdG9rZW5Qb3MgbGVmdFxcbiAgZW5kID0gKyAodG9rZW5Qb3MgcmlnaHQpIChzdHJMZW4gKHRva2VuU3RyaW5nIHJpZ2h0KSlcXG4gIC5cXG4gIHBhcmVucyBzdGFydCBlbmQgY29udGVudFwiKShsYXp5KGZ1bmN0aW9uKExfbGVmdCl7cmV0dXJuIGZ1bmN0aW9uKExfcmlnaHQpe3JldHVybiBmdW5jdGlvbihMX2NvbnRlbnQpe3JldHVybiAoZnVuY3Rpb24oKXtcblxudmFyIExfZW5kLCBMX3N0YXJ0O1xuXG5MX2VuZCA9IGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF8kbykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3Rva2VuUG9zKShMX3JpZ2h0KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zdHJMZW4pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90b2tlblN0cmluZykoTF9yaWdodCl9KX0pfTtcblxuTF9zdGFydCA9IGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90b2tlblBvcykoTF9sZWZ0KX07XG5yZXR1cm4gcmVzb2x2ZShMX3BhcmVucykoTF9zdGFydCkoTF9lbmQpKExfY29udGVudCl9KSgpfX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcInN0cmlwUGFyZW5zXCIpKDEpKFwic3RyaXBQYXJlbnMgcCA9IGlzUGFyZW5zIHAgKHBhcmVuc0NvbnRlbnQgcCkgcFwiKShsYXp5KGZ1bmN0aW9uKExfcCl7cmV0dXJuIHJlc29sdmUoTF9pc1BhcmVucykoTF9wKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcGFyZW5zQ29udGVudCkoTF9wKX0pKExfcCl9KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcInBhcnNlRXJyXCIpKDIpKFwicGFyc2VFcnIgbXNnMSBtc2cyID0gXFxcXGYgLiBmIChzdHJDYXQgKGNvbnMgbXNnMSAoY29ucyBtc2cyIG5pbCkpKVwiKShsYXp5KHNldERhdGFUeXBlKGZ1bmN0aW9uKExfbXNnMSl7cmV0dXJuIGZ1bmN0aW9uKExfbXNnMil7cmV0dXJuIHNldFR5cGUoZnVuY3Rpb24oTF9mKXtyZXR1cm4gcmVzb2x2ZShMX2YpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zdHJDYXQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShMX21zZzEpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShMX21zZzIpKExfbmlsKX0pfSl9KX0sICdwYXJzZUVycicpfX0sICdwYXJzZUVycicpKSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcInBhcnNlRXJyTXNnXCIpKDEpKFwicGFyc2VFcnJNc2cgZXJyID0gZXJyIFxcXFxtIC4gbVwiKShsYXp5KGZ1bmN0aW9uKExfZXJyKXtyZXR1cm4gcmVzb2x2ZShMX2VycikobGF6eShmdW5jdGlvbihMX20pe3JldHVybiByZXNvbHZlKExfbSl9KSl9KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImlzUGFyc2VFcnJcIikoMSkoXCJpc1BhcnNlRXJyIHRoaW5nID0gaGFzVHlwZSB0aGluZyBwYXJzZUVyclwiKShsYXp5KGZ1bmN0aW9uKExfdGhpbmcpe3JldHVybiByZXNvbHZlKExfaGFzVHlwZSkoTF90aGluZykoTF9wYXJzZUVycil9KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImVtcHR5VG9rZW5cIikoMCkoXCJlbXB0eVRva2VuID0gcmVnZXhwICdeXFxcXFxcXFxuWyBcXFxcXFxcXGldKigjfCQpJ1wiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcmVnZXhwKShcIl5cXFxcblsgXFxcXGldKigjfCQpXCIpfSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcIm1ha2VUb2tlbnNcIikoMikoXCJtYWtlVG9rZW5zIHN0cmluZ3Mgc3RhcnQgPSBzdHJpbmdzIChcXFxcaCB0IEQgLiBtYWtlTW9yZVRva2VucyBoIHQgc3RhcnQpIG5pbFwiKShsYXp5KGZ1bmN0aW9uKExfc3RyaW5ncyl7cmV0dXJuIGZ1bmN0aW9uKExfc3RhcnQpe3JldHVybiByZXNvbHZlKExfc3RyaW5ncykobGF6eShmdW5jdGlvbihMX2gpe3JldHVybiBmdW5jdGlvbihMX3Qpe3JldHVybiBmdW5jdGlvbihMX0Qpe3JldHVybiByZXNvbHZlKExfbWFrZU1vcmVUb2tlbnMpKExfaCkoTF90KShMX3N0YXJ0KX19fSkpKExfbmlsKX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcIm1ha2VNb3JlVG9rZW5zXCIpKDMpKFwibWFrZU1vcmVUb2tlbnMgaCB0IHN0YXJ0ID0gXFxcXFxcXFxcXG4gIG5leHQgPSBtYWtlVG9rZW5zIHQgKCsgc3RhcnQgKHN0ckxlbiBoKSlcXG4gIC5cXG4gIGFuZCAoc3RyTWF0Y2hlcyBoIGVtcHR5VG9rZW4pIChvciAoaXNOaWwgdCkgKHN0clN0YXJ0c1dpdGggKGhlYWQgdCkgJ1xcXFxuJykpXFxuICAgIG1ha2VUb2tlbnMgdCAoKyBzdGFydCAoc3RyTGVuIGgpKVxcbiAgICBvciAoc3RyU3RhcnRzV2l0aCBoICcgJykgKHN0clN0YXJ0c1dpdGggaCAnIycpXFxuICAgICAgbmV4dFxcbiAgICAgIGFuZCAoc3RyU3RhcnRzV2l0aCBoICdcXFxcbicpIChzdHJTdGFydHNXaXRoIChoZWFkIHQpICcjJylcXG4gICAgICAgIG1ha2VUb2tlbnMgKHRhaWwgdCkgKCsgc3RhcnQgKCsgKHN0ckxlbiBoKSAoc3RyTGVuIChoZWFkIHQpKSkpXFxuICAgICAgICBjb25zICh0b2tlbiBoIHN0YXJ0KSBuZXh0XCIpKGxhenkoZnVuY3Rpb24oTF9oKXtyZXR1cm4gZnVuY3Rpb24oTF90KXtyZXR1cm4gZnVuY3Rpb24oTF9zdGFydCl7cmV0dXJuIChmdW5jdGlvbigpe1xuXG52YXIgTF9uZXh0O1xuXG5MX25leHQgPSBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfbWFrZVRva2VucykoTF90KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfJG8pKExfc3RhcnQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zdHJMZW4pKExfaCl9KX0pfTtcbnJldHVybiByZXNvbHZlKExfYW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc3RyTWF0Y2hlcykoTF9oKShMX2VtcHR5VG9rZW4pfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX29yKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaXNOaWwpKExfdCl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc3RyU3RhcnRzV2l0aCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2hlYWQpKExfdCl9KShcIlxcblwiKX0pfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX21ha2VUb2tlbnMpKExfdCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMXyRvKShMX3N0YXJ0KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc3RyTGVuKShMX2gpfSl9KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9vcikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3N0clN0YXJ0c1dpdGgpKExfaCkoXCIgXCIpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3N0clN0YXJ0c1dpdGgpKExfaCkoXCIjXCIpfSkoTF9uZXh0KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc3RyU3RhcnRzV2l0aCkoTF9oKShcIlxcblwiKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zdHJTdGFydHNXaXRoKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaGVhZCkoTF90KX0pKFwiI1wiKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9tYWtlVG9rZW5zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdGFpbCkoTF90KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF8kbykoTF9zdGFydCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMXyRvKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc3RyTGVuKShMX2gpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3N0ckxlbikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2hlYWQpKExfdCl9KX0pfSl9KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdG9rZW4pKExfaCkoTF9zdGFydCl9KShMX25leHQpfSl9KX0pfSkoKX19fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJzcGxpdFRva2Vuc1wiKSgyKShcInNwbGl0VG9rZW5zIHN0ciBwYXQgPSBmaWx0ZXIgKFxcXFxzIC4gbm90IChlcSBzICcnKSkgKGJhc2ljU3BsaXRUb2tlbnMgc3RyIHBhdCB0cnVlKVwiKShsYXp5KGZ1bmN0aW9uKExfc3RyKXtyZXR1cm4gZnVuY3Rpb24oTF9wYXQpe3JldHVybiByZXNvbHZlKExfZmlsdGVyKShsYXp5KGZ1bmN0aW9uKExfcyl7cmV0dXJuIHJlc29sdmUoTF9ub3QpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9lcSkoTF9zKShcIlwiKX0pfSkpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9iYXNpY1NwbGl0VG9rZW5zKShMX3N0cikoTF9wYXQpKExfdHJ1ZSl9KX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcIm51bWJlclBhdFwiKSgwKShcIm51bWJlclBhdCA9IHJlZ2V4cCAnLT8oWzAtOV0rKFxcXFxcXFxcLlswLTldKyk/fFxcXFxcXFxcLlswLTldKyknXCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9yZWdleHApKFwiLT8oWzAtOV0rKFxcXFwuWzAtOV0rKT98XFxcXC5bMC05XSspXCIpfSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcIm1hdGNoT2Zmc2V0XCIpKDIpKFwibWF0Y2hPZmZzZXQgc3RyIG1hdGNoID0gaXNOaWwgbWF0Y2hcXG4gIHN0ckxlbiBzdHJcXG4gIGhlYWQgKHRhaWwgKHRhaWwgbWF0Y2gpKVwiKShsYXp5KGZ1bmN0aW9uKExfc3RyKXtyZXR1cm4gZnVuY3Rpb24oTF9tYXRjaCl7cmV0dXJuIHJlc29sdmUoTF9pc05pbCkoTF9tYXRjaCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3N0ckxlbikoTF9zdHIpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2hlYWQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90YWlsKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdGFpbCkoTF9tYXRjaCl9KX0pfSl9fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJiYXNpY1NwbGl0VG9rZW5zXCIpKDMpKFwiYmFzaWNTcGxpdFRva2VucyBzdHIgcGF0IHByZXZJc0RlbCA9ID09IHN0ciAnJ1xcbiAgbmlsXFxuICBcXFxcXFxcXFxcbiAgICBudW0gPSBzdHJNYXRjaCBzdHIgbnVtYmVyUGF0XFxuICAgIGRlbCA9IHN0ck1hdGNoIHN0ciBwYXRcXG4gICAgbnVtT2Zmc2V0ID0gbWF0Y2hPZmZzZXQgc3RyIG51bVxcbiAgICBkZWxPZmZzZXQgPSBtYXRjaE9mZnNldCBzdHIgZGVsXFxuICAgIHNlbGVjdCA9IGFuZCAoPT0gbnVtT2Zmc2V0IDApIHByZXZJc0RlbFxcbiAgICAgIFxcXFxkZWwgbnVtIGZpcnN0IC4gbnVtXFxuICAgICAgPT0gZGVsT2Zmc2V0IDBcXG4gICAgICAgIFxcXFxkZWwgbnVtIGZpcnN0IC4gZGVsXFxuICAgICAgICBcXFxcZGVsIG51bSBmaXJzdCAuIGZpcnN0XFxuICAgIGZpcnN0ID0gc2VsZWN0IChoZWFkIGRlbCkgKGhlYWQgbnVtKSAoc3RyU3Vic3RyaW5nIHN0ciAwIGRlbE9mZnNldClcXG4gICAgLlxcbiAgICBjb25zXFxuICAgICAgZmlyc3RcXG4gICAgICBiYXNpY1NwbGl0VG9rZW5zXFxuICAgICAgICBzdHJTdWJzdHJpbmcgc3RyIChzdHJMZW4gZmlyc3QpIDBcXG4gICAgICAgIHBhdFxcbiAgICAgICAgc2VsZWN0IHRydWUgZmFsc2UgZmFsc2VcIikobGF6eShmdW5jdGlvbihMX3N0cil7cmV0dXJuIGZ1bmN0aW9uKExfcGF0KXtyZXR1cm4gZnVuY3Rpb24oTF9wcmV2SXNEZWwpe3JldHVybiByZXNvbHZlKExfJHAkcCkoTF9zdHIpKFwiXCIpKExfbmlsKShmdW5jdGlvbigpe1xudmFyIExfZmlyc3QsIExfc2VsZWN0LCBMX2RlbE9mZnNldCwgTF9udW1PZmZzZXQsIExfZGVsLCBMX251bTtcblxuTF9maXJzdCA9IGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zZWxlY3QpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9oZWFkKShMX2RlbCl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaGVhZCkoTF9udW0pfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3N0clN1YnN0cmluZykoTF9zdHIpKDApKExfZGVsT2Zmc2V0KX0pfTtcblxuTF9zZWxlY3QgPSBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfJHAkcCkoTF9udW1PZmZzZXQpKDApfSkoTF9wcmV2SXNEZWwpKGxhenkoZnVuY3Rpb24oTF9kZWxfMCl7cmV0dXJuIGZ1bmN0aW9uKExfbnVtXzEpe3JldHVybiBmdW5jdGlvbihMX2ZpcnN0KXtyZXR1cm4gcmVzb2x2ZShMX251bV8xKX19fSkpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF8kcCRwKShMX2RlbE9mZnNldCkoMCkobGF6eShmdW5jdGlvbihMX2RlbF8wKXtyZXR1cm4gZnVuY3Rpb24oTF9udW1fMSl7cmV0dXJuIGZ1bmN0aW9uKExfZmlyc3Qpe3JldHVybiByZXNvbHZlKExfZGVsXzApfX19KSkobGF6eShmdW5jdGlvbihMX2RlbF8wKXtyZXR1cm4gZnVuY3Rpb24oTF9udW1fMSl7cmV0dXJuIGZ1bmN0aW9uKExfZmlyc3Qpe3JldHVybiByZXNvbHZlKExfZmlyc3QpfX19KSl9KX07XG5cbkxfZGVsT2Zmc2V0ID0gZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX21hdGNoT2Zmc2V0KShMX3N0cikoTF9kZWwpfTtcblxuTF9udW1PZmZzZXQgPSBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfbWF0Y2hPZmZzZXQpKExfc3RyKShMX251bSl9O1xuXG5MX2RlbCA9IGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zdHJNYXRjaCkoTF9zdHIpKExfcGF0KX07XG5cbkxfbnVtID0gZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3N0ck1hdGNoKShMX3N0cikoTF9udW1iZXJQYXQpfTtcbnJldHVybiByZXNvbHZlKExfY29ucykoTF9maXJzdCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2Jhc2ljU3BsaXRUb2tlbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zdHJTdWJzdHJpbmcpKExfc3RyKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc3RyTGVuKShMX2ZpcnN0KX0pKDApfSkoTF9wYXQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zZWxlY3QpKExfdHJ1ZSkoTF9mYWxzZSkoTF9mYWxzZSl9KX0pfSl9fX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwidG9rZW5zXCIpKDIpKFwidG9rZW5zIHN0ciBwYXQgPSBtYWtlVG9rZW5zIChzcGxpdFRva2VucyBzdHIgcGF0KSAwXCIpKGxhenkoZnVuY3Rpb24oTF9zdHIpe3JldHVybiBmdW5jdGlvbihMX3BhdCl7cmV0dXJuIHJlc29sdmUoTF9tYWtlVG9rZW5zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc3BsaXRUb2tlbnMpKExfc3RyKShMX3BhdCl9KSgwKX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImlzU3RyaW5nXCIpKDEpKFwiaXNTdHJpbmcgcyA9ID09IChnZXRUeXBlIHMpICcqc3RyaW5nJ1wiKShsYXp5KGZ1bmN0aW9uKExfcyl7cmV0dXJuIHJlc29sdmUoTF8kcCRwKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZ2V0VHlwZSkoTF9zKX0pKFwiKnN0cmluZ1wiKX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwiaXNOdW1iZXJcIikoMSkoXCJpc051bWJlciBzID0gPT0gKGdldFR5cGUgcykgJypudW1iZXInXCIpKGxhenkoZnVuY3Rpb24oTF9zKXtyZXR1cm4gcmVzb2x2ZShMXyRwJHApKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9nZXRUeXBlKShMX3MpfSkoXCIqbnVtYmVyXCIpfSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJpc1Rva2VuU3RyaW5nXCIpKDIpKFwiaXNUb2tlblN0cmluZyB0b2sgc3RyID0gb3JcXG4gIGFuZCAoaXNUb2tlbiB0b2spIChlcSAodG9rZW5TdHJpbmcgdG9rKSBzdHIpXFxuICBhbmQgKGlzU3RyaW5nIHRvaykgKGVxIHRvayBzdHIpXCIpKGxhenkoZnVuY3Rpb24oTF90b2spe3JldHVybiBmdW5jdGlvbihMX3N0cil7cmV0dXJuIHJlc29sdmUoTF9vcikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2FuZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2lzVG9rZW4pKExfdG9rKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9lcSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3Rva2VuU3RyaW5nKShMX3Rvayl9KShMX3N0cil9KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hbmQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pc1N0cmluZykoTF90b2spfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2VxKShMX3RvaykoTF9zdHIpfSl9KX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImlzVG9rZW5TdGFydFwiKSgyKShcImlzVG9rZW5TdGFydCB0b2sgc3RyID0gb3JcXG4gIGFuZCAoaXNUb2tlbiB0b2spIChzdHJTdGFydHNXaXRoICh0b2tlblN0cmluZyB0b2spIHN0cilcXG4gIGFuZCAoaXNTdHJpbmcgdG9rKSAoc3RyU3RhcnRzV2l0aCB0b2sgc3RyKVwiKShsYXp5KGZ1bmN0aW9uKExfdG9rKXtyZXR1cm4gZnVuY3Rpb24oTF9zdHIpe3JldHVybiByZXNvbHZlKExfb3IpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hbmQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pc1Rva2VuKShMX3Rvayl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc3RyU3RhcnRzV2l0aCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3Rva2VuU3RyaW5nKShMX3Rvayl9KShMX3N0cil9KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hbmQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pc1N0cmluZykoTF90b2spfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3N0clN0YXJ0c1dpdGgpKExfdG9rKShMX3N0cil9KX0pfX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwic3RyVG9rZW5TdHJpbmdcIikoMSkoXCJzdHJUb2tlblN0cmluZyB0b2sgPSB3aXRoVG9rZW4gdG9rIG5pbCBcXFxcc3RyIHBvcyAuIHN0clwiKShsYXp5KGZ1bmN0aW9uKExfdG9rKXtyZXR1cm4gcmVzb2x2ZShMX3dpdGhUb2tlbikoTF90b2spKExfbmlsKShsYXp5KGZ1bmN0aW9uKExfc3RyKXtyZXR1cm4gZnVuY3Rpb24oTF9wb3Mpe3JldHVybiByZXNvbHZlKExfc3RyKX19KSl9KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcIndpdGhUb2tlblwiKSgzKShcIndpdGhUb2tlbiB0b2sgbm9uVG9rQ2FzZSB0b2tDYXNlID0gaXNUb2tlbiB0b2tcXG4gIHRvayB0b2tDYXNlXFxuICBpc1N0cmluZyB0b2tcXG4gICAgdG9rQ2FzZSB0b2sgLTFcXG4gICAgbm9uVG9rQ2FzZVwiKShsYXp5KGZ1bmN0aW9uKExfdG9rKXtyZXR1cm4gZnVuY3Rpb24oTF9ub25Ub2tDYXNlKXtyZXR1cm4gZnVuY3Rpb24oTF90b2tDYXNlKXtyZXR1cm4gcmVzb2x2ZShMX2lzVG9rZW4pKExfdG9rKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdG9rKShMX3Rva0Nhc2UpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2lzU3RyaW5nKShMX3RvaykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3Rva0Nhc2UpKExfdG9rKSgtMSl9KShMX25vblRva0Nhc2UpfSl9fX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwid2l0aENvbnNcIikoMykoXCJ3aXRoQ29ucyBsIG5pbENhc2UgY29udCA9IGlzQ29ucyBsIChsIChcXFxcaCB0IEQgLiBjb250IGggdCkgbmlsQ2FzZSkgbmlsQ2FzZVwiKShsYXp5KGZ1bmN0aW9uKExfbCl7cmV0dXJuIGZ1bmN0aW9uKExfbmlsQ2FzZSl7cmV0dXJuIGZ1bmN0aW9uKExfY29udCl7cmV0dXJuIHJlc29sdmUoTF9pc0NvbnMpKExfbCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2wpKGxhenkoZnVuY3Rpb24oTF9oKXtyZXR1cm4gZnVuY3Rpb24oTF90KXtyZXR1cm4gZnVuY3Rpb24oTF9EKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnQpKExfaCkoTF90KX19fSkpKExfbmlsQ2FzZSl9KShMX25pbENhc2UpfX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImlmTm90RXJyXCIpKDIpKFwiaWZOb3RFcnIgdGhpbmcgY29udCA9IGhhc1R5cGUgdGhpbmcgcGFyc2VFcnIgdGhpbmcgKGNvbnQgdGhpbmcpXCIpKGxhenkoZnVuY3Rpb24oTF90aGluZyl7cmV0dXJuIGZ1bmN0aW9uKExfY29udCl7cmV0dXJuIHJlc29sdmUoTF9oYXNUeXBlKShMX3RoaW5nKShMX3BhcnNlRXJyKShMX3RoaW5nKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29udCkoTF90aGluZyl9KX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcInBhcnNlVG9rc1wiKSgyKShcInBhcnNlVG9rcyB0b2tzIGdyb3VwcyA9XFxuICBpc05pbCB0b2tzIG5pbFxcbiAgICBpZk5vdEVyciAocGFyc2VUb2sgdG9rcyBncm91cHMpIFxcXFxsaXN0IC4gbGlzdCBcXFxcaCB0IC5cXG4gICAgICBpZk5vdEVyciAocGFyc2VUb2tzIHQgZ3JvdXBzKSBcXFxccmVzIC5cXG4gICAgICAgIGNvbnMgaFxcbiAgICAgICAgICBhbmQgKGlzQ29ucyByZXMpIChpc0Jsb2NrU3RhcnQgKGhlYWQgcmVzKSlcXG4gICAgICAgICAgICBjb25zIHJlcyBuaWxcXG4gICAgICAgICAgICByZXNcIikobGF6eShmdW5jdGlvbihMX3Rva3Mpe3JldHVybiBmdW5jdGlvbihMX2dyb3Vwcyl7cmV0dXJuIHJlc29sdmUoTF9pc05pbCkoTF90b2tzKShMX25pbCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2lmTm90RXJyKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcGFyc2VUb2spKExfdG9rcykoTF9ncm91cHMpfSkobGF6eShmdW5jdGlvbihMX2xpc3Qpe3JldHVybiByZXNvbHZlKExfbGlzdCkobGF6eShmdW5jdGlvbihMX2gpe3JldHVybiBmdW5jdGlvbihMX3Qpe3JldHVybiByZXNvbHZlKExfaWZOb3RFcnIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9wYXJzZVRva3MpKExfdCkoTF9ncm91cHMpfSkobGF6eShmdW5jdGlvbihMX3Jlcyl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShMX2gpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hbmQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pc0NvbnMpKExfcmVzKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pc0Jsb2NrU3RhcnQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9oZWFkKShMX3Jlcyl9KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShMX3JlcykoTF9uaWwpfSkoTF9yZXMpfSl9KSl9fSkpfSkpfSl9fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJwYXJzZVRva1wiKSgyKShcInBhcnNlVG9rIHRva3MgZ3JvdXBzID0gd2l0aENvbnMgdG9rcyBuaWwgXFxcXGggdCAuXFxuICB3aXRoVG9rZW4gaCB0b2tzIFxcXFx0eHQgcG9zIC5cXG4gICAgYXNzb2MgdHh0IGdyb3Vwc1xcbiAgICAgIFxcXFxjbG9zZSAuIHBhcnNlR3JvdXAgaCB0IG5pbCBjbG9zZSBncm91cHNcXG4gICAgICBpc1Rva2VuU3RhcnQgaCAnXFxcXG4nIChwYXJzZUluZGVudCBoIHQgbmlsIGdyb3VwcylcXG4gICAgICAgIHRva3NcIikobGF6eShmdW5jdGlvbihMX3Rva3Mpe3JldHVybiBmdW5jdGlvbihMX2dyb3Vwcyl7cmV0dXJuIHJlc29sdmUoTF93aXRoQ29ucykoTF90b2tzKShMX25pbCkobGF6eShmdW5jdGlvbihMX2gpe3JldHVybiBmdW5jdGlvbihMX3Qpe3JldHVybiByZXNvbHZlKExfd2l0aFRva2VuKShMX2gpKExfdG9rcykobGF6eShmdW5jdGlvbihMX3R4dCl7cmV0dXJuIGZ1bmN0aW9uKExfcG9zKXtyZXR1cm4gcmVzb2x2ZShMX2Fzc29jKShMX3R4dCkoTF9ncm91cHMpKGxhenkoZnVuY3Rpb24oTF9jbG9zZSl7cmV0dXJuIHJlc29sdmUoTF9wYXJzZUdyb3VwKShMX2gpKExfdCkoTF9uaWwpKExfY2xvc2UpKExfZ3JvdXBzKX0pKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaXNUb2tlblN0YXJ0KShMX2gpKFwiXFxuXCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9wYXJzZUluZGVudCkoTF9oKShMX3QpKExfbmlsKShMX2dyb3Vwcyl9KShMX3Rva3MpfSl9fSkpfX0pKX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcInBhcnNlR3JvdXBcIikoNSkoXCJwYXJzZUdyb3VwIGxlZnQgdG9rcyBnciBjbG9zZSBncm91cHMgPSB3aXRoQ29ucyB0b2tzIChwYXJzZUVyciAnVW50ZXJtaW5hdGVkIGdyb3VwIHN0YXJ0aW5nICcgKGxvYyBsZWZ0KSlcXG4gIFxcXFxoIHQgLiBpc1Rva2VuU3RyaW5nIGggY2xvc2VcXG4gICAgZXEgY2xvc2UgJyknXFxuICAgICAgY29ucyAocGFyZW5zRnJvbVRva3MgbGVmdCBoIChyZXZlcnNlIGdyKSkgdFxcbiAgICAgIGNvbnMgKGNvbnMgbGVmdCAoY29ucyAocmV2ZXJzZSBncikgKGNvbnMgaCBuaWwpKSkgdFxcbiAgICB3aXRoVG9rZW4gaFxcbiAgICAgIGlmTm90RXJyIChwYXJzZVRvayB0b2tzIGdyb3VwcykgXFxcXGxpc3QgLiBsaXN0IFxcXFxyZXN0SCByZXN0VCAuXFxuICAgICAgICBwYXJzZUdyb3VwIGxlZnQgcmVzdFQgKGNvbnMgcmVzdEggZ3IpIGNsb3NlIGdyb3Vwc1xcbiAgICAgIFxcXFx0eHQgcG9zIC5cXG4gICAgICAgIHJhc3NvYyB0eHQgZ3JvdXBzXFxuICAgICAgICAgIFxcXFxvcGVuIC4gcGFyc2VFcnIgKHN0ckNhdCAoY29ucyAnTWlzbWF0Y2hlZCBncm91cDogJyAoY29ucyAodG9rZW5TdHJpbmcgbGVmdCkgKGNvbnMgdHh0IChjb25zICcgJyBuaWwpKSkpKSAobG9jIGxlZnQpXFxuICAgICAgICAgIGlmTm90RXJyIChwYXJzZVRvayB0b2tzIGdyb3VwcykgXFxcXGxpc3QgLiBsaXN0IFxcXFxyZXN0SCByZXN0VCAuIHBhcnNlR3JvdXAgbGVmdCByZXN0VCAoY29ucyByZXN0SCBncikgY2xvc2UgZ3JvdXBzXCIpKGxhenkoZnVuY3Rpb24oTF9sZWZ0KXtyZXR1cm4gZnVuY3Rpb24oTF90b2tzKXtyZXR1cm4gZnVuY3Rpb24oTF9ncil7cmV0dXJuIGZ1bmN0aW9uKExfY2xvc2Upe3JldHVybiBmdW5jdGlvbihMX2dyb3Vwcyl7cmV0dXJuIHJlc29sdmUoTF93aXRoQ29ucykoTF90b2tzKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcGFyc2VFcnIpKFwiVW50ZXJtaW5hdGVkIGdyb3VwIHN0YXJ0aW5nIFwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfbG9jKShMX2xlZnQpfSl9KShsYXp5KGZ1bmN0aW9uKExfaCl7cmV0dXJuIGZ1bmN0aW9uKExfdCl7cmV0dXJuIHJlc29sdmUoTF9pc1Rva2VuU3RyaW5nKShMX2gpKExfY2xvc2UpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9lcSkoTF9jbG9zZSkoXCIpXCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcGFyZW5zRnJvbVRva3MpKExfbGVmdCkoTF9oKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcmV2ZXJzZSkoTF9ncil9KX0pKExfdCl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKExfbGVmdCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9yZXZlcnNlKShMX2dyKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShMX2gpKExfbmlsKX0pfSl9KShMX3QpfSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfd2l0aFRva2VuKShMX2gpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pZk5vdEVycikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3BhcnNlVG9rKShMX3Rva3MpKExfZ3JvdXBzKX0pKGxhenkoZnVuY3Rpb24oTF9saXN0KXtyZXR1cm4gcmVzb2x2ZShMX2xpc3QpKGxhenkoZnVuY3Rpb24oTF9yZXN0SCl7cmV0dXJuIGZ1bmN0aW9uKExfcmVzdFQpe3JldHVybiByZXNvbHZlKExfcGFyc2VHcm91cCkoTF9sZWZ0KShMX3Jlc3RUKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF9yZXN0SCkoTF9ncil9KShMX2Nsb3NlKShMX2dyb3Vwcyl9fSkpfSkpfSkobGF6eShmdW5jdGlvbihMX3R4dCl7cmV0dXJuIGZ1bmN0aW9uKExfcG9zKXtyZXR1cm4gcmVzb2x2ZShMX3Jhc3NvYykoTF90eHQpKExfZ3JvdXBzKShsYXp5KGZ1bmN0aW9uKExfb3Blbil7cmV0dXJuIHJlc29sdmUoTF9wYXJzZUVycikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3N0ckNhdCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKFwiTWlzbWF0Y2hlZCBncm91cDogXCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdG9rZW5TdHJpbmcpKExfbGVmdCl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF90eHQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShcIiBcIikoTF9uaWwpfSl9KX0pfSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfbG9jKShMX2xlZnQpfSl9KSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2lmTm90RXJyKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcGFyc2VUb2spKExfdG9rcykoTF9ncm91cHMpfSkobGF6eShmdW5jdGlvbihMX2xpc3Qpe3JldHVybiByZXNvbHZlKExfbGlzdCkobGF6eShmdW5jdGlvbihMX3Jlc3RIKXtyZXR1cm4gZnVuY3Rpb24oTF9yZXN0VCl7cmV0dXJuIHJlc29sdmUoTF9wYXJzZUdyb3VwKShMX2xlZnQpKExfcmVzdFQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShMX3Jlc3RIKShMX2dyKX0pKExfY2xvc2UpKExfZ3JvdXBzKX19KSl9KSl9KX19KSl9KX19KSl9fX19fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJwYXJzZUluZGVudFwiKSg0KShcInBhcnNlSW5kZW50IGluZGVudCB0b2tzIGdyIGdyb3VwcyA9XFxuICB3aXRoQ29ucyB0b2tzIChjb25zIChtYWtlUGFyZW5zICh0b2tlblBvcyBpbmRlbnQpIChsZXhFbmQgKGhlYWQgZ3IpKSAocmV2ZXJzZSBncikpIG5pbClcXG4gICAgXFxcXGggdCAuIG9yICh3aXRoVG9rZW4gaCBmYWxzZSAoXFxcXHR4dCBwb3MgLiByYXNzb2MgdHh0IGdyb3VwcyAoXFxcXG9wZW4gLiB0cnVlKSBmYWxzZSkpXFxuICAgICAgYW5kIChpc1Rva2VuU3RhcnQgaCAnXFxcXG4nKSAoPD0gKHN0ckxlbiAodG9rZW5TdHJpbmcgaCkpIChzdHJMZW4gKHRva2VuU3RyaW5nIGluZGVudCkpKVxcbiAgICAgIGNvbnMgKG1ha2VQYXJlbnMgKHRva2VuUG9zIGluZGVudCkgKHRva2VuUG9zIGgpIChyZXZlcnNlIGdyKSkgdG9rc1xcbiAgICAgIGlmTm90RXJyIChwYXJzZVRvayB0b2tzIGdyb3VwcykgXFxcXGxpc3QgLiBsaXN0IFxcXFxyZXN0SCByZXN0VCAuIHBhcnNlSW5kZW50IGluZGVudCByZXN0VCAoY29ucyByZXN0SCBncikgZ3JvdXBzXCIpKGxhenkoZnVuY3Rpb24oTF9pbmRlbnQpe3JldHVybiBmdW5jdGlvbihMX3Rva3Mpe3JldHVybiBmdW5jdGlvbihMX2dyKXtyZXR1cm4gZnVuY3Rpb24oTF9ncm91cHMpe3JldHVybiByZXNvbHZlKExfd2l0aENvbnMpKExfdG9rcykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9tYWtlUGFyZW5zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdG9rZW5Qb3MpKExfaW5kZW50KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9sZXhFbmQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9oZWFkKShMX2dyKX0pfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3JldmVyc2UpKExfZ3IpfSl9KShMX25pbCl9KShsYXp5KGZ1bmN0aW9uKExfaCl7cmV0dXJuIGZ1bmN0aW9uKExfdCl7cmV0dXJuIHJlc29sdmUoTF9vcikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3dpdGhUb2tlbikoTF9oKShMX2ZhbHNlKShsYXp5KGZ1bmN0aW9uKExfdHh0KXtyZXR1cm4gZnVuY3Rpb24oTF9wb3Mpe3JldHVybiByZXNvbHZlKExfcmFzc29jKShMX3R4dCkoTF9ncm91cHMpKGxhenkoZnVuY3Rpb24oTF9vcGVuKXtyZXR1cm4gcmVzb2x2ZShMX3RydWUpfSkpKExfZmFsc2UpfX0pKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hbmQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pc1Rva2VuU3RhcnQpKExfaCkoXCJcXG5cIil9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfJHkkcCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3N0ckxlbikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3Rva2VuU3RyaW5nKShMX2gpfSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc3RyTGVuKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdG9rZW5TdHJpbmcpKExfaW5kZW50KX0pfSl9KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfbWFrZVBhcmVucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3Rva2VuUG9zKShMX2luZGVudCl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdG9rZW5Qb3MpKExfaCl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcmV2ZXJzZSkoTF9ncil9KX0pKExfdG9rcyl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaWZOb3RFcnIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9wYXJzZVRvaykoTF90b2tzKShMX2dyb3Vwcyl9KShsYXp5KGZ1bmN0aW9uKExfbGlzdCl7cmV0dXJuIHJlc29sdmUoTF9saXN0KShsYXp5KGZ1bmN0aW9uKExfcmVzdEgpe3JldHVybiBmdW5jdGlvbihMX3Jlc3RUKXtyZXR1cm4gcmVzb2x2ZShMX3BhcnNlSW5kZW50KShMX2luZGVudCkoTF9yZXN0VCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKExfcmVzdEgpKExfZ3IpfSkoTF9ncm91cHMpfX0pKX0pKX0pfX0pKX19fX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwibGl0XCIpKDEpKFwibGl0IHZhbHVlID0gXFxcXGYgLiBmIHZhbHVlXCIpKGxhenkoc2V0RGF0YVR5cGUoZnVuY3Rpb24oTF92YWx1ZSl7cmV0dXJuIHNldFR5cGUoZnVuY3Rpb24oTF9mKXtyZXR1cm4gcmVzb2x2ZShMX2YpKExfdmFsdWUpfSwgJ2xpdCcpfSwgJ2xpdCcpKSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcInJlZlwiKSgxKShcInJlZiBuYW1lID0gXFxcXGYgLiBmIG5hbWVcIikobGF6eShzZXREYXRhVHlwZShmdW5jdGlvbihMX25hbWUpe3JldHVybiBzZXRUeXBlKGZ1bmN0aW9uKExfZil7cmV0dXJuIHJlc29sdmUoTF9mKShMX25hbWUpfSwgJ3JlZicpfSwgJ3JlZicpKSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImxhbWJkYVwiKSgyKShcImxhbWJkYSBuYW1lIGJvZHkgPSBcXFxcZiAuIGYgbmFtZSBib2R5XCIpKGxhenkoc2V0RGF0YVR5cGUoZnVuY3Rpb24oTF9uYW1lKXtyZXR1cm4gZnVuY3Rpb24oTF9ib2R5KXtyZXR1cm4gc2V0VHlwZShmdW5jdGlvbihMX2Ype3JldHVybiByZXNvbHZlKExfZikoTF9uYW1lKShMX2JvZHkpfSwgJ2xhbWJkYScpfX0sICdsYW1iZGEnKSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJhcHBseVwiKSgyKShcImFwcGx5IGZ1bmMgYXJnID0gXFxcXGYgLiBmIGZ1bmMgYXJnXCIpKGxhenkoc2V0RGF0YVR5cGUoZnVuY3Rpb24oTF9mdW5jKXtyZXR1cm4gZnVuY3Rpb24oTF9hcmcpe3JldHVybiBzZXRUeXBlKGZ1bmN0aW9uKExfZil7cmV0dXJuIHJlc29sdmUoTF9mKShMX2Z1bmMpKExfYXJnKX0sICdhcHBseScpfX0sICdhcHBseScpKSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImxldFwiKSgzKShcImxldCBuYW1lIHZhbHVlIGJvZHkgPSBcXFxcZiAuIGYgbmFtZSB2YWx1ZSBib2R5XCIpKGxhenkoc2V0RGF0YVR5cGUoZnVuY3Rpb24oTF9uYW1lKXtyZXR1cm4gZnVuY3Rpb24oTF92YWx1ZSl7cmV0dXJuIGZ1bmN0aW9uKExfYm9keSl7cmV0dXJuIHNldFR5cGUoZnVuY3Rpb24oTF9mKXtyZXR1cm4gcmVzb2x2ZShMX2YpKExfbmFtZSkoTF92YWx1ZSkoTF9ib2R5KX0sICdsZXQnKX19fSwgJ2xldCcpKSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImFubm9cIikoMykoXCJhbm5vIG5hbWUgZGF0YSBib2R5ID0gXFxcXGYgLiBmIG5hbWUgZGF0YSBib2R5XCIpKGxhenkoc2V0RGF0YVR5cGUoZnVuY3Rpb24oTF9uYW1lKXtyZXR1cm4gZnVuY3Rpb24oTF9kYXRhKXtyZXR1cm4gZnVuY3Rpb24oTF9ib2R5KXtyZXR1cm4gc2V0VHlwZShmdW5jdGlvbihMX2Ype3JldHVybiByZXNvbHZlKExfZikoTF9uYW1lKShMX2RhdGEpKExfYm9keSl9LCAnYW5ubycpfX19LCAnYW5ubycpKSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcIndpdGhQYXJlbnNcIikoMykoXCJ3aXRoUGFyZW5zIHAgZXJyIGNvbnQgPSBpc1BhcmVucyBwIChwIGNvbnQpIGVyclwiKShsYXp5KGZ1bmN0aW9uKExfcCl7cmV0dXJuIGZ1bmN0aW9uKExfZXJyKXtyZXR1cm4gZnVuY3Rpb24oTF9jb250KXtyZXR1cm4gcmVzb2x2ZShMX2lzUGFyZW5zKShMX3ApKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9wKShMX2NvbnQpfSkoTF9lcnIpfX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcInNldFBhcmVuc1wiKSgyKShcInNldFBhcmVucyBwIGZ1bmMgPSBpc1BhcmVucyBwXFxuICBwIFxcXFxzdGFydCBlbmQgY29udGVudCAuIHBhcmVucyBzdGFydCBlbmQgKGZ1bmMgY29udGVudClcXG4gIGZ1bmMgcFwiKShsYXp5KGZ1bmN0aW9uKExfcCl7cmV0dXJuIGZ1bmN0aW9uKExfZnVuYyl7cmV0dXJuIHJlc29sdmUoTF9pc1BhcmVucykoTF9wKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcCkobGF6eShmdW5jdGlvbihMX3N0YXJ0KXtyZXR1cm4gZnVuY3Rpb24oTF9lbmQpe3JldHVybiBmdW5jdGlvbihMX2NvbnRlbnQpe3JldHVybiByZXNvbHZlKExfcGFyZW5zKShMX3N0YXJ0KShMX2VuZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2Z1bmMpKExfY29udGVudCl9KX19fSkpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2Z1bmMpKExfcCl9KX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcIndpdGhTdHJpcHBlZFwiKSgyKShcIndpdGhTdHJpcHBlZCBsaXN0IGNvbnQgPSB3aXRoUGFyZW5zIGxpc3QgKGNvbnQgbGlzdCkgXFxcXHN0YXJ0IGVuZCBjb250ZW50IC4gd2l0aFN0cmlwcGVkIGNvbnRlbnQgY29udFwiKShsYXp5KGZ1bmN0aW9uKExfbGlzdCl7cmV0dXJuIGZ1bmN0aW9uKExfY29udCl7cmV0dXJuIHJlc29sdmUoTF93aXRoUGFyZW5zKShMX2xpc3QpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb250KShMX2xpc3QpfSkobGF6eShmdW5jdGlvbihMX3N0YXJ0KXtyZXR1cm4gZnVuY3Rpb24oTF9lbmQpe3JldHVybiBmdW5jdGlvbihMX2NvbnRlbnQpe3JldHVybiByZXNvbHZlKExfd2l0aFN0cmlwcGVkKShMX2NvbnRlbnQpKExfY29udCl9fX0pKX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcInBvc2l0aW9uXCIpKDEpKFwicG9zaXRpb24gdGhpbmcgPSBpc1Rva2VuIHRoaW5nICh0b2tlblBvcyB0aGluZylcXG4gIGlzUGFyZW5zIHRoaW5nIChwYXJlbnNTdGFydCB0aGluZylcXG4gICAgaXNDb25zIHRoaW5nIChwb3NpdGlvbiAoaGVhZCB0aGluZykpXFxuICAgICAgLTFcIikobGF6eShmdW5jdGlvbihMX3RoaW5nKXtyZXR1cm4gcmVzb2x2ZShMX2lzVG9rZW4pKExfdGhpbmcpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90b2tlblBvcykoTF90aGluZyl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaXNQYXJlbnMpKExfdGhpbmcpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9wYXJlbnNTdGFydCkoTF90aGluZyl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaXNDb25zKShMX3RoaW5nKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcG9zaXRpb24pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9oZWFkKShMX3RoaW5nKX0pfSkoLTEpfSl9KX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwibGV4RW5kXCIpKDEpKFwibGV4RW5kIHRoaW5nID0gaXNUb2tlbiB0aGluZyAoKyAodG9rZW5Qb3MgdGhpbmcpIChzdHJMZW4gKHRva2VuU3RyaW5nIHRoaW5nKSkpXFxuICBpc1BhcmVucyB0aGluZyAocGFyZW5zRW5kIHRoaW5nKVxcbiAgICBpc0NvbnMgdGhpbmcgKGxleEVuZCAobGFzdCB0aGluZykpXFxuICAgICAgLTFcIikobGF6eShmdW5jdGlvbihMX3RoaW5nKXtyZXR1cm4gcmVzb2x2ZShMX2lzVG9rZW4pKExfdGhpbmcpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF8kbykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3Rva2VuUG9zKShMX3RoaW5nKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zdHJMZW4pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90b2tlblN0cmluZykoTF90aGluZyl9KX0pfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2lzUGFyZW5zKShMX3RoaW5nKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcGFyZW5zRW5kKShMX3RoaW5nKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pc0NvbnMpKExfdGhpbmcpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9sZXhFbmQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9sYXN0KShMX3RoaW5nKX0pfSkoLTEpfSl9KX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwibG9jXCIpKDEpKFwibG9jIHRoaW5nID0gXFxcXFxcXFxcXG4gIHAgPSBwb3NpdGlvbiB0aGluZ1xcbiAgbCA9IGVxIHAgLTEgJ2FuIHVua25vd24gbG9jYXRpb24nIHBcXG4gIC5cXG4gIHN0ckNhdCAoY29ucyAnYXQgJyAoY29ucyBsIG5pbCkpXCIpKGxhenkoZnVuY3Rpb24oTF90aGluZyl7cmV0dXJuIChmdW5jdGlvbigpe1xuXG52YXIgTF9sLCBMX3A7XG5cbkxfbCA9IGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9lcSkoTF9wKSgtMSkoXCJhbiB1bmtub3duIGxvY2F0aW9uXCIpKExfcCl9O1xuXG5MX3AgPSBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcG9zaXRpb24pKExfdGhpbmcpfTtcbnJldHVybiByZXNvbHZlKExfc3RyQ2F0KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoXCJhdCBcIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKExfbCkoTF9uaWwpfSl9KX0pKCl9KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcInNjcnViXCIpKDEpKFwic2NydWIgc3RyID0gc3RyRnJvbUxpc3QgKHNjcnViTGlzdCAoc3RyVG9MaXN0IHN0cikpXCIpKGxhenkoZnVuY3Rpb24oTF9zdHIpe3JldHVybiByZXNvbHZlKExfc3RyRnJvbUxpc3QpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zY3J1Ykxpc3QpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zdHJUb0xpc3QpKExfc3RyKX0pfSl9KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcInNjcnViTGlzdFwiKSgxKShcInNjcnViTGlzdCBsaXN0ID0gbGlzdFxcbiAgXFxcXGggdCBEIC4gXFxcXFxcXFxcXG4gICAgbmV4dCA9IHNjcnViTGlzdCB0XFxuICAgIC5cXG4gICAgZXEgaCAnXFxcXFxcXFwnIChjb25zIGggKGNvbnMgKGhlYWQgdCkgKHNjcnViTGlzdCAodGFpbCB0KSkpKVxcbiAgICAgIGVxIGggJ1xcXFxcXFwiJyAoY29ucyAnXFxcXFxcXFwnIChjb25zICdcXFxcXFxcIicgbmV4dCkpXFxuICAgICAgICBjb25zIGggbmV4dFxcbiAgbmlsXCIpKGxhenkoZnVuY3Rpb24oTF9saXN0KXtyZXR1cm4gcmVzb2x2ZShMX2xpc3QpKGxhenkoZnVuY3Rpb24oTF9oKXtyZXR1cm4gZnVuY3Rpb24oTF90KXtyZXR1cm4gZnVuY3Rpb24oTF9EKXtyZXR1cm4gKGZ1bmN0aW9uKCl7XG5cbnZhciBMX25leHQ7XG5cbkxfbmV4dCA9IGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zY3J1Ykxpc3QpKExfdCl9O1xucmV0dXJuIHJlc29sdmUoTF9lcSkoTF9oKShcIlxcXFxcIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKExfaCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9oZWFkKShMX3QpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3NjcnViTGlzdCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3RhaWwpKExfdCl9KX0pfSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZXEpKExfaCkoXCJcXFwiXCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShcIlxcXFxcIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKFwiXFxcIlwiKShMX25leHQpfSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF9oKShMX25leHQpfSl9KX0pKCl9fX0pKShMX25pbCl9KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImNyZWF0ZUFzdFwiKSgyKShcImNyZWF0ZUFzdCBpbkxpc3QgbmFtZXMgPSB3aXRoU3RyaXBwZWQgaW5MaXN0IFxcXFxsaXN0IC5cXG4gIGlzVG9rZW4gbGlzdCAoY3JlYXRlTGl0T3JSZWYgKHRva2VuU3RyaW5nIGxpc3QpIG5hbWVzKVxcbiAgICBsaXN0XFxuICAgICAgXFxcXGggdCBEIC5cXG4gICAgICAgIGlzVG9rZW5TdHJpbmcgaCAnXFxcXFxcXFxcXFxcXFxcXCcgKGNyZWF0ZUxldCBoIHQgbmFtZXMpXFxuICAgICAgICAgIGlzVG9rZW5TdHJpbmcgaCAnXFxcXFxcXFxAJyAoY3JlYXRlQW5ubyBoIHQgbmFtZXMpXFxuICAgICAgICAgICAgaXNUb2tlblN0cmluZyBoICdcXFxcXFxcXCcgKGNyZWF0ZUxhbWJkYSBoIHQgbmFtZXMpXFxuICAgICAgICAgICAgICBjcmVhdGVBcHBseSBsaXN0IG5hbWVzXFxuICAgICAgbmlsXCIpKGxhenkoZnVuY3Rpb24oTF9pbkxpc3Qpe3JldHVybiBmdW5jdGlvbihMX25hbWVzKXtyZXR1cm4gcmVzb2x2ZShMX3dpdGhTdHJpcHBlZCkoTF9pbkxpc3QpKGxhenkoZnVuY3Rpb24oTF9saXN0KXtyZXR1cm4gcmVzb2x2ZShMX2lzVG9rZW4pKExfbGlzdCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NyZWF0ZUxpdE9yUmVmKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdG9rZW5TdHJpbmcpKExfbGlzdCl9KShMX25hbWVzKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9saXN0KShsYXp5KGZ1bmN0aW9uKExfaCl7cmV0dXJuIGZ1bmN0aW9uKExfdCl7cmV0dXJuIGZ1bmN0aW9uKExfRCl7cmV0dXJuIHJlc29sdmUoTF9pc1Rva2VuU3RyaW5nKShMX2gpKFwiXFxcXFxcXFxcIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NyZWF0ZUxldCkoTF9oKShMX3QpKExfbmFtZXMpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2lzVG9rZW5TdHJpbmcpKExfaCkoXCJcXFxcQFwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY3JlYXRlQW5ubykoTF9oKShMX3QpKExfbmFtZXMpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2lzVG9rZW5TdHJpbmcpKExfaCkoXCJcXFxcXCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jcmVhdGVMYW1iZGEpKExfaCkoTF90KShMX25hbWVzKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jcmVhdGVBcHBseSkoTF9saXN0KShMX25hbWVzKX0pfSl9KX19fSkpKExfbmlsKX0pfSkpfX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwic3RyTWF0Y2hlc1wiKSgyKShcInN0ck1hdGNoZXMgc3RyIHBhdCA9IGlzQ29ucyAoc3RyTWF0Y2ggc3RyIHBhdClcIikobGF6eShmdW5jdGlvbihMX3N0cil7cmV0dXJuIGZ1bmN0aW9uKExfcGF0KXtyZXR1cm4gcmVzb2x2ZShMX2lzQ29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3N0ck1hdGNoKShMX3N0cikoTF9wYXQpfSl9fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJkaWdpdFwiKSgwKShcImRpZ2l0ID0gcmVnZXhwICdeWzAtOV0rJCdcIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3JlZ2V4cCkoXCJeWzAtOV0rJFwiKX0pfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJiYWNrc2xhc2hDb2Rlc1wiKSgwKShcImJhY2tzbGFzaENvZGVzID0gJ2JmbnJ0J1wiKShcImJmbnJ0XCIpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJiYWNrc2xhc2hWYWx1ZXNcIikoMCkoXCJiYWNrc2xhc2hWYWx1ZXMgPSAnXFxcXGJcXFxcZlxcXFxuXFxcXHJcXFxcdCdcIikoXCJcXGJcXGZcXG5cXHJcXHRcIil9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImNvbnZlcnRTdHJpbmdFc2NhcGVcIikoMykoXCJjb252ZXJ0U3RyaW5nRXNjYXBlIGNoYXIgY29kZXMgdmFsdWVzID1cXG4gIGVxIGNvZGVzICcnXFxuICAgIGNoYXJcXG4gICAgZXEgY2hhciAoc3RyQXQgY29kZXMgMClcXG4gICAgICBzdHJBdCB2YWx1ZXMgMFxcbiAgICAgIGNvbnZlcnRTdHJpbmdFc2NhcGUgY2hhciAoc3RyU3Vic3RyaW5nIGNvZGVzIDEgMCkgKHN0clN1YnN0cmluZyB2YWx1ZXMgMSAwKVwiKShsYXp5KGZ1bmN0aW9uKExfY2hhcil7cmV0dXJuIGZ1bmN0aW9uKExfY29kZXMpe3JldHVybiBmdW5jdGlvbihMX3ZhbHVlcyl7cmV0dXJuIHJlc29sdmUoTF9lcSkoTF9jb2RlcykoXCJcIikoTF9jaGFyKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZXEpKExfY2hhcikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3N0ckF0KShMX2NvZGVzKSgwKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zdHJBdCkoTF92YWx1ZXMpKDApfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnZlcnRTdHJpbmdFc2NhcGUpKExfY2hhcikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3N0clN1YnN0cmluZykoTF9jb2RlcykoMSkoMCl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc3RyU3Vic3RyaW5nKShMX3ZhbHVlcykoMSkoMCl9KX0pfSl9fX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwiY29udmVydFN0cmluZ0VzY2FwZXNcIikoMykoXCJjb252ZXJ0U3RyaW5nRXNjYXBlcyBvcmlnIHN0ciBjb250ID1cXG4gIGVxIHN0ciAnJ1xcbiAgICBjb250IHN0clxcbiAgICBlcSAoc3RyQXQgc3RyIDApICdcXFxcXFxcXCdcXG4gICAgICBlcSAoc3RyTGVuIHN0cikgMSAocGFyc2VFcnIgXFxcIkVycm9yLCBiYWNrc2xhc2ggd2l0aG91dCBjaGFyYWN0ZXIgaW4gc3RyaW5nOiBcXFwiIG9yaWcpXFxuICAgICAgICBjb252ZXJ0U3RyaW5nRXNjYXBlcyBvcmlnIChzdHJTdWJzdHJpbmcgc3RyIDIgMCkgXFxcXHJlc3QgLiBjb250XFxuICAgICAgICAgIHN0ckFkZFxcbiAgICAgICAgICAgIGNvbnZlcnRTdHJpbmdFc2NhcGUgKHN0ckF0IHN0ciAxKSBiYWNrc2xhc2hDb2RlcyBiYWNrc2xhc2hWYWx1ZXNcXG4gICAgICAgICAgICByZXN0XFxuICAgICAgY29udmVydFN0cmluZ0VzY2FwZXMgb3JpZyAoc3RyU3Vic3RyaW5nIHN0ciAxIDApIFxcXFxyZXN0IC4gY29udFxcbiAgICAgICAgc3RyQWRkXFxuICAgICAgICAgIHN0ckF0IHN0ciAwXFxuICAgICAgICAgIHJlc3RcIikobGF6eShmdW5jdGlvbihMX29yaWcpe3JldHVybiBmdW5jdGlvbihMX3N0cil7cmV0dXJuIGZ1bmN0aW9uKExfY29udCl7cmV0dXJuIHJlc29sdmUoTF9lcSkoTF9zdHIpKFwiXCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb250KShMX3N0cil9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZXEpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zdHJBdCkoTF9zdHIpKDApfSkoXCJcXFxcXCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9lcSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3N0ckxlbikoTF9zdHIpfSkoMSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3BhcnNlRXJyKShcIkVycm9yLCBiYWNrc2xhc2ggd2l0aG91dCBjaGFyYWN0ZXIgaW4gc3RyaW5nOiBcIikoTF9vcmlnKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb252ZXJ0U3RyaW5nRXNjYXBlcykoTF9vcmlnKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc3RyU3Vic3RyaW5nKShMX3N0cikoMikoMCl9KShsYXp5KGZ1bmN0aW9uKExfcmVzdCl7cmV0dXJuIHJlc29sdmUoTF9jb250KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc3RyQWRkKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29udmVydFN0cmluZ0VzY2FwZSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3N0ckF0KShMX3N0cikoMSl9KShMX2JhY2tzbGFzaENvZGVzKShMX2JhY2tzbGFzaFZhbHVlcyl9KShMX3Jlc3QpfSl9KSl9KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb252ZXJ0U3RyaW5nRXNjYXBlcykoTF9vcmlnKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc3RyU3Vic3RyaW5nKShMX3N0cikoMSkoMCl9KShsYXp5KGZ1bmN0aW9uKExfcmVzdCl7cmV0dXJuIHJlc29sdmUoTF9jb250KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc3RyQWRkKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc3RyQXQpKExfc3RyKSgwKX0pKExfcmVzdCl9KX0pKX0pfSl9fX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwicGFyc2VTdHJpbmdcIikoMikoXCJwYXJzZVN0cmluZyBzdHIgY29udCA9XFxuICBuZXEgKHN0ckF0IHN0ciAwKSAoc3RyQXQgc3RyIC0xKSAocGFyc2VFcnIgXFxcIkJhZGx5IHRlcm1pbmF0ZWQgc3RyaW5nOiBcXFwiIHN0cilcXG4gICAgY29udmVydFN0cmluZ0VzY2FwZXMgc3RyIChzdHJTdWJzdHJpbmcgc3RyIDEgLTEpIGNvbnRcIikobGF6eShmdW5jdGlvbihMX3N0cil7cmV0dXJuIGZ1bmN0aW9uKExfY29udCl7cmV0dXJuIHJlc29sdmUoTF9uZXEpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zdHJBdCkoTF9zdHIpKDApfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3N0ckF0KShMX3N0cikoLTEpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3BhcnNlRXJyKShcIkJhZGx5IHRlcm1pbmF0ZWQgc3RyaW5nOiBcIikoTF9zdHIpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnZlcnRTdHJpbmdFc2NhcGVzKShMX3N0cikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3N0clN1YnN0cmluZykoTF9zdHIpKDEpKC0xKX0pKExfY29udCl9KX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImNyZWF0ZUxpdE9yUmVmXCIpKDIpKFwiY3JlYXRlTGl0T3JSZWYgdG9rIG5hbWVzID1cXG4gIGNvbnRhaW5zIG5hbWVzIHRva1xcbiAgICByZWYgdG9rXFxuICAgIG9yIChzdHJTdGFydHNXaXRoIHRvayAnXFxcXFxcXCInKSAoc3RyU3RhcnRzV2l0aCB0b2sgXFxcIidcXFwiKVxcbiAgICAgIHBhcnNlU3RyaW5nIHRvayBcXFxcc3RyIC4gbGl0IHN0clxcbiAgICAgIHN0clN0YXJ0c1dpdGggdG9rICcuJ1xcbiAgICAgICAganNvblBhcnNlIChzdHJDYXQgKGNvbnMgJzAnIChjb25zIHRvayBuaWwpKSkgKFxcXFxlcnIgLiByZWYgdG9rKSAoXFxcXGl0ZW0gLiBsaXQgaXRlbSlcXG4gICAgICAgIG9yIChhbmQgKD49IChzdHJBdCB0b2sgMCkgJzAnKSAoPD0gKHN0ckF0IHRvayAwKSAnOScpKSAoc3RyU3RhcnRzV2l0aCB0b2sgJy0nKVxcbiAgICAgICAgICBqc29uUGFyc2UgdG9rIChcXFxcZXJyIC4gcmVmIHRvaykgKFxcXFxpdGVtIC4gbGl0IGl0ZW0pXFxuICAgICAgICAgIHJlZiB0b2tcIikobGF6eShmdW5jdGlvbihMX3Rvayl7cmV0dXJuIGZ1bmN0aW9uKExfbmFtZXMpe3JldHVybiByZXNvbHZlKExfY29udGFpbnMpKExfbmFtZXMpKExfdG9rKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcmVmKShMX3Rvayl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfb3IpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zdHJTdGFydHNXaXRoKShMX3RvaykoXCJcXFwiXCIpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3N0clN0YXJ0c1dpdGgpKExfdG9rKShcIidcIil9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcGFyc2VTdHJpbmcpKExfdG9rKShsYXp5KGZ1bmN0aW9uKExfc3RyKXtyZXR1cm4gcmVzb2x2ZShMX2xpdCkoTF9zdHIpfSkpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3N0clN0YXJ0c1dpdGgpKExfdG9rKShcIi5cIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2pzb25QYXJzZSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3N0ckNhdCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKFwiMFwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF90b2spKExfbmlsKX0pfSl9KShsYXp5KGZ1bmN0aW9uKExfZXJyKXtyZXR1cm4gcmVzb2x2ZShMX3JlZikoTF90b2spfSkpKGxhenkoZnVuY3Rpb24oTF9pdGVtKXtyZXR1cm4gcmVzb2x2ZShMX2xpdCkoTF9pdGVtKX0pKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9vcikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2FuZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMXyR6JHApKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zdHJBdCkoTF90b2spKDApfSkoXCIwXCIpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMXyR5JHApKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zdHJBdCkoTF90b2spKDApfSkoXCI5XCIpfSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc3RyU3RhcnRzV2l0aCkoTF90b2spKFwiLVwiKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9qc29uUGFyc2UpKExfdG9rKShsYXp5KGZ1bmN0aW9uKExfZXJyKXtyZXR1cm4gcmVzb2x2ZShMX3JlZikoTF90b2spfSkpKGxhenkoZnVuY3Rpb24oTF9pdGVtKXtyZXR1cm4gcmVzb2x2ZShMX2xpdCkoTF9pdGVtKX0pKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9yZWYpKExfdG9rKX0pfSl9KX0pfX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwiY3JlYXRlTGFtYmRhXCIpKDMpKFwiY3JlYXRlTGFtYmRhIHN0YXJ0IGxpc3QgbmFtZXMgPSBcXFxcXFxcXFxcbiAgZXJyID0gcGFyc2VFcnIgXFxcIkxhbWJkYSBuZWVkcyBhIHZhcmlhYmxlIG5hbWUsIGEgZG90LCBhbmQgYSBib2R5IFxcXCIgKGxvYyBzdGFydClcXG4gIC5cXG4gIHdpdGhDb25zIGxpc3QgZXJyIFxcXFxuYW1lIHJlc3QgLlxcbiAgICB3aXRoVG9rZW4gbmFtZSBlcnIgXFxcXG4gcCAuXFxuICAgICAgd2l0aENvbnMgcmVzdCBlcnIgXFxcXGRvdCBib2R5IC5cXG4gICAgICAgICMgYXJlIHRoZXNlIHBhcnRpYWwgYXBwbGljYXRpb25zIHRvbyBoYXJkIHRvIHJlYWQ/XFxuICAgICAgICBpc1Rva2VuU3RyaW5nIGRvdCAnLidcXG4gICAgICAgICAgaWZOb3RFcnIgKGNyZWF0ZUFzdCBib2R5IChjb25zIG4gbmFtZXMpKSBcXFxcYm9keUFzdCAuIGxhbWJkYSBuIGJvZHlBc3RcXG4gICAgICAgICAgaWZOb3RFcnIgKGNyZWF0ZUxhbWJkYSBzdGFydCByZXN0IChjb25zIG4gbmFtZXMpKSBcXFxcYm9keUFzdCAuIGxhbWJkYSBuIGJvZHlBc3RcIikobGF6eShmdW5jdGlvbihMX3N0YXJ0KXtyZXR1cm4gZnVuY3Rpb24oTF9saXN0KXtyZXR1cm4gZnVuY3Rpb24oTF9uYW1lcyl7cmV0dXJuIChmdW5jdGlvbigpe1xuXG52YXIgTF9lcnI7XG5cbkxfZXJyID0gZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3BhcnNlRXJyKShcIkxhbWJkYSBuZWVkcyBhIHZhcmlhYmxlIG5hbWUsIGEgZG90LCBhbmQgYSBib2R5IFwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfbG9jKShMX3N0YXJ0KX0pfTtcbnJldHVybiByZXNvbHZlKExfd2l0aENvbnMpKExfbGlzdCkoTF9lcnIpKGxhenkoZnVuY3Rpb24oTF9uYW1lKXtyZXR1cm4gZnVuY3Rpb24oTF9yZXN0KXtyZXR1cm4gcmVzb2x2ZShMX3dpdGhUb2tlbikoTF9uYW1lKShMX2VycikobGF6eShmdW5jdGlvbihMX24pe3JldHVybiBmdW5jdGlvbihMX3Ape3JldHVybiByZXNvbHZlKExfd2l0aENvbnMpKExfcmVzdCkoTF9lcnIpKGxhenkoZnVuY3Rpb24oTF9kb3Qpe3JldHVybiBmdW5jdGlvbihMX2JvZHkpe3JldHVybiByZXNvbHZlKExfaXNUb2tlblN0cmluZykoTF9kb3QpKFwiLlwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaWZOb3RFcnIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jcmVhdGVBc3QpKExfYm9keSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKExfbikoTF9uYW1lcyl9KX0pKGxhenkoZnVuY3Rpb24oTF9ib2R5QXN0KXtyZXR1cm4gcmVzb2x2ZShMX2xhbWJkYSkoTF9uKShMX2JvZHlBc3QpfSkpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2lmTm90RXJyKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY3JlYXRlTGFtYmRhKShMX3N0YXJ0KShMX3Jlc3QpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShMX24pKExfbmFtZXMpfSl9KShsYXp5KGZ1bmN0aW9uKExfYm9keUFzdCl7cmV0dXJuIHJlc29sdmUoTF9sYW1iZGEpKExfbikoTF9ib2R5QXN0KX0pKX0pfX0pKX19KSl9fSkpfSkoKX19fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJjcmVhdGVBbm5vXCIpKDMpKFwiY3JlYXRlQW5ubyBzdGFydCBsaXN0IG5hbWVzID1cXG4gIHdpdGhDb25zIGxpc3QgKHBhcnNlRXJyIFxcXCJObyBhbm5vdGF0aW9uIG5hbWUgb3IgZGF0YSBpbiBhbm5vdGF0aW9uIFxcXCIgKGxvYyBzdGFydCkpIFxcXFxuYW1lIHJlc3QgLlxcbiAgICB3aXRoQ29ucyByZXN0IChwYXJzZUVyciBcXFwiTm8gZGF0YSBmb3IgYW5ub3RhdGlvbiBcXFwiIChsb2Mgc3RhcnQpKSBcXFxcZGF0YSByZXN0IC4gXFxcXFxcXFxcXG4gICAgICBmaW5pc2ggZGF0YSBib2R5ID0gaWZOb3RFcnIgKGNyZWF0ZUFzdCBib2R5IG5hbWVzKSBcXFxcYm9keUFzdCAuXFxuICAgICAgICBjbGVhblRva2VucyBzdGFydCBuYW1lIFxcXFxuYW1lIC5cXG4gICAgICAgICAgY2xlYW5Ub2tlbnMgc3RhcnQgZGF0YSBcXFxcZGF0YSAuXFxuICAgICAgICAgICAgYW5ubyBuYW1lIGRhdGEgYm9keUFzdFxcbiAgICAgIC5cXG4gICAgICBpc1Rva2VuU3RyaW5nIGRhdGEgJy4nXFxuICAgICAgICBmaW5pc2ggbmlsIHJlc3RcXG4gICAgICAgIHdpdGhTdHJpcHBlZCBkYXRhIFxcXFxkYXRhIC5cXG4gICAgICAgICAgd2l0aENvbnMgcmVzdCAocGFyc2VFcnIgXFxcIk5vIGJvZHkgZm9yIGFubm90YXRpb24gXFxcIiAobG9jIHN0YXJ0KSkgXFxcXGRvdCBib2R5IC5cXG4gICAgICAgICAgICBpc1Rva2VuU3RyaW5nIGRvdCAnLidcXG4gICAgICAgICAgICAgIGZpbmlzaCBkYXRhIGJvZHlcXG4gICAgICAgICAgICAgIHBhcnNlRXJyIFxcXCJBbm5vdGF0aW9uIGV4cGVjdHMgZG90IGFmdGVyIG5hbWUgYW5kIGRhdGEgXFxcIiAobG9jIHN0YXJ0KVwiKShsYXp5KGZ1bmN0aW9uKExfc3RhcnQpe3JldHVybiBmdW5jdGlvbihMX2xpc3Qpe3JldHVybiBmdW5jdGlvbihMX25hbWVzKXtyZXR1cm4gcmVzb2x2ZShMX3dpdGhDb25zKShMX2xpc3QpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9wYXJzZUVycikoXCJObyBhbm5vdGF0aW9uIG5hbWUgb3IgZGF0YSBpbiBhbm5vdGF0aW9uIFwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfbG9jKShMX3N0YXJ0KX0pfSkobGF6eShmdW5jdGlvbihMX25hbWUpe3JldHVybiBmdW5jdGlvbihMX3Jlc3Qpe3JldHVybiByZXNvbHZlKExfd2l0aENvbnMpKExfcmVzdCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3BhcnNlRXJyKShcIk5vIGRhdGEgZm9yIGFubm90YXRpb24gXCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9sb2MpKExfc3RhcnQpfSl9KShsYXp5KGZ1bmN0aW9uKExfZGF0YSl7cmV0dXJuIGZ1bmN0aW9uKExfcmVzdF8wKXtyZXR1cm4gKGZ1bmN0aW9uKCl7XG5cbnZhciBMX2ZpbmlzaDtcblxuTF9maW5pc2ggPSBsYXp5KGZ1bmN0aW9uKExfZGF0YV8xKXtyZXR1cm4gZnVuY3Rpb24oTF9ib2R5KXtyZXR1cm4gcmVzb2x2ZShMX2lmTm90RXJyKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY3JlYXRlQXN0KShMX2JvZHkpKExfbmFtZXMpfSkobGF6eShmdW5jdGlvbihMX2JvZHlBc3Qpe3JldHVybiByZXNvbHZlKExfY2xlYW5Ub2tlbnMpKExfc3RhcnQpKExfbmFtZSkobGF6eShmdW5jdGlvbihMX25hbWVfMil7cmV0dXJuIHJlc29sdmUoTF9jbGVhblRva2VucykoTF9zdGFydCkoTF9kYXRhXzEpKGxhenkoZnVuY3Rpb24oTF9kYXRhXzMpe3JldHVybiByZXNvbHZlKExfYW5ubykoTF9uYW1lXzIpKExfZGF0YV8zKShMX2JvZHlBc3QpfSkpfSkpfSkpfX0pO1xucmV0dXJuIHJlc29sdmUoTF9pc1Rva2VuU3RyaW5nKShMX2RhdGEpKFwiLlwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZmluaXNoKShMX25pbCkoTF9yZXN0XzApfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3dpdGhTdHJpcHBlZCkoTF9kYXRhKShsYXp5KGZ1bmN0aW9uKExfZGF0YV8xKXtyZXR1cm4gcmVzb2x2ZShMX3dpdGhDb25zKShMX3Jlc3RfMCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3BhcnNlRXJyKShcIk5vIGJvZHkgZm9yIGFubm90YXRpb24gXCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9sb2MpKExfc3RhcnQpfSl9KShsYXp5KGZ1bmN0aW9uKExfZG90KXtyZXR1cm4gZnVuY3Rpb24oTF9ib2R5KXtyZXR1cm4gcmVzb2x2ZShMX2lzVG9rZW5TdHJpbmcpKExfZG90KShcIi5cIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2ZpbmlzaCkoTF9kYXRhXzEpKExfYm9keSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcGFyc2VFcnIpKFwiQW5ub3RhdGlvbiBleHBlY3RzIGRvdCBhZnRlciBuYW1lIGFuZCBkYXRhIFwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfbG9jKShMX3N0YXJ0KX0pfSl9fSkpfSkpfSl9KSgpfX0pKX19KSl9fX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwiYm9keVN0cnVjdFBhdFwiKSgwKShcImJvZHlTdHJ1Y3RQYXQgPSByZWdleHAgJ1xcXFxcXFxcfFxcXFxcXFxcXFxcXFxcXFx8XFxcXFxcXFxAJ1wiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcmVnZXhwKShcIlxcXFx8XFxcXFxcXFx8XFxcXEBcIil9KX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwiY3JlYXRlQXBwbHlcIikoMikoXCJjcmVhdGVBcHBseSBpbkxpc3QgbmFtZXMgPSB3aXRoU3RyaXBwZWQgaW5MaXN0IFxcXFxsaXN0IC5cXG4gIHdpdGhDb25zIGxpc3QgKHBhcnNlRXJyIFxcXCJGdW5jaW9uIGFwcGx5IGV4cGVjdGluZyBhIG5vbi1lbXB0eSBsaXN0IFxcXCIgKGxvYyBpbkxpc3QpKSBcXFxcaCB0IC5cXG4gICAgaWZOb3RFcnIgKGNyZWF0ZUFzdCBoIG5hbWVzKSBcXFxcZnVuYyAuIGNoYWluQXBwbHkgZnVuYyB0IG5hbWVzXCIpKGxhenkoZnVuY3Rpb24oTF9pbkxpc3Qpe3JldHVybiBmdW5jdGlvbihMX25hbWVzKXtyZXR1cm4gcmVzb2x2ZShMX3dpdGhTdHJpcHBlZCkoTF9pbkxpc3QpKGxhenkoZnVuY3Rpb24oTF9saXN0KXtyZXR1cm4gcmVzb2x2ZShMX3dpdGhDb25zKShMX2xpc3QpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9wYXJzZUVycikoXCJGdW5jaW9uIGFwcGx5IGV4cGVjdGluZyBhIG5vbi1lbXB0eSBsaXN0IFwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfbG9jKShMX2luTGlzdCl9KX0pKGxhenkoZnVuY3Rpb24oTF9oKXtyZXR1cm4gZnVuY3Rpb24oTF90KXtyZXR1cm4gcmVzb2x2ZShMX2lmTm90RXJyKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY3JlYXRlQXN0KShMX2gpKExfbmFtZXMpfSkobGF6eShmdW5jdGlvbihMX2Z1bmMpe3JldHVybiByZXNvbHZlKExfY2hhaW5BcHBseSkoTF9mdW5jKShMX3QpKExfbmFtZXMpfSkpfX0pKX0pKX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImJsb2NrU3RhcnRzXCIpKDApKFwiYmxvY2tTdGFydHMgPSBjb25zICdcXFxcXFxcXCcgKGNvbnMgJ1xcXFxcXFxcXFxcXFxcXFwnIChjb25zICdcXFxcXFxcXEAnIG5pbCkpXCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShcIlxcXFxcIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKFwiXFxcXFxcXFxcIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKFwiXFxcXEBcIikoTF9uaWwpfSl9KX0pfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJjaGFpbkFwcGx5XCIpKDMpKFwiY2hhaW5BcHBseSBmdW5jIGxpc3QgbmFtZXMgPSB3aXRoQ29ucyBsaXN0IGZ1bmMgXFxcXGFyZ0l0ZW0gcmVzdCAuXFxuICBhbmQgKGlzVG9rZW4gYXJnSXRlbSkgKGNvbnRhaW5zIGJsb2NrU3RhcnRzICh0b2tlblN0cmluZyBhcmdJdGVtKSlcXG4gICAgaWZOb3RFcnIgKGNyZWF0ZUFzdCBsaXN0IG5hbWVzKSBcXFxcYXJnIC4gYXBwbHkgZnVuYyBhcmdcXG4gICAgaWZOb3RFcnIgKGNyZWF0ZUFzdCBhcmdJdGVtIG5hbWVzKSBcXFxcYXJnIC4gY2hhaW5BcHBseSAoYXBwbHkgZnVuYyBhcmcpIHJlc3QgbmFtZXNcIikobGF6eShmdW5jdGlvbihMX2Z1bmMpe3JldHVybiBmdW5jdGlvbihMX2xpc3Qpe3JldHVybiBmdW5jdGlvbihMX25hbWVzKXtyZXR1cm4gcmVzb2x2ZShMX3dpdGhDb25zKShMX2xpc3QpKExfZnVuYykobGF6eShmdW5jdGlvbihMX2FyZ0l0ZW0pe3JldHVybiBmdW5jdGlvbihMX3Jlc3Qpe3JldHVybiByZXNvbHZlKExfYW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaXNUb2tlbikoTF9hcmdJdGVtKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb250YWlucykoTF9ibG9ja1N0YXJ0cykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3Rva2VuU3RyaW5nKShMX2FyZ0l0ZW0pfSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaWZOb3RFcnIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jcmVhdGVBc3QpKExfbGlzdCkoTF9uYW1lcyl9KShsYXp5KGZ1bmN0aW9uKExfYXJnKXtyZXR1cm4gcmVzb2x2ZShMX2FwcGx5KShMX2Z1bmMpKExfYXJnKX0pKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pZk5vdEVycikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NyZWF0ZUFzdCkoTF9hcmdJdGVtKShMX25hbWVzKX0pKGxhenkoZnVuY3Rpb24oTF9hcmcpe3JldHVybiByZXNvbHZlKExfY2hhaW5BcHBseSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2FwcGx5KShMX2Z1bmMpKExfYXJnKX0pKExfcmVzdCkoTF9uYW1lcyl9KSl9KX19KSl9fX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwiY2xlYW5Ub2tlbnNcIikoMykoXCJjbGVhblRva2VucyBzdGFydCB0b2tzIGNvbnQgPSBpc1Rva2VuIHRva3NcXG4gIGNvbnQgKHRva2VuU3RyaW5nIHRva3MpXFxuICB3aXRoQ29ucyB0b2tzIChjb250IHRva3MpIFxcXFxoZWFkIHRhaWwgLlxcbiAgICBjbGVhblRva2VucyBzdGFydCBoZWFkIFxcXFxoZWFkIC5cXG4gICAgICBjbGVhblRva2VucyBzdGFydCB0YWlsIFxcXFx0YWlsIC5cXG4gICAgICAgIGNvbnQgKGNvbnMgaGVhZCB0YWlsKVwiKShsYXp5KGZ1bmN0aW9uKExfc3RhcnQpe3JldHVybiBmdW5jdGlvbihMX3Rva3Mpe3JldHVybiBmdW5jdGlvbihMX2NvbnQpe3JldHVybiByZXNvbHZlKExfaXNUb2tlbikoTF90b2tzKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29udCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3Rva2VuU3RyaW5nKShMX3Rva3MpfSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfd2l0aENvbnMpKExfdG9rcykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnQpKExfdG9rcyl9KShsYXp5KGZ1bmN0aW9uKExfaGVhZCl7cmV0dXJuIGZ1bmN0aW9uKExfdGFpbCl7cmV0dXJuIHJlc29sdmUoTF9jbGVhblRva2VucykoTF9zdGFydCkoTF9oZWFkKShsYXp5KGZ1bmN0aW9uKExfaGVhZF8wKXtyZXR1cm4gcmVzb2x2ZShMX2NsZWFuVG9rZW5zKShMX3N0YXJ0KShMX3RhaWwpKGxhenkoZnVuY3Rpb24oTF90YWlsXzEpe3JldHVybiByZXNvbHZlKExfY29udCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKExfaGVhZF8wKShMX3RhaWxfMSl9KX0pKX0pKX19KSl9KX19fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJjcmVhdGVMZXRcIikoMykoXCJjcmVhdGVMZXQgc3RhcnQgbGlzdCBuYW1lcyA9IHdpdGhDb25zIGxpc3RcXG4gIHBhcnNlRXJyIFxcXCJObyB2YXJpYWJsZSBvciBib2R5IGZvciBsZXQgXFxcIiAobG9jIHN0YXJ0KVxcbiAgXFxcXGJpbmRpbmcgYm9keSAuIGVxIGJvZHkgbmlsIChjcmVhdGVBc3QgYmluZGluZyBuYW1lKVxcbiAgICBnZXRMZXROYW1lcyBzdGFydCBsaXN0IG5hbWVzIFxcXFxuZXdOYW1lcyAuXFxuICAgICAgY3JlYXRlU3VibGV0cyBzdGFydCBiaW5kaW5nIGJvZHkgbmV3TmFtZXMgaWRcIikobGF6eShmdW5jdGlvbihMX3N0YXJ0KXtyZXR1cm4gZnVuY3Rpb24oTF9saXN0KXtyZXR1cm4gZnVuY3Rpb24oTF9uYW1lcyl7cmV0dXJuIHJlc29sdmUoTF93aXRoQ29ucykoTF9saXN0KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcGFyc2VFcnIpKFwiTm8gdmFyaWFibGUgb3IgYm9keSBmb3IgbGV0IFwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfbG9jKShMX3N0YXJ0KX0pfSkobGF6eShmdW5jdGlvbihMX2JpbmRpbmcpe3JldHVybiBmdW5jdGlvbihMX2JvZHkpe3JldHVybiByZXNvbHZlKExfZXEpKExfYm9keSkoTF9uaWwpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jcmVhdGVBc3QpKExfYmluZGluZykoTF9uYW1lKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9nZXRMZXROYW1lcykoTF9zdGFydCkoTF9saXN0KShMX25hbWVzKShsYXp5KGZ1bmN0aW9uKExfbmV3TmFtZXMpe3JldHVybiByZXNvbHZlKExfY3JlYXRlU3VibGV0cykoTF9zdGFydCkoTF9iaW5kaW5nKShMX2JvZHkpKExfbmV3TmFtZXMpKExfaWQpfSkpfSl9fSkpfX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImdldExldE5hbWVzXCIpKDQpKFwiZ2V0TGV0TmFtZXMgc3RhcnQgbGlzdCBuYW1lcyBjb250ID0gXFxcXFxcXFxcXG4gIGVyciA9IHBhcnNlRXJyIFxcXCJMZXQgZXhwZWN0ZWQgYmluZGluZyBcXFwiIChsb2Mgc3RhcnQpXFxuICAuXFxuICB3aXRoQ29ucyBsaXN0IChjb250IG5hbWVzKSBcXFxcYmluZGluZyBib2R5IC5cXG4gICAgaXNUb2tlblN0cmluZyBiaW5kaW5nICcuJyAoY29udCBuYW1lcylcXG4gICAgICB3aXRoUGFyZW5zIGJpbmRpbmcgZXJyIFxcXFxzdGFydCBlbmQgZGVmIC5cXG4gICAgICAgIHdpdGhDb25zIGRlZiBlcnIgXFxcXG5hbWUgcmVzdCAuXFxuICAgICAgICAgIHdpdGhUb2tlbiBuYW1lIGVyciBcXFxcc3RyIHBvcyAuXFxuICAgICAgICAgICAgZ2V0TGV0TmFtZXMgc3RhcnQgYm9keSAoY29ucyBzdHIgbmFtZXMpIGNvbnRcIikobGF6eShmdW5jdGlvbihMX3N0YXJ0KXtyZXR1cm4gZnVuY3Rpb24oTF9saXN0KXtyZXR1cm4gZnVuY3Rpb24oTF9uYW1lcyl7cmV0dXJuIGZ1bmN0aW9uKExfY29udCl7cmV0dXJuIChmdW5jdGlvbigpe1xuXG52YXIgTF9lcnI7XG5cbkxfZXJyID0gZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3BhcnNlRXJyKShcIkxldCBleHBlY3RlZCBiaW5kaW5nIFwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfbG9jKShMX3N0YXJ0KX0pfTtcbnJldHVybiByZXNvbHZlKExfd2l0aENvbnMpKExfbGlzdCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnQpKExfbmFtZXMpfSkobGF6eShmdW5jdGlvbihMX2JpbmRpbmcpe3JldHVybiBmdW5jdGlvbihMX2JvZHkpe3JldHVybiByZXNvbHZlKExfaXNUb2tlblN0cmluZykoTF9iaW5kaW5nKShcIi5cIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnQpKExfbmFtZXMpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3dpdGhQYXJlbnMpKExfYmluZGluZykoTF9lcnIpKGxhenkoZnVuY3Rpb24oTF9zdGFydF8wKXtyZXR1cm4gZnVuY3Rpb24oTF9lbmQpe3JldHVybiBmdW5jdGlvbihMX2RlZil7cmV0dXJuIHJlc29sdmUoTF93aXRoQ29ucykoTF9kZWYpKExfZXJyKShsYXp5KGZ1bmN0aW9uKExfbmFtZSl7cmV0dXJuIGZ1bmN0aW9uKExfcmVzdCl7cmV0dXJuIHJlc29sdmUoTF93aXRoVG9rZW4pKExfbmFtZSkoTF9lcnIpKGxhenkoZnVuY3Rpb24oTF9zdHIpe3JldHVybiBmdW5jdGlvbihMX3Bvcyl7cmV0dXJuIHJlc29sdmUoTF9nZXRMZXROYW1lcykoTF9zdGFydF8wKShMX2JvZHkpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShMX3N0cikoTF9uYW1lcyl9KShMX2NvbnQpfX0pKX19KSl9fX0pKX0pfX0pKX0pKCl9fX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImNyZWF0ZVN1YmxldHNcIikoNSkoXCJjcmVhdGVTdWJsZXRzIHN0YXJ0IGJpbmRpbmcgYm9keSBuYW1lcyBjb250ID1cXG4gIGlzVG9rZW5TdHJpbmcgYmluZGluZyAnLicgKGlmTm90RXJyIChjcmVhdGVBc3QgYm9keSBuYW1lcykgY29udClcXG4gICAgd2l0aENvbnMgYm9keSAocGFyc2VFcnIgXFxcIkxldCBleHBlY3RlZCBhIGJvZHkgXFxcIiAobG9jIHN0YXJ0KSkgXFxcXGJvZHlIIGJvZHlUIC5cXG4gICAgICBnZXROYW1lQW5kRGVmIChwYXJlbnNTdGFydCBiaW5kaW5nKSAocGFyZW5zQ29udGVudCBiaW5kaW5nKSBuYW1lcyBcXFxcbmFtZSBkZWYgLlxcbiAgICAgICAgY3JlYXRlU3VibGV0cyBzdGFydCBib2R5SCBib2R5VCBuYW1lcyBcXFxcYm9keUFzdCAuXFxuICAgICAgICAgIGNvbnQgKGxldCAodG9rZW5TdHJpbmcgbmFtZSkgZGVmIGJvZHlBc3QpXCIpKGxhenkoZnVuY3Rpb24oTF9zdGFydCl7cmV0dXJuIGZ1bmN0aW9uKExfYmluZGluZyl7cmV0dXJuIGZ1bmN0aW9uKExfYm9keSl7cmV0dXJuIGZ1bmN0aW9uKExfbmFtZXMpe3JldHVybiBmdW5jdGlvbihMX2NvbnQpe3JldHVybiByZXNvbHZlKExfaXNUb2tlblN0cmluZykoTF9iaW5kaW5nKShcIi5cIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2lmTm90RXJyKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY3JlYXRlQXN0KShMX2JvZHkpKExfbmFtZXMpfSkoTF9jb250KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF93aXRoQ29ucykoTF9ib2R5KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcGFyc2VFcnIpKFwiTGV0IGV4cGVjdGVkIGEgYm9keSBcIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2xvYykoTF9zdGFydCl9KX0pKGxhenkoZnVuY3Rpb24oTF9ib2R5SCl7cmV0dXJuIGZ1bmN0aW9uKExfYm9keVQpe3JldHVybiByZXNvbHZlKExfZ2V0TmFtZUFuZERlZikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3BhcmVuc1N0YXJ0KShMX2JpbmRpbmcpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3BhcmVuc0NvbnRlbnQpKExfYmluZGluZyl9KShMX25hbWVzKShsYXp5KGZ1bmN0aW9uKExfbmFtZSl7cmV0dXJuIGZ1bmN0aW9uKExfZGVmKXtyZXR1cm4gcmVzb2x2ZShMX2NyZWF0ZVN1YmxldHMpKExfc3RhcnQpKExfYm9keUgpKExfYm9keVQpKExfbmFtZXMpKGxhenkoZnVuY3Rpb24oTF9ib2R5QXN0KXtyZXR1cm4gcmVzb2x2ZShMX2NvbnQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9sZXQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90b2tlblN0cmluZykoTF9uYW1lKX0pKExfZGVmKShMX2JvZHlBc3QpfSl9KSl9fSkpfX0pKX0pfX19fX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwiZ2V0TmFtZUFuZERlZlwiKSg0KShcImdldE5hbWVBbmREZWYgcG9zIGJpbmRpbmcgbmFtZXMgY29udCA9XFxuICB3aXRoQ29ucyAodGFpbCBiaW5kaW5nKSAocGFyc2VFcnIgXFxcIkxldCBleHBlY3RlZCBiaW5kaW5nIGF0IFxcXCIgcG9zKSBcXFxcc25kIHNuZFQgLlxcbiAgICBpc1Rva2VuU3RyaW5nIHNuZCAnPScgKGlmTm90RXJyIChjcmVhdGVBc3Qgc25kVCBuYW1lcykgXFxcXGRlZiAuIGNvbnQgKGhlYWQgYmluZGluZykgZGVmKVxcbiAgICAgIGdldExldExhbWJkYSBwb3MgKHRhaWwgYmluZGluZykgbmlsIG5hbWVzIFxcXFxsYW1iIC4gY29udCAoaGVhZCBiaW5kaW5nKSBsYW1iXCIpKGxhenkoZnVuY3Rpb24oTF9wb3Mpe3JldHVybiBmdW5jdGlvbihMX2JpbmRpbmcpe3JldHVybiBmdW5jdGlvbihMX25hbWVzKXtyZXR1cm4gZnVuY3Rpb24oTF9jb250KXtyZXR1cm4gcmVzb2x2ZShMX3dpdGhDb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdGFpbCkoTF9iaW5kaW5nKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9wYXJzZUVycikoXCJMZXQgZXhwZWN0ZWQgYmluZGluZyBhdCBcIikoTF9wb3MpfSkobGF6eShmdW5jdGlvbihMX3NuZCl7cmV0dXJuIGZ1bmN0aW9uKExfc25kVCl7cmV0dXJuIHJlc29sdmUoTF9pc1Rva2VuU3RyaW5nKShMX3NuZCkoXCI9XCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pZk5vdEVycikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NyZWF0ZUFzdCkoTF9zbmRUKShMX25hbWVzKX0pKGxhenkoZnVuY3Rpb24oTF9kZWYpe3JldHVybiByZXNvbHZlKExfY29udCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2hlYWQpKExfYmluZGluZyl9KShMX2RlZil9KSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZ2V0TGV0TGFtYmRhKShMX3BvcykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3RhaWwpKExfYmluZGluZyl9KShMX25pbCkoTF9uYW1lcykobGF6eShmdW5jdGlvbihMX2xhbWIpe3JldHVybiByZXNvbHZlKExfY29udCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2hlYWQpKExfYmluZGluZyl9KShMX2xhbWIpfSkpfSl9fSkpfX19fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJnZXRMZXRMYW1iZGFcIikoNSkoXCJnZXRMZXRMYW1iZGEgcG9zIGRlZiBhcmdzIG5hbWVzIGNvbnQgPVxcbiAgd2l0aENvbnMgZGVmIChwYXJzZUVyciBcXFwiTGV0IGV4cGVjdGVkIGJpbmRpbmcgYXQgXFxcIiBwb3MpIFxcXFxhcmcgcmVzdCAuXFxuICAgIG5vdCAoaXNUb2tlbiBhcmcpIChwYXJzZUVyciBcXFwiTGV0IGV4cGVjdGVkIGJpbmRpbmcgYXQgXFxcIiBwb3MpXFxuICAgICAgaXNUb2tlblN0cmluZyBhcmcgJz0nXFxuICAgICAgICBpZk5vdEVyciAoY3JlYXRlQXN0IChjb25zICh0b2tlbiAnXFxcXFxcXFwnIHBvcykgKGFwcGVuZCAocmV2ZXJzZSBhcmdzKSAoY29ucyAodG9rZW4gJy4nIChwb3NpdGlvbiBhcmcpKSByZXN0KSkpIG5hbWVzKSBjb250XFxuICAgICAgICBnZXRMZXRMYW1iZGEgcG9zIHJlc3QgKGNvbnMgYXJnIGFyZ3MpIG5hbWVzIGNvbnRcIikobGF6eShmdW5jdGlvbihMX3Bvcyl7cmV0dXJuIGZ1bmN0aW9uKExfZGVmKXtyZXR1cm4gZnVuY3Rpb24oTF9hcmdzKXtyZXR1cm4gZnVuY3Rpb24oTF9uYW1lcyl7cmV0dXJuIGZ1bmN0aW9uKExfY29udCl7cmV0dXJuIHJlc29sdmUoTF93aXRoQ29ucykoTF9kZWYpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9wYXJzZUVycikoXCJMZXQgZXhwZWN0ZWQgYmluZGluZyBhdCBcIikoTF9wb3MpfSkobGF6eShmdW5jdGlvbihMX2FyZyl7cmV0dXJuIGZ1bmN0aW9uKExfcmVzdCl7cmV0dXJuIHJlc29sdmUoTF9ub3QpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pc1Rva2VuKShMX2FyZyl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcGFyc2VFcnIpKFwiTGV0IGV4cGVjdGVkIGJpbmRpbmcgYXQgXCIpKExfcG9zKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pc1Rva2VuU3RyaW5nKShMX2FyZykoXCI9XCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pZk5vdEVycikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NyZWF0ZUFzdCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90b2tlbikoXCJcXFxcXCIpKExfcG9zKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hcHBlbmQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9yZXZlcnNlKShMX2FyZ3MpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90b2tlbikoXCIuXCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9wb3NpdGlvbikoTF9hcmcpfSl9KShMX3Jlc3QpfSl9KX0pKExfbmFtZXMpfSkoTF9jb250KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9nZXRMZXRMYW1iZGEpKExfcG9zKShMX3Jlc3QpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShMX2FyZykoTF9hcmdzKX0pKExfbmFtZXMpKExfY29udCl9KX0pfX0pKX19fX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcInNjYW5MaW5lR1wiKSg1KShcInNjYW5MaW5lRyBzdHIgcGF0IGdyb3VwcyBvbkRlZiBvbkV4cHIgPSBcXFxcXFxcXFxcbiAgdG9rcyA9IHRva2VucyBzdHIgcGF0XFxuICBncm91cFRva3MgPSBmb2xkciAoXFxcXGVsIHZhbHVlIC4gZWwgXFxcXGggdCAuIGNvbnMgaCAoY29ucyB0IHZhbHVlKSkgKGNvbnMgJz0nIGJsb2NrU3RhcnRzKSBncm91cHNcXG4gIC5cXG4gICMgY2hlY2sgaWYgaXQncyBhIGRlZmluaXRpb25cXG4gIGZpbmQgKFxcXFx0b2sgLiBvciAoY29udGFpbnMgZ3JvdXBUb2tzICh0b2tlblN0cmluZyB0b2spKSAoaXNDb25zIChzdHJNYXRjaCAodG9rZW5TdHJpbmcgdG9rKSAnXlxcXFxuJykpKSB0b2tzIChcXFxcaXRlbSAuIGlzVG9rZW5TdHJpbmcgaXRlbSAnPScpIGZhbHNlXFxuICAgIHRva3MgXFxcXG5hbWUgcmVzdCAuIFxcXFxcXFxcXFxuICAgICAgcGFyc2VJdCBmdW5jID0gXFxcXFxcXFxcXG4gICAgICAgIHBhcnNlZCA9IHBhcnNlVG9rcyAoY2hlY2tTZXREYXRhVHlwZSBmdW5jIHJlc3QgbmFtZSkgZ3JvdXBzXFxuICAgICAgICAuXFxuICAgICAgICBvbkRlZiAoaWZOb3RFcnIgcGFyc2VkIFxcXFxsaXN0IC4gY3JlYXRlRGVmIGxpc3QgbmFtZSAoYXJpdHkgcmVzdCAwKSBzdHIpXFxuICAgICAgLlxcbiAgICAgIGlzVG9rZW5TdHJpbmcgKGhlYWQgcmVzdCkgJz0nXFxuICAgICAgICBpc1Rva2VuU3RyaW5nIChoZWFkICh0YWlsIHJlc3QpKSAnXFxcXFxcXFwnXFxuICAgICAgICAgIHBhcnNlSXQgKHNldFR5cGVBbm5vICh0YWlsIHJlc3QpICh0b2tlblN0cmluZyBuYW1lKSlcXG4gICAgICAgICAgcGFyc2VJdCAodGFpbCByZXN0KVxcbiAgICAgICAgdHJhbnNmb3JtRGVmIG5hbWUgcmVzdCBcXFxcZGVmIC5cXG4gICAgICAgICAgcGFyc2VJdCAoY29ucyAodG9rZW4gJ1xcXFxcXFxcJyAoLSAocG9zaXRpb24gKGhlYWQgcmVzdCkpIDEpKSBkZWYpXFxuICAgIGlmTm90RXJyIChwYXJzZVRva3MgdG9rcyBncm91cHMpIFxcXFxsaXN0IC4gb25FeHByIGxpc3RcIikobGF6eShmdW5jdGlvbihMX3N0cil7cmV0dXJuIGZ1bmN0aW9uKExfcGF0KXtyZXR1cm4gZnVuY3Rpb24oTF9ncm91cHMpe3JldHVybiBmdW5jdGlvbihMX29uRGVmKXtyZXR1cm4gZnVuY3Rpb24oTF9vbkV4cHIpe3JldHVybiAoZnVuY3Rpb24oKXtcblxudmFyIExfZ3JvdXBUb2tzLCBMX3Rva3M7XG5cbkxfZ3JvdXBUb2tzID0gZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2ZvbGRyKShsYXp5KGZ1bmN0aW9uKExfZWwpe3JldHVybiBmdW5jdGlvbihMX3ZhbHVlKXtyZXR1cm4gcmVzb2x2ZShMX2VsKShsYXp5KGZ1bmN0aW9uKExfaCl7cmV0dXJuIGZ1bmN0aW9uKExfdCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShMX2gpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShMX3QpKExfdmFsdWUpfSl9fSkpfX0pKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoXCI9XCIpKExfYmxvY2tTdGFydHMpfSkoTF9ncm91cHMpfTtcblxuTF90b2tzID0gZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3Rva2VucykoTF9zdHIpKExfcGF0KX07XG5yZXR1cm4gcmVzb2x2ZShMX2ZpbmQpKGxhenkoZnVuY3Rpb24oTF90b2spe3JldHVybiByZXNvbHZlKExfb3IpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb250YWlucykoTF9ncm91cFRva3MpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90b2tlblN0cmluZykoTF90b2spfSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaXNDb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc3RyTWF0Y2gpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90b2tlblN0cmluZykoTF90b2spfSkoXCJeXFxuXCIpfSl9KX0pKShMX3Rva3MpKGxhenkoZnVuY3Rpb24oTF9pdGVtKXtyZXR1cm4gcmVzb2x2ZShMX2lzVG9rZW5TdHJpbmcpKExfaXRlbSkoXCI9XCIpfSkpKExfZmFsc2UpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90b2tzKShsYXp5KGZ1bmN0aW9uKExfbmFtZSl7cmV0dXJuIGZ1bmN0aW9uKExfcmVzdCl7cmV0dXJuIChmdW5jdGlvbigpe1xuXG52YXIgTF9wYXJzZUl0O1xuXG5MX3BhcnNlSXQgPSBsYXp5KGZ1bmN0aW9uKExfZnVuYyl7cmV0dXJuIChmdW5jdGlvbigpe1xuXG52YXIgTF9wYXJzZWQ7XG5cbkxfcGFyc2VkID0gZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3BhcnNlVG9rcykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NoZWNrU2V0RGF0YVR5cGUpKExfZnVuYykoTF9yZXN0KShMX25hbWUpfSkoTF9ncm91cHMpfTtcbnJldHVybiByZXNvbHZlKExfb25EZWYpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pZk5vdEVycikoTF9wYXJzZWQpKGxhenkoZnVuY3Rpb24oTF9saXN0KXtyZXR1cm4gcmVzb2x2ZShMX2NyZWF0ZURlZikoTF9saXN0KShMX25hbWUpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hcml0eSkoTF9yZXN0KSgwKX0pKExfc3RyKX0pKX0pfSkoKX0pO1xucmV0dXJuIHJlc29sdmUoTF9pc1Rva2VuU3RyaW5nKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaGVhZCkoTF9yZXN0KX0pKFwiPVwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaXNUb2tlblN0cmluZykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2hlYWQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90YWlsKShMX3Jlc3QpfSl9KShcIlxcXFxcIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3BhcnNlSXQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zZXRUeXBlQW5ubykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3RhaWwpKExfcmVzdCl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdG9rZW5TdHJpbmcpKExfbmFtZSl9KX0pfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3BhcnNlSXQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90YWlsKShMX3Jlc3QpfSl9KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90cmFuc2Zvcm1EZWYpKExfbmFtZSkoTF9yZXN0KShsYXp5KGZ1bmN0aW9uKExfZGVmKXtyZXR1cm4gcmVzb2x2ZShMX3BhcnNlSXQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdG9rZW4pKFwiXFxcXFwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfJF8pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9wb3NpdGlvbikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2hlYWQpKExfcmVzdCl9KX0pKDEpfSl9KShMX2RlZil9KX0pKX0pfSkoKX19KSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaWZOb3RFcnIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9wYXJzZVRva3MpKExfdG9rcykoTF9ncm91cHMpfSkobGF6eShmdW5jdGlvbihMX2xpc3Qpe3JldHVybiByZXNvbHZlKExfb25FeHByKShMX2xpc3QpfSkpfSl9KSgpfX19fX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwicGFyc2VMaW5lR1wiKSg2KShcInBhcnNlTGluZUcgc3RyIHBhdCBuYW1lcyBncm91cHMgb25EZWYgb25FeHByID0gXFxcXFxcXFxcXG4gIGFzdENhbGxiYWNrIGNiID0gXFxcXGxpc3QgLiBpZk5vdEVyciAoY3JlYXRlQXN0IGxpc3QgbmFtZXMpIFxcXFxhc3QgLiBjYiBhc3RcXG4gIC5cXG4gIHNjYW5MaW5lRyBzdHIgcGF0IGdyb3VwcyAoYXN0Q2FsbGJhY2sgb25EZWYpIChhc3RDYWxsYmFjayBvbkV4cHIpXCIpKGxhenkoZnVuY3Rpb24oTF9zdHIpe3JldHVybiBmdW5jdGlvbihMX3BhdCl7cmV0dXJuIGZ1bmN0aW9uKExfbmFtZXMpe3JldHVybiBmdW5jdGlvbihMX2dyb3Vwcyl7cmV0dXJuIGZ1bmN0aW9uKExfb25EZWYpe3JldHVybiBmdW5jdGlvbihMX29uRXhwcil7cmV0dXJuIChmdW5jdGlvbigpe1xuXG52YXIgTF9hc3RDYWxsYmFjaztcblxuTF9hc3RDYWxsYmFjayA9IGxhenkoZnVuY3Rpb24oTF9jYil7cmV0dXJuIGZ1bmN0aW9uKExfbGlzdCl7cmV0dXJuIHJlc29sdmUoTF9pZk5vdEVycikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NyZWF0ZUFzdCkoTF9saXN0KShMX25hbWVzKX0pKGxhenkoZnVuY3Rpb24oTF9hc3Qpe3JldHVybiByZXNvbHZlKExfY2IpKExfYXN0KX0pKX19KTtcbnJldHVybiByZXNvbHZlKExfc2NhbkxpbmVHKShMX3N0cikoTF9wYXQpKExfZ3JvdXBzKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYXN0Q2FsbGJhY2spKExfb25EZWYpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2FzdENhbGxiYWNrKShMX29uRXhwcil9KX0pKCl9fX19fX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwidHJhbnNmb3JtRGVmXCIpKDMpKFwidHJhbnNmb3JtRGVmIG5hbWUgdG9rcyBjb250ID0gd2l0aENvbnMgdG9rcyAocGFyc2VFcnIgXFxcIkJhZCBkZWZpbml0aW9uLCBleHBlY3RpbmcgdG9rZW5zXFxcIiAobG9jIG5hbWUpKSBcXFxcaCB0IC5cXG4gIGlzVG9rZW5TdHJpbmcgaCAnPSdcXG4gICAgaXNUb2tlblN0cmluZyAoaGVhZCB0KSAnXFxcXFxcXFwnXFxuICAgICAgY29udCAoY29ucyAodG9rZW4gJy4nIChwb3NpdGlvbiBoKSkgKHNldFR5cGVBbm5vIHQgKHRva2VuU3RyaW5nIG5hbWUpKSlcXG4gICAgICBjb250IChjb25zICh0b2tlbiAnLicgKHBvc2l0aW9uIGgpKSB0KVxcbiAgICB0cmFuc2Zvcm1EZWYgbmFtZSB0IFxcXFxsaXN0IC4gY29udCAoY29ucyBoIGxpc3QpXCIpKGxhenkoZnVuY3Rpb24oTF9uYW1lKXtyZXR1cm4gZnVuY3Rpb24oTF90b2tzKXtyZXR1cm4gZnVuY3Rpb24oTF9jb250KXtyZXR1cm4gcmVzb2x2ZShMX3dpdGhDb25zKShMX3Rva3MpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9wYXJzZUVycikoXCJCYWQgZGVmaW5pdGlvbiwgZXhwZWN0aW5nIHRva2Vuc1wiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfbG9jKShMX25hbWUpfSl9KShsYXp5KGZ1bmN0aW9uKExfaCl7cmV0dXJuIGZ1bmN0aW9uKExfdCl7cmV0dXJuIHJlc29sdmUoTF9pc1Rva2VuU3RyaW5nKShMX2gpKFwiPVwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaXNUb2tlblN0cmluZykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2hlYWQpKExfdCl9KShcIlxcXFxcIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdG9rZW4pKFwiLlwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcG9zaXRpb24pKExfaCl9KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zZXRUeXBlQW5ubykoTF90KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdG9rZW5TdHJpbmcpKExfbmFtZSl9KX0pfSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29udCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90b2tlbikoXCIuXCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9wb3NpdGlvbikoTF9oKX0pfSkoTF90KX0pfSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdHJhbnNmb3JtRGVmKShMX25hbWUpKExfdCkobGF6eShmdW5jdGlvbihMX2xpc3Qpe3JldHVybiByZXNvbHZlKExfY29udCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKExfaCkoTF9saXN0KX0pfSkpfSl9fSkpfX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcInNldFR5cGVBbm5vXCIpKDIpKFwic2V0VHlwZUFubm8gdG9rcyBuYW1lID0gXFxcXFxcXFxcXG4gIHRvayA9IFxcXFxzdHIgLiB0b2tlbiBzdHIgKHBvc2l0aW9uIHRva3MpXFxuICAuXFxuICBjb25zICh0b2sgJ1xcXFxcXFxcQCcpIChjb25zICh0b2sgJ3R5cGUnKSAoY29ucyAodG9rIG5hbWUpIChjb25zICh0b2sgJy4nKSB0b2tzKSkpXCIpKGxhenkoZnVuY3Rpb24oTF90b2tzKXtyZXR1cm4gZnVuY3Rpb24oTF9uYW1lKXtyZXR1cm4gKGZ1bmN0aW9uKCl7XG5cbnZhciBMX3RvaztcblxuTF90b2sgPSBsYXp5KGZ1bmN0aW9uKExfc3RyKXtyZXR1cm4gcmVzb2x2ZShMX3Rva2VuKShMX3N0cikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3Bvc2l0aW9uKShMX3Rva3MpfSl9KTtcbnJldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3RvaykoXCJcXFxcQFwiKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdG9rKShcInR5cGVcIil9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3RvaykoTF9uYW1lKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdG9rKShcIi5cIil9KShMX3Rva3MpfSl9KX0pfSkoKX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcInNldERhdGFUeXBlQW5ub1wiKSgyKShcInNldERhdGFUeXBlQW5ubyB0b2tzIG5hbWUgPSBcXFxcXFxcXFxcbiAgdG9rID0gXFxcXHN0ciAuIHRva2VuIHN0ciAocG9zaXRpb24gdG9rcylcXG4gIC5cXG4gIGNvbnMgKHRvayAnXFxcXFxcXFxAJykgKGNvbnMgKHRvayAnZGF0YVR5cGUnKSAoY29ucyAodG9rICh0b2tlblN0cmluZyBuYW1lKSkgKGNvbnMgKHRvayAnLicpIHRva3MpKSlcIikobGF6eShmdW5jdGlvbihMX3Rva3Mpe3JldHVybiBmdW5jdGlvbihMX25hbWUpe3JldHVybiAoZnVuY3Rpb24oKXtcblxudmFyIExfdG9rO1xuXG5MX3RvayA9IGxhenkoZnVuY3Rpb24oTF9zdHIpe3JldHVybiByZXNvbHZlKExfdG9rZW4pKExfc3RyKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcG9zaXRpb24pKExfdG9rcyl9KX0pO1xucmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdG9rKShcIlxcXFxAXCIpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90b2spKFwiZGF0YVR5cGVcIil9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3RvaykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3Rva2VuU3RyaW5nKShMX25hbWUpfSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3RvaykoXCIuXCIpfSkoTF90b2tzKX0pfSl9KX0pKCl9fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJjcmVhdGVEZWZcIikoNCkoXCJjcmVhdGVEZWYgZGVmIG5hbWUgYXJpdHkgc3JjID0gXFxcXFxcXFxcXG4gIHRvayBzdHIgPSB0b2tlbiBzdHIgKHBvc2l0aW9uIGRlZilcXG4gIC5cXG4gIGpzb25TdHJpbmdpZnkgKHRva2VuU3RyaW5nIG5hbWUpIChcXFxcZXJyIC4gcGFyc2VFcnIgKHN0ckNhdCAoY29ucyBcXFwiQmFkIGZ1bmN0aW9uIG5hbWUgXFxcIiAoY29ucyAobG9jIG5hbWUpIG5pbCkpKSBlcnIpIFxcXFxuYW1lU3RyIC5cXG4gICAganNvblN0cmluZ2lmeSBzcmMgKFxcXFxlcnIgLiBwYXJzZUVyciAoc3RyQ2F0IChjb25zIFxcXCJCYWQgc291cmNlIFxcXCIgKGNvbnMgKGxvYyBuYW1lKSBuaWwpKSkgZXJyKSBcXFxcc3JjU3RyIC5cXG4gICAgICAjY29ucyAodG9rICdkZWZpbmUnKSAoY29ucyAodG9rIG5hbWVTdHIpIChjb25zICh0b2sgKHN0clN0cmluZyBhcml0eSkpIChjb25zICh0b2sgc3JjU3RyKSAoY29ucyBkZWYgbmlsKSkpKVxcbiAgICAgIGNvbnMgKHRvayAnXFxcXFxcXFxAJykgKGNvbnMgKGNvbnMgKHRvayAnZGVmaW5pdGlvbicpIChjb25zICh0b2sgbmFtZSkgbmlsKSkgKGNvbnMgKHRvayAnLicpIChjb25zICh0b2sgJ2RlZmluZScpIChjb25zICh0b2sgbmFtZVN0cikgKGNvbnMgKHRvayAoc3RyU3RyaW5nIGFyaXR5KSkgKGNvbnMgKHRvayBzcmNTdHIpIChjb25zIGRlZiBuaWwpKSkpKSkpXCIpKGxhenkoZnVuY3Rpb24oTF9kZWYpe3JldHVybiBmdW5jdGlvbihMX25hbWUpe3JldHVybiBmdW5jdGlvbihMX2FyaXR5KXtyZXR1cm4gZnVuY3Rpb24oTF9zcmMpe3JldHVybiAoZnVuY3Rpb24oKXtcblxudmFyIExfdG9rO1xuXG5MX3RvayA9IGxhenkoZnVuY3Rpb24oTF9zdHIpe3JldHVybiByZXNvbHZlKExfdG9rZW4pKExfc3RyKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcG9zaXRpb24pKExfZGVmKX0pfSk7XG5yZXR1cm4gcmVzb2x2ZShMX2pzb25TdHJpbmdpZnkpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90b2tlblN0cmluZykoTF9uYW1lKX0pKGxhenkoZnVuY3Rpb24oTF9lcnIpe3JldHVybiByZXNvbHZlKExfcGFyc2VFcnIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zdHJDYXQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShcIkJhZCBmdW5jdGlvbiBuYW1lIFwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2xvYykoTF9uYW1lKX0pKExfbmlsKX0pfSl9KShMX2Vycil9KSkobGF6eShmdW5jdGlvbihMX25hbWVTdHIpe3JldHVybiByZXNvbHZlKExfanNvblN0cmluZ2lmeSkoTF9zcmMpKGxhenkoZnVuY3Rpb24oTF9lcnIpe3JldHVybiByZXNvbHZlKExfcGFyc2VFcnIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zdHJDYXQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShcIkJhZCBzb3VyY2UgXCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfbG9jKShMX25hbWUpfSkoTF9uaWwpfSl9KX0pKExfZXJyKX0pKShsYXp5KGZ1bmN0aW9uKExfc3JjU3RyKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90b2spKFwiXFxcXEBcIil9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90b2spKFwiZGVmaW5pdGlvblwiKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdG9rKShMX25hbWUpfSkoTF9uaWwpfSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3RvaykoXCIuXCIpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90b2spKFwiZGVmaW5lXCIpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90b2spKExfbmFtZVN0cil9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3RvaykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3N0clN0cmluZykoTF9hcml0eSl9KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdG9rKShMX3NyY1N0cil9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF9kZWYpKExfbmlsKX0pfSl9KX0pfSl9KX0pfSkpfSkpfSkoKX19fX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwiY2hlY2tTZXREYXRhVHlwZVwiKSgzKShcImNoZWNrU2V0RGF0YVR5cGUgdG9rcyBjdXJUb2tzIG5hbWUgPSB3aXRoQ29ucyBjdXJUb2tzIHRva3MgXFxcXGggdCAuXFxuICBpc1Rva2VuU3RyaW5nIGggJz0nXFxuICAgIGlzVG9rZW5TdHJpbmcgKGhlYWQgdCkgJ1xcXFxcXFxcJ1xcbiAgICAgIHNldERhdGFUeXBlQW5ubyB0b2tzIG5hbWVcXG4gICAgICB0b2tzXFxuICAgIGNoZWNrU2V0RGF0YVR5cGUgdG9rcyB0IG5hbWVcIikobGF6eShmdW5jdGlvbihMX3Rva3Mpe3JldHVybiBmdW5jdGlvbihMX2N1clRva3Mpe3JldHVybiBmdW5jdGlvbihMX25hbWUpe3JldHVybiByZXNvbHZlKExfd2l0aENvbnMpKExfY3VyVG9rcykoTF90b2tzKShsYXp5KGZ1bmN0aW9uKExfaCl7cmV0dXJuIGZ1bmN0aW9uKExfdCl7cmV0dXJuIHJlc29sdmUoTF9pc1Rva2VuU3RyaW5nKShMX2gpKFwiPVwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaXNUb2tlblN0cmluZykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2hlYWQpKExfdCl9KShcIlxcXFxcIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3NldERhdGFUeXBlQW5ubykoTF90b2tzKShMX25hbWUpfSkoTF90b2tzKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jaGVja1NldERhdGFUeXBlKShMX3Rva3MpKExfdCkoTF9uYW1lKX0pfX0pKX19fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJhcml0eVwiKSgyKShcImFyaXR5IHRva3MgbiA9IGlzVG9rZW5TdHJpbmcgKGhlYWQgdG9rcykgJz0nIG4gKGFyaXR5ICh0YWlsIHRva3MpICgrIG4gMSkpXCIpKGxhenkoZnVuY3Rpb24oTF90b2tzKXtyZXR1cm4gZnVuY3Rpb24oTF9uKXtyZXR1cm4gcmVzb2x2ZShMX2lzVG9rZW5TdHJpbmcpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9oZWFkKShMX3Rva3MpfSkoXCI9XCIpKExfbikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2FyaXR5KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdGFpbCkoTF90b2tzKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF8kbykoTF9uKSgxKX0pfSl9fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJ0b2tMaXN0U3RyXCIpKDEpKFwidG9rTGlzdFN0ciB0b2tzID0ganNvblN0cmluZ2lmeSAoam9pbiAobWFwIChcXFxcdCAuIHRva2VuU3RyaW5nIHQpIHRva3MpICcgJylcIikobGF6eShmdW5jdGlvbihMX3Rva3Mpe3JldHVybiByZXNvbHZlKExfanNvblN0cmluZ2lmeSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2pvaW4pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9tYXApKGxhenkoZnVuY3Rpb24oTF90KXtyZXR1cm4gcmVzb2x2ZShMX3Rva2VuU3RyaW5nKShMX3QpfSkpKExfdG9rcyl9KShcIiBcIil9KX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwibGluZVBhdFwiKSgwKShcImxpbmVQYXQgPSByZWdleHAgJ1xcXFxcXFxccj9cXFxcXFxcXG4oPz1bXiBdfCQpJ1wiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcmVnZXhwKShcIlxcXFxyP1xcXFxuKD89W14gXXwkKVwiKX0pfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJlbXB0eUxpbmVQYXRcIikoMCkoXCJlbXB0eUxpbmVQYXQgPSByZWdleHAgJyheWyBcXFxcXFxcXGldKlxcXFxcXFxcIy4qfF5bIFxcXFxcXFxcaV0qJHxeXFxcXFxcXFxyP1xcXFxcXFxcblsgXFxcXFxcXFxpXSokKSdcIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3JlZ2V4cCkoXCIoXlsgXFxcXGldKlxcXFwjLip8XlsgXFxcXGldKiR8XlxcXFxyP1xcXFxuWyBcXFxcaV0qJClcIil9KX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwibGluZVNjcnViXCIpKDApKFwibGluZVNjcnViID0gcmVnZXhwRmxhZ3MgJ1xcXFxcXFxcclxcXFxcXFxcbicgJ2cnXCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9yZWdleHBGbGFncykoXCJcXFxcclxcXFxuXCIpKFwiZ1wiKX0pfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJsaW5lc0ZvckZpbGVcIikoMSkoXCJsaW5lc0ZvckZpbGUgdGV4dCA9IGZpbHRlclxcbiAgXFxcXGxpbmUgLiBpc05pbCAoc3RyTWF0Y2ggbGluZSBlbXB0eUxpbmVQYXQpXFxuICBzdHJTcGxpdCAoc3RyUmVwbGFjZSB0ZXh0IGxpbmVTY3J1YiAnXFxcXG4nKSBsaW5lUGF0XCIpKGxhenkoZnVuY3Rpb24oTF90ZXh0KXtyZXR1cm4gcmVzb2x2ZShMX2ZpbHRlcikobGF6eShmdW5jdGlvbihMX2xpbmUpe3JldHVybiByZXNvbHZlKExfaXNOaWwpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zdHJNYXRjaCkoTF9saW5lKShMX2VtcHR5TGluZVBhdCl9KX0pKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc3RyU3BsaXQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zdHJSZXBsYWNlKShMX3RleHQpKExfbGluZVNjcnViKShcIlxcblwiKX0pKExfbGluZVBhdCl9KX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwiZGVmUGF0XCIpKDApKFwiZGVmUGF0ID0gcmVnZXhwICdeW14gPV0rLiogPSggfCQpJ1wiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcmVnZXhwKShcIl5bXiA9XSsuKiA9KCB8JClcIil9KX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwidW5hbmNob3JlZERlZlBhdFwiKSgwKShcInVuYW5jaG9yZWREZWZQYXQgPSByZWdleHAgJ14oKD86XFxcXFxcXFxzKlxcXFxcXFxcbnwjW15cXFxcXFxcXG5dKlxcXFxcXFxcbikqKShbXj1cXFxcXFxcXG5dKikoPVxcXFxcXFxcKFtePV0rPXw9KT8nXCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9yZWdleHApKFwiXigoPzpcXFxccypcXFxcbnwjW15cXFxcbl0qXFxcXG4pKikoW149XFxcXG5dKikoPVxcXFwoW149XSs9fD0pP1wiKX0pfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJuYW1lc0ZvckxpbmVzXCIpKDEpKFwibmFtZXNGb3JMaW5lcyBsaW5lcyA9IGZvbGRsXFxuICBcXFxccmVzdWx0IGxpbmUgLiBcXFxcXFxcXFxcbiAgICBtID0gc3RyTWF0Y2ggbGluZSBkZWZQYXRcXG4gICAgLlxcbiAgICBpc05pbCBtIHJlc3VsdCAoY29ucyAoaGVhZCAodGFpbCBtKSkgcmVzdWx0KVxcbiAgbmlsXFxuICBsaW5lc1wiKShsYXp5KGZ1bmN0aW9uKExfbGluZXMpe3JldHVybiByZXNvbHZlKExfZm9sZGwpKGxhenkoZnVuY3Rpb24oTF9yZXN1bHQpe3JldHVybiBmdW5jdGlvbihMX2xpbmUpe3JldHVybiAoZnVuY3Rpb24oKXtcblxudmFyIExfbTtcblxuTF9tID0gZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3N0ck1hdGNoKShMX2xpbmUpKExfZGVmUGF0KX07XG5yZXR1cm4gcmVzb2x2ZShMX2lzTmlsKShMX20pKExfcmVzdWx0KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2hlYWQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90YWlsKShMX20pfSl9KShMX3Jlc3VsdCl9KX0pKCl9fSkpKExfbmlsKShMX2xpbmVzKX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwicnVuUGFyc2VGaWx0ZXJzXCIpKDIpKFwicnVuUGFyc2VGaWx0ZXJzIGZpbHRlcnMgbGluZSA9IGZpbHRlcnNcXG4gIFxcXFxoIHQgRCAuIGJpbmQgKGggbGluZSkgXFxcXGZpbHRlcmVkIC4gcnVuUGFyc2VGaWx0ZXJzIHQgZmlsdGVyZWRcXG4gIGxpbmVcIikobGF6eShmdW5jdGlvbihMX2ZpbHRlcnMpe3JldHVybiBmdW5jdGlvbihMX2xpbmUpe3JldHVybiByZXNvbHZlKExfZmlsdGVycykobGF6eShmdW5jdGlvbihMX2gpe3JldHVybiBmdW5jdGlvbihMX3Qpe3JldHVybiBmdW5jdGlvbihMX0Qpe3JldHVybiByZXNvbHZlKExfYmluZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2gpKExfbGluZSl9KShsYXp5KGZ1bmN0aW9uKExfZmlsdGVyZWQpe3JldHVybiByZXNvbHZlKExfcnVuUGFyc2VGaWx0ZXJzKShMX3QpKExfZmlsdGVyZWQpfSkpfX19KSkoTF9saW5lKX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImlzQmxvY2tTdGFydFwiKSgxKShcImlzQmxvY2tTdGFydCB0b2sgPSBhbmRcXG4gIG9yIChpc1Rva2VuIHRvaykgKGlzU3RyaW5nIHRvaylcXG4gIGNvbnRhaW5zIGJsb2NrU3RhcnRzIChzdHJUb2tlblN0cmluZyB0b2spXCIpKGxhenkoZnVuY3Rpb24oTF90b2spe3JldHVybiByZXNvbHZlKExfYW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfb3IpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pc1Rva2VuKShMX3Rvayl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaXNTdHJpbmcpKExfdG9rKX0pfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnRhaW5zKShMX2Jsb2NrU3RhcnRzKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc3RyVG9rZW5TdHJpbmcpKExfdG9rKX0pfSl9KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcIm1hY3JvU3ViXCIpKDIpKFwibWFjcm9TdWIgbWFjcyBleHByID0gcG9zdFByb2Nlc3NNYWNybyAtMSAtMSAoYmFzZU1hY3JvU3ViIG1hY3MgZXhwcilcIikobGF6eShmdW5jdGlvbihMX21hY3Mpe3JldHVybiBmdW5jdGlvbihMX2V4cHIpe3JldHVybiByZXNvbHZlKExfcG9zdFByb2Nlc3NNYWNybykoLTEpKC0xKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYmFzZU1hY3JvU3ViKShMX21hY3MpKExfZXhwcil9KX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImNvbnNpZnlNYWNyb1ZhbHVlXCIpKDEpKFwiY29uc2lmeU1hY3JvVmFsdWUgdmFsdWUgPSBpc0NvbnMgdmFsdWUgdmFsdWUgKGNvbnMgdmFsdWUgbmlsKVwiKShsYXp5KGZ1bmN0aW9uKExfdmFsdWUpe3JldHVybiByZXNvbHZlKExfaXNDb25zKShMX3ZhbHVlKShMX3ZhbHVlKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF92YWx1ZSkoTF9uaWwpfSl9KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImJhc2VNYWNyb1N1YlwiKSgyKShcImJhc2VNYWNyb1N1YiBtYWNzIGV4cHIgPSBpc1Rva2VuIGV4cHJcXG4gIGV4cHJcXG4gIGlzUGFyZW5zIGV4cHJcXG4gICAgZXhwciBcXFxcc3RhcnQgZW5kIGNvbnRlbnQgLiBcXFxcXFxcXFxcbiAgICAgIHJlc3VsdCA9IGJhc2VNYWNyb1N1YiBtYWNzIGNvbnRlbnRcXG4gICAgICAuXFxuICAgICAgaXNUb2tlbiByZXN1bHQgcmVzdWx0IChwYXJlbnMgc3RhcnQgZW5kIHJlc3VsdClcXG4gICAgd2l0aENvbnMgZXhwciBleHByIFxcXFxoIHQgLlxcbiAgICAgIGlzQmxvY2tTdGFydCBoXFxuICAgICAgICBjb25zIGhcXG4gICAgICAgICAgaXNUb2tlblN0cmluZyBoICdcXFxcXFxcXFxcXFxcXFxcJ1xcbiAgICAgICAgICAgIG1hY3JvU3ViTGV0IG1hY3MgdFxcbiAgICAgICAgICAgIG1hY3JvU3ViQm9keSAnLicgbWFjcyB0XFxuICAgICAgICB3aXRoVG9rZW4gaFxcbiAgICAgICAgICBcXFxcXFxcXFxcbiAgICAgICAgICAgIHN1YkggPSBiYXNlTWFjcm9TdWIgbWFjcyBoXFxuICAgICAgICAgICAgLlxcbiAgICAgICAgICAgIHdpdGhUb2tlbiBzdWJIXFxuICAgICAgICAgICAgICBjb25zIHN1YkggKG1hcCAoYmFzZU1hY3JvU3ViIG1hY3MpIHQpXFxuICAgICAgICAgICAgICBcXFxcdG9rIHBvcyAuIGJhc2VNYWNyb1N1YiBtYWNzIChjb25zIHN1YkggdClcXG4gICAgICAgICAgXFxcXHRvayBwb3MgLiBhc3NvYyB0b2sgbWFjc1xcbiAgICAgICAgICAgIFxcXFxkZWYgLiBiYXNlTWFjcm9TdWIgbWFjcyAoZGVmIHQpXFxuICAgICAgICAgICAgY29ucyBoIChtYXAgKGJhc2VNYWNyb1N1YiBtYWNzKSB0KVwiKShsYXp5KGZ1bmN0aW9uKExfbWFjcyl7cmV0dXJuIGZ1bmN0aW9uKExfZXhwcil7cmV0dXJuIHJlc29sdmUoTF9pc1Rva2VuKShMX2V4cHIpKExfZXhwcikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2lzUGFyZW5zKShMX2V4cHIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9leHByKShsYXp5KGZ1bmN0aW9uKExfc3RhcnQpe3JldHVybiBmdW5jdGlvbihMX2VuZCl7cmV0dXJuIGZ1bmN0aW9uKExfY29udGVudCl7cmV0dXJuIChmdW5jdGlvbigpe1xuXG52YXIgTF9yZXN1bHQ7XG5cbkxfcmVzdWx0ID0gZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2Jhc2VNYWNyb1N1YikoTF9tYWNzKShMX2NvbnRlbnQpfTtcbnJldHVybiByZXNvbHZlKExfaXNUb2tlbikoTF9yZXN1bHQpKExfcmVzdWx0KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcGFyZW5zKShMX3N0YXJ0KShMX2VuZCkoTF9yZXN1bHQpfSl9KSgpfX19KSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfd2l0aENvbnMpKExfZXhwcikoTF9leHByKShsYXp5KGZ1bmN0aW9uKExfaCl7cmV0dXJuIGZ1bmN0aW9uKExfdCl7cmV0dXJuIHJlc29sdmUoTF9pc0Jsb2NrU3RhcnQpKExfaCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKExfaCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2lzVG9rZW5TdHJpbmcpKExfaCkoXCJcXFxcXFxcXFwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfbWFjcm9TdWJMZXQpKExfbWFjcykoTF90KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9tYWNyb1N1YkJvZHkpKFwiLlwiKShMX21hY3MpKExfdCl9KX0pfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3dpdGhUb2tlbikoTF9oKShmdW5jdGlvbigpe1xudmFyIExfc3ViSDtcblxuTF9zdWJIID0gZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2Jhc2VNYWNyb1N1YikoTF9tYWNzKShMX2gpfTtcbnJldHVybiByZXNvbHZlKExfd2l0aFRva2VuKShMX3N1YkgpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShMX3N1YkgpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9tYXApKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9iYXNlTWFjcm9TdWIpKExfbWFjcyl9KShMX3QpfSl9KShsYXp5KGZ1bmN0aW9uKExfdG9rKXtyZXR1cm4gZnVuY3Rpb24oTF9wb3Mpe3JldHVybiByZXNvbHZlKExfYmFzZU1hY3JvU3ViKShMX21hY3MpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShMX3N1YkgpKExfdCl9KX19KSl9KShsYXp5KGZ1bmN0aW9uKExfdG9rKXtyZXR1cm4gZnVuY3Rpb24oTF9wb3Mpe3JldHVybiByZXNvbHZlKExfYXNzb2MpKExfdG9rKShMX21hY3MpKGxhenkoZnVuY3Rpb24oTF9kZWYpe3JldHVybiByZXNvbHZlKExfYmFzZU1hY3JvU3ViKShMX21hY3MpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWYpKExfdCl9KX0pKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF9oKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfbWFwKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYmFzZU1hY3JvU3ViKShMX21hY3MpfSkoTF90KX0pfSl9fSkpfSl9fSkpfSl9KX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcIm1hY3JvU3ViTGV0XCIpKDIpKFwibWFjcm9TdWJMZXQgbWFjcyBsaXN0ID0gbGlzdFxcbiAgXFxcXGggdCBEIC4gaXNUb2tlblN0cmluZyBoICcuJ1xcbiAgICBjb25zIGggKGJhc2VNYWNyb1N1YiBtYWNzIHQpXFxuICAgIGNvbnMgKHNldFBhcmVucyBoIFxcXFxjb250ZW50IC4gbWFjcm9TdWJCb2R5ICc9JyBtYWNzIGNvbnRlbnQpIChtYWNyb1N1YkxldCBtYWNzIHQpXFxuICAjIERvbid0IGJvdGhlciB3aXRoIHBhcnNlIGVycm9ycyBhdCB0aGlzIHBvaW50IC0tIGFzdCBnZW5lcmF0b3Igd2lsbCBkZXRlY3QgdGhlbVxcbiAgbmlsXCIpKGxhenkoZnVuY3Rpb24oTF9tYWNzKXtyZXR1cm4gZnVuY3Rpb24oTF9saXN0KXtyZXR1cm4gcmVzb2x2ZShMX2xpc3QpKGxhenkoZnVuY3Rpb24oTF9oKXtyZXR1cm4gZnVuY3Rpb24oTF90KXtyZXR1cm4gZnVuY3Rpb24oTF9EKXtyZXR1cm4gcmVzb2x2ZShMX2lzVG9rZW5TdHJpbmcpKExfaCkoXCIuXCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShMX2gpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9iYXNlTWFjcm9TdWIpKExfbWFjcykoTF90KX0pfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zZXRQYXJlbnMpKExfaCkobGF6eShmdW5jdGlvbihMX2NvbnRlbnQpe3JldHVybiByZXNvbHZlKExfbWFjcm9TdWJCb2R5KShcIj1cIikoTF9tYWNzKShMX2NvbnRlbnQpfSkpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX21hY3JvU3ViTGV0KShMX21hY3MpKExfdCl9KX0pfX19KSkoTF9uaWwpfX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwibWFjcm9TdWJCb2R5XCIpKDMpKFwibWFjcm9TdWJCb2R5IGNoYXIgbWFjcyBsaXN0ID0gbGlzdFxcbiAgXFxcXGggdCBEIC4gY29ucyBoXFxuICAgIGlzVG9rZW5TdHJpbmcgaCBjaGFyIGJhc2VNYWNyb1N1YiAobWFjcm9TdWJCb2R5IGNoYXIpXFxuICAgICAgbWFjc1xcbiAgICAgIHRcXG4gIG5pbFwiKShsYXp5KGZ1bmN0aW9uKExfY2hhcil7cmV0dXJuIGZ1bmN0aW9uKExfbWFjcyl7cmV0dXJuIGZ1bmN0aW9uKExfbGlzdCl7cmV0dXJuIHJlc29sdmUoTF9saXN0KShsYXp5KGZ1bmN0aW9uKExfaCl7cmV0dXJuIGZ1bmN0aW9uKExfdCl7cmV0dXJuIGZ1bmN0aW9uKExfRCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShMX2gpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pc1Rva2VuU3RyaW5nKShMX2gpKExfY2hhcikoTF9iYXNlTWFjcm9TdWIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9tYWNyb1N1YkJvZHkpKExfY2hhcil9KShMX21hY3MpKExfdCl9KX19fSkpKExfbmlsKX19fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJwb3N0UHJvY2Vzc01hY3JvXCIpKDMpKFwicG9zdFByb2Nlc3NNYWNybyBiZWZvcmUgYWZ0ZXIgZXhwciA9IGlzU3RyaW5nIGV4cHJcXG4gIHRva2VuIGV4cHIgKGVxIGFmdGVyIC0xIGJlZm9yZSBhZnRlcilcXG4gIGlzUGFyZW5zIGV4cHJcXG4gICAgZXhwciBcXFxcc3RhcnQgZW5kIGNvbnRlbnRzIC4gcGFyZW5zIHN0YXJ0IGVuZCAocG9zdFByb2Nlc3NNYWNybyBzdGFydCBlbmQgY29udGVudHMpXFxuICAgIGlzQ29ucyBleHByXFxuICAgICAgZXhwciBcXFxcaCB0IC5cXG4gICAgICAgIGlzVG9rZW4gaFxcbiAgICAgICAgICBjb25zIGggKHBvc3RQcm9jZXNzTWFjcm8gKCsgMSAoKyAodG9rZW5Qb3MgaCkgKHN0ckxlbiAodG9rZW5TdHJpbmcgaCkpKSkgLTEgdClcXG4gICAgICAgICAgXFxcXFxcXFxcXG4gICAgICAgICAgICBwb3NTdGFydCA9IHBvc2l0aW9uIGhcXG4gICAgICAgICAgICBwb3NFbmQgPSBwb3NpdGlvbiB0XFxuICAgICAgICAgICAgdDIgPSBwb3N0UHJvY2Vzc01hY3JvIC0xIGFmdGVyIHRcXG4gICAgICAgICAgICBoMiA9IHBvc3RQcm9jZXNzTWFjcm8gYmVmb3JlIC0xIGhcXG4gICAgICAgICAgICAuXFxuICAgICAgICAgICAgZXEgcG9zU3RhcnQgLTFcXG4gICAgICAgICAgICAgIGNvbnMgKHBvc3RQcm9jZXNzTWFjcm8gYmVmb3JlIChwb3NpdGlvbiB0MikgaCkgdDJcXG4gICAgICAgICAgICAgIGNvbnMgaDIgKHBvc3RQcm9jZXNzTWFjcm8gKCsgMSAobGV4RW5kIGgyKSkgYWZ0ZXIgdClcXG4gICAgICBpc051bWJlciBleHByXFxuICAgICAgICB0b2tlbiAoc3RyU3RyaW5nIGV4cHIpIChlcSBhZnRlciAtMSBiZWZvcmUgYWZ0ZXIpXFxuICAgICAgICBleHByXCIpKGxhenkoZnVuY3Rpb24oTF9iZWZvcmUpe3JldHVybiBmdW5jdGlvbihMX2FmdGVyKXtyZXR1cm4gZnVuY3Rpb24oTF9leHByKXtyZXR1cm4gcmVzb2x2ZShMX2lzU3RyaW5nKShMX2V4cHIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90b2tlbikoTF9leHByKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZXEpKExfYWZ0ZXIpKC0xKShMX2JlZm9yZSkoTF9hZnRlcil9KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pc1BhcmVucykoTF9leHByKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZXhwcikobGF6eShmdW5jdGlvbihMX3N0YXJ0KXtyZXR1cm4gZnVuY3Rpb24oTF9lbmQpe3JldHVybiBmdW5jdGlvbihMX2NvbnRlbnRzKXtyZXR1cm4gcmVzb2x2ZShMX3BhcmVucykoTF9zdGFydCkoTF9lbmQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9wb3N0UHJvY2Vzc01hY3JvKShMX3N0YXJ0KShMX2VuZCkoTF9jb250ZW50cyl9KX19fSkpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2lzQ29ucykoTF9leHByKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZXhwcikobGF6eShmdW5jdGlvbihMX2gpe3JldHVybiBmdW5jdGlvbihMX3Qpe3JldHVybiByZXNvbHZlKExfaXNUb2tlbikoTF9oKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF9oKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcG9zdFByb2Nlc3NNYWNybykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMXyRvKSgxKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfJG8pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90b2tlblBvcykoTF9oKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zdHJMZW4pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90b2tlblN0cmluZykoTF9oKX0pfSl9KX0pKC0xKShMX3QpfSl9KShmdW5jdGlvbigpe1xudmFyIExfaDIsIExfdDIsIExfcG9zRW5kLCBMX3Bvc1N0YXJ0O1xuXG5MX2gyID0gZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3Bvc3RQcm9jZXNzTWFjcm8pKExfYmVmb3JlKSgtMSkoTF9oKX07XG5cbkxfdDIgPSBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcG9zdFByb2Nlc3NNYWNybykoLTEpKExfYWZ0ZXIpKExfdCl9O1xuXG5MX3Bvc0VuZCA9IGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9wb3NpdGlvbikoTF90KX07XG5cbkxfcG9zU3RhcnQgPSBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcG9zaXRpb24pKExfaCl9O1xucmV0dXJuIHJlc29sdmUoTF9lcSkoTF9wb3NTdGFydCkoLTEpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcG9zdFByb2Nlc3NNYWNybykoTF9iZWZvcmUpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9wb3NpdGlvbikoTF90Mil9KShMX2gpfSkoTF90Mil9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF9oMikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3Bvc3RQcm9jZXNzTWFjcm8pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF8kbykoMSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2xleEVuZCkoTF9oMil9KX0pKExfYWZ0ZXIpKExfdCl9KX0pfSl9fSkpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2lzTnVtYmVyKShMX2V4cHIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90b2tlbikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3N0clN0cmluZykoTF9leHByKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9lcSkoTF9hZnRlcikoLTEpKExfYmVmb3JlKShMX2FmdGVyKX0pfSkoTF9leHByKX0pfSl9KX19fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJkZWZNYWNyb1wiKSgyKShcImRlZk1hY3JvIG5hbWUgZGVmID0gYmluZCAoZ2V0VmFsdWUgJ21hY3JvRGVmcycpIFxcXFxtYWNzIC4gc2V0VmFsdWUgJ21hY3JvRGVmcycgKGFjb25zIG5hbWUgZGVmIG1hY3MpXCIpKGxhenkoZnVuY3Rpb24oTF9uYW1lKXtyZXR1cm4gZnVuY3Rpb24oTF9kZWYpe3JldHVybiByZXNvbHZlKExfYmluZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2dldFZhbHVlKShcIm1hY3JvRGVmc1wiKX0pKGxhenkoZnVuY3Rpb24oTF9tYWNzKXtyZXR1cm4gcmVzb2x2ZShMX3NldFZhbHVlKShcIm1hY3JvRGVmc1wiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYWNvbnMpKExfbmFtZSkoTF9kZWYpKExfbWFjcyl9KX0pKX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImRlbGltaXRlckxpc3RQcmVmaXhcIikoMCkoXCJkZWxpbWl0ZXJMaXN0UHJlZml4ID0gXFxcIlxcXFxcXFwiKD86XFxcXFxcXFxcXFxcXFxcXC58W15cXFxcXFxcIl0pKlxcXFxcXFwifCcoPzpcXFxcXFxcXFxcXFxcXFxcLnxbXiddKSonfFxcXFxcXFxcbiAqfCMuKnwgK1xcXCJcIikoXCJcXFwiKD86XFxcXFxcXFwufFteXFxcIl0pKlxcXCJ8Jyg/OlxcXFxcXFxcLnxbXiddKSonfFxcXFxuICp8Iy4qfCArXCIpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJyZWdleHBFc2NhcGVQYXRcIikoMCkoXCJyZWdleHBFc2NhcGVQYXQgPSByZWdleHBGbGFncyAnW1xcXFxcXFxcLVxcXFxcXFxcW1xcXFxcXFxcXS9cXFxcXFxcXHtcXFxcXFxcXH1cXFxcXFxcXChcXFxcXFxcXClcXFxcXFxcXCpcXFxcXFxcXCtcXFxcXFxcXD9cXFxcXFxcXC5cXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxeXFxcXFxcXFwkXFxcXFxcXFx8XScgJ2cnXCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9yZWdleHBGbGFncykoXCJbXFxcXC1cXFxcW1xcXFxdL1xcXFx7XFxcXH1cXFxcKFxcXFwpXFxcXCpcXFxcK1xcXFw/XFxcXC5cXFxcXFxcXFxcXFxeXFxcXCRcXFxcfF1cIikoXCJnXCIpfSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImFkZFRva2VuXCIpKDEpKFwiYWRkVG9rZW4gZGVsID0gYmluZCAoZ2V0VmFsdWUgJ3Rva2VuTGlzdCcpXFxuICBcXFxcZGVscyAuIGNvbnRhaW5zIGRlbHMgZGVsXFxuICAgIGZhbHNlXFxuICAgIFxcXFxcXFxcXFxuICAgICAgbmV3RGVscyA9IGluc2VydFNvcnRlZCAoXFxcXGEgYiAuID4gKHN0ckxlbiBhKSAoc3RyTGVuIGIpKSBkZWwgZGVsc1xcbiAgICAgIC5cXG4gICAgICBiaW5kIChzZXRWYWx1ZSAndG9rZW5MaXN0JyBuZXdEZWxzKVxcbiAgICAgICAgXFxcXF8gLiBjb21wdXRlVG9rZW5QYXQgbmV3RGVsc1wiKShsYXp5KGZ1bmN0aW9uKExfZGVsKXtyZXR1cm4gcmVzb2x2ZShMX2JpbmQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9nZXRWYWx1ZSkoXCJ0b2tlbkxpc3RcIil9KShsYXp5KGZ1bmN0aW9uKExfZGVscyl7cmV0dXJuIHJlc29sdmUoTF9jb250YWlucykoTF9kZWxzKShMX2RlbCkoTF9mYWxzZSkoZnVuY3Rpb24oKXtcbnZhciBMX25ld0RlbHM7XG5cbkxfbmV3RGVscyA9IGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pbnNlcnRTb3J0ZWQpKGxhenkoZnVuY3Rpb24oTF9hKXtyZXR1cm4gZnVuY3Rpb24oTF9iKXtyZXR1cm4gcmVzb2x2ZShMXyR6KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc3RyTGVuKShMX2EpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3N0ckxlbikoTF9iKX0pfX0pKShMX2RlbCkoTF9kZWxzKX07XG5yZXR1cm4gcmVzb2x2ZShMX2JpbmQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zZXRWYWx1ZSkoXCJ0b2tlbkxpc3RcIikoTF9uZXdEZWxzKX0pKGxhenkoZnVuY3Rpb24oTF9fKXtyZXR1cm4gcmVzb2x2ZShMX2NvbXB1dGVUb2tlblBhdCkoTF9uZXdEZWxzKX0pKX0pfSkpfSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJjb21wdXRlVG9rZW5QYXRcIikoMSkoXCJjb21wdXRlVG9rZW5QYXQgZGVscyA9IFxcXFxcXFxcXFxuICBkZWxQYXRzID0gbWFwIChcXFxcaXRlbSAuIHN0clJlcGxhY2UgaXRlbSByZWdleHBFc2NhcGVQYXQgXFxcIlxcXFxcXFxcJCZcXFwiKSBkZWxzXFxuICBuZXdQYXQgPSBzdHJDYXQgKGNvbnMgJygnIChjb25zIChqb2luIChjb25zIGRlbGltaXRlckxpc3RQcmVmaXggZGVsUGF0cykgJ3wnKSAoY29ucyAnKScgbmlsKSkpXFxuICAuXFxuICBzZXRWYWx1ZSAndG9rZW5QYXQnIG5ld1BhdFwiKShsYXp5KGZ1bmN0aW9uKExfZGVscyl7cmV0dXJuIChmdW5jdGlvbigpe1xuXG52YXIgTF9uZXdQYXQsIExfZGVsUGF0cztcblxuTF9uZXdQYXQgPSBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc3RyQ2F0KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoXCIoXCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfam9pbikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKExfZGVsaW1pdGVyTGlzdFByZWZpeCkoTF9kZWxQYXRzKX0pKFwifFwiKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShcIilcIikoTF9uaWwpfSl9KX0pfTtcblxuTF9kZWxQYXRzID0gZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX21hcCkobGF6eShmdW5jdGlvbihMX2l0ZW0pe3JldHVybiByZXNvbHZlKExfc3RyUmVwbGFjZSkoTF9pdGVtKShMX3JlZ2V4cEVzY2FwZVBhdCkoXCJcXFxcJCZcIil9KSkoTF9kZWxzKX07XG5yZXR1cm4gcmVzb2x2ZShMX3NldFZhbHVlKShcInRva2VuUGF0XCIpKExfbmV3UGF0KX0pKCl9KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImFkZFRva2VuR3JvdXBcIikoMikoXCJhZGRUb2tlbkdyb3VwIG9wZW4gY2xvc2UgPSBiaW5kIChhZGRUb2tlbiBvcGVuKVxcbiAgXFxcXF8gLiBiaW5kIChhZGRUb2tlbiBjbG9zZSlcXG4gICAgXFxcXF8gLiBiaW5kIChnZXRWYWx1ZSAndG9rZW5Hcm91cHMnKVxcbiAgICAgIFxcXFxnciAuIHNldFZhbHVlICd0b2tlbkdyb3VwcycgKGFjb25zIG9wZW4gY2xvc2UgZ3IpXCIpKGxhenkoZnVuY3Rpb24oTF9vcGVuKXtyZXR1cm4gZnVuY3Rpb24oTF9jbG9zZSl7cmV0dXJuIHJlc29sdmUoTF9iaW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYWRkVG9rZW4pKExfb3Blbil9KShsYXp5KGZ1bmN0aW9uKExfXyl7cmV0dXJuIHJlc29sdmUoTF9iaW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYWRkVG9rZW4pKExfY2xvc2UpfSkobGF6eShmdW5jdGlvbihMX19fMCl7cmV0dXJuIHJlc29sdmUoTF9iaW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZ2V0VmFsdWUpKFwidG9rZW5Hcm91cHNcIil9KShsYXp5KGZ1bmN0aW9uKExfZ3Ipe3JldHVybiByZXNvbHZlKExfc2V0VmFsdWUpKFwidG9rZW5Hcm91cHNcIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2Fjb25zKShMX29wZW4pKExfY2xvc2UpKExfZ3IpfSl9KSl9KSl9KSl9fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJwYXJlbkdyb3Vwc1wiKSgwKShcInBhcmVuR3JvdXBzID0gYWNvbnMgJygnICcpJyBuaWxcIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2Fjb25zKShcIihcIikoXCIpXCIpKExfbmlsKX0pfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJwYXJzZVwiKSgyKShcInBhcnNlIHN0ciBwYXQgPSBpZk5vdEVyciAocGFyc2VJbmRlbnQgKHRva2VuICdcXFxcbicgMCkgKHRva2VucyBzdHIgcGF0KSBuaWwgcGFyZW5Hcm91cHMpIFxcXFxsaXN0IC4gbGlzdCBcXFxcaCB0IC4gc3RyaXBQYXJlbnMgaFwiKShsYXp5KGZ1bmN0aW9uKExfc3RyKXtyZXR1cm4gZnVuY3Rpb24oTF9wYXQpe3JldHVybiByZXNvbHZlKExfaWZOb3RFcnIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9wYXJzZUluZGVudCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3Rva2VuKShcIlxcblwiKSgwKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90b2tlbnMpKExfc3RyKShMX3BhdCl9KShMX25pbCkoTF9wYXJlbkdyb3Vwcyl9KShsYXp5KGZ1bmN0aW9uKExfbGlzdCl7cmV0dXJuIHJlc29sdmUoTF9saXN0KShsYXp5KGZ1bmN0aW9uKExfaCl7cmV0dXJuIGZ1bmN0aW9uKExfdCl7cmV0dXJuIHJlc29sdmUoTF9zdHJpcFBhcmVucykoTF9oKX19KSl9KSl9fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJwYXJzZUdcIikoMykoXCJwYXJzZUcgc3RyIHBhdCBncm91cHMgPSBpZk5vdEVyciAocGFyc2VJbmRlbnQgKHRva2VuICdcXFxcbicgMCkgKHRva2VucyBzdHIgcGF0KSBuaWwgZ3JvdXBzKSBcXFxcbGlzdCAuIGxpc3QgXFxcXGggdCAuIHN0cmlwUGFyZW5zIGhcIikobGF6eShmdW5jdGlvbihMX3N0cil7cmV0dXJuIGZ1bmN0aW9uKExfcGF0KXtyZXR1cm4gZnVuY3Rpb24oTF9ncm91cHMpe3JldHVybiByZXNvbHZlKExfaWZOb3RFcnIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9wYXJzZUluZGVudCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3Rva2VuKShcIlxcblwiKSgwKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90b2tlbnMpKExfc3RyKShMX3BhdCl9KShMX25pbCkoTF9ncm91cHMpfSkobGF6eShmdW5jdGlvbihMX2xpc3Qpe3JldHVybiByZXNvbHZlKExfbGlzdCkobGF6eShmdW5jdGlvbihMX2gpe3JldHVybiBmdW5jdGlvbihMX3Qpe3JldHVybiByZXNvbHZlKExfc3RyaXBQYXJlbnMpKExfaCl9fSkpfSkpfX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcInBhcnNlVG9Bc3RcIikoMikoXCJwYXJzZVRvQXN0IHN0ciBwYXQgPSBjcmVhdGVBc3QgKHBhcnNlIHN0ciBwYXQpIG5pbFwiKShsYXp5KGZ1bmN0aW9uKExfc3RyKXtyZXR1cm4gZnVuY3Rpb24oTF9wYXQpe3JldHVybiByZXNvbHZlKExfY3JlYXRlQXN0KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcGFyc2UpKExfc3RyKShMX3BhdCl9KShMX25pbCl9fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJwYXJzZU1cIikoMSkoXCJwYXJzZU0gc3RyID1cXG4gIGJpbmQgKGdldFZhbHVlICd0b2tlblBhdCcpXFxuICAgIFxcXFx0b2tQYXQgLiBiaW5kIChnZXRWYWx1ZSAndG9rZW5Hcm91cHMnKVxcbiAgICAgIFxcXFxncm91cHMgLiBwYXJzZUcgc3RyIHRva1BhdCBncm91cHNcIikobGF6eShmdW5jdGlvbihMX3N0cil7cmV0dXJuIHJlc29sdmUoTF9iaW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZ2V0VmFsdWUpKFwidG9rZW5QYXRcIil9KShsYXp5KGZ1bmN0aW9uKExfdG9rUGF0KXtyZXR1cm4gcmVzb2x2ZShMX2JpbmQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9nZXRWYWx1ZSkoXCJ0b2tlbkdyb3Vwc1wiKX0pKGxhenkoZnVuY3Rpb24oTF9ncm91cHMpe3JldHVybiByZXNvbHZlKExfcGFyc2VHKShMX3N0cikoTF90b2tQYXQpKExfZ3JvdXBzKX0pKX0pKX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwic2NhbkxpbmVcIikoNCkoXCJzY2FuTGluZSBzdHIgcGF0IG9uRGVmIG9uRXhwciA9IHNjYW5MaW5lRyBzdHIgcGF0IHBhcmVuR3JvdXBzIG9uRGVmIG9uRXhwclwiKShsYXp5KGZ1bmN0aW9uKExfc3RyKXtyZXR1cm4gZnVuY3Rpb24oTF9wYXQpe3JldHVybiBmdW5jdGlvbihMX29uRGVmKXtyZXR1cm4gZnVuY3Rpb24oTF9vbkV4cHIpe3JldHVybiByZXNvbHZlKExfc2NhbkxpbmVHKShMX3N0cikoTF9wYXQpKExfcGFyZW5Hcm91cHMpKExfb25EZWYpKExfb25FeHByKX19fX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwicGFyc2VMaW5lXCIpKDUpKFwicGFyc2VMaW5lIHN0ciBwYXQgbmFtZXMgb25EZWYgb25FeHByID0gcGFyc2VMaW5lRyBzdHIgcGF0IG5hbWVzIHBhcmVuR3JvdXBzIG9uRGVmIG9uRXhwclwiKShsYXp5KGZ1bmN0aW9uKExfc3RyKXtyZXR1cm4gZnVuY3Rpb24oTF9wYXQpe3JldHVybiBmdW5jdGlvbihMX25hbWVzKXtyZXR1cm4gZnVuY3Rpb24oTF9vbkRlZil7cmV0dXJuIGZ1bmN0aW9uKExfb25FeHByKXtyZXR1cm4gcmVzb2x2ZShMX3BhcnNlTGluZUcpKExfc3RyKShMX3BhdCkoTF9uYW1lcykoTF9wYXJlbkdyb3VwcykoTF9vbkRlZikoTF9vbkV4cHIpfX19fX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwicGFyc2VMaW5lTVwiKSgxKShcInBhcnNlTGluZU0gc3RyID0gYmluZCAoZ2V0VmFsdWUgJ3Rva2VuUGF0JylcXG4gIFxcXFx0b2tQYXQgLiBiaW5kIChnZXRWYWx1ZSAndG9rZW5Hcm91cHMnKVxcbiAgICBcXFxcZ3JvdXBzIC4gcGFyc2VMaW5lRyBzdHIgdG9rUGF0IG5pbCBncm91cHMgaWQgaWRcIikobGF6eShmdW5jdGlvbihMX3N0cil7cmV0dXJuIHJlc29sdmUoTF9iaW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZ2V0VmFsdWUpKFwidG9rZW5QYXRcIil9KShsYXp5KGZ1bmN0aW9uKExfdG9rUGF0KXtyZXR1cm4gcmVzb2x2ZShMX2JpbmQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9nZXRWYWx1ZSkoXCJ0b2tlbkdyb3Vwc1wiKX0pKGxhenkoZnVuY3Rpb24oTF9ncm91cHMpe3JldHVybiByZXNvbHZlKExfcGFyc2VMaW5lRykoTF9zdHIpKExfdG9rUGF0KShMX25pbCkoTF9ncm91cHMpKExfaWQpKExfaWQpfSkpfSkpfSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJtYWNyb1N1Yk1cIikoMSkoXCJtYWNyb1N1Yk0gZXhwciA9XFxuICBiaW5kIChnZXRWYWx1ZSAnbWFjcm9EZWZzJylcXG4gICAgXFxcXG1hY3MgLiBtYWNyb1N1YiBtYWNzIGV4cHJcIikobGF6eShmdW5jdGlvbihMX2V4cHIpe3JldHVybiByZXNvbHZlKExfYmluZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2dldFZhbHVlKShcIm1hY3JvRGVmc1wiKX0pKGxhenkoZnVuY3Rpb24oTF9tYWNzKXtyZXR1cm4gcmVzb2x2ZShMX21hY3JvU3ViKShMX21hY3MpKExfZXhwcil9KSl9KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcIm1hY3JvUGFyc2VcIikoMSkoXCJtYWNyb1BhcnNlIHN0ciA9XFxuICBiaW5kIChwYXJzZU0gc3RyKVxcbiAgICBcXFxcZXggLiBtYWNyb1N1Yk0gZXhcIikobGF6eShmdW5jdGlvbihMX3N0cil7cmV0dXJuIHJlc29sdmUoTF9iaW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcGFyc2VNKShMX3N0cil9KShsYXp5KGZ1bmN0aW9uKExfZXgpe3JldHVybiByZXNvbHZlKExfbWFjcm9TdWJNKShMX2V4KX0pKX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwidG9rZW5zTVwiKSgxKShcInRva2Vuc00gc3RyID1cXG4gIGJpbmQgKGdldFZhbHVlICd0b2tlblBhdCcpXFxuICAgIFxcXFxkZWxpbWl0ZXJQYXQgLiB0b2tlbnMgc3RyIGRlbGltaXRlclBhdFwiKShsYXp5KGZ1bmN0aW9uKExfc3RyKXtyZXR1cm4gcmVzb2x2ZShMX2JpbmQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9nZXRWYWx1ZSkoXCJ0b2tlblBhdFwiKX0pKGxhenkoZnVuY3Rpb24oTF9kZWxpbWl0ZXJQYXQpe3JldHVybiByZXNvbHZlKExfdG9rZW5zKShMX3N0cikoTF9kZWxpbWl0ZXJQYXQpfSkpfSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJwYXJzZUxpbmVzXCIpKDIpKFwicGFyc2VMaW5lcyBsaW5lcyByZXN1bHQgPSBsaW5lc1xcbiAgXFxcXGggdCBEIC4gYmluZCAocGFyc2VMaW5lTSBoKVxcbiAgICBcXFxcYXN0IC4gcGFyc2VMaW5lcyB0IChjb25zIGFzdCByZXN1bHQpXFxuICByZXZlcnNlIHJlc3VsdFwiKShsYXp5KGZ1bmN0aW9uKExfbGluZXMpe3JldHVybiBmdW5jdGlvbihMX3Jlc3VsdCl7cmV0dXJuIHJlc29sdmUoTF9saW5lcykobGF6eShmdW5jdGlvbihMX2gpe3JldHVybiBmdW5jdGlvbihMX3Qpe3JldHVybiBmdW5jdGlvbihMX0Qpe3JldHVybiByZXNvbHZlKExfYmluZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3BhcnNlTGluZU0pKExfaCl9KShsYXp5KGZ1bmN0aW9uKExfYXN0KXtyZXR1cm4gcmVzb2x2ZShMX3BhcnNlTGluZXMpKExfdCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKExfYXN0KShMX3Jlc3VsdCl9KX0pKX19fSkpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9yZXZlcnNlKShMX3Jlc3VsdCl9KX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcInBhcnNlRmlsZVwiKSgxKShcInBhcnNlRmlsZSB0ZXh0ID0gcGFyc2VMaW5lcyAobGluZXNGb3JGaWxlIHRleHQpIG5pbFwiKShsYXp5KGZ1bmN0aW9uKExfdGV4dCl7cmV0dXJuIHJlc29sdmUoTF9wYXJzZUxpbmVzKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfbGluZXNGb3JGaWxlKShMX3RleHQpfSkoTF9uaWwpfSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJzaW1wbGVTY2FuTGluZVwiKSgxKShcInNpbXBsZVNjYW5MaW5lIGxpbmUgPSBiaW5kIChnZXRWYWx1ZSAndG9rZW5QYXQnKVxcbiAgXFxcXHRva2VuUGF0IC4gYmluZCAoZ2V0VmFsdWUgJ3Rva2VuR3JvdXBzJylcXG4gICAgXFxcXGdyb3VwcyAuIHNjYW5MaW5lRyBsaW5lIHRva2VuUGF0IGdyb3VwcyBpZCBpZFwiKShsYXp5KGZ1bmN0aW9uKExfbGluZSl7cmV0dXJuIHJlc29sdmUoTF9iaW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZ2V0VmFsdWUpKFwidG9rZW5QYXRcIil9KShsYXp5KGZ1bmN0aW9uKExfdG9rZW5QYXQpe3JldHVybiByZXNvbHZlKExfYmluZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2dldFZhbHVlKShcInRva2VuR3JvdXBzXCIpfSkobGF6eShmdW5jdGlvbihMX2dyb3Vwcyl7cmV0dXJuIHJlc29sdmUoTF9zY2FuTGluZUcpKExfbGluZSkoTF90b2tlblBhdCkoTF9ncm91cHMpKExfaWQpKExfaWQpfSkpfSkpfSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJzY2FuTGluZU1cIikoMSkoXCJzY2FuTGluZU0gbGluZSA9IGJpbmQgKGdldFZhbHVlICd0b2tlblBhdCcpXFxuICBcXFxcdG9rZW5QYXQgLiBiaW5kIChnZXRWYWx1ZSAndG9rZW5Hcm91cHMnKVxcbiAgICBcXFxcZ3JvdXBzIC4gYmluZCAoZ2V0VmFsdWUgJ3BhcnNlRmlsdGVycycpXFxuICAgICAgXFxcXGZpbHRlcnMgLiBiaW5kIChnZXRWYWx1ZSAnbWFjcm9EZWZzJylcXG4gICAgICAgIFxcXFxtYWNyb3MgLiBiaW5kIChydW5QYXJzZUZpbHRlcnMgZmlsdGVycyAoc2NhbkxpbmVHIGxpbmUgdG9rZW5QYXQgZ3JvdXBzIGlkIGlkKSlcXG4gICAgICAgICAgXFxcXHNjYW5uZWQgLiBtYWNyb1N1YiBtYWNyb3Mgc2Nhbm5lZFwiKShsYXp5KGZ1bmN0aW9uKExfbGluZSl7cmV0dXJuIHJlc29sdmUoTF9iaW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZ2V0VmFsdWUpKFwidG9rZW5QYXRcIil9KShsYXp5KGZ1bmN0aW9uKExfdG9rZW5QYXQpe3JldHVybiByZXNvbHZlKExfYmluZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2dldFZhbHVlKShcInRva2VuR3JvdXBzXCIpfSkobGF6eShmdW5jdGlvbihMX2dyb3Vwcyl7cmV0dXJuIHJlc29sdmUoTF9iaW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZ2V0VmFsdWUpKFwicGFyc2VGaWx0ZXJzXCIpfSkobGF6eShmdW5jdGlvbihMX2ZpbHRlcnMpe3JldHVybiByZXNvbHZlKExfYmluZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2dldFZhbHVlKShcIm1hY3JvRGVmc1wiKX0pKGxhenkoZnVuY3Rpb24oTF9tYWNyb3Mpe3JldHVybiByZXNvbHZlKExfYmluZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3J1blBhcnNlRmlsdGVycykoTF9maWx0ZXJzKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc2NhbkxpbmVHKShMX2xpbmUpKExfdG9rZW5QYXQpKExfZ3JvdXBzKShMX2lkKShMX2lkKX0pfSkobGF6eShmdW5jdGlvbihMX3NjYW5uZWQpe3JldHVybiByZXNvbHZlKExfbWFjcm9TdWIpKExfbWFjcm9zKShMX3NjYW5uZWQpfSkpfSkpfSkpfSkpfSkpfSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJuZXdQYXJzZUxpbmVcIikoMikoXCJuZXdQYXJzZUxpbmUgbmFtZXMgbGluZSA9IGJpbmQgKHNjYW5MaW5lTSBsaW5lKVxcbiAgXFxcXHNjYW5uZWQgLiBpZk5vdEVyciAoY3JlYXRlQXN0IHNjYW5uZWQgbmFtZXMpIFxcXFxhc3QgLiBhc3RcIikobGF6eShmdW5jdGlvbihMX25hbWVzKXtyZXR1cm4gZnVuY3Rpb24oTF9saW5lKXtyZXR1cm4gcmVzb2x2ZShMX2JpbmQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zY2FuTGluZU0pKExfbGluZSl9KShsYXp5KGZ1bmN0aW9uKExfc2Nhbm5lZCl7cmV0dXJuIHJlc29sdmUoTF9pZk5vdEVycikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NyZWF0ZUFzdCkoTF9zY2FubmVkKShMX25hbWVzKX0pKGxhenkoZnVuY3Rpb24oTF9hc3Qpe3JldHVybiByZXNvbHZlKExfYXN0KX0pKX0pKX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcInJ1bkxpbmVcIikoMikoXCJydW5MaW5lIG5hbWVzIGxpbmUgPSBiaW5kIChuZXdQYXJzZUxpbmUgbmFtZXMgbGluZSlcXG4gIFxcXFxhc3QgLiBiaW5kIChydW5Bc3QgYXN0KVxcbiAgICBcXFxccmVzdWx0IC4gY29uc1xcbiAgICAgIGFzdFxcbiAgICAgIGlzUGFyc2VFcnIgcmVzdWx0XFxuICAgICAgICBsZWZ0IChwYXJzZUVyck1zZyByZXN1bHQpXFxuICAgICAgICByaWdodCByZXN1bHRcIikobGF6eShmdW5jdGlvbihMX25hbWVzKXtyZXR1cm4gZnVuY3Rpb24oTF9saW5lKXtyZXR1cm4gcmVzb2x2ZShMX2JpbmQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9uZXdQYXJzZUxpbmUpKExfbmFtZXMpKExfbGluZSl9KShsYXp5KGZ1bmN0aW9uKExfYXN0KXtyZXR1cm4gcmVzb2x2ZShMX2JpbmQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9ydW5Bc3QpKExfYXN0KX0pKGxhenkoZnVuY3Rpb24oTF9yZXN1bHQpe3JldHVybiByZXNvbHZlKExfY29ucykoTF9hc3QpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pc1BhcnNlRXJyKShMX3Jlc3VsdCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2xlZnQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9wYXJzZUVyck1zZykoTF9yZXN1bHQpfSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcmlnaHQpKExfcmVzdWx0KX0pfSl9KSl9KSl9fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJydW5MaW5lc1wiKSgyKShcInJ1bkxpbmVzIG5hbWVzIGxpbmVzID0gbGluZXNcXG4gIFxcXFxoIHQgRCAuIGJpbmQgKHJ1bkxpbmUgbmFtZXMgaClcXG4gICAgXFxcXGxpbmUgLiBiaW5kIChydW5MaW5lcyBuYW1lcyB0KVxcbiAgICAgIFxcXFxyZXN0IC4gY29ucyBsaW5lIHJlc3RcXG4gIG5pbFwiKShsYXp5KGZ1bmN0aW9uKExfbmFtZXMpe3JldHVybiBmdW5jdGlvbihMX2xpbmVzKXtyZXR1cm4gcmVzb2x2ZShMX2xpbmVzKShsYXp5KGZ1bmN0aW9uKExfaCl7cmV0dXJuIGZ1bmN0aW9uKExfdCl7cmV0dXJuIGZ1bmN0aW9uKExfRCl7cmV0dXJuIHJlc29sdmUoTF9iaW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcnVuTGluZSkoTF9uYW1lcykoTF9oKX0pKGxhenkoZnVuY3Rpb24oTF9saW5lKXtyZXR1cm4gcmVzb2x2ZShMX2JpbmQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9ydW5MaW5lcykoTF9uYW1lcykoTF90KX0pKGxhenkoZnVuY3Rpb24oTF9yZXN0KXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKExfbGluZSkoTF9yZXN0KX0pKX0pKX19fSkpKExfbmlsKX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcInJ1bkZpbGVcIikoMSkoXCJydW5GaWxlIHRleHQgPSBcXFxcXFxcXFxcbiAgbGluZXMgPSBsaW5lc0ZvckZpbGUgdGV4dFxcbiAgbmFtZXMgPSBuYW1lc0ZvckxpbmVzIGxpbmVzXFxuICAuXFxuICBydW5MaW5lcyBuYW1lcyBsaW5lc1wiKShsYXp5KGZ1bmN0aW9uKExfdGV4dCl7cmV0dXJuIChmdW5jdGlvbigpe1xuXG52YXIgTF9uYW1lcywgTF9saW5lcztcblxuTF9uYW1lcyA9IGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9uYW1lc0ZvckxpbmVzKShMX2xpbmVzKX07XG5cbkxfbGluZXMgPSBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfbGluZXNGb3JGaWxlKShMX3RleHQpfTtcbnJldHVybiByZXNvbHZlKExfcnVuTGluZXMpKExfbmFtZXMpKExfbGluZXMpfSkoKX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwiYmFzZUxvYWRcIikoMSkoXCJiYXNlTG9hZCBmaWxlID0gYmluZCAocmVhZEZpbGUgZmlsZSlcXG4gIFxcXFxyZXN1bHQgLiByZXN1bHRcXG4gICAgXFxcXGVyciAuIGVyclxcbiAgICBcXFxcY29udGVudHMgLiBiaW5kIChnZXRWYWx1ZSAnYWN0aXZlVG9rZW5QYWNrcycpXFxuICAgICAgXFxcXGFjdGl2ZVBhY2tzIC4gYmluZCByZXNldFN0ZFRva2VuUGFja3NcXG4gICAgICAgIFxcXFxfIC4gYmluZCAocnVuRmlsZSBjb250ZW50cylcXG4gICAgICAgICAgXFxcXHJlc3VsdCAuIGlzTmlsIGFjdGl2ZVBhY2tzXFxuICAgICAgICAgICAgYmluZCByZXNldFN0ZFRva2VuUGFja3NcXG4gICAgICAgICAgICAgIFxcXFxfIC4gcmVzdWx0XFxuICAgICAgICAgICAgYmluZCAocmVzZXRUb2tlblBhY2tzIGFjdGl2ZVBhY2tzKVxcbiAgICAgICAgICAgICAgICBcXFxcXyAuIHJlc3VsdFwiKShsYXp5KGZ1bmN0aW9uKExfZmlsZSl7cmV0dXJuIHJlc29sdmUoTF9iaW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcmVhZEZpbGUpKExfZmlsZSl9KShsYXp5KGZ1bmN0aW9uKExfcmVzdWx0KXtyZXR1cm4gcmVzb2x2ZShMX3Jlc3VsdCkobGF6eShmdW5jdGlvbihMX2Vycil7cmV0dXJuIHJlc29sdmUoTF9lcnIpfSkpKGxhenkoZnVuY3Rpb24oTF9jb250ZW50cyl7cmV0dXJuIHJlc29sdmUoTF9iaW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZ2V0VmFsdWUpKFwiYWN0aXZlVG9rZW5QYWNrc1wiKX0pKGxhenkoZnVuY3Rpb24oTF9hY3RpdmVQYWNrcyl7cmV0dXJuIHJlc29sdmUoTF9iaW5kKShMX3Jlc2V0U3RkVG9rZW5QYWNrcykobGF6eShmdW5jdGlvbihMX18pe3JldHVybiByZXNvbHZlKExfYmluZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3J1bkZpbGUpKExfY29udGVudHMpfSkobGF6eShmdW5jdGlvbihMX3Jlc3VsdF8wKXtyZXR1cm4gcmVzb2x2ZShMX2lzTmlsKShMX2FjdGl2ZVBhY2tzKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYmluZCkoTF9yZXNldFN0ZFRva2VuUGFja3MpKGxhenkoZnVuY3Rpb24oTF9fXzEpe3JldHVybiByZXNvbHZlKExfcmVzdWx0XzApfSkpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2JpbmQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9yZXNldFRva2VuUGFja3MpKExfYWN0aXZlUGFja3MpfSkobGF6eShmdW5jdGlvbihMX19fMSl7cmV0dXJuIHJlc29sdmUoTF9yZXN1bHRfMCl9KSl9KX0pKX0pKX0pKX0pKX0pKX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwibG9hZFwiKSgxKShcImxvYWQgZmlsZSA9IGJpbmQgKGJhc2VMb2FkIGZpbGUpXFxuICBcXFxccmVzdWx0IC4gXFxcXFxcXFxcXG4gICAgZXJycyA9IGZvbGRyIChcXFxcbGluZSByZXN1bHRzIC4gdGFpbCBsaW5lIChcXFxcZXIgLiBjb25zIGVyIHJlc3VsdHMpIChcXFxceCAuIHJlc3VsdHMpKSBuaWwgcmVzdWx0XFxuICAgIC5cXG4gICAgaXNOaWwgZXJyc1xcbiAgICAgIHJpZ2h0IHRydWVcXG4gICAgICBsZWZ0IGVycnNcIikobGF6eShmdW5jdGlvbihMX2ZpbGUpe3JldHVybiByZXNvbHZlKExfYmluZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2Jhc2VMb2FkKShMX2ZpbGUpfSkobGF6eShmdW5jdGlvbihMX3Jlc3VsdCl7cmV0dXJuIChmdW5jdGlvbigpe1xuXG52YXIgTF9lcnJzO1xuXG5MX2VycnMgPSBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZm9sZHIpKGxhenkoZnVuY3Rpb24oTF9saW5lKXtyZXR1cm4gZnVuY3Rpb24oTF9yZXN1bHRzKXtyZXR1cm4gcmVzb2x2ZShMX3RhaWwpKExfbGluZSkobGF6eShmdW5jdGlvbihMX2VyKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKExfZXIpKExfcmVzdWx0cyl9KSkobGF6eShmdW5jdGlvbihMX3gpe3JldHVybiByZXNvbHZlKExfcmVzdWx0cyl9KSl9fSkpKExfbmlsKShMX3Jlc3VsdCl9O1xucmV0dXJuIHJlc29sdmUoTF9pc05pbCkoTF9lcnJzKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcmlnaHQpKExfdHJ1ZSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfbGVmdCkoTF9lcnJzKX0pfSkoKX0pKX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwicmVxdWlyZVwiKSgxKShcInJlcXVpcmUgZmlsZSA9IGJpbmQgKGdldFZhbHVlICdyZXF1aXJlZEZpbGVzJylcXG4gIFxcXFxmaWxlcyAuIGNvbnRhaW5zIGZpbGVzIGZpbGVcXG4gICAgZmFsc2VcXG4gICAgYmluZCAobG9hZCBmaWxlKVxcbiAgICAgIFxcXFxyZXN1bHQgLiByZXN1bHRcXG4gICAgICAgIFxcXFx4IC4gbGVmdCB4XFxuICAgICAgICBcXFxcXyAuIGJpbmQgKHNldFZhbHVlICdyZXF1aXJlZEZpbGVzJyAoY29ucyBmaWxlIGZpbGVzKSlcXG4gICAgICAgICAgXFxcXF8gLiByaWdodCB0cnVlXCIpKGxhenkoZnVuY3Rpb24oTF9maWxlKXtyZXR1cm4gcmVzb2x2ZShMX2JpbmQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9nZXRWYWx1ZSkoXCJyZXF1aXJlZEZpbGVzXCIpfSkobGF6eShmdW5jdGlvbihMX2ZpbGVzKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnRhaW5zKShMX2ZpbGVzKShMX2ZpbGUpKExfZmFsc2UpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9iaW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfbG9hZCkoTF9maWxlKX0pKGxhenkoZnVuY3Rpb24oTF9yZXN1bHQpe3JldHVybiByZXNvbHZlKExfcmVzdWx0KShsYXp5KGZ1bmN0aW9uKExfeCl7cmV0dXJuIHJlc29sdmUoTF9sZWZ0KShMX3gpfSkpKGxhenkoZnVuY3Rpb24oTF9fKXtyZXR1cm4gcmVzb2x2ZShMX2JpbmQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zZXRWYWx1ZSkoXCJyZXF1aXJlZEZpbGVzXCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShMX2ZpbGUpKExfZmlsZXMpfSl9KShsYXp5KGZ1bmN0aW9uKExfX18wKXtyZXR1cm4gcmVzb2x2ZShMX3JpZ2h0KShMX3RydWUpfSkpfSkpfSkpfSl9KSl9KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImRlZlRva2VuUGFja1wiKSgyKShcImRlZlRva2VuUGFjayBuYW1lIHBhY2sgPSBiaW5kIChnZXRWYWx1ZSAndG9rZW5QYWNrcycpXFxuICBcXFxccGFja3MgLiBzZXRWYWx1ZSAndG9rZW5QYWNrcycgKGFjb25zIG5hbWUgcGFjayBwYWNrcylcIikobGF6eShmdW5jdGlvbihMX25hbWUpe3JldHVybiBmdW5jdGlvbihMX3BhY2spe3JldHVybiByZXNvbHZlKExfYmluZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2dldFZhbHVlKShcInRva2VuUGFja3NcIil9KShsYXp5KGZ1bmN0aW9uKExfcGFja3Mpe3JldHVybiByZXNvbHZlKExfc2V0VmFsdWUpKFwidG9rZW5QYWNrc1wiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYWNvbnMpKExfbmFtZSkoTF9wYWNrKShMX3BhY2tzKX0pfSkpfX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwidXNlVG9rZW5QYWNrXCIpKDEpKFwidXNlVG9rZW5QYWNrIG5hbWUgPSBiaW5kIChnZXRWYWx1ZSAndG9rZW5QYWNrcycpXFxuICBcXFxccGFja3MgLiBiaW5kIChnZXRWYWx1ZSAndG9rZW5Hcm91cHMnKVxcbiAgICBcXFxcZ3JvdXBzIC4gYmluZCAoZ2V0VmFsdWUgJ3Rva2VuTGlzdCcpXFxuICAgICAgXFxcXHRva2VucyAuIGJpbmQgKGdldFZhbHVlICdhY3RpdmVUb2tlblBhY2tzJylcXG4gICAgICAgIFxcXFxhY3RpdmVQYWNrcyAuIGJpbmQgKGdldFZhbHVlICdwYXJzZUZpbHRlcnMnKVxcbiAgICAgICAgICBcXFxcZmlsdGVycyAuIGFzc29jIG5hbWUgcGFja3NcXG4gICAgICAgICAgICBcXFxccGFjayAuIFxcXFxcXFxcXFxuICAgICAgICAgICAgICBncm91cFRva3MgPSBmb2xkbCAoXFxcXHZhbHVlIGVsIC4gZWwgXFxcXGggdCAuIGNvbnMgaCAoY29ucyB0IHZhbHVlKSkgbmlsIChoZWFkICh0YWlsIHBhY2spKVxcbiAgICAgICAgICAgICAgbmV3VG9rcyA9IHF1aWNrc29ydCAoXFxcXGEgYiAuID4gKHN0ckxlbiBhKSAoc3RyTGVuIGIpKSAoYXBwZW5kIChoZWFkIHBhY2spIChhcHBlbmQgZ3JvdXBUb2tzIHRva2VucykpXFxuICAgICAgICAgICAgICAuXFxuICAgICAgICAgICAgICBiaW5kIChzZXRWYWx1ZSAndG9rZW5MaXN0JyBuZXdUb2tzKVxcbiAgICAgICAgICAgICAgICBcXFxcXyAuIGJpbmQgKHNldFZhbHVlICd0b2tlbkdyb3VwcycgKGFwcGVuZEFsaXN0IChoZWFkICh0YWlsIHBhY2spKSBncm91cHMpKVxcbiAgICAgICAgICAgICAgICAgIFxcXFxfIC4gYmluZCAoc2V0VmFsdWUgJ3BhcnNlRmlsdGVycycgKGFwcGVuZCBmaWx0ZXJzIChoZWFkICh0YWlsICh0YWlsIHBhY2spKSkpKVxcbiAgICAgICAgICAgICAgICAgICAgXFxcXF8gLiBiaW5kIChjb21wdXRlVG9rZW5QYXQgbmV3VG9rcylcXG4gICAgICAgICAgICAgICAgICAgICAgXFxcXF8gLiBzZXRWYWx1ZSAnYWN0aXZlVG9rZW5QYWNrcycgKGNvbnMgbmFtZSBhY3RpdmVQYWNrcylcXG4gICAgICAgICAgICBuaWxcIikobGF6eShmdW5jdGlvbihMX25hbWUpe3JldHVybiByZXNvbHZlKExfYmluZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2dldFZhbHVlKShcInRva2VuUGFja3NcIil9KShsYXp5KGZ1bmN0aW9uKExfcGFja3Mpe3JldHVybiByZXNvbHZlKExfYmluZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2dldFZhbHVlKShcInRva2VuR3JvdXBzXCIpfSkobGF6eShmdW5jdGlvbihMX2dyb3Vwcyl7cmV0dXJuIHJlc29sdmUoTF9iaW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZ2V0VmFsdWUpKFwidG9rZW5MaXN0XCIpfSkobGF6eShmdW5jdGlvbihMX3Rva2Vucyl7cmV0dXJuIHJlc29sdmUoTF9iaW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZ2V0VmFsdWUpKFwiYWN0aXZlVG9rZW5QYWNrc1wiKX0pKGxhenkoZnVuY3Rpb24oTF9hY3RpdmVQYWNrcyl7cmV0dXJuIHJlc29sdmUoTF9iaW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZ2V0VmFsdWUpKFwicGFyc2VGaWx0ZXJzXCIpfSkobGF6eShmdW5jdGlvbihMX2ZpbHRlcnMpe3JldHVybiByZXNvbHZlKExfYXNzb2MpKExfbmFtZSkoTF9wYWNrcykobGF6eShmdW5jdGlvbihMX3BhY2spe3JldHVybiAoZnVuY3Rpb24oKXtcblxudmFyIExfbmV3VG9rcywgTF9ncm91cFRva3M7XG5cbkxfbmV3VG9rcyA9IGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9xdWlja3NvcnQpKGxhenkoZnVuY3Rpb24oTF9hKXtyZXR1cm4gZnVuY3Rpb24oTF9iKXtyZXR1cm4gcmVzb2x2ZShMXyR6KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc3RyTGVuKShMX2EpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3N0ckxlbikoTF9iKX0pfX0pKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYXBwZW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaGVhZCkoTF9wYWNrKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hcHBlbmQpKExfZ3JvdXBUb2tzKShMX3Rva2Vucyl9KX0pfTtcblxuTF9ncm91cFRva3MgPSBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZm9sZGwpKGxhenkoZnVuY3Rpb24oTF92YWx1ZSl7cmV0dXJuIGZ1bmN0aW9uKExfZWwpe3JldHVybiByZXNvbHZlKExfZWwpKGxhenkoZnVuY3Rpb24oTF9oKXtyZXR1cm4gZnVuY3Rpb24oTF90KXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKExfaCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKExfdCkoTF92YWx1ZSl9KX19KSl9fSkpKExfbmlsKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaGVhZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3RhaWwpKExfcGFjayl9KX0pfTtcbnJldHVybiByZXNvbHZlKExfYmluZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3NldFZhbHVlKShcInRva2VuTGlzdFwiKShMX25ld1Rva3MpfSkobGF6eShmdW5jdGlvbihMX18pe3JldHVybiByZXNvbHZlKExfYmluZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3NldFZhbHVlKShcInRva2VuR3JvdXBzXCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hcHBlbmRBbGlzdCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2hlYWQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90YWlsKShMX3BhY2spfSl9KShMX2dyb3Vwcyl9KX0pKGxhenkoZnVuY3Rpb24oTF9fXzApe3JldHVybiByZXNvbHZlKExfYmluZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3NldFZhbHVlKShcInBhcnNlRmlsdGVyc1wiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYXBwZW5kKShMX2ZpbHRlcnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9oZWFkKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdGFpbCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3RhaWwpKExfcGFjayl9KX0pfSl9KX0pKGxhenkoZnVuY3Rpb24oTF9fXzEpe3JldHVybiByZXNvbHZlKExfYmluZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbXB1dGVUb2tlblBhdCkoTF9uZXdUb2tzKX0pKGxhenkoZnVuY3Rpb24oTF9fXzIpe3JldHVybiByZXNvbHZlKExfc2V0VmFsdWUpKFwiYWN0aXZlVG9rZW5QYWNrc1wiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF9uYW1lKShMX2FjdGl2ZVBhY2tzKX0pfSkpfSkpfSkpfSkpfSkoKX0pKShMX25pbCl9KSl9KSl9KSl9KSl9KSl9KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcInJlc2V0VG9rZW5QYWNrc1wiKSgxKShcInJlc2V0VG9rZW5QYWNrcyBwYWNrcyA9IGJpbmQgKHNldFZhbHVlICd0b2tlbkdyb3VwcycgbmlsKVxcbiAgXFxcXF8gLiBiaW5kIChzZXRWYWx1ZSAndG9rZW5MaXN0JyBuaWwpXFxuICAgIFxcXFxfIC4gYmluZCAoc2V0VmFsdWUgJ2FjdGl2ZVRva2VuUGFja3MnIG5pbClcXG4gICAgICBcXFxcXyAuIGJpbmQgKHNldFZhbHVlICdwYXJzZUZpbHRlcnMnIG5pbClcXG4gICAgICAgIFxcXFxfIC4gZm9sZHIxXFxuICAgICAgICAgIFxcXFxwYWNrQ21kIHJlc3VsdCAuIGJpbmQgcGFja0NtZCBcXFxcXyAuIHJlc3VsdFxcbiAgICAgICAgICBtYXAgdXNlVG9rZW5QYWNrIHBhY2tzXCIpKGxhenkoZnVuY3Rpb24oTF9wYWNrcyl7cmV0dXJuIHJlc29sdmUoTF9iaW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc2V0VmFsdWUpKFwidG9rZW5Hcm91cHNcIikoTF9uaWwpfSkobGF6eShmdW5jdGlvbihMX18pe3JldHVybiByZXNvbHZlKExfYmluZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3NldFZhbHVlKShcInRva2VuTGlzdFwiKShMX25pbCl9KShsYXp5KGZ1bmN0aW9uKExfX18wKXtyZXR1cm4gcmVzb2x2ZShMX2JpbmQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zZXRWYWx1ZSkoXCJhY3RpdmVUb2tlblBhY2tzXCIpKExfbmlsKX0pKGxhenkoZnVuY3Rpb24oTF9fXzEpe3JldHVybiByZXNvbHZlKExfYmluZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3NldFZhbHVlKShcInBhcnNlRmlsdGVyc1wiKShMX25pbCl9KShsYXp5KGZ1bmN0aW9uKExfX18yKXtyZXR1cm4gcmVzb2x2ZShMX2ZvbGRyMSkobGF6eShmdW5jdGlvbihMX3BhY2tDbWQpe3JldHVybiBmdW5jdGlvbihMX3Jlc3VsdCl7cmV0dXJuIHJlc29sdmUoTF9iaW5kKShMX3BhY2tDbWQpKGxhenkoZnVuY3Rpb24oTF9fXzMpe3JldHVybiByZXNvbHZlKExfcmVzdWx0KX0pKX19KSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX21hcCkoTF91c2VUb2tlblBhY2spKExfcGFja3MpfSl9KSl9KSl9KSl9KSl9KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcInJlc2V0U3RkVG9rZW5QYWNrc1wiKSgwKShcInJlc2V0U3RkVG9rZW5QYWNrcyA9IGJpbmQgKGdldFZhbHVlICdzdGRUb2tlblBhY2tzJylcXG4gIFxcXFxzdGRzIC4gYmluZCAocmVzZXRUb2tlblBhY2tzIHN0ZHMpXFxuICAgIFxcXFxfIC4gc2V0VmFsdWUgJ2FjdGl2ZVRva2VuUGFja3MnIG5pbFwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYmluZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2dldFZhbHVlKShcInN0ZFRva2VuUGFja3NcIil9KShsYXp5KGZ1bmN0aW9uKExfc3Rkcyl7cmV0dXJuIHJlc29sdmUoTF9iaW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcmVzZXRUb2tlblBhY2tzKShMX3N0ZHMpfSkobGF6eShmdW5jdGlvbihMX18pe3JldHVybiByZXNvbHZlKExfc2V0VmFsdWUpKFwiYWN0aXZlVG9rZW5QYWNrc1wiKShMX25pbCl9KSl9KSl9KX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwiYWRkU3RkVG9rZW5QYWNrc1wiKSgxKShcImFkZFN0ZFRva2VuUGFja3MgbW9yZVBhY2tzID0gYmluZCAoZ2V0VmFsdWUgJ3N0ZFRva2VuUGFja3MnKVxcbiAgXFxcXHN0ZHMgLiBzZXRWYWx1ZSAnc3RkVG9rZW5QYWNrcycgKGFwcGVuZCBzdGRzIG1vcmVQYWNrcylcIikobGF6eShmdW5jdGlvbihMX21vcmVQYWNrcyl7cmV0dXJuIHJlc29sdmUoTF9iaW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZ2V0VmFsdWUpKFwic3RkVG9rZW5QYWNrc1wiKX0pKGxhenkoZnVuY3Rpb24oTF9zdGRzKXtyZXR1cm4gcmVzb2x2ZShMX3NldFZhbHVlKShcInN0ZFRva2VuUGFja3NcIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2FwcGVuZCkoTF9zdGRzKShMX21vcmVQYWNrcyl9KX0pKX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwiYWRkUGFyc2VGaWx0ZXJcIikoMSkoXCJhZGRQYXJzZUZpbHRlciBmaWx0ID0gYmluZCAoZ2V0VmFsdWUgJ3BhcnNlRmlsdGVycycpXFxuICBcXFxcZmlsdGVycyAuIHNldFZhbHVlICdwYXJzZUZpbHRlcnMnIChhcHBlbmQgZmlsdGVycyAoY29ucyBmaWx0IG5pbCkpXCIpKGxhenkoZnVuY3Rpb24oTF9maWx0KXtyZXR1cm4gcmVzb2x2ZShMX2JpbmQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9nZXRWYWx1ZSkoXCJwYXJzZUZpbHRlcnNcIil9KShsYXp5KGZ1bmN0aW9uKExfZmlsdGVycyl7cmV0dXJuIHJlc29sdmUoTF9zZXRWYWx1ZSkoXCJwYXJzZUZpbHRlcnNcIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2FwcGVuZCkoTF9maWx0ZXJzKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF9maWx0KShMX25pbCl9KX0pfSkpfSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJkXCIpKDMpKFwiZCBsYWJlbCB2YWx1ZSBleHByID0gbG9nIChzdHJDYXQgKGNvbnMgbGFiZWwgKGNvbnMgdmFsdWUgbmlsKSkpIGV4cHJcIikobGF6eShmdW5jdGlvbihMX2xhYmVsKXtyZXR1cm4gZnVuY3Rpb24oTF92YWx1ZSl7cmV0dXJuIGZ1bmN0aW9uKExfZXhwcil7cmV0dXJuIHJlc29sdmUoTF9sb2cpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zdHJDYXQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShMX2xhYmVsKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF92YWx1ZSkoTF9uaWwpfSl9KX0pKExfZXhwcil9fX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwiZGRcIikoMikoXCJkZCBsYWJlbCBhcmcgPSBkIGxhYmVsIGFyZyBhcmdcIikobGF6eShmdW5jdGlvbihMX2xhYmVsKXtyZXR1cm4gZnVuY3Rpb24oTF9hcmcpe3JldHVybiByZXNvbHZlKExfZCkoTF9sYWJlbCkoTF9hcmcpKExfYXJnKX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc2V0VmFsdWUpKFwibWFjcm9EZWZzXCIpKExfbmlsKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zZXRWYWx1ZSkoXCJyZXF1aXJlZEZpbGVzXCIpKExfbmlsKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zZXRWYWx1ZSkoXCJ0b2tlblBhY2tzXCIpKExfbmlsKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zZXRWYWx1ZSkoXCJhY3RpdmVUb2tlblBhY2tzXCIpKExfbmlsKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zZXRWYWx1ZSkoXCJzdGRUb2tlblBhY2tzXCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShcInN0ZFwiKShMX25pbCl9KX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZUb2tlblBhY2spKFwic3RkXCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoXCIuXCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShcIlxcXFxcIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKFwiXFxcXFxcXFxcIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKFwiXFxcXEBcIikoTF9uaWwpfSl9KX0pfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hY29ucykoXCIoXCIpKFwiKVwiKShMX25pbCl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF9uaWwpKExfbmlsKX0pfSl9KX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9yZXNldFN0ZFRva2VuUGFja3MpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2FkZFRva2VuR3JvdXApKFwiW1wiKShcIl1cIil9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYWRkVG9rZW4pKFwifFwiKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwibGlzdGlmeU9wXCIpKDIpKFwibGlzdGlmeU9wIG9wIGxpc3QgPSBsaXN0XFxuICBcXFxcaCB0IEQgLiBpc1Rva2VuU3RyaW5nIGggJ3wnXFxuICAgIGNvbnMgdCBuaWxcXG4gICAgY29ucyAoY29ucyBvcCAoY29ucyBoIChsaXN0aWZ5T3Agb3AgdCkpKSBuaWxcXG4gIGNvbnMgJ25pbCcgbmlsXCIpKGxhenkoZnVuY3Rpb24oTF9vcCl7cmV0dXJuIGZ1bmN0aW9uKExfbGlzdCl7cmV0dXJuIHJlc29sdmUoTF9saXN0KShsYXp5KGZ1bmN0aW9uKExfaCl7cmV0dXJuIGZ1bmN0aW9uKExfdCl7cmV0dXJuIGZ1bmN0aW9uKExfRCl7cmV0dXJuIHJlc29sdmUoTF9pc1Rva2VuU3RyaW5nKShMX2gpKFwifFwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF90KShMX25pbCl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKExfb3ApKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShMX2gpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9saXN0aWZ5T3ApKExfb3ApKExfdCl9KX0pfSkoTF9uaWwpfSl9fX0pKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoXCJuaWxcIikoTF9uaWwpfSl9fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJsaXN0aWZ5XCIpKDEpKFwibGlzdGlmeSBsaXN0ID0gbGlzdGlmeU9wICdjb25zJyBsaXN0XCIpKGxhenkoZnVuY3Rpb24oTF9saXN0KXtyZXR1cm4gcmVzb2x2ZShMX2xpc3RpZnlPcCkoXCJjb25zXCIpKExfbGlzdCl9KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmTWFjcm8pKFwiW1wiKShsYXp5KGZ1bmN0aW9uKExfbGlzdCl7cmV0dXJuIHJlc29sdmUoTF9saXN0KShsYXp5KGZ1bmN0aW9uKExfaCl7cmV0dXJuIGZ1bmN0aW9uKExfdCl7cmV0dXJuIHJlc29sdmUoTF9saXN0aWZ5KShMX2gpfX0pKX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwibGlzdEZpbHRlclwiKSgxKShcImxpc3RGaWx0ZXIgY29kZSA9IGJpbmQgKGdldFZhbHVlICdsaXN0TWFjcm9zJylcXG4gIFxcXFxsaXN0TWFjcm9zIC4gZmlsdGVyQXBwbGllcyBjb2RlIFxcXFxsaXN0IC4gbGlzdCBcXFxcaCB0IC5cXG4gICAgYW5kIChpc1Rva2VuIGgpIChjb250YWlucyBsaXN0TWFjcm9zICh0b2tlblN0cmluZyBoKSlcXG4gICAgICBsaXN0RmlsdGVyVGFpbCBsaXN0XFxuICAgICAgbGlzdFwiKShsYXp5KGZ1bmN0aW9uKExfY29kZSl7cmV0dXJuIHJlc29sdmUoTF9iaW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZ2V0VmFsdWUpKFwibGlzdE1hY3Jvc1wiKX0pKGxhenkoZnVuY3Rpb24oTF9saXN0TWFjcm9zKXtyZXR1cm4gcmVzb2x2ZShMX2ZpbHRlckFwcGxpZXMpKExfY29kZSkobGF6eShmdW5jdGlvbihMX2xpc3Qpe3JldHVybiByZXNvbHZlKExfbGlzdCkobGF6eShmdW5jdGlvbihMX2gpe3JldHVybiBmdW5jdGlvbihMX3Qpe3JldHVybiByZXNvbHZlKExfYW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaXNUb2tlbikoTF9oKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb250YWlucykoTF9saXN0TWFjcm9zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdG9rZW5TdHJpbmcpKExfaCl9KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9saXN0RmlsdGVyVGFpbCkoTF9saXN0KX0pKExfbGlzdCl9fSkpfSkpfSkpfSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJsaXN0RmlsdGVyVGFpbFwiKSgxKShcImxpc3RGaWx0ZXJUYWlsIGxpc3QgPSBsaXN0XFxuICBcXFxcaCB0IEQgLiBpc1Rva2VuU3RyaW5nIGggJ3wnXFxuICAgID4gKGxlbmd0aCB0KSAyXFxuICAgICAgY29ucyBoIChjb25zIChyZW1vdmVMYXN0IHQpIChjb25zIChsYXN0IHQpIG5pbCkpXFxuICAgICAgbGlzdFxcbiAgICBjb25zIGggKGxpc3RGaWx0ZXJUYWlsIHQpXFxuICBuaWxcIikobGF6eShmdW5jdGlvbihMX2xpc3Qpe3JldHVybiByZXNvbHZlKExfbGlzdCkobGF6eShmdW5jdGlvbihMX2gpe3JldHVybiBmdW5jdGlvbihMX3Qpe3JldHVybiBmdW5jdGlvbihMX0Qpe3JldHVybiByZXNvbHZlKExfaXNUb2tlblN0cmluZykoTF9oKShcInxcIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMXyR6KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfbGVuZ3RoKShMX3QpfSkoMikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKExfaCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9yZW1vdmVMYXN0KShMX3QpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9sYXN0KShMX3QpfSkoTF9uaWwpfSl9KX0pKExfbGlzdCl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF9oKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfbGlzdEZpbHRlclRhaWwpKExfdCl9KX0pfX19KSkoTF9uaWwpfSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJmaWx0ZXJBcHBsaWVzXCIpKDIpKFwiZmlsdGVyQXBwbGllcyBjb2RlIGZ1bmMgPSBpc1BhcmVucyBjb2RlXFxuICBjb2RlIFxcXFxzdGFydCBlbmQgY29udGVudHMgLiBwYXJlbnMgc3RhcnQgZW5kIChmaWx0ZXJBcHBsaWVzIGNvbnRlbnRzIGZ1bmMpXFxuICBpc0NvbnMgY29kZVxcbiAgICBcXFxcXFxcXFxcbiAgICAgIGZpbHRlcmVkID0gZmlsdGVyQXBwbHlFbGVtZW50cyBjb2RlIGZ1bmNcXG4gICAgICAuXFxuICAgICAgYW5kIChpc0NvbnMgZmlsdGVyZWQpIChpc0Jsb2NrU3RhcnQgKGhlYWQgZmlsdGVyZWQpKVxcbiAgICAgICAgZmlsdGVyZWRcXG4gICAgICAgIGZ1bmMgZmlsdGVyZWRcXG4gICAgY29kZVwiKShsYXp5KGZ1bmN0aW9uKExfY29kZSl7cmV0dXJuIGZ1bmN0aW9uKExfZnVuYyl7cmV0dXJuIHJlc29sdmUoTF9pc1BhcmVucykoTF9jb2RlKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29kZSkobGF6eShmdW5jdGlvbihMX3N0YXJ0KXtyZXR1cm4gZnVuY3Rpb24oTF9lbmQpe3JldHVybiBmdW5jdGlvbihMX2NvbnRlbnRzKXtyZXR1cm4gcmVzb2x2ZShMX3BhcmVucykoTF9zdGFydCkoTF9lbmQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9maWx0ZXJBcHBsaWVzKShMX2NvbnRlbnRzKShMX2Z1bmMpfSl9fX0pKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pc0NvbnMpKExfY29kZSkoZnVuY3Rpb24oKXtcbnZhciBMX2ZpbHRlcmVkO1xuXG5MX2ZpbHRlcmVkID0gZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2ZpbHRlckFwcGx5RWxlbWVudHMpKExfY29kZSkoTF9mdW5jKX07XG5yZXR1cm4gcmVzb2x2ZShMX2FuZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2lzQ29ucykoTF9maWx0ZXJlZCl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaXNCbG9ja1N0YXJ0KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaGVhZCkoTF9maWx0ZXJlZCl9KX0pKExfZmlsdGVyZWQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9mdW5jKShMX2ZpbHRlcmVkKX0pfSkoTF9jb2RlKX0pfX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwiZmlsdGVyQXBwbHlFbGVtZW50c1wiKSgyKShcImZpbHRlckFwcGx5RWxlbWVudHMgY29kZSBmdW5jID0gY29kZVxcbiAgXFxcXGggdCBEIC4gaXNCbG9ja1N0YXJ0IGhcXG4gICAgY29ucyBoIChmaWx0ZXJCbG9jayBoIHQgZnVuYylcXG4gICAgY29ucyAoZmlsdGVyQXBwbGllcyBoIGZ1bmMpXFxuICAgICAgYW5kIChpc0NvbnMgdCkgKGlzQmxvY2tTdGFydCAoaGVhZCB0KSlcXG4gICAgICAgIGNvbnMgKGZpbHRlckFwcGx5RWxlbWVudHMgdCBmdW5jKSBuaWxcXG4gICAgICAgIGZpbHRlckFwcGx5RWxlbWVudHMgdCBmdW5jXFxuICBuaWxcIikobGF6eShmdW5jdGlvbihMX2NvZGUpe3JldHVybiBmdW5jdGlvbihMX2Z1bmMpe3JldHVybiByZXNvbHZlKExfY29kZSkobGF6eShmdW5jdGlvbihMX2gpe3JldHVybiBmdW5jdGlvbihMX3Qpe3JldHVybiBmdW5jdGlvbihMX0Qpe3JldHVybiByZXNvbHZlKExfaXNCbG9ja1N0YXJ0KShMX2gpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShMX2gpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9maWx0ZXJCbG9jaykoTF9oKShMX3QpKExfZnVuYyl9KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZmlsdGVyQXBwbGllcykoTF9oKShMX2Z1bmMpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2FuZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2lzQ29ucykoTF90KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pc0Jsb2NrU3RhcnQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9oZWFkKShMX3QpfSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2ZpbHRlckFwcGx5RWxlbWVudHMpKExfdCkoTF9mdW5jKX0pKExfbmlsKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9maWx0ZXJBcHBseUVsZW1lbnRzKShMX3QpKExfZnVuYyl9KX0pfSl9fX0pKShMX25pbCl9fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJmaWx0ZXJCbG9ja1wiKSgzKShcImZpbHRlckJsb2NrIHR5cGUgY29kZSBmdW5jID0gaXNUb2tlblN0cmluZyB0eXBlICdcXFxcXFxcXCdcXG4gIGZpbHRlckxhbWJkYSBjb2RlIGZ1bmNcXG4gIGZpbHRlckxldCBjb2RlIGZ1bmNcIikobGF6eShmdW5jdGlvbihMX3R5cGUpe3JldHVybiBmdW5jdGlvbihMX2NvZGUpe3JldHVybiBmdW5jdGlvbihMX2Z1bmMpe3JldHVybiByZXNvbHZlKExfaXNUb2tlblN0cmluZykoTF90eXBlKShcIlxcXFxcIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2ZpbHRlckxhbWJkYSkoTF9jb2RlKShMX2Z1bmMpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2ZpbHRlckxldCkoTF9jb2RlKShMX2Z1bmMpfSl9fX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwiZmlsdGVyTGV0XCIpKDIpKFwiZmlsdGVyTGV0IGNvZGUgZnVuYyA9IGNvZGUgXFxcXGggdCAuIGlzVG9rZW5TdHJpbmcgaCAnLidcXG4gIGNvbnMgaCAoZmlsdGVyQXBwbGllcyB0IGZ1bmMpXFxuICBjb25zIChmaWx0ZXJMZXRCaW5kaW5nIGggZnVuYylcXG4gICAgZmlsdGVyTGV0IHQgZnVuY1wiKShsYXp5KGZ1bmN0aW9uKExfY29kZSl7cmV0dXJuIGZ1bmN0aW9uKExfZnVuYyl7cmV0dXJuIHJlc29sdmUoTF9jb2RlKShsYXp5KGZ1bmN0aW9uKExfaCl7cmV0dXJuIGZ1bmN0aW9uKExfdCl7cmV0dXJuIHJlc29sdmUoTF9pc1Rva2VuU3RyaW5nKShMX2gpKFwiLlwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF9oKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZmlsdGVyQXBwbGllcykoTF90KShMX2Z1bmMpfSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2ZpbHRlckxldEJpbmRpbmcpKExfaCkoTF9mdW5jKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9maWx0ZXJMZXQpKExfdCkoTF9mdW5jKX0pfSl9fSkpfX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwiZmlsdGVyTGV0QmluZGluZ1wiKSgyKShcImZpbHRlckxldEJpbmRpbmcgY29kZSBmdW5jID0gaXNQYXJlbnMgY29kZVxcbiAgc2V0UGFyZW5zIGNvZGUgXFxcXGNvbnRlbnRzIC4gZmlsdGVyTGV0QmluZGluZyBjb250ZW50cyBmdW5jXFxuICBpc0NvbnMgY29kZVxcbiAgICBjb2RlIFxcXFxoIHQgLiBjb25zIGhcXG4gICAgICBpc1Rva2VuU3RyaW5nIGggJz0nXFxuICAgICAgICBmaWx0ZXJBcHBsaWVzIHQgZnVuY1xcbiAgICAgICAgZmlsdGVyTGV0QmluZGluZyB0IGZ1bmNcXG4gICAgY29kZVwiKShsYXp5KGZ1bmN0aW9uKExfY29kZSl7cmV0dXJuIGZ1bmN0aW9uKExfZnVuYyl7cmV0dXJuIHJlc29sdmUoTF9pc1BhcmVucykoTF9jb2RlKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc2V0UGFyZW5zKShMX2NvZGUpKGxhenkoZnVuY3Rpb24oTF9jb250ZW50cyl7cmV0dXJuIHJlc29sdmUoTF9maWx0ZXJMZXRCaW5kaW5nKShMX2NvbnRlbnRzKShMX2Z1bmMpfSkpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2lzQ29ucykoTF9jb2RlKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29kZSkobGF6eShmdW5jdGlvbihMX2gpe3JldHVybiBmdW5jdGlvbihMX3Qpe3JldHVybiByZXNvbHZlKExfY29ucykoTF9oKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaXNUb2tlblN0cmluZykoTF9oKShcIj1cIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2ZpbHRlckFwcGxpZXMpKExfdCkoTF9mdW5jKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9maWx0ZXJMZXRCaW5kaW5nKShMX3QpKExfZnVuYyl9KX0pfX0pKX0pKExfY29kZSl9KX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImZpbHRlckxhbWJkYVwiKSgyKShcImZpbHRlckxhbWJkYSBjb2RlIGZ1bmMgPSBjb2RlIFxcXFxoIHQgLiBjb25zIGhcXG4gIGlzVG9rZW5TdHJpbmcgaCAnLidcXG4gICAgZmlsdGVyQXBwbGllcyB0IGZ1bmNcXG4gICAgZmlsdGVyTGFtYmRhIHQgZnVuY1wiKShsYXp5KGZ1bmN0aW9uKExfY29kZSl7cmV0dXJuIGZ1bmN0aW9uKExfZnVuYyl7cmV0dXJuIHJlc29sdmUoTF9jb2RlKShsYXp5KGZ1bmN0aW9uKExfaCl7cmV0dXJuIGZ1bmN0aW9uKExfdCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShMX2gpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pc1Rva2VuU3RyaW5nKShMX2gpKFwiLlwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZmlsdGVyQXBwbGllcykoTF90KShMX2Z1bmMpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2ZpbHRlckxhbWJkYSkoTF90KShMX2Z1bmMpfSl9KX19KSl9fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3NldFZhbHVlKShcImxpc3RNYWNyb3NcIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKFwiW1wiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoXCJ7XCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShcImhhbXR7XCIpKExfbmlsKX0pfSl9KX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hZGRQYXJzZUZpbHRlcikoTF9saXN0RmlsdGVyKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hZGRUb2tlbkdyb3VwKShcIntcIikoXCJ9XCIpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZk1hY3JvKShcIntcIikobGF6eShmdW5jdGlvbihMX2xpc3Qpe3JldHVybiByZXNvbHZlKExfbGlzdCkobGF6eShmdW5jdGlvbihMX2gpe3JldHVybiBmdW5jdGlvbihMX3Qpe3JldHVybiByZXNvbHZlKExfbGlzdGlmeU9wKShcImFjb25zUGFpclwiKShMX2gpfX0pKX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hZGRUb2tlbkdyb3VwKShcImhhbXR7XCIpKFwifVwiKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZNYWNybykoXCJoYW10e1wiKShsYXp5KGZ1bmN0aW9uKExfbGlzdCl7cmV0dXJuIHJlc29sdmUoTF9saXN0KShsYXp5KGZ1bmN0aW9uKExfaCl7cmV0dXJuIGZ1bmN0aW9uKExfdCl7cmV0dXJuIHJlc29sdmUoTF9oYW10aWZ5KShMX2gpfX0pKX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwiaGFtdFdpdGhQYWlyXCIpKDIpKFwiaGFtdFdpdGhQYWlyIHBhaXIgdCA9IGhhbXRXaXRoIChoZWFkIHBhaXIpICh0YWlsIHBhaXIpIHRcIikobGF6eShmdW5jdGlvbihMX3BhaXIpe3JldHVybiBmdW5jdGlvbihMX3Qpe3JldHVybiByZXNvbHZlKExfaGFtdFdpdGgpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9oZWFkKShMX3BhaXIpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3RhaWwpKExfcGFpcil9KShMX3QpfX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwiaGFtdGlmeVwiKSgxKShcImhhbXRpZnkgbGlzdCA9IGxpc3RcXG4gIFxcXFxoIHQgRCAuIGlzVG9rZW5TdHJpbmcgaCAnfCdcXG4gICAgY29ucyB0IG5pbFxcbiAgICBhbmQgKGlzQ29ucyBoKSAob3IgKGlzVG9rZW5TdHJpbmcgKGhlYWQgaCkgJ2NvbnMnKSAoaXNUb2tlblN0cmluZyAoaGVhZCBoKSAnOicpKVxcbiAgICAgIFtbJ2hhbXRXaXRoJyAoaGVhZCAodGFpbCBoKSkgKGhlYWQgKHRhaWwgKHRhaWwgaCkpKSB8IGhhbXRpZnkgdF1dXFxuICAgICAgW1snaGFtdFdpdGhQYWlyJyBoIHwgaGFtdGlmeSB0XV1cXG4gIFsnaGFtdCddXCIpKGxhenkoZnVuY3Rpb24oTF9saXN0KXtyZXR1cm4gcmVzb2x2ZShMX2xpc3QpKGxhenkoZnVuY3Rpb24oTF9oKXtyZXR1cm4gZnVuY3Rpb24oTF90KXtyZXR1cm4gZnVuY3Rpb24oTF9EKXtyZXR1cm4gcmVzb2x2ZShMX2lzVG9rZW5TdHJpbmcpKExfaCkoXCJ8XCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShMX3QpKExfbmlsKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hbmQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pc0NvbnMpKExfaCl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfb3IpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pc1Rva2VuU3RyaW5nKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaGVhZCkoTF9oKX0pKFwiY29uc1wiKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pc1Rva2VuU3RyaW5nKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaGVhZCkoTF9oKX0pKFwiOlwiKX0pfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShcImhhbXRXaXRoXCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaGVhZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3RhaWwpKExfaCl9KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaGVhZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3RhaWwpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90YWlsKShMX2gpfSl9KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9oYW10aWZ5KShMX3QpfSl9KX0pfSkoTF9uaWwpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShcImhhbXRXaXRoUGFpclwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF9oKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaGFtdGlmeSkoTF90KX0pfSl9KShMX25pbCl9KX0pfX19KSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKFwiaGFtdFwiKShMX25pbCl9KX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZUb2tlblBhY2spKFwibGlzdFwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKFwifFwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoXCI9XCIpKExfbmlsKX0pfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hY29uc1BhaXIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShcIntcIikoXCJ9XCIpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2Fjb25zUGFpcikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKFwiaGFtdHtcIikoXCJ9XCIpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2Fjb25zUGFpcikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKFwiW1wiKShcIl1cIil9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYWNvbnNQYWlyKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoXCJvcltcIikoXCJdXCIpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2Fjb25zUGFpcikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKFwiYW5kW1wiKShcIl1cIil9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYWNvbnNQYWlyKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoXCJjb25jYXRbXCIpKFwiXVwiKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hY29uc1BhaXIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShcImNvbmNhdEZsYXRbXCIpKFwiXVwiKX0pKExfbmlsKX0pfSl9KX0pfSl9KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF9saXN0RmlsdGVyKShMX25pbCl9KShMX25pbCl9KX0pfSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYWRkVG9rZW5Hcm91cCkoXCJvcltcIikoXCJdXCIpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2FkZFRva2VuR3JvdXApKFwiYW5kW1wiKShcIl1cIil9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYWRkVG9rZW5Hcm91cCkoXCJjb25jYXRbXCIpKFwiXVwiKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hZGRUb2tlbkdyb3VwKShcImNvbmNhdEZsYXRbXCIpKFwiXVwiKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwibGlzdE1hY3JvRm9sZE9wXCIpKDMpKFwibGlzdE1hY3JvRm9sZE9wIG9wIGVtcHR5Q2FzZSBsaXN0ID0gbGlzdCBcXFxcaCB0IC4gZm9sZHJcXG4gICAgXFxcXGNhc2UgcmVzdWx0IC4gW29wIGNhc2UgcmVzdWx0XVxcbiAgICBlbXB0eUNhc2VcXG4gICAgaFwiKShsYXp5KGZ1bmN0aW9uKExfb3Ape3JldHVybiBmdW5jdGlvbihMX2VtcHR5Q2FzZSl7cmV0dXJuIGZ1bmN0aW9uKExfbGlzdCl7cmV0dXJuIHJlc29sdmUoTF9saXN0KShsYXp5KGZ1bmN0aW9uKExfaCl7cmV0dXJuIGZ1bmN0aW9uKExfdCl7cmV0dXJuIHJlc29sdmUoTF9mb2xkcikobGF6eShmdW5jdGlvbihMX2Nhc2Upe3JldHVybiBmdW5jdGlvbihMX3Jlc3VsdCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShMX29wKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF9jYXNlKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF9yZXN1bHQpKExfbmlsKX0pfSl9fSkpKExfZW1wdHlDYXNlKShMX2gpfX0pKX19fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZk1hY3JvKShcIm9yW1wiKShsYXp5KGZ1bmN0aW9uKExfbGlzdCl7cmV0dXJuIHJlc29sdmUoTF9saXN0TWFjcm9Gb2xkT3ApKFwib3JcIikoXCJmYWxzZVwiKShMX2xpc3QpfSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZk1hY3JvKShcImFuZFtcIikobGF6eShmdW5jdGlvbihMX2xpc3Qpe3JldHVybiByZXNvbHZlKExfbGlzdE1hY3JvRm9sZE9wKShcImFuZFwiKShcInRydWVcIikoTF9saXN0KX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZNYWNybykoXCJjb25jYXRbXCIpKGxhenkoZnVuY3Rpb24oTF9saXN0KXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKFwic3RyQ2F0XCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2xpc3RpZnkpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9oZWFkKShMX2xpc3QpfSl9KShMX25pbCl9KShMX25pbCl9KX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZNYWNybykoXCJjb25jYXRGbGF0W1wiKShsYXp5KGZ1bmN0aW9uKExfbGlzdCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShcInN0ckNhdFwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKFwiZmxhdHRlblwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9saXN0aWZ5KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaGVhZCkoTF9saXN0KX0pfSkoTF9uaWwpfSkoTF9uaWwpfSl9KShMX25pbCl9KX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9iaW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZ2V0VmFsdWUpKFwibGlzdE1hY3Jvc1wiKX0pKGxhenkoZnVuY3Rpb24oTF9sbSl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShcImNvbmNhdFtcIikoTF9sbSl9KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImluZml4XCIpKDEpKFwiaW5maXggY29kZSA9IGJpbmQgKGdldFZhbHVlICdpbmZpeFByZWNlZGVuY2UnKVxcbiAgXFxcXHByZWMgLiBiaW5kIChnZXRWYWx1ZSAnaW5maXhSaWdodEFzc29jaWF0aXZlJylcXG4gICAgXFxcXHJpZ2h0IC4gYmluZCAoZ2V0VmFsdWUgJ3Rva2VuR3JvdXBzJylcXG4gICAgICBcXFxcZ3JvdXBzIC4gZmlsdGVyQXBwbGllc1xcbiAgICAgICAgY29kZVxcbiAgICAgICAgXFxcXGV4cHIgLiBpbmZpeFJlYXJyYW5nZSBwcmVjIHJpZ2h0IChtYXAgKFxcXFxjZWxsIC4gdGFpbCBjZWxsKSBncm91cHMpIGV4cHJcIikobGF6eShmdW5jdGlvbihMX2NvZGUpe3JldHVybiByZXNvbHZlKExfYmluZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2dldFZhbHVlKShcImluZml4UHJlY2VkZW5jZVwiKX0pKGxhenkoZnVuY3Rpb24oTF9wcmVjKXtyZXR1cm4gcmVzb2x2ZShMX2JpbmQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9nZXRWYWx1ZSkoXCJpbmZpeFJpZ2h0QXNzb2NpYXRpdmVcIil9KShsYXp5KGZ1bmN0aW9uKExfcmlnaHQpe3JldHVybiByZXNvbHZlKExfYmluZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2dldFZhbHVlKShcInRva2VuR3JvdXBzXCIpfSkobGF6eShmdW5jdGlvbihMX2dyb3Vwcyl7cmV0dXJuIHJlc29sdmUoTF9maWx0ZXJBcHBsaWVzKShMX2NvZGUpKGxhenkoZnVuY3Rpb24oTF9leHByKXtyZXR1cm4gcmVzb2x2ZShMX2luZml4UmVhcnJhbmdlKShMX3ByZWMpKExfcmlnaHQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9tYXApKGxhenkoZnVuY3Rpb24oTF9jZWxsKXtyZXR1cm4gcmVzb2x2ZShMX3RhaWwpKExfY2VsbCl9KSkoTF9ncm91cHMpfSkoTF9leHByKX0pKX0pKX0pKX0pKX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwiaW5maXhSZWFycmFuZ2VcIikoNCkoXCJpbmZpeFJlYXJyYW5nZSBwcmVjIHJpZ2h0IGNsb3NlcyBsaXN0ID0gXFxcXFxcXFxcXG4gIGxlbiA9IGxlbmd0aCBsaXN0XFxuICBoZWFkMSA9IGhlYWQgbGlzdFxcbiAgdGFpbDEgPSB0YWlsIGxpc3RcXG4gIGhlYWQyID0gaGVhZCB0YWlsMVxcbiAgdGFpbDIgPSB0YWlsIHRhaWwxXFxuICBoZWFkMyA9IGhlYWQgdGFpbDJcXG4gIG9wUHJlYyA9IGdldFByZWMgcHJlYyBoZWFkMlxcbiAgLlxcbiAgPCBsZW4gMlxcbiAgICBsaXN0XFxuICAgIGlzSW5maXggb3BQcmVjIGhlYWQxIGhlYWQyIGxlblxcbiAgICAgIG9yICg9PSBsZW4gMikgKG5vdCAoaXNJbmZpeEFyZyBjbG9zZXMgaGVhZDMpKVxcbiAgICAgICAgW1toZWFkMiBoZWFkMV0gfCB0YWlsMl1cXG4gICAgICAgIGluZml4UmVhcnJhbmdlIHByZWMgcmlnaHQgY2xvc2VzIChhYnNvcmJBcmd1bWVudCBvcFByZWMgcHJlYyByaWdodCBjbG9zZXMgaGVhZDEgaGVhZDIgdGFpbDIgaGVhZDMgKC0gbGVuIDIpKVxcbiAgICAgIFtoZWFkMSB8IGluZml4UmVhcnJhbmdlIHByZWMgcmlnaHQgY2xvc2VzIHRhaWwxXVwiKShsYXp5KGZ1bmN0aW9uKExfcHJlYyl7cmV0dXJuIGZ1bmN0aW9uKExfcmlnaHQpe3JldHVybiBmdW5jdGlvbihMX2Nsb3Nlcyl7cmV0dXJuIGZ1bmN0aW9uKExfbGlzdCl7cmV0dXJuIChmdW5jdGlvbigpe1xuXG52YXIgTF9vcFByZWMsIExfaGVhZDMsIExfdGFpbDIsIExfaGVhZDIsIExfdGFpbDEsIExfaGVhZDEsIExfbGVuO1xuXG5MX29wUHJlYyA9IGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9nZXRQcmVjKShMX3ByZWMpKExfaGVhZDIpfTtcblxuTF9oZWFkMyA9IGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9oZWFkKShMX3RhaWwyKX07XG5cbkxfdGFpbDIgPSBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdGFpbCkoTF90YWlsMSl9O1xuXG5MX2hlYWQyID0gZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2hlYWQpKExfdGFpbDEpfTtcblxuTF90YWlsMSA9IGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90YWlsKShMX2xpc3QpfTtcblxuTF9oZWFkMSA9IGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9oZWFkKShMX2xpc3QpfTtcblxuTF9sZW4gPSBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfbGVuZ3RoKShMX2xpc3QpfTtcbnJldHVybiByZXNvbHZlKExfJHkpKExfbGVuKSgyKShMX2xpc3QpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pc0luZml4KShMX29wUHJlYykoTF9oZWFkMSkoTF9oZWFkMikoTF9sZW4pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9vcikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMXyRwJHApKExfbGVuKSgyKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9ub3QpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pc0luZml4QXJnKShMX2Nsb3NlcykoTF9oZWFkMyl9KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF9oZWFkMikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKExfaGVhZDEpKExfbmlsKX0pfSkoTF90YWlsMil9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaW5maXhSZWFycmFuZ2UpKExfcHJlYykoTF9yaWdodCkoTF9jbG9zZXMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hYnNvcmJBcmd1bWVudCkoTF9vcFByZWMpKExfcHJlYykoTF9yaWdodCkoTF9jbG9zZXMpKExfaGVhZDEpKExfaGVhZDIpKExfdGFpbDIpKExfaGVhZDMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF8kXykoTF9sZW4pKDIpfSl9KX0pfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKExfaGVhZDEpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pbmZpeFJlYXJyYW5nZSkoTF9wcmVjKShMX3JpZ2h0KShMX2Nsb3NlcykoTF90YWlsMSl9KX0pfSl9KSgpfX19fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJhYnNvcmJBcmd1bWVudFwiKSg5KShcImFic29yYkFyZ3VtZW50IG9wUHJlYyBwcmVjIHJpZ2h0IGNsb3NlcyBoZWFkMSBoZWFkMiB0YWlsMiBoZWFkMyBsZW4gPSBcXFxcXFxcXFxcbiAgdGFpbDMgPSB0YWlsIHRhaWwyXFxuICBoZWFkNCA9IGhlYWQgdGFpbDNcXG4gIHRhaWw0ID0gdGFpbCB0YWlsM1xcbiAgaGVhZDUgPSBoZWFkIHRhaWw0XFxuICAuXFxuICBpbmZpeFNob3VsZEVhdE5leHQgb3BQcmVjIHByZWMgKGNvbnRhaW5zIHJpZ2h0IChzdHJUb2tlblN0cmluZyBoZWFkMikpIGhlYWQzIGhlYWQ0IGhlYWQ1IGNsb3NlcyBsZW5cXG4gICAgW2hlYWQxIGhlYWQyIHwgYWJzb3JiQXJndW1lbnQgKGdldFByZWMgcHJlYyBoZWFkNCkgcHJlYyByaWdodCBjbG9zZXMgaGVhZDMgaGVhZDQgdGFpbDQgaGVhZDUgKC0gbGVuIDIpXVxcbiAgICBbW2hlYWQyIGhlYWQxIGhlYWQzXSB8IHRhaWwzXVwiKShsYXp5KGZ1bmN0aW9uKExfb3BQcmVjKXtyZXR1cm4gZnVuY3Rpb24oTF9wcmVjKXtyZXR1cm4gZnVuY3Rpb24oTF9yaWdodCl7cmV0dXJuIGZ1bmN0aW9uKExfY2xvc2VzKXtyZXR1cm4gZnVuY3Rpb24oTF9oZWFkMSl7cmV0dXJuIGZ1bmN0aW9uKExfaGVhZDIpe3JldHVybiBmdW5jdGlvbihMX3RhaWwyKXtyZXR1cm4gZnVuY3Rpb24oTF9oZWFkMyl7cmV0dXJuIGZ1bmN0aW9uKExfbGVuKXtyZXR1cm4gKGZ1bmN0aW9uKCl7XG5cbnZhciBMX2hlYWQ1LCBMX3RhaWw0LCBMX2hlYWQ0LCBMX3RhaWwzO1xuXG5MX2hlYWQ1ID0gZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2hlYWQpKExfdGFpbDQpfTtcblxuTF90YWlsNCA9IGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90YWlsKShMX3RhaWwzKX07XG5cbkxfaGVhZDQgPSBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaGVhZCkoTF90YWlsMyl9O1xuXG5MX3RhaWwzID0gZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3RhaWwpKExfdGFpbDIpfTtcbnJldHVybiByZXNvbHZlKExfaW5maXhTaG91bGRFYXROZXh0KShMX29wUHJlYykoTF9wcmVjKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29udGFpbnMpKExfcmlnaHQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zdHJUb2tlblN0cmluZykoTF9oZWFkMil9KX0pKExfaGVhZDMpKExfaGVhZDQpKExfaGVhZDUpKExfY2xvc2VzKShMX2xlbikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKExfaGVhZDEpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShMX2hlYWQyKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYWJzb3JiQXJndW1lbnQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9nZXRQcmVjKShMX3ByZWMpKExfaGVhZDQpfSkoTF9wcmVjKShMX3JpZ2h0KShMX2Nsb3NlcykoTF9oZWFkMykoTF9oZWFkNCkoTF90YWlsNCkoTF9oZWFkNSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMXyRfKShMX2xlbikoMil9KX0pfSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKExfaGVhZDIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShMX2hlYWQxKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF9oZWFkMykoTF9uaWwpfSl9KX0pKExfdGFpbDMpfSl9KSgpfX19fX19fX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImlzSW5maXhBcmdcIikoMikoXCJpc0luZml4QXJnIGNsb3NlcyBpdGVtID0gb3JbXFxuICBpc1BhcmVucyBpdGVtXFxuICBpc0NvbnMgaXRlbVxcbiAgYW5kW1xcbiAgICBpc1Rva2VuIGl0ZW1cXG4gICAgbm90IChjb250YWlucyBjbG9zZXMgKHRva2VuU3RyaW5nIGl0ZW0pKVxcbiAgICBub3QgKGlzQmxvY2tTdGFydCBpdGVtKV1dXCIpKGxhenkoZnVuY3Rpb24oTF9jbG9zZXMpe3JldHVybiBmdW5jdGlvbihMX2l0ZW0pe3JldHVybiByZXNvbHZlKExfb3IpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pc1BhcmVucykoTF9pdGVtKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9vcikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2lzQ29ucykoTF9pdGVtKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9vcikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2FuZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2lzVG9rZW4pKExfaXRlbSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfbm90KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29udGFpbnMpKExfY2xvc2VzKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdG9rZW5TdHJpbmcpKExfaXRlbSl9KX0pfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2FuZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX25vdCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2lzQmxvY2tTdGFydCkoTF9pdGVtKX0pfSkoTF90cnVlKX0pfSl9KShMX2ZhbHNlKX0pfSl9fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJpc0luZml4XCIpKDQpKFwiaXNJbmZpeCBvcFByZWMgaGVhZDEgaGVhZDIgbGVuID0gYW5kW1xcbiAgPiBsZW4gMVxcbiAgPiBvcFByZWMgLTFcXG4gIGlzSW5maXhBcmcgbmlsIGhlYWQxXVwiKShsYXp5KGZ1bmN0aW9uKExfb3BQcmVjKXtyZXR1cm4gZnVuY3Rpb24oTF9oZWFkMSl7cmV0dXJuIGZ1bmN0aW9uKExfaGVhZDIpe3JldHVybiBmdW5jdGlvbihMX2xlbil7cmV0dXJuIHJlc29sdmUoTF9hbmQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF8keikoTF9sZW4pKDEpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2FuZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMXyR6KShMX29wUHJlYykoLTEpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2FuZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2lzSW5maXhBcmcpKExfbmlsKShMX2hlYWQxKX0pKExfdHJ1ZSl9KX0pfX19fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJnZXRQcmVjXCIpKDIpKFwiZ2V0UHJlYyBwcmVjIHRva2VuID0gXFxcXFxcXFxcXG4gIHN0ciA9IHRva2VuU3RyaW5nIHRva2VuXFxuICAuXFxuICBpc1Rva2VuIHRva2VuXFxuICAgIGZpbmRJbmRleCAoXFxcXGxldmVsIC4gY29udGFpbnMgbGV2ZWwgc3RyKSBwcmVjXFxuICAgIC0xXCIpKGxhenkoZnVuY3Rpb24oTF9wcmVjKXtyZXR1cm4gZnVuY3Rpb24oTF90b2tlbil7cmV0dXJuIChmdW5jdGlvbigpe1xuXG52YXIgTF9zdHI7XG5cbkxfc3RyID0gZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3Rva2VuU3RyaW5nKShMX3Rva2VuKX07XG5yZXR1cm4gcmVzb2x2ZShMX2lzVG9rZW4pKExfdG9rZW4pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9maW5kSW5kZXgpKGxhenkoZnVuY3Rpb24oTF9sZXZlbCl7cmV0dXJuIHJlc29sdmUoTF9jb250YWlucykoTF9sZXZlbCkoTF9zdHIpfSkpKExfcHJlYyl9KSgtMSl9KSgpfX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwiaW5maXhTaG91bGRFYXROZXh0XCIpKDgpKFwiaW5maXhTaG91bGRFYXROZXh0IG9wUHJlYyBwcmVjIGlzUmlnaHQgY3VyQXJnIG5leHRPcCBuZXh0QXJnIGNsb3NlcyBsZW4gPSBcXFxcXFxcXFxcbiAgbmV4dFByZWMgPSBnZXRQcmVjIHByZWMgbmV4dE9wXFxuICAuXFxuICBhbmRbXFxuICAgID4gbGVuIDJcXG4gICAgaXNJbmZpeCBuZXh0UHJlYyBjdXJBcmcgbmV4dE9wIGxlblxcbiAgICBvciAoPiBvcFByZWMgbmV4dFByZWMpIChhbmQgKD09IG9wUHJlYyBuZXh0UHJlYykgaXNSaWdodClcXG4gICAgaXNJbmZpeEFyZyBjbG9zZXMgbmV4dEFyZ11cIikobGF6eShmdW5jdGlvbihMX29wUHJlYyl7cmV0dXJuIGZ1bmN0aW9uKExfcHJlYyl7cmV0dXJuIGZ1bmN0aW9uKExfaXNSaWdodCl7cmV0dXJuIGZ1bmN0aW9uKExfY3VyQXJnKXtyZXR1cm4gZnVuY3Rpb24oTF9uZXh0T3Ape3JldHVybiBmdW5jdGlvbihMX25leHRBcmcpe3JldHVybiBmdW5jdGlvbihMX2Nsb3Nlcyl7cmV0dXJuIGZ1bmN0aW9uKExfbGVuKXtyZXR1cm4gKGZ1bmN0aW9uKCl7XG5cbnZhciBMX25leHRQcmVjO1xuXG5MX25leHRQcmVjID0gZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2dldFByZWMpKExfcHJlYykoTF9uZXh0T3ApfTtcbnJldHVybiByZXNvbHZlKExfYW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfJHopKExfbGVuKSgyKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hbmQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pc0luZml4KShMX25leHRQcmVjKShMX2N1ckFyZykoTF9uZXh0T3ApKExfbGVuKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hbmQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9vcikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMXyR6KShMX29wUHJlYykoTF9uZXh0UHJlYyl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfJHAkcCkoTF9vcFByZWMpKExfbmV4dFByZWMpfSkoTF9pc1JpZ2h0KX0pfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2FuZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2lzSW5maXhBcmcpKExfY2xvc2VzKShMX25leHRBcmcpfSkoTF90cnVlKX0pfSl9KX0pKCl9fX19fX19fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZk1hY3JvKShcIjpcIikobGF6eShmdW5jdGlvbihMX2xpc3Qpe3JldHVybiByZXNvbHZlKExfY29ucykoXCJjb25zXCIpKExfbGlzdCl9KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImlwcmVjXCIpKDApKFwiaXByZWMgPSBbWycqJyAnLycgJyUnXSBbJysnICctJ10gWyc6J10gWyc8JyAnPicgJzw9JyAnPj0nXSBbJz09JyAnIT0nXV1cIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShcIipcIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKFwiL1wiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoXCIlXCIpKExfbmlsKX0pfSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKFwiK1wiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoXCItXCIpKExfbmlsKX0pfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShcIjpcIikoTF9uaWwpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShcIjxcIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKFwiPlwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoXCI8PVwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoXCI+PVwiKShMX25pbCl9KX0pfSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKFwiPT1cIikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKFwiIT1cIikoTF9uaWwpfSl9KShMX25pbCl9KX0pfSl9KX0pfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkoXCJyaWdodEFzc29jXCIpKDApKFwicmlnaHRBc3NvYyA9IFsnOiddXCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShcIjpcIikoTF9uaWwpfSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc2V0VmFsdWUpKFwiaW5maXhQcmVjZWRlbmNlXCIpKExfaXByZWMpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3NldFZhbHVlKShcImluZml4UmlnaHRBc3NvY2lhdGl2ZVwiKShMX3JpZ2h0QXNzb2MpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZlRva2VuUGFjaykoXCJpbmZpeFwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2ZsYXR0ZW4pKExfaXByZWMpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKExfbmlsKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKExfaW5maXgpKExfbmlsKX0pKExfbmlsKX0pfSl9KX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF91c2VUb2tlblBhY2spKFwiaW5maXhcIil9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmTWFjcm8pKFwiZG9cIikobGF6eShmdW5jdGlvbihMX2xpc3Qpe3JldHVybiByZXNvbHZlKExfaGFuZGxlRG8pKExfbGlzdCkoTF9mYWxzZSkoTF9pZCl9KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShcImhhbmRsZURvXCIpKDMpKFwiaGFuZGxlRG8gbGlzdCBpbkxldCBjb250ID0gbGlzdFxcbiAgXFxcXGggdCBEIC4gaXNOaWwgdFxcbiAgICBjb250IChpbkxldCBbJy4nIGhdIFtoXSlcXG4gICAgZG9DbGF1c2UgKHN0cmlwUGFyZW5zIGgpIGggbmlsIGluTGV0IFxcXFxuZXdJbkxldCBjaGFpbiAuXFxuICAgICAgaGFuZGxlRG8gdCBuZXdJbkxldCBcXFxccmVzdCAuIGNvbnQgKGNoYWluIHJlc3QpXFxuICBjb250IG5pbFwiKShsYXp5KGZ1bmN0aW9uKExfbGlzdCl7cmV0dXJuIGZ1bmN0aW9uKExfaW5MZXQpe3JldHVybiBmdW5jdGlvbihMX2NvbnQpe3JldHVybiByZXNvbHZlKExfbGlzdCkobGF6eShmdW5jdGlvbihMX2gpe3JldHVybiBmdW5jdGlvbihMX3Qpe3JldHVybiBmdW5jdGlvbihMX0Qpe3JldHVybiByZXNvbHZlKExfaXNOaWwpKExfdCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pbkxldCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKFwiLlwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF9oKShMX25pbCl9KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShMX2gpKExfbmlsKX0pfSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZG9DbGF1c2UpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zdHJpcFBhcmVucykoTF9oKX0pKExfaCkoTF9uaWwpKExfaW5MZXQpKGxhenkoZnVuY3Rpb24oTF9uZXdJbkxldCl7cmV0dXJuIGZ1bmN0aW9uKExfY2hhaW4pe3JldHVybiByZXNvbHZlKExfaGFuZGxlRG8pKExfdCkoTF9uZXdJbkxldCkobGF6eShmdW5jdGlvbihMX3Jlc3Qpe3JldHVybiByZXNvbHZlKExfY29udCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NoYWluKShMX3Jlc3QpfSl9KSl9fSkpfSl9fX0pKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29udCkoTF9uaWwpfSl9fX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKFwiZG9DbGF1c2VcIikoNSkoXCJkb0NsYXVzZSBzdGVwcGluZ0NsYXVzZSBjbGF1c2UgcHJlZml4IGluTGV0IGNvbnQgPSBcXFxcXFxcXFxcbiAgbWFrZUJpbmQgdmFyIG1vbmFkID0gY29udCBmYWxzZSBcXFxccmVzdCAuIGluTGV0IChjb25zICcuJykgaWRcXG4gICAgWydiaW5kJyBtb25hZCBbJ1xcXFxcXFxcJyB2YXIgJy4nIHwgcmVzdF1dXFxuICAuXFxuICBpc0NvbnMgc3RlcHBpbmdDbGF1c2VcXG4gICAgc3RlcHBpbmdDbGF1c2UgXFxcXGggdCAuIGlzVG9rZW5TdHJpbmcgaCAnPSdcXG4gICAgICBpbkxldFxcbiAgICAgICAgY29udCB0cnVlIFxcXFxyZXN0IC4gW2NsYXVzZSB8IHJlc3RdXFxuICAgICAgICBjb250IHRydWUgXFxcXHJlc3QgLiBbJ1xcXFxcXFxcXFxcXFxcXFwnIGNsYXVzZSB8IHJlc3RdXFxuICAgICAgaXNUb2tlblN0cmluZyBoICc8LSdcXG4gICAgICAgIGlzTmlsIHRcXG4gICAgICAgICAgcGFyc2VFcnIgXFxcIk5vIG1vbmFkIGluIGRvLWNsYXVzZTogXFxcIiBjbGF1c2VcXG4gICAgICAgICAgcHJlZml4XFxuICAgICAgICAgICAgXFxcXHBoIHB0IEQgLiBpc05pbCBwdFxcbiAgICAgICAgICAgICAgbWFrZUJpbmQgKGlzTmlsIHByZWZpeCAnXycgKGhlYWQgcHJlZml4KSkgdFxcbiAgICAgICAgICAgICAgcGFyc2VFcnIgXFxcIk1vcmUgdGhhbiBvbmUgdmFyaWFibGUgaW4gZG8tY2xhdXNlOiBcXFwiIGNsYXVzZVxcbiAgICAgICAgICAgIG1ha2VCaW5kICdfJyB0XFxuICAgICAgICBkb0NsYXVzZSB0IGNsYXVzZSBbaCB8IHByZWZpeF0gaW5MZXQgY29udFxcbiAgICBtYWtlQmluZCAnXycgY2xhdXNlXCIpKGxhenkoZnVuY3Rpb24oTF9zdGVwcGluZ0NsYXVzZSl7cmV0dXJuIGZ1bmN0aW9uKExfY2xhdXNlKXtyZXR1cm4gZnVuY3Rpb24oTF9wcmVmaXgpe3JldHVybiBmdW5jdGlvbihMX2luTGV0KXtyZXR1cm4gZnVuY3Rpb24oTF9jb250KXtyZXR1cm4gKGZ1bmN0aW9uKCl7XG5cbnZhciBMX21ha2VCaW5kO1xuXG5MX21ha2VCaW5kID0gbGF6eShmdW5jdGlvbihMX3Zhcil7cmV0dXJuIGZ1bmN0aW9uKExfbW9uYWQpe3JldHVybiByZXNvbHZlKExfY29udCkoTF9mYWxzZSkobGF6eShmdW5jdGlvbihMX3Jlc3Qpe3JldHVybiByZXNvbHZlKExfaW5MZXQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShcIi5cIil9KShMX2lkKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoXCJiaW5kXCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShMX21vbmFkKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKFwiXFxcXFwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF92YXIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShcIi5cIikoTF9yZXN0KX0pfSl9KShMX25pbCl9KX0pfSl9KSl9fSk7XG5yZXR1cm4gcmVzb2x2ZShMX2lzQ29ucykoTF9zdGVwcGluZ0NsYXVzZSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3N0ZXBwaW5nQ2xhdXNlKShsYXp5KGZ1bmN0aW9uKExfaCl7cmV0dXJuIGZ1bmN0aW9uKExfdCl7cmV0dXJuIHJlc29sdmUoTF9pc1Rva2VuU3RyaW5nKShMX2gpKFwiPVwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaW5MZXQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb250KShMX3RydWUpKGxhenkoZnVuY3Rpb24oTF9yZXN0KXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKExfY2xhdXNlKShMX3Jlc3QpfSkpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnQpKExfdHJ1ZSkobGF6eShmdW5jdGlvbihMX3Jlc3Qpe3JldHVybiByZXNvbHZlKExfY29ucykoXCJcXFxcXFxcXFwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF9jbGF1c2UpKExfcmVzdCl9KX0pKX0pfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2lzVG9rZW5TdHJpbmcpKExfaCkoXCI8LVwiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaXNOaWwpKExfdCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3BhcnNlRXJyKShcIk5vIG1vbmFkIGluIGRvLWNsYXVzZTogXCIpKExfY2xhdXNlKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9wcmVmaXgpKGxhenkoZnVuY3Rpb24oTF9waCl7cmV0dXJuIGZ1bmN0aW9uKExfcHQpe3JldHVybiBmdW5jdGlvbihMX0Qpe3JldHVybiByZXNvbHZlKExfaXNOaWwpKExfcHQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9tYWtlQmluZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2lzTmlsKShMX3ByZWZpeCkoXCJfXCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9oZWFkKShMX3ByZWZpeCl9KX0pKExfdCl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcGFyc2VFcnIpKFwiTW9yZSB0aGFuIG9uZSB2YXJpYWJsZSBpbiBkby1jbGF1c2U6IFwiKShMX2NsYXVzZSl9KX19fSkpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9tYWtlQmluZCkoXCJfXCIpKExfdCl9KX0pfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RvQ2xhdXNlKShMX3QpKExfY2xhdXNlKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF9oKShMX3ByZWZpeCl9KShMX2luTGV0KShMX2NvbnQpfSl9KX19KSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfbWFrZUJpbmQpKFwiX1wiKShMX2NsYXVzZSl9KX0pKCl9fX19fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZlRva2VuUGFjaykoXCJkb1wiKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKFwiPC1cIikoTF9uaWwpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKExfbmlsKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF9uaWwpKExfbmlsKX0pfSl9KX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hZGRTdGRUb2tlblBhY2tzKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoXCJsaXN0XCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShcImluZml4XCIpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShcImRvXCIpKExfbmlsKX0pfSl9KX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9yZXNldFN0ZFRva2VuUGFja3MpfV0pO1xuIiwiKGZ1bmN0aW9uKGdsb2JhbCl7LyohXG4gTG8tRGFzaCAwLjcuMCBsb2Rhc2guY29tL2xpY2Vuc2VcbiBVbmRlcnNjb3JlLmpzIDEuMy4zIGdpdGh1Yi5jb20vZG9jdW1lbnRjbG91ZC91bmRlcnNjb3JlL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiovXG47KGZ1bmN0aW9uKGUsdCl7ZnVuY3Rpb24gcyhlKXtyZXR1cm4gbmV3IG8oZSl9ZnVuY3Rpb24gbyhlKXtpZihlJiZlLl9fd3JhcHBlZF9fKXJldHVybiBlO3RoaXMuX193cmFwcGVkX189ZX1mdW5jdGlvbiB1KGUsdCl7cmV0dXJuIGZ1bmN0aW9uKG4scixpKXtyZXR1cm4gZS5jYWxsKHQsbixyLGkpfX1mdW5jdGlvbiBhKGUsdCxuKXt0fHwodD0wKTt2YXIgcj1lLmxlbmd0aCxpPXItdD49KG58fFcpLHM9aT97fTplO2lmKGkpZm9yKHZhciBvPXQtMTsrK288cjspbj1lW29dK1wiXCIsKGF0LmNhbGwocyxuKT9zW25dOnNbbl09W10pLnB1c2goZVtvXSk7cmV0dXJuIGZ1bmN0aW9uKGUpe2lmKGkpe3ZhciBuPWUrXCJcIjtyZXR1cm4gYXQuY2FsbChzLG4pJiYtMTxMKHNbbl0sZSl9cmV0dXJuLTE8TChzLGUsdCl9fWZ1bmN0aW9uIGYoZSxuKXt2YXIgcj1lLmIsaT1uLmIsZT1lLmEsbj1uLmE7aWYoZSE9PW4pe2lmKGU+bnx8ZT09PXQpcmV0dXJuIDE7aWYoZTxufHxuPT09dClyZXR1cm4tMX1yZXR1cm4gcjxcbmk/LTE6MX1mdW5jdGlvbiBsKGUsdCxuKXtmdW5jdGlvbiByKCl7dmFyIHU9YXJndW1lbnRzLGE9cz90aGlzOnQ7cmV0dXJuIGl8fChlPXRbb10pLG4ubGVuZ3RoJiYodT11Lmxlbmd0aD9uLmNvbmNhdChjdC5jYWxsKHUpKTpuKSx0aGlzIGluc3RhbmNlb2Ygcj8odi5wcm90b3R5cGU9ZS5wcm90b3R5cGUsYT1uZXcgdiwodT1lLmFwcGx5KGEsdSkpJiYkdFt0eXBlb2YgdV0/dTphKTplLmFwcGx5KGEsdSl9dmFyIGk9RShlKSxzPSFuLG89ZTtyZXR1cm4gcyYmKG49dCkscn1mdW5jdGlvbiBjKCl7Zm9yKHZhciBlLHQsbixzPS0xLG89YXJndW1lbnRzLmxlbmd0aCxhPXtlOlwiXCIsZjpcIlwiLGo6XCJcIixxOlwiXCIsYzp7ZDpcIlwifSxtOntkOlwiXCJ9fTsrK3M8bzspZm9yKHQgaW4gZT1hcmd1bWVudHNbc10sZSluPShuPWVbdF0pPT1yP1wiXCI6biwvZHxpLy50ZXN0KHQpPyhcInN0cmluZ1wiPT10eXBlb2YgbiYmKG49e2I6bixsOm59KSxhLmNbdF09bi5ifHxcIlwiLGEubVt0XT1uLmx8fFwiXCIpOmFbdF09bjtlPVxuYS5hLHQ9L15bXixdKy8uZXhlYyhlKVswXSxuPWEucyxhLmc9dCxhLmg9TXQsYS5rPVJ0LGEubj1QdCxhLnA9cnQsYS5yPWEuciE9PWksYS5zPW49PXI/VXQ6bixhLm89PXImJihhLm89anQpLGEuZnx8KGEuZj1cImlmKCFcIit0K1wiKXJldHVybiB1XCIpO2lmKFwiZVwiIT10fHwhYS5jLmkpYS5jPXI7dD1cIlwiLGEucyYmKHQrPVwiJ3VzZSBzdHJpY3QnO1wiKSx0Kz1cInZhciBqLEEsaz1cIithLmcrXCIsdVwiLGEuaiYmKHQrPVwiPVwiK2EuaiksdCs9XCI7XCIrYS5mK1wiO1wiK2EucStcIjtcIixhLmMmJih0Kz1cInZhciBsPWsubGVuZ3RoO2o9LTE7XCIsYS5tJiYodCs9XCJpZihsPT09K2wpe1wiKSxhLm8mJih0Kz1cImlmKHouY2FsbChrKT09eCl7az1rLnNwbGl0KCcnKX1cIiksdCs9YS5jLmQrXCI7d2hpbGUoKytqPGwpe0E9a1tqXTtcIithLmMuaStcIn1cIixhLm0mJih0Kz1cIn1cIikpO2lmKGEubSl7YS5jP3QrPVwiZWxzZXtcIjphLm4mJih0Kz1cInZhciBsPWsubGVuZ3RoO2o9LTE7aWYobCYmTyhrKSl7d2hpbGUoKytqPGwpe0E9a1tqKz0nJ107XCIrXG5hLm0uaStcIn19ZWxzZXtcIiksYS5ofHwodCs9XCJ2YXIgdj10eXBlb2Ygaz09J2Z1bmN0aW9uJyYmci5jYWxsKGssJ3Byb3RvdHlwZScpO1wiKTtpZihhLmsmJmEucil0Kz1cInZhciBvPS0xLHA9WFt0eXBlb2Yga10/bShrKTpbXSxsPXAubGVuZ3RoO1wiK2EubS5kK1wiO3doaWxlKCsrbzxsKXtqPXBbb107XCIsYS5ofHwodCs9XCJpZighKHYmJmo9PSdwcm90b3R5cGUnKSl7XCIpLHQrPVwiQT1rW2pdO1wiK2EubS5pK1wiXCIsYS5ofHwodCs9XCJ9XCIpO2Vsc2V7dCs9YS5tLmQrXCI7Zm9yKGogaW4gayl7XCI7aWYoIWEuaHx8YS5yKXQrPVwiaWYoXCIsYS5ofHwodCs9XCIhKHYmJmo9PSdwcm90b3R5cGUnKVwiKSwhYS5oJiZhLnImJih0Kz1cIiYmXCIpLGEuciYmKHQrPVwiaC5jYWxsKGssailcIiksdCs9XCIpe1wiO3QrPVwiQT1rW2pdO1wiK2EubS5pK1wiO1wiO2lmKCFhLmh8fGEucil0Kz1cIn1cIn10Kz1cIn1cIjtpZihhLmgpe3QrPVwidmFyIGc9ay5jb25zdHJ1Y3RvcjtcIjtmb3Iobj0wOzc+bjtuKyspdCs9XCJqPSdcIithLnBbbl0rXCInO2lmKFwiXG4sXCJjb25zdHJ1Y3RvclwiPT1hLnBbbl0mJih0Kz1cIiEoZyYmZy5wcm90b3R5cGU9PT1rKSYmXCIpLHQrPVwiaC5jYWxsKGssaikpe0E9a1tqXTtcIithLm0uaStcIn1cIn1pZihhLmN8fGEubil0Kz1cIn1cIn1yZXR1cm4gdCs9YS5lK1wiO3JldHVybiB1XCIsRnVuY3Rpb24oXCJELEUsRixjLEksZixKLGgsaSxNLE8sUSxTLFQsVyxYLG0scix3LHgselwiLFwidmFyIEc9ZnVuY3Rpb24oXCIrZStcIil7XCIrdCtcIn07cmV0dXJuIEdcIikoenQsUixELHUsZix1dCxsbixhdCxQLEwsdyxzbixFLG9uLEN0LCR0LGd0LGx0LGN0LEx0LGh0KX1mdW5jdGlvbiBoKGUsdCl7cmV0dXJuIG90W3RdfWZ1bmN0aW9uIHAoZSl7cmV0dXJuXCJcXFxcXCIrSnRbZV19ZnVuY3Rpb24gZChlKXtyZXR1cm4gWHRbZV19ZnVuY3Rpb24gdigpe31mdW5jdGlvbiBtKGUsdCl7aWYoZSYmVi50ZXN0KHQpKXJldHVyblwiPGUlLVwiK3QrXCIlPlwiO3ZhciBuPW90Lmxlbmd0aDtyZXR1cm4gb3Rbbl09XCInK19fZShcIit0K1wiKSsnXCIsaXQrbitzdH1mdW5jdGlvbiBnXG4oZSx0LG4saSl7cmV0dXJuIGk/KGU9b3QubGVuZ3RoLG90W2VdPVwiJztcIitpK1wiO19fcCs9J1wiLGl0K2Urc3QpOnQ/bShyLHQpOnkocixuKX1mdW5jdGlvbiB5KGUsdCl7aWYoZSYmVi50ZXN0KHQpKXJldHVyblwiPGUlPVwiK3QrXCIlPlwiO3ZhciBuPW90Lmxlbmd0aDtyZXR1cm4gb3Rbbl09XCInKygoX190PShcIit0K1wiKSk9PW51bGw/Jyc6X190KSsnXCIsaXQrbitzdH1mdW5jdGlvbiBiKGUpe3JldHVybiBWdFtlXX1mdW5jdGlvbiB3KGUpe3JldHVybiBodC5jYWxsKGUpPT1FdH1mdW5jdGlvbiBFKGUpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIGV9ZnVuY3Rpb24gUyhlLHQpe3ZhciBuPWk7aWYoIWV8fFwib2JqZWN0XCIhPXR5cGVvZiBlfHwhdCYmdyhlKSlyZXR1cm4gbjt2YXIgcj1lLmNvbnN0cnVjdG9yO3JldHVybighRnR8fFwiZnVuY3Rpb25cIj09dHlwZW9mIGUudG9TdHJpbmd8fFwic3RyaW5nXCIhPXR5cGVvZiAoZStcIlwiKSkmJighRShyKXx8ciBpbnN0YW5jZW9mIHIpP0R0PyhsbihlLGZ1bmN0aW9uKFxuZSx0LHIpe3JldHVybiBuPSFhdC5jYWxsKHIsdCksaX0pLG49PT1pKToobG4oZSxmdW5jdGlvbihlLHQpe249dH0pLG49PT1pfHxhdC5jYWxsKGUsbikpOm59ZnVuY3Rpb24geChlLHQscyxvLHUpe2lmKGU9PXIpcmV0dXJuIGU7cyYmKHQ9aSk7aWYocz0kdFt0eXBlb2YgZV0pe3ZhciBhPWh0LmNhbGwoZSk7aWYoIVd0W2FdfHxIdCYmdyhlKSlyZXR1cm4gZTt2YXIgZj1hPT1TdCxzPWZ8fChhPT1DdD9vbihlLG4pOnMpfWlmKCFzfHwhdClyZXR1cm4gcz9mP2N0LmNhbGwoZSk6Zm4oe30sZSk6ZTtzPWUuY29uc3RydWN0b3I7c3dpdGNoKGEpe2Nhc2UgeHQ6cmV0dXJuIG5ldyBzKGU9PW4pO2Nhc2UgVHQ6cmV0dXJuIG5ldyBzKCtlKTtjYXNlIE50OmNhc2UgTHQ6cmV0dXJuIG5ldyBzKGUpO2Nhc2Uga3Q6cmV0dXJuIHMoZS5zb3VyY2UsRy5leGVjKGUpKX1vfHwobz1bXSksdXx8KHU9W10pO2ZvcihhPW8ubGVuZ3RoO2EtLTspaWYob1thXT09ZSlyZXR1cm4gdVthXTt2YXIgbD1mP3MoXG5hPWUubGVuZ3RoKTp7fTtvLnB1c2goZSksdS5wdXNoKGwpO2lmKGYpZm9yKGY9LTE7KytmPGE7KWxbZl09eChlW2ZdLHQscixvLHUpO2Vsc2UgY24oZSxmdW5jdGlvbihlLG4pe2xbbl09eChlLHQscixvLHUpfSk7cmV0dXJuIGx9ZnVuY3Rpb24gVChlLHQscyxvKXtpZihlPT1yfHx0PT1yKXJldHVybiBlPT09dDtpZihlPT09dClyZXR1cm4gMCE9PWV8fDEvZT09MS90O2lmKCR0W3R5cGVvZiBlXXx8JHRbdHlwZW9mIHRdKWU9ZS5fX3dyYXBwZWRfX3x8ZSx0PXQuX193cmFwcGVkX198fHQ7dmFyIHU9aHQuY2FsbChlKTtpZih1IT1odC5jYWxsKHQpKXJldHVybiBpO3N3aXRjaCh1KXtjYXNlIHh0OmNhc2UgVHQ6cmV0dXJuK2U9PSt0O2Nhc2UgTnQ6cmV0dXJuIGUhPStlP3QhPSt0OjA9PWU/MS9lPT0xL3Q6ZT09K3Q7Y2FzZSBrdDpjYXNlIEx0OnJldHVybiBlPT10K1wiXCJ9dmFyIGE9enRbdV07aWYoSHQmJiFhJiYoYT13KGUpKSYmIXcodCl8fCFhJiYodSE9Q3R8fEZ0JiYoXCJmdW5jdGlvblwiIT10eXBlb2YgXG5lLnRvU3RyaW5nJiZcInN0cmluZ1wiPT10eXBlb2YgKGUrXCJcIil8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQudG9TdHJpbmcmJlwic3RyaW5nXCI9PXR5cGVvZiAodCtcIlwiKSkpKXJldHVybiBpO3N8fChzPVtdKSxvfHwobz1bXSk7Zm9yKHU9cy5sZW5ndGg7dS0tOylpZihzW3VdPT1lKXJldHVybiBvW3VdPT10O3ZhciB1PS0xLGY9bixsPTA7cy5wdXNoKGUpLG8ucHVzaCh0KTtpZihhKXtsPWUubGVuZ3RoO2lmKGY9bD09dC5sZW5ndGgpZm9yKDtsLS0mJihmPVQoZVtsXSx0W2xdLHMsbykpOyk7cmV0dXJuIGZ9YT1lLmNvbnN0cnVjdG9yLGY9dC5jb25zdHJ1Y3RvcjtpZihhIT1mJiYoIUUoYSl8fCEoYSBpbnN0YW5jZW9mIGEmJkUoZikmJmYgaW5zdGFuY2VvZiBmKSkpcmV0dXJuIGk7Zm9yKHZhciBjIGluIGUpaWYoYXQuY2FsbChlLGMpJiYobCsrLCFhdC5jYWxsKHQsYyl8fCFUKGVbY10sdFtjXSxzLG8pKSlyZXR1cm4gaTtmb3IoYyBpbiB0KWlmKGF0LmNhbGwodCxjKSYmIShsLS0pKXJldHVybiBpXG47aWYoTXQpZm9yKDs3PisrdTspaWYoYz1ydFt1XSxhdC5jYWxsKGUsYykmJighYXQuY2FsbCh0LGMpfHwhVChlW2NdLHRbY10scyxvKSkpcmV0dXJuIGk7cmV0dXJuIG59ZnVuY3Rpb24gTihlLHQsbixyKXtpZighZSlyZXR1cm4gbjt2YXIgaT1lLmxlbmd0aCxzPTM+YXJndW1lbnRzLmxlbmd0aDtyJiYodD11KHQscikpO2lmKGk9PT0raSl7dmFyIG89anQmJmh0LmNhbGwoZSk9PUx0P2Uuc3BsaXQoXCJcIik6ZTtmb3IoaSYmcyYmKG49b1stLWldKTtpLS07KW49dChuLG9baV0saSxlKTtyZXR1cm4gbn1vPXZuKGUpO2ZvcigoaT1vLmxlbmd0aCkmJnMmJihuPWVbb1stLWldXSk7aS0tOylzPW9baV0sbj10KG4sZVtzXSxzLGUpO3JldHVybiBufWZ1bmN0aW9uIEMoZSx0LG4pe2lmKGUpcmV0dXJuIHQ9PXJ8fG4/ZVswXTpjdC5jYWxsKGUsMCx0KX1mdW5jdGlvbiBrKGUsdCl7dmFyIG49W107aWYoIWUpcmV0dXJuIG47Zm9yKHZhciByLGk9LTEscz1lLmxlbmd0aDsrK2k8czspcj1lW2ldLFxuc24ocik/ZnQuYXBwbHkobix0P3I6ayhyKSk6bi5wdXNoKHIpO3JldHVybiBufWZ1bmN0aW9uIEwoZSx0LG4pe2lmKCFlKXJldHVybi0xO3ZhciByPS0xLGk9ZS5sZW5ndGg7aWYobil7aWYoXCJudW1iZXJcIiE9dHlwZW9mIG4pcmV0dXJuIHI9TShlLHQpLGVbcl09PT10P3I6LTE7cj0oMD5uP3l0KDAsaStuKTpuKS0xfWZvcig7KytyPGk7KWlmKGVbcl09PT10KXJldHVybiByO3JldHVybi0xfWZ1bmN0aW9uIEEoZSx0LG4pe3ZhciByPS1JbmZpbml0eSxpPXI7aWYoIWUpcmV0dXJuIGk7dmFyIHM9LTEsbz1lLmxlbmd0aDtpZighdCl7Zm9yKDsrK3M8bzspZVtzXT5pJiYoaT1lW3NdKTtyZXR1cm4gaX1mb3IobiYmKHQ9dSh0LG4pKTsrK3M8bzspbj10KGVbc10scyxlKSxuPnImJihyPW4saT1lW3NdKTtyZXR1cm4gaX1mdW5jdGlvbiBPKGUsdCxuKXtyZXR1cm4gZT9jdC5jYWxsKGUsdD09cnx8bj8xOnQpOltdfWZ1bmN0aW9uIE0oZSx0LG4scil7aWYoIWUpcmV0dXJuIDA7dmFyIGk9MCxcbnM9ZS5sZW5ndGg7aWYobil7ciYmKG49RChuLHIpKTtmb3IodD1uKHQpO2k8czspcj1pK3M+Pj4xLG4oZVtyXSk8dD9pPXIrMTpzPXJ9ZWxzZSBmb3IoO2k8czspcj1pK3M+Pj4xLGVbcl08dD9pPXIrMTpzPXI7cmV0dXJuIGl9ZnVuY3Rpb24gXyhlLHQsbixyKXt2YXIgcz1bXTtpZighZSlyZXR1cm4gczt2YXIgbz0tMSxhPWUubGVuZ3RoLGY9W107XCJmdW5jdGlvblwiPT10eXBlb2YgdCYmKHI9bixuPXQsdD1pKTtmb3Iobj9yJiYobj11KG4scikpOm49UDsrK288YTspaWYocj1uKGVbb10sbyxlKSx0PyFvfHxmW2YubGVuZ3RoLTFdIT09cjowPkwoZixyKSlmLnB1c2gocikscy5wdXNoKGVbb10pO3JldHVybiBzfWZ1bmN0aW9uIEQoZSx0KXtyZXR1cm4gcXR8fHB0JiYyPGFyZ3VtZW50cy5sZW5ndGg/cHQuY2FsbC5hcHBseShwdCxhcmd1bWVudHMpOmwoZSx0LGN0LmNhbGwoYXJndW1lbnRzLDIpKX1mdW5jdGlvbiBQKGUpe3JldHVybiBlfWZ1bmN0aW9uIEgoZSl7Q24oaG4oZSksZnVuY3Rpb24oXG50KXt2YXIgcj1zW3RdPWVbdF07by5wcm90b3R5cGVbdF09ZnVuY3Rpb24oKXt2YXIgZT1bdGhpcy5fX3dyYXBwZWRfX107cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGgmJmZ0LmFwcGx5KGUsYXJndW1lbnRzKSxlPXIuYXBwbHkocyxlKSx0aGlzLl9fY2hhaW5fXyYmKGU9bmV3IG8oZSksZS5fX2NoYWluX189biksZX19KX12YXIgbj0hMCxyPW51bGwsaT0hMSxCLGosRixJLHE9XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJmV4cG9ydHMmJihcIm9iamVjdFwiPT10eXBlb2YgZ2xvYmFsJiZnbG9iYWwmJmdsb2JhbD09Z2xvYmFsLmdsb2JhbCYmKGU9Z2xvYmFsKSxleHBvcnRzKSxSPUFycmF5LnByb3RvdHlwZSxVPU9iamVjdC5wcm90b3R5cGUsej0wLFc9MzAsWD1lLl8sVj0vWy0/Kz0hfiolJl48Pnx7KFxcL118XFxbXFxEfFxcYig/OmRlbGV0ZXxpbnxpbnN0YW5jZW9mfG5ld3x0eXBlb2Z8dm9pZClcXGIvLCQ9LyYoPzphbXB8bHR8Z3R8cXVvdHwjeDI3KTsvZyxKPS9cXGJfX3BcXCs9Jyc7L2csSz0vXFxiKF9fcFxcKz0pJydcXCsvZ1xuLFE9LyhfX2VcXCguKj9cXCl8XFxiX190XFwpKVxcKycnOy9nLEc9L1xcdyokLyxZPS8oPzpfX2V8X190PSlcXChcXHMqKD8hW1xcZFxcc1wiJ118dGhpc1xcLikvZyxaPVJlZ0V4cChcIl5cIisoVS52YWx1ZU9mK1wiXCIpLnJlcGxhY2UoL1suKis/Xj0hOiR7fSgpfFtcXF1cXC9cXFxcXS9nLFwiXFxcXCQmXCIpLnJlcGxhY2UoL3ZhbHVlT2Z8Zm9yIFteXFxdXSsvZyxcIi4rP1wiKStcIiRcIiksZXQ9L19fdG9rZW4oXFxkKylfXy9nLHR0PS9bJjw+XCInXS9nLG50PS9bJ1xcblxcclxcdFxcdTIwMjhcXHUyMDI5XFxcXF0vZyxydD1cImNvbnN0cnVjdG9yIGhhc093blByb3BlcnR5IGlzUHJvdG90eXBlT2YgcHJvcGVydHlJc0VudW1lcmFibGUgdG9Mb2NhbGVTdHJpbmcgdG9TdHJpbmcgdmFsdWVPZlwiLnNwbGl0KFwiIFwiKSxpdD1cIl9fdG9rZW5cIixzdD1cIl9fXCIsb3Q9W10sdXQ9Ui5jb25jYXQsYXQ9VS5oYXNPd25Qcm9wZXJ0eSxmdD1SLnB1c2gsbHQ9VS5wcm9wZXJ0eUlzRW51bWVyYWJsZSxjdD1SLnNsaWNlLGh0PVUudG9TdHJpbmcscHQ9Wi50ZXN0KFxucHQ9Y3QuYmluZCkmJnB0LGR0PU1hdGguZmxvb3IsdnQ9Wi50ZXN0KHZ0PUFycmF5LmlzQXJyYXkpJiZ2dCxtdD1lLmlzRmluaXRlLGd0PVoudGVzdChndD1PYmplY3Qua2V5cykmJmd0LHl0PU1hdGgubWF4LGJ0PU1hdGgubWluLHd0PU1hdGgucmFuZG9tLEV0PVwiW29iamVjdCBBcmd1bWVudHNdXCIsU3Q9XCJbb2JqZWN0IEFycmF5XVwiLHh0PVwiW29iamVjdCBCb29sZWFuXVwiLFR0PVwiW29iamVjdCBEYXRlXVwiLE50PVwiW29iamVjdCBOdW1iZXJdXCIsQ3Q9XCJbb2JqZWN0IE9iamVjdF1cIixrdD1cIltvYmplY3QgUmVnRXhwXVwiLEx0PVwiW29iamVjdCBTdHJpbmddXCIsQXQ9ZS5jbGVhclRpbWVvdXQsT3Q9ZS5zZXRUaW1lb3V0LE10LF90LER0LFB0PW47KGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe3RoaXMueD0xfXZhciB0PXswOjEsbGVuZ3RoOjF9LG49W107ZS5wcm90b3R5cGU9e3ZhbHVlT2Y6MSx5OjF9O2Zvcih2YXIgciBpbiBuZXcgZSluLnB1c2gocik7Zm9yKHIgaW4gYXJndW1lbnRzKVB0PSFyO010PTQ+XG4obitcIlwiKS5sZW5ndGgsRHQ9XCJ4XCIhPW5bMF0sX3Q9KG4uc3BsaWNlLmNhbGwodCwwLDEpLHRbMF0pfSkoMSk7dmFyIEh0PSF3KGFyZ3VtZW50cyksQnQ9XCJ4XCIhPWN0LmNhbGwoXCJ4XCIpWzBdLGp0PVwieHhcIiE9XCJ4XCJbMF0rT2JqZWN0KFwieFwiKVswXTt0cnl7dmFyIEZ0PShcIltvYmplY3QgT2JqZWN0XVwiLGh0LmNhbGwoZS5kb2N1bWVudHx8MCk9PUN0KX1jYXRjaChJdCl7fXZhciBxdD1wdCYmL1xcbnxPcGVyYS8udGVzdChwdCtodC5jYWxsKGUub3BlcmEpKSxSdD1ndCYmL14uKyR8dHJ1ZS8udGVzdChndCshIWUuYXR0YWNoRXZlbnQpLFV0PSFxdCx6dD17fTt6dFt4dF09enRbVHRdPXp0W1wiW29iamVjdCBGdW5jdGlvbl1cIl09enRbTnRdPXp0W0N0XT16dFtrdF09aSx6dFtFdF09enRbU3RdPXp0W0x0XT1uO3ZhciBXdD17fTtXdFtFdF09V3RbXCJbb2JqZWN0IEZ1bmN0aW9uXVwiXT1pLFd0W1N0XT1XdFt4dF09V3RbVHRdPVd0W050XT1XdFtDdF09V3Rba3RdPVd0W0x0XT1uO3ZhciBYdD17XCImXCJcbjpcIiZhbXA7XCIsXCI8XCI6XCImbHQ7XCIsXCI+XCI6XCImZ3Q7XCIsJ1wiJzpcIiZxdW90O1wiLFwiJ1wiOlwiJiN4Mjc7XCJ9LFZ0PXtcIiZhbXA7XCI6XCImXCIsXCImbHQ7XCI6XCI8XCIsXCImZ3Q7XCI6XCI+XCIsXCImcXVvdDtcIjonXCInLFwiJiN4Mjc7XCI6XCInXCJ9LCR0PXtcImJvb2xlYW5cIjppLFwiZnVuY3Rpb25cIjpuLG9iamVjdDpuLG51bWJlcjppLHN0cmluZzppLFwidW5kZWZpbmVkXCI6aSx1bmtub3duOm59LEp0PXtcIlxcXFxcIjpcIlxcXFxcIixcIidcIjpcIidcIixcIlxcblwiOlwiblwiLFwiXFxyXCI6XCJyXCIsXCJcdFwiOlwidFwiLFwiXFx1MjAyOFwiOlwidTIwMjhcIixcIlxcdTIwMjlcIjpcInUyMDI5XCJ9O3MudGVtcGxhdGVTZXR0aW5ncz17ZXNjYXBlOi88JS0oW1xcc1xcU10rPyklPi9nLGV2YWx1YXRlOi88JShbXFxzXFxTXSs/KSU+L2csaW50ZXJwb2xhdGU6LzwlPShbXFxzXFxTXSs/KSU+L2csdmFyaWFibGU6XCJcIn07dmFyIEt0PXthOlwiZSxkLHlcIixqOlwiZVwiLHE6XCJpZighZClkPWk7ZWxzZSBpZih5KWQ9YyhkLHkpXCIsaTpcImlmKGQoQSxqLGUpPT09ZmFsc2UpcmV0dXJuIHVcIn0sUXQ9e2o6XCJ7fVwiXG4scTpcInZhciBxO2lmKHR5cGVvZiBkIT0nZnVuY3Rpb24nKXt2YXIgaGg9ZDtkPWZ1bmN0aW9uKEEpe3JldHVybiBBW2hoXX19ZWxzZSBpZih5KWQ9YyhkLHkpXCIsaTpcInE9ZChBLGosZSk7KGguY2FsbCh1LHEpP3VbcV0rKzp1W3FdPTEpXCJ9LEd0PXtqOlwidHJ1ZVwiLGk6XCJpZighZChBLGosZSkpcmV0dXJuIXVcIn0sWXQ9e3I6aSxzOmksYTpcIm5cIixqOlwiblwiLHE6XCJmb3IodmFyIGE9MSxiPWFyZ3VtZW50cy5sZW5ndGg7YTxiO2ErKyl7aWYoaz1hcmd1bWVudHNbYV0pe1wiLGk6XCJ1W2pdPUFcIixlOlwifX1cIn0sWnQ9e2o6XCJbXVwiLGk6XCJkKEEsaixlKSYmdS5wdXNoKEEpXCJ9LGVuPXtxOlwiaWYoeSlkPWMoZCx5KVwifSx0bj17aTp7bDpLdC5pfX0sbm49e2o6XCJcIixmOlwiaWYoIWUpcmV0dXJuW11cIixkOntiOlwidT1BcnJheShsKVwiLGw6XCJ1PVwiKyhSdD9cIkFycmF5KGwpXCI6XCJbXVwiKX0saTp7YjpcInVbal09ZChBLGosZSlcIixsOlwidVwiKyhSdD9cIltvXT1cIjpcIi5wdXNoXCIpK1wiKGQoQSxqLGUpKVwifX0scm49e3I6XG5pLGE6XCJuLGQseVwiLGo6XCJ7fVwiLHE6XCJ2YXIgUj10eXBlb2YgZD09J2Z1bmN0aW9uJztpZighUil7dmFyIHQ9Zi5hcHBseShFLGFyZ3VtZW50cyl9ZWxzZSBpZih5KWQ9YyhkLHkpXCIsaTpcImlmKFI/IWQoQSxqLG4pOk0odCxqKTwwKXVbal09QVwifTtIdCYmKHc9ZnVuY3Rpb24oZSl7cmV0dXJuISFlJiYhIWF0LmNhbGwoZSxcImNhbGxlZVwiKX0pO3ZhciBzbj12dHx8ZnVuY3Rpb24oZSl7cmV0dXJuIGh0LmNhbGwoZSk9PVN0fTtFKC94LykmJihFPWZ1bmN0aW9uKGUpe3JldHVyblwiW29iamVjdCBGdW5jdGlvbl1cIj09aHQuY2FsbChlKX0pO3ZhciBvbj0kdC5fX3Byb3RvX18hPVU/UzpmdW5jdGlvbihlLHQpe2lmKCFlKXJldHVybiBpO3ZhciBuPWUudmFsdWVPZixyPVwiZnVuY3Rpb25cIj09dHlwZW9mIG4mJihyPW4uX19wcm90b19fKSYmci5fX3Byb3RvX187cmV0dXJuIHI/ZT09cnx8ZS5fX3Byb3RvX189PXImJih0fHwhdyhlKSk6UyhlKX0sdW49Yyh7YTpcIm5cIixqOlwiW11cIixpOlwidS5wdXNoKGopXCJcbn0pLGFuPWMoWXQse2k6XCJpZih1W2pdPT1udWxsKVwiK1l0Lml9KSxmbj1jKFl0KSxsbj1jKEt0LGVuLHRuLHtyOml9KSxjbj1jKEt0LGVuLHRuKSxobj1jKHtyOmksYTpcIm5cIixqOlwiW11cIixpOlwiaWYoUyhBKSl1LnB1c2goailcIixlOlwidS5zb3J0KClcIn0pLHBuPWMoe2E6XCJuXCIsajpcInt9XCIsaTpcInVbQV09alwifSksZG49Yyh7YTpcIkFcIixqOlwidHJ1ZVwiLHE6XCJ2YXIgSD16LmNhbGwoQSksbD1BLmxlbmd0aDtpZihEW0hdXCIrKEh0P1wifHxPKEEpXCI6XCJcIikrXCJ8fChIPT1XJiZsPT09K2wmJlMoQS5zcGxpY2UpKSlyZXR1cm4hbFwiLGk6e2w6XCJyZXR1cm4gZmFsc2VcIn19KSx2bj1ndD9mdW5jdGlvbihlKXt2YXIgdD10eXBlb2YgZTtyZXR1cm5cImZ1bmN0aW9uXCI9PXQmJmx0LmNhbGwoZSxcInByb3RvdHlwZVwiKT91bihlKTplJiYkdFt0XT9ndChlKTpbXX06dW4sbW49YyhZdCx7YTpcIm4sY2MsTlwiLHE6XCJ2YXIgYixQLGRkLGVlLEM9YXJndW1lbnRzLGE9MDtpZihOPT1UKXtiPTI7ZGQ9Q1szXTtlZT1DWzRdfWVsc2V7Yj1DLmxlbmd0aDtkZD1bXTtlZT1bXX13aGlsZSgrK2E8Yil7aWYoaz1DW2FdKXtcIlxuLGk6XCJpZigoY2M9QSkmJigoUD1RKGNjKSl8fFQoY2MpKSl7dmFyIEs9ZmFsc2UsZmY9ZGQubGVuZ3RoO3doaWxlKGZmLS0paWYoSz1kZFtmZl09PWNjKWJyZWFrO2lmKEspe3Vbal09ZWVbZmZdfWVsc2V7ZGQucHVzaChjYyk7ZWUucHVzaChBPShBPXVbal0pJiZQPyhRKEEpP0E6W10pOihUKEEpP0E6e30pKTt1W2pdPUcoQSxjYyxULGRkLGVlKX19ZWxzZSBpZihjYyE9bnVsbCl1W2pdPWNjXCJ9KSxnbj1jKHJuKSx5bj1jKHthOlwiblwiLGo6XCJbXVwiLGk6XCJ1XCIrKFJ0P1wiW29dPVwiOlwiLnB1c2hcIikrXCIoW2osQV0pXCJ9KSxibj1jKHJuLHtxOlwiaWYodHlwZW9mIGQhPSdmdW5jdGlvbicpe3ZhciBxLHQ9Zi5hcHBseShFLGFyZ3VtZW50cyksbD10Lmxlbmd0aDtmb3Ioaj0xO2o8bDtqKyspe3E9dFtqXTtpZihxIGluIG4pdVtxXT1uW3FdfX1lbHNle2lmKHkpZD1jKGQseSlcIixpOlwiaWYoZChBLGosbikpdVtqXT1BXCIsZTpcIn1cIn0pLHduPWMoe2E6XCJuXCIsajpcIltdXCIsaTpcInUucHVzaChBKVwifSksRW49XG5jKHthOlwiZSxnZ1wiLGo6XCJmYWxzZVwiLG86aSxkOntiOlwiaWYoei5jYWxsKGUpPT14KXJldHVybiBlLmluZGV4T2YoZ2cpPi0xXCJ9LGk6XCJpZihBPT09Z2cpcmV0dXJuIHRydWVcIn0pLFNuPWMoS3QsUXQpLHhuPWMoS3QsR3QpLFRuPWMoS3QsWnQpLE5uPWMoS3QsZW4se2o6XCJcIixpOlwiaWYoZChBLGosZSkpcmV0dXJuIEFcIn0pLENuPWMoS3QsZW4pLGtuPWMoS3QsUXQse2k6XCJxPWQoQSxqLGUpOyhoLmNhbGwodSxxKT91W3FdOnVbcV09W10pLnB1c2goQSlcIn0pLExuPWMobm4se2E6XCJlLFVcIixxOlwidmFyIEM9dy5jYWxsKGFyZ3VtZW50cywyKSxSPXR5cGVvZiBVPT0nZnVuY3Rpb24nXCIsaTp7YjpcInVbal09KFI/VTpBW1VdKS5hcHBseShBLEMpXCIsbDpcInVcIisoUnQ/XCJbb109XCI6XCIucHVzaFwiKStcIigoUj9VOkFbVV0pLmFwcGx5KEEsQykpXCJ9fSksQW49YyhLdCxubiksT249Yyhubix7YTpcImUsYWFcIixpOntiOlwidVtqXT1BW2FhXVwiLGw6XCJ1XCIrKFJ0P1wiW29dPVwiOlwiLnB1c2hcIikrXCIoQVthYV0pXCJ9XG59KSxNbj1jKHthOlwiZSxkLEIseVwiLGo6XCJCXCIscTpcInZhciBWPWFyZ3VtZW50cy5sZW5ndGg8MztpZih5KWQ9YyhkLHkpXCIsZDp7YjpcImlmKFYpdT1rWysral1cIn0saTp7YjpcInU9ZCh1LEEsaixlKVwiLGw6XCJ1PVY/KFY9ZmFsc2UsQSk6ZCh1LEEsaixlKVwifX0pLF9uPWMoS3QsWnQse2k6XCIhXCIrWnQuaX0pLERuPWMoS3QsR3Qse2o6XCJmYWxzZVwiLGk6R3QuaS5yZXBsYWNlKFwiIVwiLFwiXCIpfSksUG49YyhLdCxRdCxubix7aTp7YjpcInVbal09e2E6ZChBLGosZSksYjpqLGM6QX1cIixsOlwidVwiKyhSdD9cIltvXT1cIjpcIi5wdXNoXCIpK1wiKHthOmQoQSxqLGUpLGI6aixjOkF9KVwifSxlOlwidS5zb3J0KEkpO2w9dS5sZW5ndGg7d2hpbGUobC0tKXVbbF09dVtsXS5jXCJ9KSxIbj1jKFp0LHthOlwiZSxaXCIscTpcInZhciB0PVtdO0ooWixmdW5jdGlvbihBLHEpe3QucHVzaChxKX0pO3ZhciBiYj10Lmxlbmd0aFwiLGk6XCJmb3IodmFyIHEsWT10cnVlLHM9MDtzPGJiO3MrKyl7cT10W3NdO2lmKCEoWT1BW3FdPT09WltxXSkpYnJlYWt9WSYmdS5wdXNoKEEpXCJcbn0pLEJuPWMoe3I6aSxzOmksYTpcIm5cIixqOlwiblwiLHE6XCJ2YXIgTD1hcmd1bWVudHMsbD1MLmxlbmd0aDtpZihsPjEpe2Zvcih2YXIgaj0xO2o8bDtqKyspdVtMW2pdXT1GKHVbTFtqXV0sdSk7cmV0dXJuIHV9XCIsaTpcImlmKFModVtqXSkpdVtqXT1GKHVbal0sdSlcIn0pO3MuVkVSU0lPTj1cIjAuNy4wXCIscy5hZnRlcj1mdW5jdGlvbihlLHQpe3JldHVybiAxPmU/dCgpOmZ1bmN0aW9uKCl7aWYoMT4tLWUpcmV0dXJuIHQuYXBwbHkodGhpcyxhcmd1bWVudHMpfX0scy5iaW5kPUQscy5iaW5kQWxsPUJuLHMuY2hhaW49ZnVuY3Rpb24oZSl7cmV0dXJuIGU9bmV3IG8oZSksZS5fX2NoYWluX189bixlfSxzLmNsb25lPXgscy5jb21wYWN0PWZ1bmN0aW9uKGUpe3ZhciB0PVtdO2lmKCFlKXJldHVybiB0O2Zvcih2YXIgbj0tMSxyPWUubGVuZ3RoOysrbjxyOyllW25dJiZ0LnB1c2goZVtuXSk7cmV0dXJuIHR9LHMuY29tcG9zZT1mdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cztyZXR1cm4gZnVuY3Rpb24oXG4pe2Zvcih2YXIgdD1hcmd1bWVudHMsbj1lLmxlbmd0aDtuLS07KXQ9W2Vbbl0uYXBwbHkodGhpcyx0KV07cmV0dXJuIHRbMF19fSxzLmNvbnRhaW5zPUVuLHMuY291bnRCeT1TbixzLmRlYm91bmNlPWZ1bmN0aW9uKGUsdCxuKXtmdW5jdGlvbiBpKCl7YT1yLG58fChvPWUuYXBwbHkodSxzKSl9dmFyIHMsbyx1LGE7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIHI9biYmIWE7cmV0dXJuIHM9YXJndW1lbnRzLHU9dGhpcyxBdChhKSxhPU90KGksdCksciYmKG89ZS5hcHBseSh1LHMpKSxvfX0scy5kZWZhdWx0cz1hbixzLmRlZmVyPWZ1bmN0aW9uKGUpe3ZhciBuPWN0LmNhbGwoYXJndW1lbnRzLDEpO3JldHVybiBPdChmdW5jdGlvbigpe3JldHVybiBlLmFwcGx5KHQsbil9LDEpfSxzLmRlbGF5PWZ1bmN0aW9uKGUsbil7dmFyIHI9Y3QuY2FsbChhcmd1bWVudHMsMik7cmV0dXJuIE90KGZ1bmN0aW9uKCl7cmV0dXJuIGUuYXBwbHkodCxyKX0sbil9LHMuZGlmZmVyZW5jZT1mdW5jdGlvbihlKXtcbnZhciB0PVtdO2lmKCFlKXJldHVybiB0O2Zvcih2YXIgbj0tMSxyPWUubGVuZ3RoLGk9dXQuYXBwbHkodCxhcmd1bWVudHMpLGk9YShpLHIpOysrbjxyOylpKGVbbl0pfHx0LnB1c2goZVtuXSk7cmV0dXJuIHR9LHMuZXNjYXBlPWZ1bmN0aW9uKGUpe3JldHVybiBlPT1yP1wiXCI6KGUrXCJcIikucmVwbGFjZSh0dCxkKX0scy5ldmVyeT14bixzLmV4dGVuZD1mbixzLmZpbHRlcj1UbixzLmZpbmQ9Tm4scy5maXJzdD1DLHMuZmxhdHRlbj1rLHMuZm9yRWFjaD1DbixzLmZvckluPWxuLHMuZm9yT3duPWNuLHMuZnVuY3Rpb25zPWhuLHMuZ3JvdXBCeT1rbixzLmhhcz1mdW5jdGlvbihlLHQpe3JldHVybiBlP2F0LmNhbGwoZSx0KTppfSxzLmlkZW50aXR5PVAscy5pbmRleE9mPUwscy5pbml0aWFsPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZT9jdC5jYWxsKGUsMCwtKHQ9PXJ8fG4/MTp0KSk6W119LHMuaW50ZXJzZWN0aW9uPWZ1bmN0aW9uKGUpe3ZhciB0PVtdO2lmKCFlKXJldHVybiB0O3ZhciBuXG4scj1hcmd1bWVudHMubGVuZ3RoLGk9W10scz0tMSxvPWUubGVuZ3RoO2U6Zm9yKDsrK3M8bzspaWYobj1lW3NdLDA+TCh0LG4pKXtmb3IodmFyIHU9MTt1PHI7dSsrKWlmKCEoaVt1XXx8KGlbdV09YShhcmd1bWVudHNbdV0pKSkobikpY29udGludWUgZTt0LnB1c2gobil9cmV0dXJuIHR9LHMuaW52ZXJ0PXBuLHMuaW52b2tlPUxuLHMuaXNBcmd1bWVudHM9dyxzLmlzQXJyYXk9c24scy5pc0Jvb2xlYW49ZnVuY3Rpb24oZSl7cmV0dXJuIGU9PT1ufHxlPT09aXx8aHQuY2FsbChlKT09eHR9LHMuaXNFbGVtZW50PWZ1bmN0aW9uKGUpe3JldHVybiBlPzE9PT1lLm5vZGVUeXBlOml9LHMuaXNFbXB0eT1kbixzLmlzRXF1YWw9VCxzLmlzRmluaXRlPWZ1bmN0aW9uKGUpe3JldHVybiBtdChlKSYmaHQuY2FsbChlKT09TnR9LHMuaXNGdW5jdGlvbj1FLHMuaXNOYU49ZnVuY3Rpb24oZSl7cmV0dXJuIGh0LmNhbGwoZSk9PU50JiZlIT0rZX0scy5pc051bGw9ZnVuY3Rpb24oZSl7cmV0dXJuIGU9PT1cbnJ9LHMuaXNPYmplY3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIGU/JHRbdHlwZW9mIGVdOml9LHMuaXNVbmRlZmluZWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGU9PT10fSxzLmtleXM9dm4scy5sYXN0PWZ1bmN0aW9uKGUsdCxuKXtpZihlKXt2YXIgaT1lLmxlbmd0aDtyZXR1cm4gdD09cnx8bj9lW2ktMV06Y3QuY2FsbChlLC10fHxpKX19LHMubGFzdEluZGV4T2Y9ZnVuY3Rpb24oZSx0LG4pe2lmKCFlKXJldHVybi0xO3ZhciByPWUubGVuZ3RoO2ZvcihuJiZcIm51bWJlclwiPT10eXBlb2YgbiYmKHI9KDA+bj95dCgwLHIrbik6YnQobixyLTEpKSsxKTtyLS07KWlmKGVbcl09PT10KXJldHVybiByO3JldHVybi0xfSxzLmxhdGVCaW5kPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGwodCxlLGN0LmNhbGwoYXJndW1lbnRzLDIpKX0scy5tYXA9QW4scy5tYXg9QSxzLm1lbW9pemU9ZnVuY3Rpb24oZSx0KXt2YXIgbj17fTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgcj10P3QuYXBwbHkodGhpcyxhcmd1bWVudHMpXG46YXJndW1lbnRzWzBdO3JldHVybiBhdC5jYWxsKG4scik/bltyXTpuW3JdPWUuYXBwbHkodGhpcyxhcmd1bWVudHMpfX0scy5tZXJnZT1tbixzLm1pbj1mdW5jdGlvbihlLHQsbil7dmFyIHI9SW5maW5pdHksaT1yO2lmKCFlKXJldHVybiBpO3ZhciBzPS0xLG89ZS5sZW5ndGg7aWYoIXQpe2Zvcig7KytzPG87KWVbc108aSYmKGk9ZVtzXSk7cmV0dXJuIGl9Zm9yKG4mJih0PXUodCxuKSk7KytzPG87KW49dChlW3NdLHMsZSksbjxyJiYocj1uLGk9ZVtzXSk7cmV0dXJuIGl9LHMubWl4aW49SCxzLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gZS5fPVgsdGhpc30scy5vYmplY3Q9ZnVuY3Rpb24oZSx0KXtpZighZSlyZXR1cm57fTtmb3IodmFyIG49LTEscj1lLmxlbmd0aCxpPXt9OysrbjxyOyl0P2lbZVtuXV09dFtuXTppW2Vbbl1bMF1dPWVbbl1bMV07cmV0dXJuIGl9LHMub21pdD1nbixzLm9uY2U9ZnVuY3Rpb24oZSl7dmFyIHQscz1pO3JldHVybiBmdW5jdGlvbigpe3JldHVybiBzP1xudDoocz1uLHQ9ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyksZT1yLHQpfX0scy5wYWlycz15bixzLnBhcnRpYWw9ZnVuY3Rpb24oZSl7cmV0dXJuIGwoZSxjdC5jYWxsKGFyZ3VtZW50cywxKSl9LHMucGljaz1ibixzLnBsdWNrPU9uLHMucmFuZG9tPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU9PXImJnQ9PXI/d3QoKTooZT0rZXx8MCx0PT1yJiYodD1lLGU9MCksZStkdCh3dCgpKigoK3R8fDApLWUrMSkpKX0scy5yYW5nZT1mdW5jdGlvbihlLHQsbil7ZT0rZXx8MCxuPStufHwxLHQ9PXImJih0PWUsZT0wKTtmb3IodmFyIGk9LTEsdD15dCgwLE1hdGguY2VpbCgodC1lKS9uKSkscz1BcnJheSh0KTsrK2k8dDspc1tpXT1lLGUrPW47cmV0dXJuIHN9LHMucmVkdWNlPU1uLHMucmVkdWNlUmlnaHQ9TixzLnJlamVjdD1fbixzLnJlc3Q9TyxzLnJlc3VsdD1mdW5jdGlvbihlLHQpe2lmKCFlKXJldHVybiByO3ZhciBuPWVbdF07cmV0dXJuIEUobik/ZVt0XSgpOm59LHMuc2h1ZmZsZT1mdW5jdGlvbihcbmUpe2lmKCFlKXJldHVybltdO2Zvcih2YXIgdCxuPS0xLHI9ZS5sZW5ndGgsaT1BcnJheShyKTsrK248cjspdD1kdCh3dCgpKihuKzEpKSxpW25dPWlbdF0saVt0XT1lW25dO3JldHVybiBpfSxzLnNpemU9ZnVuY3Rpb24oZSl7aWYoIWUpcmV0dXJuIDA7dmFyIHQ9ZS5sZW5ndGg7cmV0dXJuIHQ9PT0rdD90OnZuKGUpLmxlbmd0aH0scy5zb21lPURuLHMuc29ydEJ5PVBuLHMuc29ydGVkSW5kZXg9TSxzLnRhcD1mdW5jdGlvbihlLHQpe3JldHVybiB0KGUpLGV9LHMudGVtcGxhdGU9ZnVuY3Rpb24oZSx0LG4pe258fChuPXt9KTt2YXIgZT1lK1wiXCIsbyx1O289bi5lc2NhcGU7dmFyIGE9bi5ldmFsdWF0ZSxmPW4uaW50ZXJwb2xhdGUsbD1zLnRlbXBsYXRlU2V0dGluZ3MsYz1uPW4udmFyaWFibGV8fGwudmFyaWFibGU7bz09ciYmKG89bC5lc2NhcGUpLGE9PXImJihhPWwuZXZhbHVhdGV8fGkpLGY9PXImJihmPWwuaW50ZXJwb2xhdGUpLG8mJihlPWUucmVwbGFjZShvLG0pKSxmJiYoZT1lXG4ucmVwbGFjZShmLHkpKSxhIT1CJiYoQj1hLEk9UmVnRXhwKFwiPGUlLShbXFxcXHNcXFxcU10rPyklPnw8ZSU9KFtcXFxcc1xcXFxTXSs/KSU+XCIrKGE/XCJ8XCIrYS5zb3VyY2U6XCJcIiksXCJnXCIpKSxvPW90Lmxlbmd0aCxlPWUucmVwbGFjZShJLGcpLG89byE9b3QubGVuZ3RoLGU9XCJfX3AgKz0gJ1wiK2UucmVwbGFjZShudCxwKS5yZXBsYWNlKGV0LGgpK1wiJztcIixvdC5sZW5ndGg9MCxjfHwobj1qfHxcIm9ialwiLG8/ZT1cIndpdGgoXCIrbitcIil7XCIrZStcIn1cIjoobiE9aiYmKGo9bixGPVJlZ0V4cChcIihcXFxcKFxcXFxzKilcIituK1wiXFxcXC5cIituK1wiXFxcXGJcIixcImdcIikpLGU9ZS5yZXBsYWNlKFksXCIkJlwiK24rXCIuXCIpLnJlcGxhY2UoRixcIiQxX19kXCIpKSksZT0obz9lLnJlcGxhY2UoSixcIlwiKTplKS5yZXBsYWNlKEssXCIkMVwiKS5yZXBsYWNlKFEsXCIkMTtcIiksZT1cImZ1bmN0aW9uKFwiK24rXCIpe1wiKyhjP1wiXCI6bitcInx8KFwiK24rXCI9e30pO1wiKStcInZhciBfX3QsX19wPScnLF9fZT1fLmVzY2FwZVwiKyhvP1wiLF9faj1BcnJheS5wcm90b3R5cGUuam9pbjtmdW5jdGlvbiBwcmludCgpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKX1cIlxuOihjP1wiXCI6XCIsX19kPVwiK24rXCIuXCIrbitcInx8XCIrbikrXCI7XCIpK2UrXCJyZXR1cm4gX19wfVwiO3RyeXt1PUZ1bmN0aW9uKFwiX1wiLFwicmV0dXJuIFwiK2UpKHMpfWNhdGNoKGQpe3Rocm93IGQuc291cmNlPWUsZH1yZXR1cm4gdD91KHQpOih1LnNvdXJjZT1lLHUpfSxzLnRocm90dGxlPWZ1bmN0aW9uKGUsdCl7ZnVuY3Rpb24gbigpe2E9bmV3IERhdGUsdT1yLHM9ZS5hcHBseShvLGkpfXZhciBpLHMsbyx1LGE9MDtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgcj1uZXcgRGF0ZSxmPXQtKHItYSk7cmV0dXJuIGk9YXJndW1lbnRzLG89dGhpcywwPj1mPyhhPXIscz1lLmFwcGx5KG8saSkpOnV8fCh1PU90KG4sZikpLHN9fSxzLnRpbWVzPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj0tMTtpZihuKWZvcig7KytyPGU7KXQuY2FsbChuLHIpO2Vsc2UgZm9yKDsrK3I8ZTspdChyKX0scy50b0FycmF5PWZ1bmN0aW9uKGUpe2lmKCFlKXJldHVybltdO3ZhciB0PWUubGVuZ3RoO3JldHVybiB0PT09K3Q/KEJ0P2h0LlxuY2FsbChlKT09THQ6XCJzdHJpbmdcIj09dHlwZW9mIGUpP2Uuc3BsaXQoXCJcIik6Y3QuY2FsbChlKTp3bihlKX0scy51bmVzY2FwZT1mdW5jdGlvbihlKXtyZXR1cm4gZT09cj9cIlwiOihlK1wiXCIpLnJlcGxhY2UoJCxiKX0scy51bmlvbj1mdW5jdGlvbigpe2Zvcih2YXIgZT0tMSx0PVtdLG49dXQuYXBwbHkodCxhcmd1bWVudHMpLHI9bi5sZW5ndGg7KytlPHI7KTA+TCh0LG5bZV0pJiZ0LnB1c2gobltlXSk7cmV0dXJuIHR9LHMudW5pcT1fLHMudW5pcXVlSWQ9ZnVuY3Rpb24oZSl7dmFyIHQ9eisrO3JldHVybiBlP2UrdDp0fSxzLnZhbHVlcz13bixzLndoZXJlPUhuLHMud2l0aG91dD1mdW5jdGlvbihlKXt2YXIgdD1bXTtpZighZSlyZXR1cm4gdDtmb3IodmFyIG49LTEscj1lLmxlbmd0aCxpPWEoYXJndW1lbnRzLDEsMjApOysrbjxyOylpKGVbbl0pfHx0LnB1c2goZVtuXSk7cmV0dXJuIHR9LHMud3JhcD1mdW5jdGlvbihlLHQpe3JldHVybiBmdW5jdGlvbigpe3ZhciBuPVtlXTtyZXR1cm4gYXJndW1lbnRzXG4ubGVuZ3RoJiZmdC5hcHBseShuLGFyZ3VtZW50cyksdC5hcHBseSh0aGlzLG4pfX0scy56aXA9ZnVuY3Rpb24oZSl7aWYoIWUpcmV0dXJuW107Zm9yKHZhciB0PS0xLG49QShPbihhcmd1bWVudHMsXCJsZW5ndGhcIikpLHI9QXJyYXkobik7Kyt0PG47KXJbdF09T24oYXJndW1lbnRzLHQpO3JldHVybiByfSxzLmFsbD14bixzLmFueT1EbixzLmNvbGxlY3Q9QW4scy5kZXRlY3Q9Tm4scy5kcm9wPU8scy5lYWNoPUNuLHMuZm9sZGw9TW4scy5mb2xkcj1OLHMuaGVhZD1DLHMuaW5jbHVkZT1FbixzLmluamVjdD1NbixzLm1ldGhvZHM9aG4scy5zZWxlY3Q9VG4scy50YWlsPU8scy50YWtlPUMscy51bmlxdWU9XyxDbih7RGF0ZTpUdCxOdW1iZXI6TnQsUmVnRXhwOmt0LFN0cmluZzpMdH0sZnVuY3Rpb24oZSx0KXtzW1wiaXNcIit0XT1mdW5jdGlvbih0KXtyZXR1cm4gaHQuY2FsbCh0KT09ZX19KSxvLnByb3RvdHlwZT1zLnByb3RvdHlwZSxIKHMpLG8ucHJvdG90eXBlLmNoYWluPWZ1bmN0aW9uKFxuKXtyZXR1cm4gdGhpcy5fX2NoYWluX189bix0aGlzfSxvLnByb3RvdHlwZS52YWx1ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9fd3JhcHBlZF9ffSxDbihcInBvcCBwdXNoIHJldmVyc2Ugc2hpZnQgc29ydCBzcGxpY2UgdW5zaGlmdFwiLnNwbGl0KFwiIFwiKSxmdW5jdGlvbihlKXt2YXIgdD1SW2VdO28ucHJvdG90eXBlW2VdPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5fX3dyYXBwZWRfXztyZXR1cm4gdC5hcHBseShlLGFyZ3VtZW50cyksX3QmJmUubGVuZ3RoPT09MCYmZGVsZXRlIGVbMF0sdGhpcy5fX2NoYWluX18mJihlPW5ldyBvKGUpLGUuX19jaGFpbl9fPW4pLGV9fSksQ24oW1wiY29uY2F0XCIsXCJqb2luXCIsXCJzbGljZVwiXSxmdW5jdGlvbihlKXt2YXIgdD1SW2VdO28ucHJvdG90eXBlW2VdPWZ1bmN0aW9uKCl7dmFyIGU9dC5hcHBseSh0aGlzLl9fd3JhcHBlZF9fLGFyZ3VtZW50cyk7cmV0dXJuIHRoaXMuX19jaGFpbl9fJiYoZT1uZXcgbyhlKSxlLl9fY2hhaW5fXz1uKSxlfX0pLHR5cGVvZiBcbmRlZmluZT09XCJmdW5jdGlvblwiJiZ0eXBlb2YgZGVmaW5lLmFtZD09XCJvYmplY3RcIiYmZGVmaW5lLmFtZD8oZS5fPXMsZGVmaW5lKGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSk6cT9cIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlJiZtb2R1bGUmJm1vZHVsZS5leHBvcnRzPT1xPyhtb2R1bGUuZXhwb3J0cz1zKS5fPXM6cS5fPXM6ZS5fPXN9KSh0aGlzKTtcbn0pKHNlbGYpIiwiKGZ1bmN0aW9uKGdsb2JhbCl7LyoqXG4gKiBtYXJrZWQgLSBBIG1hcmtkb3duIHBhcnNlciAoaHR0cHM6Ly9naXRodWIuY29tL2NoamovbWFya2VkKVxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTIsIENocmlzdG9waGVyIEplZmZyZXkuIChNSVQgTGljZW5zZWQpXG4gKi9cblxuOyhmdW5jdGlvbigpIHtcblxuLyoqXG4gKiBCbG9jay1MZXZlbCBHcmFtbWFyXG4gKi9cblxudmFyIGJsb2NrID0ge1xuICBuZXdsaW5lOiAvXlxcbisvLFxuICBjb2RlOiAvXiggezR9W15cXG5dK1xcbiopKy8sXG4gIGZlbmNlczogbm9vcCxcbiAgaHI6IC9eKCAqWy0qX10pezMsfSAqKD86XFxuK3wkKS8sXG4gIGhlYWRpbmc6IC9eICooI3sxLDZ9KSAqKFteXFxuXSs/KSAqIyogKig/Olxcbit8JCkvLFxuICBsaGVhZGluZzogL14oW15cXG5dKylcXG4gKig9fC0pezMsfSAqXFxuKi8sXG4gIGJsb2NrcXVvdGU6IC9eKCAqPlteXFxuXSsoXFxuW15cXG5dKykqXFxuKikrLyxcbiAgbGlzdDogL14oICopKGJ1bGwpIFteXFwwXSs/KD86aHJ8XFxuezIsfSg/ISApKD8hXFwxYnVsbCApXFxuKnxcXHMqJCkvLFxuICBodG1sOiAvXiAqKD86Y29tbWVudHxjbG9zZWR8Y2xvc2luZykgKig/OlxcbnsyLH18XFxzKiQpLyxcbiAgZGVmOiAvXiAqXFxbKFteXFxdXSspXFxdOiAqKFteXFxzXSspKD86ICtbXCIoXShbXlxcbl0rKVtcIildKT8gKig/Olxcbit8JCkvLFxuICBwYXJhZ3JhcGg6IC9eKFteXFxuXStcXG4/KD8haHJ8aGVhZGluZ3xsaGVhZGluZ3xibG9ja3F1b3RlfHRhZ3xkZWYpKStcXG4qLyxcbiAgdGV4dDogL15bXlxcbl0rL1xufTtcblxuYmxvY2suYnVsbGV0ID0gLyg/OlsqKy1dfFxcZCtcXC4pLztcbmJsb2NrLml0ZW0gPSAvXiggKikoYnVsbCkgW15cXG5dKig/Olxcbig/IVxcMWJ1bGwgKVteXFxuXSopKi87XG5ibG9jay5pdGVtID0gcmVwbGFjZShibG9jay5pdGVtLCAnZ20nKVxuICAoL2J1bGwvZywgYmxvY2suYnVsbGV0KVxuICAoKTtcblxuYmxvY2subGlzdCA9IHJlcGxhY2UoYmxvY2subGlzdClcbiAgKC9idWxsL2csIGJsb2NrLmJ1bGxldClcbiAgKCdocicsIC9cXG4rKD89KD86ICpbLSpfXSl7Myx9ICooPzpcXG4rfCQpKS8pXG4gICgpO1xuXG5ibG9jay5odG1sID0gcmVwbGFjZShibG9jay5odG1sKVxuICAoJ2NvbW1lbnQnLCAvPCEtLVteXFwwXSo/LS0+LylcbiAgKCdjbG9zZWQnLCAvPCh0YWcpW15cXDBdKz88XFwvXFwxPi8pXG4gICgnY2xvc2luZycsIC88dGFnKD86XCJbXlwiXSpcInwnW14nXSonfFteJ1wiPl0pKj8+LylcbiAgKC90YWcvZywgdGFnKCkpXG4gICgpO1xuXG5ibG9jay5wYXJhZ3JhcGggPSByZXBsYWNlKGJsb2NrLnBhcmFncmFwaClcbiAgKCdocicsIGJsb2NrLmhyKVxuICAoJ2hlYWRpbmcnLCBibG9jay5oZWFkaW5nKVxuICAoJ2xoZWFkaW5nJywgYmxvY2subGhlYWRpbmcpXG4gICgnYmxvY2txdW90ZScsIGJsb2NrLmJsb2NrcXVvdGUpXG4gICgndGFnJywgJzwnICsgdGFnKCkpXG4gICgnZGVmJywgYmxvY2suZGVmKVxuICAoKTtcblxuYmxvY2subm9ybWFsID0ge1xuICBmZW5jZXM6IGJsb2NrLmZlbmNlcyxcbiAgcGFyYWdyYXBoOiBibG9jay5wYXJhZ3JhcGhcbn07XG5cbmJsb2NrLmdmbSA9IHtcbiAgZmVuY2VzOiAvXiAqKGBgYHx+fn4pICooXFx3Kyk/ICpcXG4oW15cXDBdKz8pXFxzKlxcMSAqKD86XFxuK3wkKS8sXG4gIHBhcmFncmFwaDogL14vXG59O1xuXG5ibG9jay5nZm0ucGFyYWdyYXBoID0gcmVwbGFjZShibG9jay5wYXJhZ3JhcGgpXG4gICgnKD8hJywgJyg/IScgKyBibG9jay5nZm0uZmVuY2VzLnNvdXJjZS5yZXBsYWNlKCdcXFxcMScsICdcXFxcMicpICsgJ3wnKVxuICAoKTtcblxuLyoqXG4gKiBCbG9jayBMZXhlclxuICovXG5cbmJsb2NrLmxleGVyID0gZnVuY3Rpb24oc3JjKSB7XG4gIHZhciB0b2tlbnMgPSBbXTtcblxuICB0b2tlbnMubGlua3MgPSB7fTtcblxuICBzcmMgPSBzcmNcbiAgICAucmVwbGFjZSgvXFxyXFxufFxcci9nLCAnXFxuJylcbiAgICAucmVwbGFjZSgvXFx0L2csICcgICAgJyk7XG5cbiAgcmV0dXJuIGJsb2NrLnRva2VuKHNyYywgdG9rZW5zLCB0cnVlKTtcbn07XG5cbmJsb2NrLnRva2VuID0gZnVuY3Rpb24oc3JjLCB0b2tlbnMsIHRvcCkge1xuICB2YXIgc3JjID0gc3JjLnJlcGxhY2UoL14gKyQvZ20sICcnKVxuICAgICwgbmV4dFxuICAgICwgbG9vc2VcbiAgICAsIGNhcFxuICAgICwgaXRlbVxuICAgICwgc3BhY2VcbiAgICAsIGlcbiAgICAsIGxcbiAgICAsIHN0YXJ0O1xuXG4gIHdoaWxlIChzcmMpIHtcbiAgICBzdGFydCA9IHNyYy5sZW5ndGg7XG4gICAgLy8gbmV3bGluZVxuICAgIGlmIChjYXAgPSBibG9jay5uZXdsaW5lLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIGlmIChjYXBbMF0ubGVuZ3RoID4gMSkge1xuICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogJ3NwYWNlJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb2RlXG4gICAgaWYgKGNhcCA9IGJsb2NrLmNvZGUuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgY2FwID0gY2FwWzBdLnJlcGxhY2UoL14gezR9L2dtLCAnJyk7XG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdjb2RlJyxcbiAgICAgICAgdGV4dDogIW9wdGlvbnMucGVkYW50aWNcbiAgICAgICAgICA/IGNhcC5yZXBsYWNlKC9cXG4rJC8sICcnKVxuICAgICAgICAgIDogY2FwLFxuICAgICAgICB0ZXh0TGVuOiBzdGFydCAtIHNyYy5sZW5ndGgsXG4gICAgICAgIHJlbWFpbjogc3JjLmxlbmd0aFxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBmZW5jZXMgKGdmbSlcbiAgICBpZiAoY2FwID0gYmxvY2suZmVuY2VzLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICBsYW5nOiBjYXBbMl0sXG4gICAgICAgIHRleHQ6IGNhcFszXSxcbiAgICAgICAgdGV4dExlbjogc3RhcnQgLSBzcmMubGVuZ3RoLFxuICAgICAgICByZW1haW46IHNyYy5sZW5ndGhcbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gaGVhZGluZ1xuICAgIGlmIChjYXAgPSBibG9jay5oZWFkaW5nLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgICAgICBkZXB0aDogY2FwWzFdLmxlbmd0aCxcbiAgICAgICAgdGV4dDogY2FwWzJdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGxoZWFkaW5nXG4gICAgaWYgKGNhcCA9IGJsb2NrLmxoZWFkaW5nLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgICAgICBkZXB0aDogY2FwWzJdID09PSAnPScgPyAxIDogMixcbiAgICAgICAgdGV4dDogY2FwWzFdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGhyXG4gICAgaWYgKGNhcCA9IGJsb2NrLmhyLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2hyJ1xuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBibG9ja3F1b3RlXG4gICAgaWYgKGNhcCA9IGJsb2NrLmJsb2NrcXVvdGUuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuXG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdibG9ja3F1b3RlX3N0YXJ0J1xuICAgICAgfSk7XG5cbiAgICAgIGNhcCA9IGNhcFswXS5yZXBsYWNlKC9eICo+ID8vZ20sICcnKTtcblxuICAgICAgLy8gUGFzcyBgdG9wYCB0byBrZWVwIHRoZSBjdXJyZW50XG4gICAgICAvLyBcInRvcGxldmVsXCIgc3RhdGUuIFRoaXMgaXMgZXhhY3RseVxuICAgICAgLy8gaG93IG1hcmtkb3duLnBsIHdvcmtzLlxuICAgICAgYmxvY2sudG9rZW4oY2FwLCB0b2tlbnMsIHRvcCk7XG5cbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2Jsb2NrcXVvdGVfZW5kJ1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGxpc3RcbiAgICBpZiAoY2FwID0gYmxvY2subGlzdC5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG5cbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2xpc3Rfc3RhcnQnLFxuICAgICAgICBvcmRlcmVkOiBpc0Zpbml0ZShjYXBbMl0pXG4gICAgICB9KTtcblxuICAgICAgLy8gR2V0IGVhY2ggdG9wLWxldmVsIGl0ZW0uXG4gICAgICBjYXAgPSBjYXBbMF0ubWF0Y2goYmxvY2suaXRlbSk7XG5cbiAgICAgIG5leHQgPSBmYWxzZTtcbiAgICAgIGwgPSBjYXAubGVuZ3RoO1xuICAgICAgaSA9IDA7XG5cbiAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBjYXBbaV07XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBsaXN0IGl0ZW0ncyBidWxsZXRcbiAgICAgICAgLy8gc28gaXQgaXMgc2VlbiBhcyB0aGUgbmV4dCB0b2tlbi5cbiAgICAgICAgc3BhY2UgPSBpdGVtLmxlbmd0aDtcbiAgICAgICAgaXRlbSA9IGl0ZW0ucmVwbGFjZSgvXiAqKFsqKy1dfFxcZCtcXC4pICsvLCAnJyk7XG5cbiAgICAgICAgLy8gT3V0ZGVudCB3aGF0ZXZlciB0aGVcbiAgICAgICAgLy8gbGlzdCBpdGVtIGNvbnRhaW5zLiBIYWNreS5cbiAgICAgICAgaWYgKH5pdGVtLmluZGV4T2YoJ1xcbiAnKSkge1xuICAgICAgICAgIHNwYWNlIC09IGl0ZW0ubGVuZ3RoO1xuICAgICAgICAgIGl0ZW0gPSAhb3B0aW9ucy5wZWRhbnRpY1xuICAgICAgICAgICAgPyBpdGVtLnJlcGxhY2UobmV3IFJlZ0V4cCgnXiB7MSwnICsgc3BhY2UgKyAnfScsICdnbScpLCAnJylcbiAgICAgICAgICAgIDogaXRlbS5yZXBsYWNlKC9eIHsxLDR9L2dtLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgd2hldGhlciBpdGVtIGlzIGxvb3NlIG9yIG5vdC5cbiAgICAgICAgLy8gVXNlOiAvKF58XFxuKSg/ISApW15cXG5dK1xcblxcbig/IVxccyokKS9cbiAgICAgICAgLy8gZm9yIGRpc2NvdW50IGJlaGF2aW9yLlxuICAgICAgICBsb29zZSA9IG5leHQgfHwgL1xcblxcbig/IVxccyokKS8udGVzdChpdGVtKTtcbiAgICAgICAgaWYgKGkgIT09IGwgLSAxKSB7XG4gICAgICAgICAgbmV4dCA9IGl0ZW1baXRlbS5sZW5ndGgtMV0gPT09ICdcXG4nO1xuICAgICAgICAgIGlmICghbG9vc2UpIGxvb3NlID0gbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBsb29zZVxuICAgICAgICAgICAgPyAnbG9vc2VfaXRlbV9zdGFydCdcbiAgICAgICAgICAgIDogJ2xpc3RfaXRlbV9zdGFydCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmVjdXJzZS5cbiAgICAgICAgYmxvY2sudG9rZW4oaXRlbSwgdG9rZW5zKTtcblxuICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogJ2xpc3RfaXRlbV9lbmQnXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdsaXN0X2VuZCdcbiAgICAgIH0pO1xuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBodG1sXG4gICAgaWYgKGNhcCA9IGJsb2NrLmh0bWwuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiBvcHRpb25zLnNhbml0aXplXG4gICAgICAgICAgPyAncGFyYWdyYXBoJ1xuICAgICAgICAgIDogJ2h0bWwnLFxuICAgICAgICBwcmU6IGNhcFsxXSA9PT0gJ3ByZScsXG4gICAgICAgIHRleHQ6IGNhcFswXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBkZWZcbiAgICBpZiAodG9wICYmIChjYXAgPSBibG9jay5kZWYuZXhlYyhzcmMpKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRva2Vucy5saW5rc1tjYXBbMV0udG9Mb3dlckNhc2UoKV0gPSB7XG4gICAgICAgIGhyZWY6IGNhcFsyXSxcbiAgICAgICAgdGl0bGU6IGNhcFszXVxuICAgICAgfTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRvcC1sZXZlbCBwYXJhZ3JhcGhcbiAgICBpZiAodG9wICYmIChjYXAgPSBibG9jay5wYXJhZ3JhcGguZXhlYyhzcmMpKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ3BhcmFncmFwaCcsXG4gICAgICAgIHRleHQ6IGNhcFswXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0ZXh0XG4gICAgaWYgKGNhcCA9IGJsb2NrLnRleHQuZXhlYyhzcmMpKSB7XG4gICAgICAvLyBUb3AtbGV2ZWwgc2hvdWxkIG5ldmVyIHJlYWNoIGhlcmUuXG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgIHRleHQ6IGNhcFswXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG9rZW5zO1xufTtcblxuLyoqXG4gKiBJbmxpbmUgUHJvY2Vzc2luZ1xuICovXG5cbnZhciBpbmxpbmUgPSB7XG4gIGVzY2FwZTogL15cXFxcKFtcXFxcYCp7fVxcW1xcXSgpIytcXC0uIV8+XSkvLFxuICBhdXRvbGluazogL148KFteID5dKyhAfDpcXC8pW14gPl0rKT4vLFxuICB1cmw6IG5vb3AsXG4gIHRhZzogL148IS0tW15cXDBdKj8tLT58XjxcXC8/XFx3Kyg/OlwiW15cIl0qXCJ8J1teJ10qJ3xbXidcIj5dKSo/Pi8sXG4gIGxpbms6IC9eIT9cXFsoaW5zaWRlKVxcXVxcKGhyZWZcXCkvLFxuICByZWZsaW5rOiAvXiE/XFxbKGluc2lkZSlcXF1cXHMqXFxbKFteXFxdXSopXFxdLyxcbiAgbm9saW5rOiAvXiE/XFxbKCg/OlxcW1teXFxdXSpcXF18W15cXFtcXF1dKSopXFxdLyxcbiAgc3Ryb25nOiAvXl9fKFteXFwwXSs/KV9fKD8hXyl8XlxcKlxcKihbXlxcMF0rPylcXCpcXCooPyFcXCopLyxcbiAgZW06IC9eXFxiXygoPzpfX3xbXlxcMF0pKz8pX1xcYnxeXFwqKCg/OlxcKlxcKnxbXlxcMF0pKz8pXFwqKD8hXFwqKS8sXG4gIGNvZGU6IC9eKGArKShbXlxcMF0qP1teYF0pXFwxKD8hYCkvLFxuICBicjogL14gezIsfVxcbig/IVxccyokKS8sXG4gIHRleHQ6IC9eW15cXDBdKz8oPz1bXFxcXDwhXFxbXypgXXwgezIsfVxcbnwkKS9cbn07XG5cbmlubGluZS5fbGlua0luc2lkZSA9IC8oPzpcXFtbXlxcXV0qXFxdfFteXFxdXXxcXF0oPz1bXlxcW10qXFxdKSkqLztcbmlubGluZS5fbGlua0hyZWYgPSAvXFxzKjw/KFteXFxzXSo/KT4/KD86XFxzK1snXCJdKFteXFwwXSo/KVsnXCJdKT9cXHMqLztcblxuaW5saW5lLmxpbmsgPSByZXBsYWNlKGlubGluZS5saW5rKVxuICAoJ2luc2lkZScsIGlubGluZS5fbGlua0luc2lkZSlcbiAgKCdocmVmJywgaW5saW5lLl9saW5rSHJlZilcbiAgKCk7XG5cbmlubGluZS5yZWZsaW5rID0gcmVwbGFjZShpbmxpbmUucmVmbGluaylcbiAgKCdpbnNpZGUnLCBpbmxpbmUuX2xpbmtJbnNpZGUpXG4gICgpO1xuXG5pbmxpbmUubm9ybWFsID0ge1xuICB1cmw6IGlubGluZS51cmwsXG4gIHN0cm9uZzogaW5saW5lLnN0cm9uZyxcbiAgZW06IGlubGluZS5lbSxcbiAgdGV4dDogaW5saW5lLnRleHRcbn07XG5cbmlubGluZS5wZWRhbnRpYyA9IHtcbiAgc3Ryb25nOiAvXl9fKD89XFxTKShbXlxcMF0qP1xcUylfXyg/IV8pfF5cXCpcXCooPz1cXFMpKFteXFwwXSo/XFxTKVxcKlxcKig/IVxcKikvLFxuICBlbTogL15fKD89XFxTKShbXlxcMF0qP1xcUylfKD8hXyl8XlxcKig/PVxcUykoW15cXDBdKj9cXFMpXFwqKD8hXFwqKS9cbn07XG5cbmlubGluZS5nZm0gPSB7XG4gIHVybDogL14oaHR0cHM/OlxcL1xcL1teXFxzXStbXi4sOjtcIicpXFxdXFxzXSkvLFxuICB0ZXh0OiAvXlteXFwwXSs/KD89W1xcXFw8IVxcW18qYF18aHR0cHM/OlxcL1xcL3wgezIsfVxcbnwkKS9cbn07XG5cbi8qKlxuICogSW5saW5lIExleGVyXG4gKi9cblxuaW5saW5lLmxleGVyID0gZnVuY3Rpb24oc3JjKSB7XG4gIHZhciBvdXQgPSAnJ1xuICAgICwgbGlua3MgPSB0b2tlbnMubGlua3NcbiAgICAsIGxpbmtcbiAgICAsIHRleHRcbiAgICAsIGhyZWZcbiAgICAsIGNhcDtcblxuICB3aGlsZSAoc3JjKSB7XG4gICAgLy8gZXNjYXBlXG4gICAgaWYgKGNhcCA9IGlubGluZS5lc2NhcGUuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IGNhcFsxXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGF1dG9saW5rXG4gICAgaWYgKGNhcCA9IGlubGluZS5hdXRvbGluay5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBpZiAoY2FwWzJdID09PSAnQCcpIHtcbiAgICAgICAgdGV4dCA9IGNhcFsxXVs2XSA9PT0gJzonXG4gICAgICAgICAgPyBtYW5nbGUoY2FwWzFdLnN1YnN0cmluZyg3KSlcbiAgICAgICAgICA6IG1hbmdsZShjYXBbMV0pO1xuICAgICAgICBocmVmID0gbWFuZ2xlKCdtYWlsdG86JykgKyB0ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dCA9IGVzY2FwZShjYXBbMV0pO1xuICAgICAgICBocmVmID0gdGV4dDtcbiAgICAgIH1cbiAgICAgIG91dCArPSAnPGEgaHJlZj1cIidcbiAgICAgICAgKyBocmVmXG4gICAgICAgICsgJ1wiPidcbiAgICAgICAgKyB0ZXh0XG4gICAgICAgICsgJzwvYT4nO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdXJsIChnZm0pXG4gICAgaWYgKGNhcCA9IGlubGluZS51cmwuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGV4dCA9IGVzY2FwZShjYXBbMV0pO1xuICAgICAgaHJlZiA9IHRleHQ7XG4gICAgICBvdXQgKz0gJzxhIGhyZWY9XCInXG4gICAgICAgICsgaHJlZlxuICAgICAgICArICdcIj4nXG4gICAgICAgICsgdGV4dFxuICAgICAgICArICc8L2E+JztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRhZ1xuICAgIGlmIChjYXAgPSBpbmxpbmUudGFnLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSBvcHRpb25zLnNhbml0aXplXG4gICAgICAgID8gZXNjYXBlKGNhcFswXSlcbiAgICAgICAgOiBjYXBbMF07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBsaW5rXG4gICAgaWYgKGNhcCA9IGlubGluZS5saW5rLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSBvdXRwdXRMaW5rKGNhcCwge1xuICAgICAgICBocmVmOiBjYXBbMl0sXG4gICAgICAgIHRpdGxlOiBjYXBbM11cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gcmVmbGluaywgbm9saW5rXG4gICAgaWYgKChjYXAgPSBpbmxpbmUucmVmbGluay5leGVjKHNyYykpXG4gICAgICAgIHx8IChjYXAgPSBpbmxpbmUubm9saW5rLmV4ZWMoc3JjKSkpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBsaW5rID0gKGNhcFsyXSB8fCBjYXBbMV0pLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICAgIGxpbmsgPSBsaW5rc1tsaW5rLnRvTG93ZXJDYXNlKCldO1xuICAgICAgaWYgKCFsaW5rIHx8ICFsaW5rLmhyZWYpIHtcbiAgICAgICAgb3V0ICs9IGNhcFswXVswXTtcbiAgICAgICAgc3JjID0gY2FwWzBdLnN1YnN0cmluZygxKSArIHNyYztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBvdXQgKz0gb3V0cHV0TGluayhjYXAsIGxpbmspO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gc3Ryb25nXG4gICAgaWYgKGNhcCA9IGlubGluZS5zdHJvbmcuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9ICc8c3Ryb25nPidcbiAgICAgICAgKyBpbmxpbmUubGV4ZXIoY2FwWzJdIHx8IGNhcFsxXSlcbiAgICAgICAgKyAnPC9zdHJvbmc+JztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGVtXG4gICAgaWYgKGNhcCA9IGlubGluZS5lbS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gJzxlbT4nXG4gICAgICAgICsgaW5saW5lLmxleGVyKGNhcFsyXSB8fCBjYXBbMV0pXG4gICAgICAgICsgJzwvZW0+JztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGNvZGVcbiAgICBpZiAoY2FwID0gaW5saW5lLmNvZGUuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9ICc8Y29kZT4nXG4gICAgICAgICsgZXNjYXBlKGNhcFsyXSwgdHJ1ZSlcbiAgICAgICAgKyAnPC9jb2RlPic7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBiclxuICAgIGlmIChjYXAgPSBpbmxpbmUuYnIuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9ICc8YnI+JztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRleHRcbiAgICBpZiAoY2FwID0gaW5saW5lLnRleHQuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IGVzY2FwZShjYXBbMF0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbmZ1bmN0aW9uIG91dHB1dExpbmsoY2FwLCBsaW5rKSB7XG4gIGlmIChjYXBbMF1bMF0gIT09ICchJykge1xuICAgIHJldHVybiAnPGEgaHJlZj1cIidcbiAgICAgICsgZXNjYXBlKGxpbmsuaHJlZilcbiAgICAgICsgJ1wiJ1xuICAgICAgKyAobGluay50aXRsZVxuICAgICAgPyAnIHRpdGxlPVwiJ1xuICAgICAgKyBlc2NhcGUobGluay50aXRsZSlcbiAgICAgICsgJ1wiJ1xuICAgICAgOiAnJylcbiAgICAgICsgJz4nXG4gICAgICArIGlubGluZS5sZXhlcihjYXBbMV0pXG4gICAgICArICc8L2E+JztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJzxpbWcgc3JjPVwiJ1xuICAgICAgKyBlc2NhcGUobGluay5ocmVmKVxuICAgICAgKyAnXCIgYWx0PVwiJ1xuICAgICAgKyBlc2NhcGUoY2FwWzFdKVxuICAgICAgKyAnXCInXG4gICAgICArIChsaW5rLnRpdGxlXG4gICAgICA/ICcgdGl0bGU9XCInXG4gICAgICArIGVzY2FwZShsaW5rLnRpdGxlKVxuICAgICAgKyAnXCInXG4gICAgICA6ICcnKVxuICAgICAgKyAnPic7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzaW5nXG4gKi9cblxudmFyIHRva2Vuc1xuICAsIHRva2VuO1xuXG5mdW5jdGlvbiBuZXh0KCkge1xuICByZXR1cm4gdG9rZW4gPSB0b2tlbnMucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHRvaygpIHtcbiAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgY2FzZSAnc3BhY2UnOiB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGNhc2UgJ2hyJzoge1xuICAgICAgcmV0dXJuICc8aHI+XFxuJztcbiAgICB9XG4gICAgY2FzZSAnaGVhZGluZyc6IHtcbiAgICAgIHJldHVybiAnPGgnXG4gICAgICAgICsgdG9rZW4uZGVwdGhcbiAgICAgICAgKyAnPidcbiAgICAgICAgKyBpbmxpbmUubGV4ZXIodG9rZW4udGV4dClcbiAgICAgICAgKyAnPC9oJ1xuICAgICAgICArIHRva2VuLmRlcHRoXG4gICAgICAgICsgJz5cXG4nO1xuICAgIH1cbiAgICBjYXNlICdjb2RlJzoge1xuICAgICAgaWYgKG9wdGlvbnMuaGlnaGxpZ2h0KSB7XG4gICAgICAgIHRva2VuLmNvZGUgPSBvcHRpb25zLmhpZ2hsaWdodCh0b2tlbi50ZXh0LCB0b2tlbi5sYW5nKTtcbiAgICAgICAgaWYgKHRva2VuLmNvZGUgIT0gbnVsbCAmJiB0b2tlbi5jb2RlICE9PSB0b2tlbi50ZXh0KSB7XG4gICAgICAgICAgdG9rZW4uZXNjYXBlZCA9IHRydWU7XG4gICAgICAgICAgdG9rZW4udGV4dCA9IHRva2VuLmNvZGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF0b2tlbi5lc2NhcGVkKSB7XG4gICAgICAgIHRva2VuLnRleHQgPSBlc2NhcGUodG9rZW4udGV4dCwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnPHByZT48Y29kZSdcbiAgICAgICAgKyAodG9rZW4ubGFuZ1xuICAgICAgICA/ICcgY2xhc3M9XCJsYW5nLSdcbiAgICAgICAgKyB0b2tlbi5sYW5nXG4gICAgICAgICsgJ1wiJ1xuICAgICAgICA6ICcnKVxuICAgICAgICArICc+J1xuICAgICAgICArIHRva2VuLnRleHRcbiAgICAgICAgKyAnPC9jb2RlPjwvcHJlPlxcbic7XG4gICAgfVxuICAgIGNhc2UgJ2Jsb2NrcXVvdGVfc3RhcnQnOiB7XG4gICAgICB2YXIgYm9keSA9ICcnO1xuXG4gICAgICB3aGlsZSAobmV4dCgpLnR5cGUgIT09ICdibG9ja3F1b3RlX2VuZCcpIHtcbiAgICAgICAgYm9keSArPSB0b2soKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICc8YmxvY2txdW90ZT5cXG4nXG4gICAgICAgICsgYm9keVxuICAgICAgICArICc8L2Jsb2NrcXVvdGU+XFxuJztcbiAgICB9XG4gICAgY2FzZSAnbGlzdF9zdGFydCc6IHtcbiAgICAgIHZhciB0eXBlID0gdG9rZW4ub3JkZXJlZCA/ICdvbCcgOiAndWwnXG4gICAgICAgICwgYm9keSA9ICcnO1xuXG4gICAgICB3aGlsZSAobmV4dCgpLnR5cGUgIT09ICdsaXN0X2VuZCcpIHtcbiAgICAgICAgYm9keSArPSB0b2soKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICc8J1xuICAgICAgICArIHR5cGVcbiAgICAgICAgKyAnPlxcbidcbiAgICAgICAgKyBib2R5XG4gICAgICAgICsgJzwvJ1xuICAgICAgICArIHR5cGVcbiAgICAgICAgKyAnPlxcbic7XG4gICAgfVxuICAgIGNhc2UgJ2xpc3RfaXRlbV9zdGFydCc6IHtcbiAgICAgIHZhciBib2R5ID0gJyc7XG5cbiAgICAgIHdoaWxlIChuZXh0KCkudHlwZSAhPT0gJ2xpc3RfaXRlbV9lbmQnKSB7XG4gICAgICAgIGJvZHkgKz0gdG9rZW4udHlwZSA9PT0gJ3RleHQnXG4gICAgICAgICAgPyBwYXJzZVRleHQoKVxuICAgICAgICAgIDogdG9rKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnPGxpPidcbiAgICAgICAgKyBib2R5XG4gICAgICAgICsgJzwvbGk+XFxuJztcbiAgICB9XG4gICAgY2FzZSAnbG9vc2VfaXRlbV9zdGFydCc6IHtcbiAgICAgIHZhciBib2R5ID0gJyc7XG5cbiAgICAgIHdoaWxlIChuZXh0KCkudHlwZSAhPT0gJ2xpc3RfaXRlbV9lbmQnKSB7XG4gICAgICAgIGJvZHkgKz0gdG9rKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnPGxpPidcbiAgICAgICAgKyBib2R5XG4gICAgICAgICsgJzwvbGk+XFxuJztcbiAgICB9XG4gICAgY2FzZSAnaHRtbCc6IHtcbiAgICAgIHJldHVybiAhdG9rZW4ucHJlICYmICFvcHRpb25zLnBlZGFudGljXG4gICAgICAgID8gaW5saW5lLmxleGVyKHRva2VuLnRleHQpXG4gICAgICAgIDogdG9rZW4udGV4dDtcbiAgICB9XG4gICAgY2FzZSAncGFyYWdyYXBoJzoge1xuICAgICAgcmV0dXJuICc8cD4nXG4gICAgICAgICsgaW5saW5lLmxleGVyKHRva2VuLnRleHQpXG4gICAgICAgICsgJzwvcD5cXG4nO1xuICAgIH1cbiAgICBjYXNlICd0ZXh0Jzoge1xuICAgICAgcmV0dXJuICc8cD4nXG4gICAgICAgICsgcGFyc2VUZXh0KClcbiAgICAgICAgKyAnPC9wPlxcbic7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlVGV4dCgpIHtcbiAgdmFyIGJvZHkgPSB0b2tlbi50ZXh0XG4gICAgLCB0b3A7XG5cbiAgd2hpbGUgKCh0b3AgPSB0b2tlbnNbdG9rZW5zLmxlbmd0aC0xXSlcbiAgICAgICAgICYmIHRvcC50eXBlID09PSAndGV4dCcpIHtcbiAgICBib2R5ICs9ICdcXG4nICsgbmV4dCgpLnRleHQ7XG4gIH1cblxuICByZXR1cm4gaW5saW5lLmxleGVyKGJvZHkpO1xufVxuXG5mdW5jdGlvbiBwYXJzZShzcmMpIHtcbiAgdG9rZW5zID0gc3JjLnJldmVyc2UoKTtcblxuICB2YXIgb3V0ID0gJyc7XG4gIHdoaWxlIChuZXh0KCkpIHtcbiAgICBvdXQgKz0gdG9rKCk7XG4gIH1cblxuICB0b2tlbnMgPSBudWxsO1xuICB0b2tlbiA9IG51bGw7XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBIZWxwZXJzXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlKGh0bWwsIGVuY29kZSkge1xuICByZXR1cm4gaHRtbFxuICAgIC5yZXBsYWNlKCFlbmNvZGUgPyAvJig/ISM/XFx3KzspL2cgOiAvJi9nLCAnJmFtcDsnKVxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKVxuICAgIC5yZXBsYWNlKC8nL2csICcmIzM5OycpO1xufVxuXG5mdW5jdGlvbiBtYW5nbGUodGV4dCkge1xuICB2YXIgb3V0ID0gJydcbiAgICAsIGwgPSB0ZXh0Lmxlbmd0aFxuICAgICwgaSA9IDBcbiAgICAsIGNoO1xuXG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgY2ggPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjUpIHtcbiAgICAgIGNoID0gJ3gnICsgY2gudG9TdHJpbmcoMTYpO1xuICAgIH1cbiAgICBvdXQgKz0gJyYjJyArIGNoICsgJzsnO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gdGFnKCkge1xuICB2YXIgdGFnID0gJyg/ISg/OidcbiAgICArICdhfGVtfHN0cm9uZ3xzbWFsbHxzfGNpdGV8cXxkZm58YWJicnxkYXRhfHRpbWV8Y29kZSdcbiAgICArICd8dmFyfHNhbXB8a2JkfHN1YnxzdXB8aXxifHV8bWFya3xydWJ5fHJ0fHJwfGJkaXxiZG8nXG4gICAgKyAnfHNwYW58YnJ8d2JyfGluc3xkZWx8aW1nKVxcXFxiKVxcXFx3Kyg/ITovfEApXFxcXGInO1xuXG4gIHJldHVybiB0YWc7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2UocmVnZXgsIG9wdCkge1xuICByZWdleCA9IHJlZ2V4LnNvdXJjZTtcbiAgb3B0ID0gb3B0IHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb24gc2VsZihuYW1lLCB2YWwpIHtcbiAgICBpZiAoIW5hbWUpIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4LCBvcHQpO1xuICAgIHZhbCA9IHZhbC5zb3VyY2UgfHwgdmFsO1xuICAgIHZhbCA9IHZhbC5yZXBsYWNlKC8oXnxbXlxcW10pXFxeL2csICckMScpO1xuICAgIHJlZ2V4ID0gcmVnZXgucmVwbGFjZShuYW1lLCB2YWwpO1xuICAgIHJldHVybiBzZWxmO1xuICB9O1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cbm5vb3AuZXhlYyA9IG5vb3A7XG5cbi8qKlxuICogTWFya2VkXG4gKi9cblxuZnVuY3Rpb24gbWFya2VkKHNyYywgb3B0KSB7XG4gIHNldE9wdGlvbnMob3B0KTtcbiAgaWYgKG9wdCAmJiBvcHQuc2F2ZUxleCkge1xuICAgIHJldHVybiBbcGFyc2UoYmxvY2subGV4ZXIoc3JjKSksIGJsb2NrLmxleGVyKHNyYyldO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXJzZShibG9jay5sZXhlcihzcmMpKTtcbiAgfVxufVxuXG4vKipcbiAqIE9wdGlvbnNcbiAqL1xuXG52YXIgb3B0aW9uc1xuICAsIGRlZmF1bHRzO1xuXG5mdW5jdGlvbiBzZXRPcHRpb25zKG9wdCkge1xuICBpZiAoIW9wdCkgb3B0ID0gZGVmYXVsdHM7XG4gIGlmIChvcHRpb25zID09PSBvcHQpIHJldHVybjtcbiAgb3B0aW9ucyA9IG9wdDtcblxuICBpZiAob3B0aW9ucy5nZm0pIHtcbiAgICBibG9jay5mZW5jZXMgPSBibG9jay5nZm0uZmVuY2VzO1xuICAgIGJsb2NrLnBhcmFncmFwaCA9IGJsb2NrLmdmbS5wYXJhZ3JhcGg7XG4gICAgaW5saW5lLnRleHQgPSBpbmxpbmUuZ2ZtLnRleHQ7XG4gICAgaW5saW5lLnVybCA9IGlubGluZS5nZm0udXJsO1xuICB9IGVsc2Uge1xuICAgIGJsb2NrLmZlbmNlcyA9IGJsb2NrLm5vcm1hbC5mZW5jZXM7XG4gICAgYmxvY2sucGFyYWdyYXBoID0gYmxvY2subm9ybWFsLnBhcmFncmFwaDtcbiAgICBpbmxpbmUudGV4dCA9IGlubGluZS5ub3JtYWwudGV4dDtcbiAgICBpbmxpbmUudXJsID0gaW5saW5lLm5vcm1hbC51cmw7XG4gIH1cblxuICBpZiAob3B0aW9ucy5wZWRhbnRpYykge1xuICAgIGlubGluZS5lbSA9IGlubGluZS5wZWRhbnRpYy5lbTtcbiAgICBpbmxpbmUuc3Ryb25nID0gaW5saW5lLnBlZGFudGljLnN0cm9uZztcbiAgfSBlbHNlIHtcbiAgICBpbmxpbmUuZW0gPSBpbmxpbmUubm9ybWFsLmVtO1xuICAgIGlubGluZS5zdHJvbmcgPSBpbmxpbmUubm9ybWFsLnN0cm9uZztcbiAgfVxufVxuXG5tYXJrZWQub3B0aW9ucyA9XG5tYXJrZWQuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdCkge1xuICBkZWZhdWx0cyA9IG9wdDtcbiAgc2V0T3B0aW9ucyhvcHQpO1xuICByZXR1cm4gbWFya2VkO1xufTtcblxubWFya2VkLnNldE9wdGlvbnMoe1xuICBnZm06IHRydWUsXG4gIHBlZGFudGljOiBmYWxzZSxcbiAgc2FuaXRpemU6IGZhbHNlLFxuICBoaWdobGlnaHQ6IG51bGxcbn0pO1xuXG4vKipcbiAqIEV4cG9zZVxuICovXG5cbm1hcmtlZC5wYXJzZXIgPSBmdW5jdGlvbihzcmMsIG9wdCkge1xuICBzZXRPcHRpb25zKG9wdCk7XG4gIHJldHVybiBwYXJzZShzcmMpO1xufTtcblxubWFya2VkLmxleGVyID0gZnVuY3Rpb24oc3JjLCBvcHQpIHtcbiAgc2V0T3B0aW9ucyhvcHQpO1xuICByZXR1cm4gYmxvY2subGV4ZXIoc3JjKTtcbn07XG5cbm1hcmtlZC5wYXJzZSA9IG1hcmtlZDtcblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gbWFya2VkO1xufSBlbHNlIHtcbiAgdGhpcy5tYXJrZWQgPSBtYXJrZWQ7XG59XG5cbn0pLmNhbGwoZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzIHx8ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbCk7XG59KCkpO1xuXG59KShzZWxmKSIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS42LjJcbihmdW5jdGlvbigpIHtcbiAgdmFyICQsIERPV05fQVJST1csIEVORCwgRU5URVIsIEVTQywgSE9NRSwgTEVGVF9BUlJPVywgTm90ZWJvb2ssIFBBR0VfRE9XTiwgUEFHRV9VUCwgUSwgUklHSFRfQVJST1csIFVQX0FSUk9XLCBhcnJvd3MsIGJpbmRNYXJrdXBEaXYsIGJpbmRTbGlkZXIsIGNob29zZVNsaWRlLCBjbGVhbkVtcHR5Tm9kZXMsIGNsb3NlV2luZG93LCBjb3VudFNsaWRlLCBjcmVhdGVOb2RlLCBkZWxheSwgZWRpdGluZ0VuYWJsZWQsIGVuYWJsZUVkaXRpbmcsIGVuYWJsZVNsaWRlQ29udHJvbHMsIGZpcnN0U2xpZGUsIGdldEVsZW1lbnRDb2RlLCBoYW5kbGVJbnRlcm5hbFNlY3Rpb25zLCBoaWRlU2xpZGUsIGluc2VydENvbnRyb2xzLCBpc0xlaXN1cmVDb2RlLCBqUXVlcnksIGxhc3RTbGlkZSwgbWFrZU1hcmt1cERpdiwgbWFrZVNlY3Rpb24sIG1ha2VTbGlkZURpdiwgbWFya3VwQnV0dG9ucywgbWFya3VwRWxlbWVudCwgbWFya3VwU2xpZGVDb250ZW50LCBtYXJrdXBTbGlkZXMsIG1lcmdlTGVpc3VyZUNvZGUsIG1lcmdlVXAsIG5leHRTaWJsaW5nLCBuZXh0U2xpZGUsIG50aFNsaWRlLCBvbGRTbGlkZSwgcGFkU2xpZGUsIHByZXNlbnRMZWlzdXJlQ29kZSwgcHJlc2VudFNsaWRlLCBwcmV2U2xpZGUsIHByZXZpb3VzU2libGluZywgcmVtb3ZlLCBzaG93U2xpZGUsIHNsaWRlQ29udHJvbHMsIHNsaWRlQ29udHJvbHNFbmFibGVkLCBzbGlkZUtleUxpc3RlbmVyLCBzbGlkZU5hbWUsIHNsaWRlUGF0LCBzbGlkZXMsIHNsaWRpbmcsIHRleHROb2RlLCB1bndyYXAsIHVud3JhcENvbnRlbnQsIF8sIF9yZWYsXG4gICAgX19pbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbihpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSByZXR1cm4gaTsgfSByZXR1cm4gLTE7IH07XG5cbiAgalF1ZXJ5ID0gd2luZG93LmpRdWVyeSwgJCA9IHdpbmRvdy4kLCBfID0gd2luZG93Ll87XG5cbiAgX3JlZiA9IE5vdGVib29rID0gcmVxdWlyZSgnLi9ub3RlYm9vaycpLCBFTlRFUiA9IF9yZWYuRU5URVIsIGRlbGF5ID0gX3JlZi5kZWxheSwgdGV4dE5vZGUgPSBfcmVmLnRleHROb2RlLCBjcmVhdGVOb2RlID0gX3JlZi5jcmVhdGVOb2RlLCByZW1vdmUgPSBfcmVmLnJlbW92ZSwgdW53cmFwID0gX3JlZi51bndyYXAsIGluc2VydENvbnRyb2xzID0gX3JlZi5pbnNlcnRDb250cm9scywgY2xlYW5FbXB0eU5vZGVzID0gX3JlZi5jbGVhbkVtcHR5Tm9kZXMsIGlzTGVpc3VyZUNvZGUgPSBfcmVmLmlzTGVpc3VyZUNvZGUsIGdldEVsZW1lbnRDb2RlID0gX3JlZi5nZXRFbGVtZW50Q29kZSwgcHJldmlvdXNTaWJsaW5nID0gX3JlZi5wcmV2aW91c1NpYmxpbmcsIG5leHRTaWJsaW5nID0gX3JlZi5uZXh0U2libGluZywgcHJlc2VudExlaXN1cmVDb2RlID0gX3JlZi5wcmVzZW50TGVpc3VyZUNvZGUsIG1lcmdlTGVpc3VyZUNvZGUgPSBfcmVmLm1lcmdlTGVpc3VyZUNvZGUsIGNsb3NlV2luZG93ID0gX3JlZi5jbG9zZVdpbmRvdywgbWFya3VwQnV0dG9ucyA9IF9yZWYubWFya3VwQnV0dG9ucywgRVNDID0gX3JlZi5FU0MsIEhPTUUgPSBfcmVmLkhPTUUsIEVORCA9IF9yZWYuRU5ELCBQQUdFX1VQID0gX3JlZi5QQUdFX1VQLCBQQUdFX0RPV04gPSBfcmVmLlBBR0VfRE9XTiwgTEVGVF9BUlJPVyA9IF9yZWYuTEVGVF9BUlJPVywgUklHSFRfQVJST1cgPSBfcmVmLlJJR0hUX0FSUk9XLCBVUF9BUlJPVyA9IF9yZWYuVVBfQVJST1csIERPV05fQVJST1cgPSBfcmVmLkRPV05fQVJST1csIGFycm93cyA9IF9yZWYuYXJyb3dzO1xuXG4gIFEgPSA4MTtcblxuICB3aW5kb3cubWFya3VwID0gZnVuY3Rpb24obWQpIHtcbiAgICB2YXIgbWFpbmRvYywgbm9kZXMsIF9yZWYxO1xuXG4gICAgbm9kZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbbWFpbmRvY10nKTtcbiAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBtYWluZG9jID0gY3JlYXRlTm9kZShcIjxkaXYgbWFpbmRvYz48L2Rpdj5cIik7XG4gICAgICBkb2N1bWVudC5ib2R5Lmluc2VydEJlZm9yZShtYWluZG9jLCBkb2N1bWVudC5ib2R5LmZpcnN0Q2hpbGQpO1xuICAgICAgbm9kZXMgPSBbbWFpbmRvY107XG4gICAgfSBlbHNlIHtcbiAgICAgIG1haW5kb2MgPSBub2Rlc1swXTtcbiAgICB9XG4gICAgbWQgPSAoKF9yZWYxID0gbWQgIT0gbnVsbCA/IG1kLnJlcGxhY2UoL1xcclxcbi9tZywgJ1xcbicpIDogdm9pZCAwKSAhPSBudWxsID8gX3JlZjEgOiBtYWluZG9jLmlubmVySFRNTC5yZXBsYWNlKC9eXFxzKjwhLS0qLywgJycpLnJlcGxhY2UoLy0tPlxccypcXG4qL20sICcnKSkudHJpbSgpO1xuICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCgnaGlkZUNvbnRyb2xzJyk7XG4gICAgbWFya3VwU2xpZGVzKG1haW5kb2MsIG1kKTtcbiAgICByZXR1cm4gaW5zZXJ0Q29udHJvbHMobWFpbmRvYyk7XG4gIH07XG5cbiAgbGFzdFNsaWRlID0gbnVsbDtcblxuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG5ldyBFcnJvcihcIlJFTUlOREVSOiBJbmNvbXBhdGliaWxpdHk6IHVzaW5nIC13ZWJraXQtY2FsY1wiKS5zdGFjayk7XG4gICAgfVxuICB9XG5cbiAgc2xpZGVQYXQgPSAvXihcXCpcXCpcXCpbXlxcbl0qXFxuKD86LS0/XFxuKT8pL207XG5cbiAgc2xpZGVOYW1lID0gL15cXCpcXCpcXCooW15cXG5dKilcXG4oPzotLT9cXG4pPy9tO1xuXG4gIHNsaWRpbmcgPSBmYWxzZTtcblxuICBtYXJrdXBTbGlkZXMgPSBmdW5jdGlvbihlbCwgbWQpIHtcbiAgICB2YXIgZGl2LCBoYXNDb2RlLCBzbGlkZXM7XG5cbiAgICBoYXNDb2RlID0gbWFya3VwU2xpZGVDb250ZW50KGVsLCBtZCk7XG4gICAgc2xpZGVzID0gZWwucXVlcnlTZWxlY3RvckFsbCgnW2xlaXN1cmVTZWN0aW9uXScpO1xuICAgIGlmIChzbGlkZXMubGVuZ3RoIDw9IChlbC5xdWVyeVNlbGVjdG9yKCdbbGVpc3VyZVNlY3Rpb249XCJMZWlzdXJlIENvbnRyb2xzXCJdJykgPyAyIDogMSkpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChcIm9uZVNsaWRlXCIpO1xuICAgIH1cbiAgICBkaXYgPSBjcmVhdGVOb2RlKFwiPGRpdiBjbGFzcz0nc2xpZGUtY29udHJvbHMnPlxcbiAgPGRpdiBpZD0nc2xpZGUta2lsbGJ1dHRvbicgb25jbGljaz0ndG9nZ2xlU2xpZGVTaG93KCknIHN0eWxlPSdmbG9hdDogcmlnaHQnPjxidXR0b24+U2xpZGVzPC9idXR0b24+PC9kaXY+XFxuICA8ZGl2IGlkPSdzbGlkZS1udW0nIHN0eWxlPSdmbG9hdDogcmlnaHQ7IG1hcmdpbi1yaWdodDogMTBweCc+PC9kaXY+XFxuPC9kaXY+XCIpO1xuICAgIG1hcmt1cEJ1dHRvbnMoZGl2KTtcbiAgICBlbC5hcHBlbmRDaGlsZChkaXYpO1xuICAgIGlmIChsb2NhdGlvbi5zZWFyY2ggJiYgXy5maW5kKGxvY2F0aW9uLnNlYXJjaC5zbGljZSgxKS5zcGxpdCgnJicpLCAoZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIHAubWF0Y2goL15zbGlkZXM9Lyk7XG4gICAgfSkpKSB7XG4gICAgICBzbGlkaW5nID0gdHJ1ZTtcbiAgICAgIHNob3dTbGlkZSgkKGNob29zZVNsaWRlKCkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdzY3JvbGwnKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc0NvZGU7XG4gIH07XG5cbiAgbWFya3VwU2xpZGVDb250ZW50ID0gZnVuY3Rpb24oZWwsIG1kLCBub01haW4pIHtcbiAgICB2YXIgY29udGVudCwgaGFzQ29kZSwgaSwgbSwgcCwgcGFnZVR5cGUsIHBhZ2VzLCBfaSwgX3JlZjEsIF9yZWYyO1xuXG4gICAgcGFnZXMgPSBtZC5zcGxpdChzbGlkZVBhdCk7XG4gICAgaGFzQ29kZSA9IGZhbHNlO1xuICAgIGlmIChwYWdlcy5sZW5ndGggPiAxKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ3NsaWRlLWNvbnRhaW5lcicpO1xuICAgICAgZWwuaW5uZXJIVE1MID0gJyc7XG4gICAgICBiaW5kU2xpZGVyKCk7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2RvYycpO1xuICAgICAgaWYgKHBhZ2VzLmxlbmd0aCA9PT0gMyAmJiAhcGFnZXNbMF0gJiYgIXBhZ2VzWzJdKSB7XG4gICAgICAgIHBhZ2VzWzJdID0gJ1xcbic7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSBfaSA9IDAsIF9yZWYxID0gcGFnZXMubGVuZ3RoOyBfaSA8IF9yZWYxOyBpID0gX2kgKz0gMikge1xuICAgICAgICBwID0gcGFnZXNbaV07XG4gICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgcGFnZVR5cGUgPSBpID4gMCA/IChtID0gKF9yZWYyID0gcGFnZXNbaSAtIDFdLm1hdGNoKHNsaWRlUGF0KSkgIT0gbnVsbCA/IF9yZWYyWzFdIDogdm9pZCAwLCBtLm1hdGNoKC9cXG4tXFxuLykgPyBbJ2NvbnRpbnVhdGlvbicsICdoaWRkZW5QYWdlJ10gOiBtLm1hdGNoKC9cXG4tLVxcbi8pID8gWydoaWRkZW5QYWdlJywgJ3NlY3JldFBhZ2UnXSA6IFtdKSA6IFtdO1xuICAgICAgICAgIGNvbnRlbnQgPSBtYWtlU2xpZGVEaXYoZWwsIHBhZ2VUeXBlLCAoaSA+IDAgPyBwYWdlc1tpIC0gMV0ubWF0Y2goc2xpZGVOYW1lKVsxXS50cmltKCkgOiAnTWFpbicpKTtcbiAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGhhc0NvZGUgPSAobWFya3VwRWxlbWVudChjb250ZW50LCBwYWdlc1tpIC0gMV0gKyBwKSkgfHwgaGFzQ29kZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFzQ29kZSA9IChtYXJrdXBFbGVtZW50KGNvbnRlbnQsICcqKipcXG4nICsgcCkpIHx8IGhhc0NvZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhZFNsaWRlKGNvbnRlbnQsIChpID4gMCA/IHBhZ2VzW2kgLSAxXSA6ICcqKipcXG4nKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudCA9IG1ha2VTbGlkZURpdihlbCwgWydwYWdlJ10sICdNYWluJyk7XG4gICAgICB3aGlsZSAoZWwuZmlyc3RDaGlsZCAhPT0gY29udGVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICBoYXNDb2RlID0gbWFya3VwRWxlbWVudChjb250ZW50LCBtZCk7XG4gICAgICBwYWRTbGlkZShjb250ZW50LCAnKioqXFxuJyk7XG4gICAgICBpZiAobm9NYWluKSB7XG4gICAgICAgIHVud3JhcENvbnRlbnQoY29udGVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoYXNDb2RlO1xuICB9O1xuXG4gIHBhZFNsaWRlID0gZnVuY3Rpb24oY29udGVudCwgaGVhZGVyKSB7XG4gICAgdmFyIGRpdiwgcmFuZ2U7XG5cbiAgICBpZiAoIWNvbnRlbnQuZmlyc3RDaGlsZCB8fCBpc0xlaXN1cmVDb2RlKGNvbnRlbnQuZmlyc3RDaGlsZCkpIHtcbiAgICAgIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgIHJhbmdlLnNldFN0YXJ0KGNvbnRlbnQsIDApO1xuICAgICAgcmFuZ2Uuc2V0RW5kKGNvbnRlbnQsIDApO1xuICAgICAgZGl2ID0gbWFrZU1hcmt1cERpdihyYW5nZSwgaGVhZGVyKTtcbiAgICAgIGRpdi5hcHBlbmRDaGlsZChjcmVhdGVOb2RlKCc8YnI+JykpO1xuICAgIH1cbiAgICBpZiAoaXNMZWlzdXJlQ29kZShjb250ZW50Lmxhc3RDaGlsZCkpIHtcbiAgICAgIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgIHJhbmdlLnNldFN0YXJ0QWZ0ZXIoY29udGVudC5sYXN0Q2hpbGQpO1xuICAgICAgcmFuZ2Uuc2V0RW5kQWZ0ZXIoY29udGVudC5sYXN0Q2hpbGQpO1xuICAgICAgZGl2ID0gbWFrZU1hcmt1cERpdihyYW5nZSwgJ1xcbicpO1xuICAgICAgcmV0dXJuIGRpdi5hcHBlbmRDaGlsZChjcmVhdGVOb2RlKCc8YnI+JykpO1xuICAgIH1cbiAgfTtcblxuICB1bndyYXBDb250ZW50ID0gZnVuY3Rpb24oY29udGVudCkge1xuICAgIHZhciBlbCwgc2VjdGlvbjtcblxuICAgIHNlY3Rpb24gPSBjb250ZW50LnBhcmVudE5vZGU7XG4gICAgZWwgPSBzZWN0aW9uLnBhcmVudE5vZGU7XG4gICAgZWwuaW5zZXJ0QmVmb3JlKGNvbnRlbnQsIHNlY3Rpb24pO1xuICAgIHJlbW92ZShzZWN0aW9uKTtcbiAgICByZXR1cm4gdW53cmFwKGNvbnRlbnQpO1xuICB9O1xuXG4gIG1ha2VTbGlkZURpdiA9IGZ1bmN0aW9uKGVsLCBwYWdlVHlwZXMsIHRpdGxlKSB7XG4gICAgdmFyIGNvbnRlbnQsIGRpdiwgcGFnZVR5cGUsIHNlY3Rpb25UaXRsZSwgX2ksIF9sZW47XG5cbiAgICBsYXN0U2xpZGUgPSBkaXYgPSBjcmVhdGVOb2RlKFwiPGRpdiBjbGFzcz0nbGVpc3VyZV9wYWdlJz48L2Rpdj5cIik7XG4gICAgZGl2LnNldEF0dHJpYnV0ZSgnbGVpc3VyZVNlY3Rpb24nLCB0aXRsZSk7XG4gICAgZGl2LnNldEF0dHJpYnV0ZSgnZG9jJywgJycpO1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ3NsaWRlJywgJycpO1xuICAgIGRpdi5jbGFzc0xpc3QuYWRkKCdzbGlkZScpO1xuICAgIGRpdi5jbGFzc0xpc3QuYWRkKCd1aS1jb3JuZXItYWxsJyk7XG4gICAgZGl2LmNsYXNzTGlzdC5hZGQoJ3VpLXdpZGdldCcpO1xuICAgIGRpdi5jbGFzc0xpc3QuYWRkKCd1aS13aWRnZXQtY29udGVudCcpO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gcGFnZVR5cGVzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBwYWdlVHlwZSA9IHBhZ2VUeXBlc1tfaV07XG4gICAgICBkaXYuY2xhc3NMaXN0LmFkZChwYWdlVHlwZSk7XG4gICAgfVxuICAgIGVsLmFwcGVuZENoaWxkKGRpdik7XG4gICAgc2VjdGlvblRpdGxlID0gY3JlYXRlTm9kZShcIjxkaXYgY2xhc3M9J3BhZ2VUaXRsZSc+XCIgKyB0aXRsZSArIFwiPC9kaXY+XCIpO1xuICAgIHNlY3Rpb25UaXRsZS5zZXRBdHRyaWJ1dGUoJ2xlaXN1cmVvdXRwdXQnLCAnJyk7XG4gICAgZGl2LmFwcGVuZENoaWxkKHNlY3Rpb25UaXRsZSk7XG4gICAgY29udGVudCA9IGNyZWF0ZU5vZGUoXCI8ZGl2IGNsYXNzPSdwYWdlQ29udGVudCc+PC9kaXY+XCIpO1xuICAgIGRpdi5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfTtcblxuICBjaG9vc2VTbGlkZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwYXJhbTtcblxuICAgIHBhcmFtID0gXy5maW5kKGxvY2F0aW9uLnNlYXJjaC5zbGljZSgxKS5zcGxpdCgnJicpLCAoZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIHAubWF0Y2goL15zbGlkZT0uKi8pO1xuICAgIH0pKTtcbiAgICBjb25zb2xlLmxvZyhwYXJhbSk7XG4gICAgaWYgKHBhcmFtKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIltzbGlkZT0nXCIgKyAocGFyYW0uc3BsaXQoJz0nKVsxXSkgKyBcIiddXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW21haW5kb2NdJykuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgfVxuICB9O1xuXG4gIG9sZFNsaWRlID0gMDtcblxuICB3aW5kb3cudG9nZ2xlU2xpZGVTaG93ID0gZnVuY3Rpb24oKSB7XG4gICAgc2xpZGluZyA9ICQoZG9jdW1lbnQuYm9keSkuaXMoJy5zY3JvbGwnKTtcbiAgICBlbmFibGVTbGlkZUNvbnRyb2xzKHRydWUpO1xuICAgIGVuYWJsZUVkaXRpbmcodHJ1ZSk7XG4gICAgaWYgKHNsaWRpbmcpIHtcbiAgICAgICQoZG9jdW1lbnQuYm9keSkucmVtb3ZlQ2xhc3MoJ3Njcm9sbCcpO1xuICAgICAgcmV0dXJuIHNob3dTbGlkZShudGhTbGlkZShvbGRTbGlkZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvbGRTbGlkZSA9ICQoJy5zbGlkZS5zaG93aW5nJykuYXR0cignc2xpZGUnKTtcbiAgICAgIGhpZGVTbGlkZSgkKCcuc2xpZGUuc2hvd2luZycpKTtcbiAgICAgICQoZG9jdW1lbnQuYm9keSkuYWRkQ2xhc3MoJ3Njcm9sbCcpO1xuICAgICAgcmV0dXJuICQoJyNzbGlkZS1udW0nKS5odG1sKCcnKTtcbiAgICB9XG4gIH07XG5cbiAgYmluZFNsaWRlciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBzbGlkZUtleUxpc3RlbmVyKTtcbiAgfTtcblxuICBzbGlkZUNvbnRyb2xzID0gW1EsIEVTQywgTEVGVF9BUlJPVywgUklHSFRfQVJST1csIEhPTUUsIEVORCwgUEFHRV9VUCwgUEFHRV9ET1dOXTtcblxuICBzbGlkZUNvbnRyb2xzRW5hYmxlZCA9IHRydWU7XG5cbiAgZW5hYmxlU2xpZGVDb250cm9scyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgcmV0dXJuIHNsaWRlQ29udHJvbHNFbmFibGVkID0gc3RhdGU7XG4gIH07XG5cbiAgcHJlc2VudFNsaWRlID0gZnVuY3Rpb24ocykge1xuICAgIGhpZGVTbGlkZSgkKCcuc2xpZGUuc2hvd2luZycpKTtcbiAgICByZXR1cm4gc2hvd1NsaWRlKHMpO1xuICB9O1xuXG4gIGZpcnN0U2xpZGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2xpZGVzKCk7XG4gIH07XG5cbiAgbGFzdFNsaWRlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNsaWRlcygpLmxhc3QoKTtcbiAgfTtcblxuICBwcmV2U2xpZGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbjtcblxuICAgIG4gPSAkKCcuc2xpZGUuc2hvd2luZycpLnByZXZBbGwoJ1tzbGlkZV0nKS5ub3QoJ1tsZWlzdXJlU2VjdGlvbj1cIkxlaXN1cmUgQ29udHJvbHNcIl0nKS5ub3QoJy5oaWRkZW5QYWdlJykubm90KCcuc2VjcmV0UGFnZScpO1xuICAgIGlmIChuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG47XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzbGlkZXMoKTtcbiAgICB9XG4gIH07XG5cbiAgbmV4dFNsaWRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG47XG5cbiAgICBuID0gJCgnLnNsaWRlLnNob3dpbmcnKS5uZXh0QWxsKCdbc2xpZGVdJykubm90KCdbbGVpc3VyZVNlY3Rpb249XCJMZWlzdXJlIENvbnRyb2xzXCJdJykubm90KCcuaGlkZGVuUGFnZScpLm5vdCgnLnNlY3JldFBhZ2UnKTtcbiAgICBpZiAobi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBuO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJCgnLnNsaWRlLnNob3dpbmcnKTtcbiAgICB9XG4gIH07XG5cbiAgc2xpZGVLZXlMaXN0ZW5lciA9IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgYztcblxuICAgIGlmIChzbGlkaW5nKSB7XG4gICAgICB3aW5kb3cuZXZ0ID0gZTtcbiAgICAgIGMgPSBlLmNoYXJDb2RlIHx8IGUua2V5Q29kZSB8fCBlLndoaWNoO1xuICAgICAgaWYgKChfX2luZGV4T2YuY2FsbChzbGlkZUNvbnRyb2xzLCBjKSA+PSAwKSAmJiAhJChlLnRhcmdldCkuaXMoJ1tsZWlzdXJlbm9kZT1jb2RlXSxbbGVpc3VyZW5vZGU9Y29kZV0gKicpICYmIHNsaWRlQ29udHJvbHNFbmFibGVkKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKGMgPT09IEVTQykge1xuICAgICAgICAgIHJldHVybiB0b2dnbGVTbGlkZVNob3coKTtcbiAgICAgICAgfSBlbHNlIGlmIChjID09PSBRKSB7XG4gICAgICAgICAgcmV0dXJuIGNsb3NlV2luZG93KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHByZXNlbnRTbGlkZSgoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICAgIGNhc2UgSE9NRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlyc3RTbGlkZSgpO1xuICAgICAgICAgICAgICBjYXNlIEVORDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFzdFNsaWRlKCk7XG4gICAgICAgICAgICAgIGNhc2UgTEVGVF9BUlJPVzpcbiAgICAgICAgICAgICAgY2FzZSBQQUdFX1VQOlxuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2U2xpZGUoKTtcbiAgICAgICAgICAgICAgY2FzZSBSSUdIVF9BUlJPVzpcbiAgICAgICAgICAgICAgY2FzZSBQQUdFX0RPV046XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHRTbGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKCkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBzbGlkZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJCgnW3NsaWRlXScpLm5vdCgnW2xlaXN1cmVTZWN0aW9uPVwiTGVpc3VyZSBDb250cm9sc1wiXScpLm5vdCgnLmhpZGRlblBhZ2UnKS5ub3QoJy5zZWNyZXRQYWdlJyk7XG4gIH07XG5cbiAgbnRoU2xpZGUgPSBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIHNsaWRlcygpLnNsaWNlKG4pO1xuICB9O1xuXG4gIGNvdW50U2xpZGUgPSBmdW5jdGlvbihlbCkge1xuICAgIHZhciBjb3VudCwgbiwgc2xpZGUsIF9pLCBfbGVuLCBfcmVmMTtcblxuICAgIG4gPSAtMTtcbiAgICBjb3VudCA9IDA7XG4gICAgX3JlZjEgPSBzbGlkZXMoKTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBzbGlkZSA9IF9yZWYxW19pXTtcbiAgICAgIGNvdW50Kys7XG4gICAgICBpZiAoc2xpZGUgPT09IGVsKSB7XG4gICAgICAgIG4gPSBjb3VudDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtuLCBjb3VudF07XG4gIH07XG5cbiAgc2hvd1NsaWRlID0gZnVuY3Rpb24oZWwpIHtcbiAgICB2YXIgY291bnQsIG4sIF9yZWYxO1xuXG4gICAgX3JlZjEgPSBjb3VudFNsaWRlKGVsWzBdKSwgbiA9IF9yZWYxWzBdLCBjb3VudCA9IF9yZWYxWzFdO1xuICAgIG9sZFNsaWRlID0gbjtcbiAgICAkKCcjc2xpZGUtbnVtJykuaHRtbChcIlwiICsgbiArIFwiIC8gXCIgKyBjb3VudCk7XG4gICAgcmV0dXJuICQoZWwpLmZpcnN0KCkucmVtb3ZlQ2xhc3MoJ2hpZGRlbicpLmFkZENsYXNzKCdzaG93aW5nJyk7XG4gIH07XG5cbiAgaGlkZVNsaWRlID0gZnVuY3Rpb24oZWwpIHtcbiAgICByZXR1cm4gJChlbCkuZmlyc3QoKS5hZGRDbGFzcygnaGlkZGVuJykucmVtb3ZlQ2xhc3MoJ3Nob3dpbmcnKTtcbiAgfTtcblxuICBtYXJrdXBFbGVtZW50ID0gZnVuY3Rpb24oZWwsIG1kKSB7XG4gICAgdmFyIGNvZGUsIGNvZGVQb3MsIGxlbiwgbGV4LCBtYXJrdXAsIG5vZGUsIHByZXYsIHByZXZDb2RlUG9zLCByYW5nZSwgc2xpZGUsIF9pLCBfbGVuLCBfcmVmMSwgX3JlZjIsIF9yZWYzO1xuXG4gICAgbGVuID0gbWQubGVuZ3RoO1xuICAgIHNsaWRlID0gKF9yZWYxID0gbWQubWF0Y2goc2xpZGVQYXQpKSAhPSBudWxsID8gX3JlZjEgOiAnJztcbiAgICBfcmVmMiA9IHdpbmRvdy5tYXJrZWQoKHNsaWRlID8gbWQuc2xpY2Uoc2xpZGVbMF0ubGVuZ3RoKSA6IG1kKSwge1xuICAgICAgc2F2ZUxleDogdHJ1ZSxcbiAgICAgIGdmbTogdHJ1ZVxuICAgIH0pLCBtYXJrdXAgPSBfcmVmMlswXSwgbGV4ID0gX3JlZjJbMV07XG4gICAgZWwuaW5uZXJIVE1MID0gbWFya3VwLnRyaW0oKSB8fCAnPGJyPic7XG4gICAgcHJldiA9IG51bGw7XG4gICAgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIHByZXZDb2RlUG9zID0gLTE7XG4gICAgY29kZVBvcyA9IDA7XG4gICAgX3JlZjMgPSBlbC5xdWVyeVNlbGVjdG9yQWxsKCdjb2RlJyk7XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgbm9kZSA9IF9yZWYzW19pXTtcbiAgICAgIHdoaWxlIChsZXhbY29kZVBvc10udHlwZSAhPT0gJ2NvZGUnKSB7XG4gICAgICAgIGNvZGVQb3MrKztcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLnBhcmVudE5vZGUudGFnTmFtZSAhPT0gJ1BSRScpIHtcbiAgICAgICAgY29kZSA9IG5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICBjb2RlLmlubmVySFRNTCA9IG5vZGUuaW5uZXJIVE1MO1xuICAgICAgfVxuICAgICAgY29kZS5zZXRBdHRyaWJ1dGUoJ25vTGVpc3VyZUJhcicsICcnKTtcbiAgICAgIGNvZGUuc2V0QXR0cmlidXRlKCdsZWlzdXJlTm9kZScsICdjb2RlJyk7XG4gICAgICBjb2RlLm1kID0gbGV4W2NvZGVQb3NdLnRleHQ7XG4gICAgICBpZiAoY29kZS5wYXJlbnROb2RlLmZpcnN0Q2hpbGQgIT09IGNvZGUpIHtcbiAgICAgICAgaWYgKHByZXYgPT09IG51bGwgfHwgcHJldi5wYXJlbnROb2RlICE9PSBjb2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICByYW5nZS5zZXRTdGFydChjb2RlLnBhcmVudE5vZGUsIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJhbmdlLnNldFN0YXJ0QWZ0ZXIocHJldik7XG4gICAgICAgIH1cbiAgICAgICAgcmFuZ2Uuc2V0RW5kQmVmb3JlKGNvZGUpO1xuICAgICAgICBtYWtlTWFya3VwRGl2KHJhbmdlLCBtZC5zdWJzdHJpbmcoKHByZXZDb2RlUG9zID09PSAtMSA/IDAgOiBsZW4gLSBsZXhbcHJldkNvZGVQb3NdLnJlbWFpbiksIGxlbiAtIGxleFtjb2RlUG9zXS5yZW1haW4gLSBsZXhbY29kZVBvc10udGV4dExlbikpO1xuICAgICAgfVxuICAgICAgcHJldkNvZGVQb3MgPSBjb2RlUG9zO1xuICAgICAgY29kZVBvcysrO1xuICAgICAgcHJldiA9IGNvZGU7XG4gICAgfVxuICAgIGlmIChwcmV2Q29kZVBvcyA+IC0xKSB7XG4gICAgICBpZiAobGV4W3ByZXZDb2RlUG9zXS5yZW1haW4gPiAwKSB7XG4gICAgICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhwcmV2LnBhcmVudE5vZGUpO1xuICAgICAgICByYW5nZS5zZXRTdGFydEFmdGVyKHByZXYpO1xuICAgICAgICBtYWtlTWFya3VwRGl2KHJhbmdlLCBtZC5zdWJzdHJpbmcobGVuIC0gbGV4W3ByZXZDb2RlUG9zXS5yZW1haW4pKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKGVsKTtcbiAgICAgIG1ha2VNYXJrdXBEaXYocmFuZ2UsIG1kKTtcbiAgICB9XG4gICAgcmV0dXJuIHByZXZDb2RlUG9zID4gLTE7XG4gIH07XG5cbiAgaGFuZGxlSW50ZXJuYWxTZWN0aW9ucyA9IGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICB2YXIgYmVmb3JlLCBpbm5lclNlY3Rpb25zLCBtYXJrZXIsIG5vZGUsIG5vZGVDb250ZW50LCBub2RlVGl0bGUsIHByZXYsIHNlY3Rpb24sIHNlY3Rpb25Ib2xkZXIsIHRpdGxlLCBfaSwgX2osIF9sZW4sIF9sZW4xLCBfcmVmMTtcblxuICAgIHNlY3Rpb24gPSBjb250ZW50LnBhcmVudE5vZGU7XG4gICAgc2VjdGlvbkhvbGRlciA9IHNlY3Rpb24ucGFyZW50Tm9kZTtcbiAgICBpbm5lclNlY3Rpb25zID0gc2VjdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCdbbGVpc3VyZVNlY3Rpb25dJyk7XG4gICAgaWYgKGlubmVyU2VjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAoISgoX3JlZjEgPSBjb250ZW50LmZpcnN0Q2hpbGQubWQpICE9IG51bGwgPyBfcmVmMS5tYXRjaCgvXlxcKlxcKlxcKi8pIDogdm9pZCAwKSkge1xuICAgICAgICBpZiAoIXNlY3Rpb24ucHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIHNlY3Rpb24uc2V0QXR0cmlidXRlKCdsZWlzdXJlU2VjdGlvbicsICdNYWluJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldiA9IHNlY3Rpb24ucHJldmlvdXNTaWJsaW5nLnF1ZXJ5U2VsZWN0b3IoJy5wYWdlQ29udGVudCcpO1xuICAgICAgICAgIHdoaWxlIChjb250ZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIG1lcmdlVXAoY29udGVudC5maXJzdENoaWxkLCBwcmV2KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlbW92ZShzZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZSA9IHNlY3Rpb24uZ2V0QXR0cmlidXRlKCdsZWlzdXJlU2VjdGlvbicpO1xuICAgICAgYmVmb3JlID0gZmFsc2U7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGlubmVyU2VjdGlvbnMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgbm9kZSA9IGlubmVyU2VjdGlvbnNbX2ldO1xuICAgICAgICBpZiAobm9kZS5nZXRBdHRyaWJ1dGUoJ2xlaXN1cmVTZWN0aW9uJykgPT09IHRpdGxlKSB7XG4gICAgICAgICAgYmVmb3JlID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYmVmb3JlID0gYmVmb3JlIHx8ICghaW5uZXJTZWN0aW9uc1swXS5wcmV2aW91c1NpYmxpbmcpO1xuICAgICAgbWFya2VyID0gc2VjdGlvbjtcbiAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IGlubmVyU2VjdGlvbnMubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgIG5vZGUgPSBpbm5lclNlY3Rpb25zW19qXTtcbiAgICAgICAgbm9kZVRpdGxlID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2xlaXN1cmVTZWN0aW9uJyk7XG4gICAgICAgIG5vZGVDb250ZW50ID0gbm9kZS5xdWVyeVNlbGVjdG9yKCcucGFnZUNvbnRlbnQnKTtcbiAgICAgICAgaWYgKG5vZGVUaXRsZSA9PT0gdGl0bGUgfHwgKG5vZGUucHJldmlvdXNTaWJsaW5nICYmIG5vZGVUaXRsZSA9PT0gJ01haW4nKSkge1xuICAgICAgICAgIGlmIChub2RlVGl0bGUgPT09IHRpdGxlKSB7XG4gICAgICAgICAgICBiZWZvcmUgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKG5vZGVDb250ZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIGNvbnRlbnQuaW5zZXJ0QmVmb3JlKG5vZGVDb250ZW50LmZpcnN0Q2hpbGQsIG5vZGUpO1xuICAgICAgICAgICAgbWVyZ2VMZWlzdXJlQ29kZShub2RlLnByZXZpb3VzU2libGluZywgbm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlbW92ZShub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aGlsZSAobm9kZS5uZXh0U2libGluZyAmJiAhbm9kZS5uZXh0U2libGluZy5nZXRBdHRyaWJ1dGUoJ2xlaXN1cmVTZWN0aW9uJykpIHtcbiAgICAgICAgICAgIG1lcmdlVXAobm9kZS5uZXh0U2libGluZywgbm9kZUNvbnRlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYWRTbGlkZShub2RlQ29udGVudCwgXCIqKipcIiArIG5vZGVUaXRsZSArIFwiXFxuXCIpO1xuICAgICAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgICAgIHNlY3Rpb24ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgc2VjdGlvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlY3Rpb24ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgbWFya2VyLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIG1hcmtlciA9IG5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWNvbnRlbnQuZmlyc3RDaGlsZCkge1xuICAgICAgICByZXR1cm4gcmVtb3ZlKHNlY3Rpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhZFNsaWRlKGNvbnRlbnQsIFwiKioqXCIgKyB0aXRsZSArIFwiXFxuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBtZXJnZVVwID0gZnVuY3Rpb24oZWwsIG5ld1BhcmVudCkge1xuICAgIG5ld1BhcmVudC5hcHBlbmRDaGlsZChlbCk7XG4gICAgcmV0dXJuIG1lcmdlTGVpc3VyZUNvZGUobmV3UGFyZW50Lmxhc3RDaGlsZC5wcmV2aW91c1NpYmxpbmcsIG5ld1BhcmVudC5sYXN0Q2hpbGQpO1xuICB9O1xuXG4gIG1ha2VTZWN0aW9uID0gZnVuY3Rpb24odGl0bGUsIG5vZGUsIG5leHQpIHtcbiAgICB2YXIgZGl2O1xuXG4gICAgZGl2ID0gY3JlYXRlTm9kZShcIjxkaXYgbGVpc3VyZVNlY3Rpb249J1wiICsgdGl0bGUgKyBcIic+PC9kaXY+XCIpO1xuICAgIG5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZGl2LCBub2RlKTtcbiAgICB3aGlsZSAoZGl2Lm5leHRTaWJsaW5nICYmIGRpdi5uZXh0U2libGluZyAhPT0gbmV4dCkge1xuICAgICAgZGl2LmFwcGVuZENoaWxkKGRpdi5uZXh0U2libGluZyk7XG4gICAgfVxuICAgIHJldHVybiBkaXY7XG4gIH07XG5cbiAgbWFrZU1hcmt1cERpdiA9IGZ1bmN0aW9uKHJhbmdlLCBtZCkge1xuICAgIHZhciBkaXY7XG5cbiAgICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICByYW5nZS5zdXJyb3VuZENvbnRlbnRzKGRpdik7XG4gICAgZGl2Lm1kID0gbWQ7XG4gICAgYmluZE1hcmt1cERpdihkaXYpO1xuICAgIHJldHVybiBkaXY7XG4gIH07XG5cbiAgZWRpdGluZ0VuYWJsZWQgPSB0cnVlO1xuXG4gIGVuYWJsZUVkaXRpbmcgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHJldHVybiBlZGl0aW5nRW5hYmxlZCA9IHN0YXRlO1xuICB9O1xuXG4gIGJpbmRNYXJrdXBEaXYgPSBmdW5jdGlvbihkaXYpIHtcbiAgICB2YXIgZWRpdGluZztcblxuICAgIGRpdi5ib3VuZCA9IHRydWU7XG4gICAgZGl2LnNldEF0dHJpYnV0ZSgnbGVpc3VyZU5vZGUnLCAnbWFya2Rvd24nKTtcbiAgICBkaXYuc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCAnZmFsc2UnKTtcbiAgICBlZGl0aW5nID0gZmFsc2U7XG4gICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKCFlZGl0aW5nICYmIGVkaXRpbmdFbmFibGVkKSB7XG4gICAgICAgIGRpdi5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgZGl2LmFwcGVuZENoaWxkKHRleHROb2RlKGRpdi5tZCkpO1xuICAgICAgICBkaXYuc3R5bGUud2hpdGVTcGFjZSA9ICdwcmUtd3JhcCc7XG4gICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScsICd0cnVlJyk7XG4gICAgICAgIGVkaXRpbmcgPSB0cnVlO1xuICAgICAgICBkaXYucGFyZW50Tm9kZS5zZXRBdHRyaWJ1dGUoJ2VkaXRpbmcnLCAndHJ1ZScpO1xuICAgICAgICByZXR1cm4gZGl2LmZvY3VzKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIGJyLCByLCBzO1xuXG4gICAgICBpZiAoZWRpdGluZykge1xuICAgICAgICBzID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgICByID0gcy5nZXRSYW5nZUF0KDApO1xuICAgICAgICBpZiAoKGUuY2hhckNvZGUgfHwgZS5rZXlDb2RlIHx8IGUud2hpY2gpID09PSBFTlRFUikge1xuICAgICAgICAgIGJyID0gdGV4dE5vZGUoJ1xcbicpO1xuICAgICAgICAgIHIuaW5zZXJ0Tm9kZShicik7XG4gICAgICAgICAgciA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgci5zZXRTdGFydChiciwgMSk7XG4gICAgICAgICAgcy5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICBzLmFkZFJhbmdlKHIpO1xuICAgICAgICAgIHJldHVybiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZGl2LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgZmlyc3QsIGZyYWcsIGxhc3QsIG5vZGUsIHBhcmVudCwgcHJldlNlY3Rpb24sIHIsIHNjcm9sbCwgX2ksIF9sZW4sIF9yZWYxLCBfcmVmMjtcblxuICAgICAgaWYgKGVkaXRpbmcpIHtcbiAgICAgICAgc2Nyb2xsID0gZG9jdW1lbnQuYm9keS5zY3JvbGxUb3A7XG4gICAgICAgIGRpdi5zdHlsZS53aGl0ZVNwYWNlID0gJyc7XG4gICAgICAgIGVkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgZGl2LnBhcmVudE5vZGUucmVtb3ZlQXR0cmlidXRlKCdlZGl0aW5nJyk7XG4gICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScsICdmYWxzZScpO1xuICAgICAgICBwcmV2U2VjdGlvbiA9IChfcmVmMSA9IGRpdi5wYXJlbnROb2RlLnBhcmVudE5vZGUucHJldmlvdXNTaWJsaW5nKSAhPSBudWxsID8gX3JlZjEuZ2V0QXR0cmlidXRlKCdsZWlzdXJlU2VjdGlvbicpIDogdm9pZCAwO1xuICAgICAgICBwYXJlbnQgPSBkaXYucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKG1hcmt1cFNsaWRlQ29udGVudChkaXYsIGRpdi50ZXh0Q29udGVudCwgcHJldlNlY3Rpb24gJiYgcHJldlNlY3Rpb24gIT09ICdMZWlzdXJlIENvbnRyb2xzJykpIHtcbiAgICAgICAgICBfcmVmMiA9IGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW2xlaXN1cmVub2RlPSdjb2RlJ11cIik7XG4gICAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgbm9kZSA9IF9yZWYyW19pXTtcbiAgICAgICAgICAgIHByZXNlbnRMZWlzdXJlQ29kZShub2RlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGl2LnRleHRDb250ZW50LnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICBjbGVhbkVtcHR5Tm9kZXMoZGl2KTtcbiAgICAgICAgfVxuICAgICAgICByID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgci5zZWxlY3ROb2RlQ29udGVudHMoZGl2KTtcbiAgICAgICAgZnJhZyA9IHIuZXh0cmFjdENvbnRlbnRzKCk7XG4gICAgICAgIGZpcnN0ID0gZnJhZy5jaGlsZE5vZGVzWzBdO1xuICAgICAgICBsYXN0ID0gZnJhZy5jaGlsZE5vZGVzW2ZyYWcuY2hpbGROb2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZChmcmFnLCBkaXYpO1xuICAgICAgICBtZXJnZUxlaXN1cmVDb2RlKHByZXZpb3VzU2libGluZyhmaXJzdCksIGZpcnN0KTtcbiAgICAgICAgbWVyZ2VMZWlzdXJlQ29kZShsYXN0LCBuZXh0U2libGluZyhsYXN0KSk7XG4gICAgICAgIGhhbmRsZUludGVybmFsU2VjdGlvbnMocGFyZW50KTtcbiAgICAgICAgcmV0dXJuIGRlbGF5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCA9IHNjcm9sbDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgTm90ZWJvb2subWFya3VwRWxlbWVudCA9IG1hcmt1cEVsZW1lbnQ7XG5cbiAgTm90ZWJvb2suZW5hYmxlU2xpZGVDb250cm9scyA9IGVuYWJsZVNsaWRlQ29udHJvbHM7XG5cbiAgTm90ZWJvb2suZW5hYmxlRWRpdGluZyA9IGVuYWJsZUVkaXRpbmc7XG5cbiAgTm90ZWJvb2sucHJlc2VudFNsaWRlID0gcHJlc2VudFNsaWRlO1xuXG4gIE5vdGVib29rLmZpcnN0U2xpZGUgPSBmaXJzdFNsaWRlO1xuXG4gIE5vdGVib29rLmxhc3RTbGlkZSA9IGxhc3RTbGlkZTtcblxuICBOb3RlYm9vay5wcmV2U2xpZGUgPSBwcmV2U2xpZGU7XG5cbiAgTm90ZWJvb2submV4dFNsaWRlID0gbmV4dFNsaWRlO1xuXG59KS5jYWxsKHRoaXMpO1xuXG4vKlxuLy9AIHNvdXJjZU1hcHBpbmdVUkw9bWQubWFwXG4qL1xuIiwiKGZ1bmN0aW9uKGdsb2JhbCl7Ly8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjYuMlxuLypcbiMgdXNlIGFuIGVsZW1lbnQgYXMgYSBMZWlzdXJlIG5vdGVib29rXG4jIE9ubHkgcnVucyBpbiB0aGUgY29udGV4dCBvZiBhIGJyb3dzZXJcbiovXG5cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgJCwgQlMsIERFTCwgRE9XTl9BUlJPVywgRU5ELCBFTlRFUiwgRVNDLCBIT01FLCBMRUZUX0FSUk9XLCBMZWlzdXJlX2Fubm8sIE5pbCwgUEFHRV9ET1dOLCBQQUdFX1VQLCBSSUdIVF9BUlJPVywgVEFCLCBVUF9BUlJPVywgVVJJLCBYdXMsIGFjY2VwdENvZGUsIGFkZEJveENsYXNzZXMsIGFkZERlZkNvbnRyb2xzLCBhZGRzTGluZSwgYWxsb3dFdmVudHMsIGFycm93cywgYXV0b1J1biwgYmFzZUVsZW1lbnRzLCBiYXNlU3Ryb2tlV2lkdGgsIGJhc2ljQ2FsbCwgYmluZEFsbCwgYmluZE5vdGVib29rLCBib290Tm90ZWJvb2ssIGJveCwgYm94Q2xhc3NlcywgYnV0dG9uQ2xhc3NlcywgYywgY2hhaW5FdmFsTm9kZXMsIGNoYW5nZVRoZW1lLCBjaGFuZ2VWaWV3LCBjaGVja0RlbGV0ZUV4cHIsIGNoZWNrSGlkZVNvdXJjZSwgY2hlY2tNdXRhdGVGcm9tTW9kaWZpY2F0aW9uLCBjbGVhbkVtcHR5Tm9kZXMsIGNsZWFuT3V0cHV0LCBjbGVhckFzdCwgY2xlYXJPdXRwdXRCb3gsIGNsZWFyVXBkYXRlcywgY2xpY2tUZXN0LCBjbG9zZVdpbmRvdywgY29kZUJveCwgY29kZUZvY3VzLCBjb2RlU3BhbiwgY29uZmlndXJlU2F2ZUxpbmssIGNvbnRpbnVlUmFuZ2VQb3NpdGlvbiwgY3JlYXRlRnJhZ21lbnQsIGNyZWF0ZU5vZGUsIGNyZWF0ZVBlZXIsIGNyZWF0ZVNsaWRlciwgZGVidWcsIGRlZmF1bHRFbnYsIGRlZmluZSwgZGVsYXksIGRvY0ZvY3VzLCBlbnZGb3IsIGVyclN0cmluZywgZXNjYXBlSHRtbCwgZXZhbEJveCwgZXZhbERvYywgZXZhbERvY0NvZGUsIGV2YWxOb2RlcywgZXZhbE91dHB1dCwgZXZhbHVhdGluZywgZXZhbHVhdGlvblF1ZXVlLCBldmVudCwgZmlsZW5hbWUsIGZpbmRDdXJyZW50Q29kZUhvbGRlciwgZmluZERlZnMsIGZpbmRVcGRhdGVTZWxlY3RvciwgZm9jdXNCb3gsIGZvbGRMZWZ0LCBnZW4sIGdldEFubm9Cb2R5LCBnZXRBbm5vRGF0YSwgZ2V0QW5ub05hbWUsIGdldEFzdCwgZ2V0Qm94LCBnZXREZWZOYW1lLCBnZXRFbGVtZW50Q29kZSwgZ2V0RWxlbWVudHMsIGdldEV4cHJTb3VyY2UsIGdldEh0bWwsIGdldE1ERG9jdW1lbnQsIGdldE1heFN0cm9rZVdpZHRoLCBnZXRQYXJzZUVyciwgZ2V0UmFuZ2VQb3NpdGlvbiwgZ2V0UmFuZ2VUZXh0LCBnZXRSYW5nZXMsIGdldFJlZk5hbWUsIGdldFN2Z0VsZW1lbnQsIGdldFR5cGUsIGdycCwgaGFuZGxlS2V5LCBoYXNGdW5jLCBoYXNNb25hZE91dHB1dCwgaGVhZCwgaGlkZGVuUGF0LCBoaWRlQ29udHJvbFNlY3Rpb24sIGhpZGVPdXRwdXRTb3VyY2UsIGhpZGVTbGlkZXIsIGhpZ2hsaWdodE5vdGVib29rRnVuY3Rpb24sIGhpZ2hsaWdodFBvc2l0aW9uLCBpZCwgaWRlbnRpdHksIGlnbm9yZURlbGV0ZU91dHB1dEJveCwgaW5pdCwgaW5pdE5vdGVib29rLCBpbnNlcnRDb250cm9scywgaXNEZWYsIGlzTGVpc3VyZUNvZGUsIGlzTW9uYWQsIGlzT3V0cHV0LCBpc1NsaWRlciwgbGF6eSwgbGVpc3VyZUNvbnRleHRTdHJpbmcsIGxpbmVQYXQsIGxpbmtTb3VyY2UsIGxvYWRQcm9ncmFtLCBsb2FkZWQsIGx6LCBtYWtlSWQsIG1ha2VMYWJlbCwgbWFrZU1vbmFkLCBtYWtlT3B0aW9uLCBtYWtlT3V0cHV0Qm94LCBtYWtlT3V0cHV0Q29udHJvbHMsIG1ha2VSYW5nZSwgbWFrZVN5bmNNb25hZCwgbWFrZVRlc3RCb3gsIG1ha2VUZXN0Q2FzZSwgbWFya1BhcnRpYWxBcHBsaWVzLCBtYXJrdXBCdXR0b24sIG1hcmt1cEJ1dHRvbnMsIG1hcmt1cERlZnMsIG1lcmdlTGVpc3VyZUNvZGUsIG5hbWVTdWIsIG5leHRJZCwgbmV4dFNpYmxpbmcsIG5vZGVFbmQsIG5vZGVGb3IsIG5vbnByaW50YWJsZSwgbnVtYmVyRW5kLCBudW1iZXJTdGFydCwgb2xkQnJhY2tldHMsIG93bmVyLCBwYXRjaEZ1bmNBc3QsIHBlZXIsIHBlZXJHZXREb2N1bWVudCwgcGVlckdldEZ1bmN0aW9ucywgcGVlck5vdGlmeVNlbGVjdGlvbiwgcG9zdExvYWRRdWV1ZSwgcHJlcEV4cHIsIHByZXNlbnRMZWlzdXJlQ29kZSwgcHJlc2VudFZhbHVlLCBwcmV2aW91c0JveFJhbmdlSW50ZXJuYWwsIHByZXZpb3VzQm94UmFuZ2VTdGFydCwgcHJldmlvdXNTaWJsaW5nLCBwcmltU3ZnTWVhc3VyZSwgcHJpbWNvbmNhdE5vZGVzLCBwcmludGFibGUsIHByaW50YWJsZUNvbnRyb2xDaGFyYWN0ZXJzLCBwcm9jZXNzTGluZSwgcHNnbiwgcXVldWVBZnRlckxvYWQsIHJlbW92ZSwgcmVtb3ZlQm94Q2xhc3NlcywgcmVtb3ZlT2xkRGVmcywgcmVwbGFjZUNvbnRlbnRzLCByZXBsYWNlUmFuZ2UsIHJlcGxpY2F0ZSwgcmVxLCByZXNvbHZlLCByb290LCBydW5BdXRvLCBydW5Nb25hZCwgcnVuVGVzdCwgcnVuVGVzdHMsIHJ6LCBzYXZlUHJvZ3JhbSwgc2V0QXN0LCBzZXRGaWxlbmFtZSwgc2V0TWluTWF4LCBzZXRTbmFwcGVyLCBzZXRVcGRhdGUsIHNob3dBc3QsIHNob3dFcnJvciwgc2hvd0ZpbGVuYW1lLCBzaG93RmlsZW5hbWVzLCBzaG93T3V0cHV0U291cmNlLCBzaG93UmVzdWx0LCBzaG93U2xpZGVyQnV0dG9uLCBzaG93U291cmNlLCBza2lwTGVmdE92ZXJPdXRwdXRCb3gsIHNsaWRlciwgc25hcHNob3QsIHN2Z0JldHRlck1lYXN1cmUsIHN2Z01lYXN1cmUsIHN2Z01lYXN1cmVUZXh0LCB0YWlsLCB0ZXN0UGF0LCB0ZXh0Tm9kZSwgdG9EZWZCb3gsIHRvRXhwckJveCwgdG9nZ2xlRWRpdCwgdHJhbnNmb3JtU3Ryb2tlV2lkdGgsIHRyYW5zZm9ybWVkUG9pbnQsIHVud3JhcCwgdXBkYXRlLCB1cGRhdGVQYXQsIHdyYXBSYW5nZSwgeHVzRW52LCBfLCBfcmVmLCBfcmVmMSwgX3JlZjIsXG4gICAgX19zbGljZSA9IFtdLnNsaWNlLFxuICAgIF9faW5kZXhPZiA9IFtdLmluZGV4T2YgfHwgZnVuY3Rpb24oaXRlbSkgeyBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSkgcmV0dXJuIGk7IH0gcmV0dXJuIC0xOyB9O1xuXG4gIGNvbnNvbGUubG9nKFwiTE9BRElORyBOT1RFQk9PS1wiKTtcblxuICBfcmVmID0gcm9vdCA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9iYXNlJyksIHJlc29sdmUgPSBfcmVmLnJlc29sdmUsIGxhenkgPSBfcmVmLmxhenk7XG5cbiAgcnogPSByZXNvbHZlO1xuXG4gIGx6ID0gbGF6eTtcblxuICBfcmVmMSA9IHJvb3QgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vYXN0JyksIG5hbWVTdWIgPSBfcmVmMS5uYW1lU3ViLCBnZXRSZWZOYW1lID0gX3JlZjEuZ2V0UmVmTmFtZSwgZGVmaW5lID0gX3JlZjEuZGVmaW5lLCBmb2xkTGVmdCA9IF9yZWYxLmZvbGRMZWZ0LCBOaWwgPSBfcmVmMS5OaWwsIGdldFR5cGUgPSBfcmVmMS5nZXRUeXBlLCBnZXRBbm5vTmFtZSA9IF9yZWYxLmdldEFubm9OYW1lLCBnZXRBbm5vRGF0YSA9IF9yZWYxLmdldEFubm9EYXRhLCBnZXRBbm5vQm9keSA9IF9yZWYxLmdldEFubm9Cb2R5LCBMZWlzdXJlX2Fubm8gPSBfcmVmMS5MZWlzdXJlX2Fubm87XG5cbiAgX3JlZjIgPSByZXF1aXJlKCcuL3J1bnRpbWUnKSwgaXNNb25hZCA9IF9yZWYyLmlzTW9uYWQsIHJ1bk1vbmFkID0gX3JlZjIucnVuTW9uYWQsIG1ha2VNb25hZCA9IF9yZWYyLm1ha2VNb25hZCwgbWFrZVN5bmNNb25hZCA9IF9yZWYyLm1ha2VTeW5jTW9uYWQsIGlkZW50aXR5ID0gX3JlZjIuaWRlbnRpdHksIGRlZmF1bHRFbnYgPSBfcmVmMi5kZWZhdWx0RW52LCBiYXNpY0NhbGwgPSBfcmVmMi5iYXNpY0NhbGw7XG5cbiAgZ2VuID0gcmVxdWlyZSgnLi9nZW4nKS5nZW47XG5cbiAgVVJJID0gd2luZG93LlVSSTtcblxuICBYdXMgPSB3aW5kb3cuWHVzO1xuXG4gICQgPSB3aW5kb3cuJDtcblxuICBfID0gcmVxdWlyZSgnLi9sb2Rhc2gubWluJyk7XG5cbiAgd2luZG93Lmdsb2JhbCA9IHdpbmRvdztcblxuICBkZWJ1ZyA9IGZhbHNlO1xuXG4gIEJTID0gODtcblxuICBUQUIgPSA5O1xuXG4gIEVOVEVSID0gMTM7XG5cbiAgRVNDID0gMjc7XG5cbiAgUEFHRV9VUCA9IDMzO1xuXG4gIFBBR0VfRE9XTiA9IDM0O1xuXG4gIEVORCA9IDM1O1xuXG4gIEhPTUUgPSAzNjtcblxuICBMRUZUX0FSUk9XID0gMzc7XG5cbiAgVVBfQVJST1cgPSAzODtcblxuICBSSUdIVF9BUlJPVyA9IDM5O1xuXG4gIERPV05fQVJST1cgPSA0MDtcblxuICBERUwgPSA0NjtcblxuICBhcnJvd3MgPSBbMzcsIDM4LCAzOSwgNDBdO1xuXG4gIHVwZGF0ZVBhdCA9IC8oXnxcXG4pKCNAdXBkYXRlICkoW15cXG5dKykoPzpefFxcbikvO1xuXG4gIHBlZXIgPSBudWxsO1xuXG4gIG5leHRJZCA9IDA7XG5cbiAgZmlsZW5hbWUgPSBudWxsO1xuXG4gIGV2ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MsIHdpZGdldDtcblxuICAgIHdpZGdldCA9IGFyZ3VtZW50c1swXSwgYXJncyA9IDIgPD0gYXJndW1lbnRzLmxlbmd0aCA/IF9fc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpIDogW107XG4gICAgcmV0dXJuIGJhc2ljQ2FsbChhcmdzLCBlbnZGb3Iod2lkZ2V0KSwgaWRlbnRpdHkpO1xuICB9O1xuXG4gIGRlZmF1bHRFbnYucmVhZEZpbGUgPSBmdW5jdGlvbihmaWxlTmFtZSwgY29udCkge1xuICAgIHZhciB1cmk7XG5cbiAgICB1cmkgPSBuZXcgVVJJKGRvY3VtZW50LmxvY2F0aW9uLmhyZWYsIGZpbGVOYW1lKTtcbiAgICBjb25zb2xlLmxvZyhcIlxcblxcbkBAQEBSRUFEIEZJTEU6IFwiICsgdXJpICsgXCJcXG5cXG5cIik7XG4gICAgcmV0dXJuICQuZ2V0KFN0cmluZyh1cmkpKS5kb25lKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiBjb250KG51bGwsIGRhdGEpO1xuICAgIH0pLmZhaWwoZnVuY3Rpb24oZXJyKSB7XG4gICAgICByZXR1cm4gY29udChlcnIsIG51bGwpO1xuICAgIH0pO1xuICB9O1xuXG4gIGRlZmF1bHRFbnYud3JpdGVGaWxlID0gZnVuY3Rpb24oZmlsZU5hbWUsIGRhdGEsIGNvbnQpIHt9O1xuXG4gIHNuYXBzaG90ID0gZnVuY3Rpb24oZWwsIHBnbSkge307XG5cbiAgc2V0U25hcHBlciA9IGZ1bmN0aW9uKHNuYXBGdW5jKSB7XG4gICAgcmV0dXJuIHNuYXBzaG90ID0gc25hcEZ1bmM7XG4gIH07XG5cbiAgZGVsYXkgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmMsIDEpO1xuICB9O1xuXG4gIGdldFBhcnNlRXJyID0gZ2V0SHRtbCA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geChseihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHJ6KHZhbHVlKTtcbiAgICB9KSk7XG4gIH07XG5cbiAgZXNjYXBlSHRtbCA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bPD5dL2csIGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICByZXR1cm4gJyZsdDsnO1xuICAgICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgcmV0dXJuICcmZ3Q7JztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICB9O1xuXG4gIHByZXNlbnRWYWx1ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgY29udGVudDtcblxuICAgIGlmICgoZ2V0VHlwZSh2KSkgPT09ICdzdmdOb2RlJykge1xuICAgICAgY29udGVudCA9IHYoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIF9zdmdQcmVzZW50KCkoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgfSkoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoKGdldFR5cGUodikpID09PSAnaHRtbCcpIHtcbiAgICAgIHJldHVybiBnZXRIdG1sKHYpO1xuICAgIH0gZWxzZSBpZiAoKGdldFR5cGUodikpID09PSAncGFyc2VFcnInKSB7XG4gICAgICByZXR1cm4gXCJQQVJTRSBFUlJPUjogXCIgKyAoZ2V0UGFyc2VFcnIodikpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZXNjYXBlSHRtbChTdHJpbmcodikpO1xuICAgIH1cbiAgfTtcblxuICBib290Tm90ZWJvb2sgPSBmdW5jdGlvbihlbCkge1xuICAgIGlmICgoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NoYW5uZWxMaXN0JykpID09IG51bGwpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY3JlYXRlTm9kZShcIjxkYXRhbGlzdCBpZD0nY2hhbm5lbExpc3QnPlxcbiAgIDxvcHRpb24gdmFsdWU9Jyc+PC9vcHRpb24+XFxuICAgPG9wdGlvbiB2YWx1ZT0nYXBwJz5hcHA8L29wdGlvbj5cXG4gICA8b3B0aW9uIHZhbHVlPSdjb21waWxlJz5jb21waWxlPC9vcHRpb24+XFxuICAgPG9wdGlvbiB2YWx1ZT0nZWRpdG9yRm9jdXMnPmVkaXRvckZvY3VzPC9vcHRpb24+XFxuPC9kYXRhbGlzdD5cIikpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlUGVlcigpO1xuICB9O1xuXG4gIGNsb3NlV2luZG93ID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc29sZS5sb2coXCJDTE9TSU5HIFdJTkRPV1wiKTtcbiAgICB3aW5kb3cub3BlbignJywgJ19zZWxmJywgJycpO1xuICAgIHJldHVybiB3aW5kb3cuY2xvc2UoKTtcbiAgfTtcblxuICBjcmVhdGVQZWVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGssIHBhcmFtLCBwYXJhbXMsIHNlcnZlciwgdiwgX2ksIF9sZW4sIF9yZWYzLCBfcmVmNDtcblxuICAgIHJvb3QueHVzU2VydmVyID0gc2VydmVyID0gbmV3IFh1cy5TZXJ2ZXIoKTtcbiAgICBzZXJ2ZXIuZXhpdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNsb3NlV2luZG93KCk7XG4gICAgfTtcbiAgICBwZWVyID0gcm9vdC5wZWVyID0gWHVzLmNyZWF0ZURpcmVjdFBlZXIoc2VydmVyKTtcbiAgICBwZWVyLnNlcnZlciA9IHNlcnZlcjtcbiAgICBwZWVyLmxpc3RlbignbGVpc3VyZS9zZWxlY3Rpb24vY29udGVudHMnLCB0cnVlLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgbm9kZSwgciwgcztcblxuICAgICAgaWYgKGtleSA9PT0gJ2xlaXN1cmUvc2VsZWN0aW9uL2NvbnRlbnRzJykge1xuICAgICAgICBzID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgICBpZiAocy5yYW5nZUNvdW50ICYmIHMudG9TdHJpbmcoKSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICByID0gcy5nZXRSYW5nZUF0KDApO1xuICAgICAgICAgIHIuZGVsZXRlQ29udGVudHMoKTtcbiAgICAgICAgICBub2RlID0gdGV4dE5vZGUodmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgci5pbnNlcnROb2RlKG5vZGUpO1xuICAgICAgICAgIHMucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgci5zZWxlY3ROb2RlKG5vZGUpO1xuICAgICAgICAgIHJldHVybiBzLmFkZFJhbmdlKHIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcGVlci5zZXQoJ2xlaXN1cmUvZXZhbEV4cHInLCBudWxsLCAndHJhbnNpZW50Jyk7XG4gICAgcGVlci5saXN0ZW4oJ2xlaXN1cmUvZXZhbEV4cHInLCBmYWxzZSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGVudiwgZXhwciwgcmVzdWx0O1xuXG4gICAgICBpZiAoa2V5ID09PSAnbGVpc3VyZS9ldmFsRXhwcicgJiYgKHZhbHVlICE9IG51bGwpKSB7XG4gICAgICAgIGV4cHIgPSB2YWx1ZVswXSwgcmVzdWx0ID0gdmFsdWVbMV07XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRVZBTDogXCIgKyBleHByICsgXCIsIFJFU1VMVDogXCIgKyByZXN1bHQpO1xuICAgICAgICBlbnYgPSB4dXNFbnYocmVzdWx0LCBleHByKTtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NMaW5lKGV4cHIsIGVudiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBlbnYuY2xlYW51cCA9PT0gXCJmdW5jdGlvblwiID8gZW52LmNsZWFudXAoKSA6IHZvaWQgMDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcGVlci5zZXQoJ2xlaXN1cmUvZG9jdW1lbnQnLCBwZWVyR2V0RG9jdW1lbnQpO1xuICAgIHBlZXIuc2V0KCdsZWlzdXJlL2Z1bmN0aW9ucycsIHBlZXJHZXRGdW5jdGlvbnMpO1xuICAgIHBlZXIuc2V0KCdsZWlzdXJlL3N0b3JhZ2UnLCBbXSk7XG4gICAgaWYgKEJvb3QuZG9jdW1lbnRGcmFnbWVudCkge1xuICAgICAgcGFyYW1zID0ge307XG4gICAgICBfcmVmMyA9IEJvb3QuZG9jdW1lbnRGcmFnbWVudC5zdWJzdHJpbmcoMSkuc3BsaXQoJyYnKTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcGFyYW0gPSBfcmVmM1tfaV07XG4gICAgICAgIF9yZWY0ID0gcGFyYW0uc3BsaXQoJz0nKSwgayA9IF9yZWY0WzBdLCB2ID0gX3JlZjRbMV07XG4gICAgICAgIHBhcmFtc1trLnRvTG93ZXJDYXNlKCldID0gZGVjb2RlVVJJQ29tcG9uZW50KHYpO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcy54dXNwcm94eSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBYdXMueHVzVG9Qcm94eShzZXJ2ZXIsIHBhcmFtcy54dXNwcm94eSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJlcGxhY2VDb250ZW50cyA9IGZ1bmN0aW9uKHVyaSwgY29udGVudHMpIHtcbiAgICBpZiAoIWNvbnRlbnRzKSB7XG4gICAgICBjb250ZW50cyA9IHVyaTtcbiAgICAgIHVyaSA9IG51bGw7XG4gICAgfVxuICAgIGlmICh1cmkpIHtcbiAgICAgIHNldEZpbGVuYW1lKHVyaS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgZG9jdW1lbnQuYm9keS5zZXRBdHRyaWJ1dGUoJ2RvYycsICcnKTtcbiAgICB3aW5kb3cubGVpc3VyZUF1dG9SdW5BbGwgPSB0cnVlO1xuICAgIHdpbmRvdy5tYXJrdXAoY29udGVudHMpO1xuICAgIHJldHVybiBiaW5kQWxsKCk7XG4gIH07XG5cbiAgYmluZEFsbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBub2RlLCBfaSwgX2xlbiwgX3JlZjM7XG5cbiAgICBfcmVmMyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbGVpc3VyZW5vZGU9J2NvZGUnXVwiKTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBub2RlID0gX3JlZjNbX2ldO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRFZGl0YWJsZScsICd0cnVlJyk7XG4gICAgICBiaW5kTm90ZWJvb2sobm9kZSk7XG4gICAgICBjaGFuZ2VUaGVtZShub2RlLCAndGhpbicpO1xuICAgICAgZXZhbERvYyhub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHNob3dGaWxlbmFtZXMoKTtcbiAgfTtcblxuICB4dXNFbnYgPSBmdW5jdGlvbihyZXN1bHRWYXIsIGV4cHIpIHtcbiAgICB2YXIgZW52LCByZXN1bHQ7XG5cbiAgICByZXN1bHQgPSAnJztcbiAgICBlbnYgPSB7XG4gICAgICBkZWJ1ZzogZGVidWcsXG4gICAgICBmaW5pc2hlZEV2ZW50OiBmdW5jdGlvbigpIHt9LFxuICAgICAgb3duZXI6IG51bGwsXG4gICAgICByZXF1aXJlOiByZXEsXG4gICAgICB3cml0ZTogZnVuY3Rpb24obXNnKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQgKz0gXCJcIiArIG1zZyArIFwiXFxuXCI7XG4gICAgICB9LFxuICAgICAgcHJvbXB0OiBmdW5jdGlvbihtc2csIGNvbnQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCArPSBcIkF0dGVtcHQgdG8gcHJvbXB0IHdpdGggXCIgKyBtc2c7XG4gICAgICB9LFxuICAgICAgcHJvY2Vzc1Jlc3VsdDogZnVuY3Rpb24ocmVzLCBhc3QpIHtcbiAgICAgICAgcmVzdWx0ICs9IHJlcztcbiAgICAgICAgcmV0dXJuIHBlZXIuc2V0KHJlc3VsdFZhciwgSlNPTi5zdHJpbmdpZnkocmVzdWx0KSk7XG4gICAgICB9LFxuICAgICAgcHJlc2VudFZhbHVlOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgICAgfSxcbiAgICAgIGZpbGVTZXR0aW5nczoge1xuICAgICAgICB1cmk6IG5ldyBVUkkoZG9jdW1lbnQubG9jYXRpb24uaHJlZilcbiAgICAgIH0sXG4gICAgICBlcnI6IGZ1bmN0aW9uKGVycikge1xuICAgICAgICByZXN1bHQgKz0gZXJyLmxlaXN1cmVDb250ZXh0ID8gXCJFUlJPUjogXCIgKyBlcnIgKyBcIjpcXG5cIiArIChsZWlzdXJlQ29udGV4dFN0cmluZyhlcnIpKSArIFwiXFxuXCIgKyBlcnIuc3RhY2sgOiBcIkNvdWxkbid0IHBhcnNlOiBcIiArIGV4cHI7XG4gICAgICAgIHJldHVybiBwZWVyLnNldChyZXN1bHRWYXIsIHJlc3VsdCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBlbnYuX19wcm90b19fID0gcm9vdC5kZWZhdWx0RW52O1xuICAgIHJldHVybiBlbnY7XG4gIH07XG5cbiAgcGVlckdldERvY3VtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5vZGVzO1xuXG4gICAgbm9kZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW2xlaXN1cmVub2RlPSdjb2RlJ11cIik7XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA+IDEgfHwgTm90ZWJvb2subWQpIHtcbiAgICAgIHJldHVybiBnZXRNRERvY3VtZW50KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZXRTaW1wbGVEb2N1bWVudCgpO1xuICAgIH1cbiAgfTtcblxuICBwZWVyR2V0RnVuY3Rpb25zID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIChfLnVuaXEod2luZG93LmxlaXN1cmVGdW5jTmFtZXMudG9BcnJheSgpLnNvcnQoKSwgdHJ1ZSkpLnNvcnQoKTtcbiAgfTtcblxuICBnZXRNRERvY3VtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1kLCBub2RlLCBfaSwgX2xlbiwgX3JlZjMsIF9yZWY0O1xuXG4gICAgbWQgPSAnJztcbiAgICBfcmVmMyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkb2NdIFtsZWlzdXJlTm9kZV0nKTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBub2RlID0gX3JlZjNbX2ldO1xuICAgICAgbWQgKz0gaXNMZWlzdXJlQ29kZShub2RlKSA/IFwiYGBgXFxuXCIgKyAoZ2V0RWxlbWVudENvZGUobm9kZSkpICsgXCJcXG5gYGBcXG5cIiA6IChfcmVmNCA9IG5vZGUubWQpICE9IG51bGwgPyBfcmVmNCA6ICcnO1xuICAgIH1cbiAgICByZXR1cm4gbWQ7XG4gIH07XG5cbiAgbWFrZUlkID0gZnVuY3Rpb24oZWwpIHtcbiAgICBpZiAoIWVsLmlkKSB7XG4gICAgICByZXR1cm4gZWwuaWQgPSBcIkxlaXN1cmUtXCIgKyAobmV4dElkKyspO1xuICAgIH1cbiAgfTtcblxuICBhbGxvd0V2ZW50cyA9IHRydWU7XG5cbiAgaW5pdCA9IGZhbHNlO1xuXG4gIGJpbmROb3RlYm9vayA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgaWYgKCFpbml0KSB7XG4gICAgICBpbml0ID0gdHJ1ZTtcbiAgICAgIGRlZmF1bHRFbnYucHJlc2VudFZhbHVlID0gcHJlc2VudFZhbHVlO1xuICAgICAgZGVmYXVsdEVudi53cml0ZSA9IGZ1bmN0aW9uKG1zZykge1xuICAgICAgICByZXR1cm4gY29uc29sZS5sb2cobXNnKTtcbiAgICAgIH07XG4gICAgICBkZWZhdWx0RW52Lm93bmVyID0gZG9jdW1lbnQuYm9keTtcbiAgICAgIGRlZmF1bHRFbnYuZmluaXNoZWRFdmVudCA9IGZ1bmN0aW9uKGV2dCwgY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gdXBkYXRlKGNoYW5uZWwgIT0gbnVsbCA/IGNoYW5uZWwgOiAnYXBwJywgZGVmYXVsdEVudik7XG4gICAgICB9O1xuICAgICAgZGVmYXVsdEVudi5kZWJ1ZyA9IGRlYnVnO1xuICAgIH1cbiAgICBpZiAoZWwuYm91bmQgPT0gbnVsbCkge1xuICAgICAgbWFrZUlkKGVsKTtcbiAgICAgIGVsLmJvdW5kID0gdHJ1ZTtcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNoYXJhY3RlckRhdGFNb2RpZmllZCcsIChmdW5jdGlvbihldnQpIHtcbiAgICAgICAgaWYgKGFsbG93RXZlbnRzICYmICFlbC5yZXBsYWNpbmcpIHtcbiAgICAgICAgICByZXR1cm4gZGVsYXkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tNdXRhdGVGcm9tTW9kaWZpY2F0aW9uKGV2dCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pLCB0cnVlKTtcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ0RPTVN1YnRyZWVNb2RpZmllZCcsIChmdW5jdGlvbihldnQpIHtcbiAgICAgICAgaWYgKGFsbG93RXZlbnRzICYmICFlbC5yZXBsYWNpbmcpIHtcbiAgICAgICAgICByZXR1cm4gZGVsYXkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tNdXRhdGVGcm9tTW9kaWZpY2F0aW9uKGV2dCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pLCB0cnVlKTtcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIChmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICghaXNTbGlkZXIoZS5zcmNFbGVtZW50KSkge1xuICAgICAgICAgIHJldHVybiBkZWxheShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBoaWdobGlnaHRQb3NpdGlvbihlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSksIHRydWUpO1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCFpc1NsaWRlcihlLnNyY0VsZW1lbnQpKSB7XG4gICAgICAgICAgcmV0dXJuIGRlbGF5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGhpZ2hsaWdodFBvc2l0aW9uKGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KSwgdHJ1ZSk7XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCFpc1NsaWRlcihlLnNyY0VsZW1lbnQpKSB7XG4gICAgICAgICAgcmV0dXJuIGRlbGF5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGhpZ2hsaWdodFBvc2l0aW9uKGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KSwgdHJ1ZSk7XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgYywgciwgcztcblxuICAgICAgICBjID0gZS5jaGFyQ29kZSB8fCBlLmtleUNvZGUgfHwgZS53aGljaDtcbiAgICAgICAgaWYgKGMgPT09IERFTCB8fCBjID09PSBCUykge1xuICAgICAgICAgIHMgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgciA9IHMuZ2V0UmFuZ2VBdCgwKTtcbiAgICAgICAgICBpZiAoYyA9PT0gQlMpIHtcbiAgICAgICAgICAgIGNoZWNrRGVsZXRlRXhwcihnZXRCb3goci5zdGFydENvbnRhaW5lcikpO1xuICAgICAgICAgICAgaWYgKHNraXBMZWZ0T3Zlck91dHB1dEJveChlbCwgcikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09IERFTCkge1xuICAgICAgICAgICAgY2hlY2tEZWxldGVFeHByKGdldEJveChyLnN0YXJ0Q29udGFpbmVyKSk7XG4gICAgICAgICAgICBpZiAoaWdub3JlRGVsZXRlT3V0cHV0Qm94KGVsLCByKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJpbnRhYmxlKGMpKSB7XG4gICAgICAgICAgY2xlYXJBc3QoZ2V0Qm94KHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5mb2N1c05vZGUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKF9faW5kZXhPZi5jYWxsKGFycm93cywgYykgPj0gMCkgfHwgcHJpbnRhYmxlKGMpKSB7XG4gICAgICAgICAgZGVsYXkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gaGlnaGxpZ2h0UG9zaXRpb24oZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUuY3RybEtleSAmJiBjID09PSBFTlRFUikge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVLZXkoXCJDLUVOVEVSXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGUuYWx0S2V5ICYmIGMgPT09IEVOVEVSKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUtleShcIk0tRU5URVJcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gVEFCKSB7XG4gICAgICAgICAgaGFuZGxlS2V5KFwiVEFCXCIpO1xuICAgICAgICAgIHJldHVybiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBiciwgYngsIHIsIHMsIHNwO1xuXG4gICAgICAgIHMgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIHIgPSBzLmdldFJhbmdlQXQoMCk7XG4gICAgICAgIGlmICgoZS5jaGFyQ29kZSB8fCBlLmtleUNvZGUgfHwgZS53aGljaCkgPT09IEVOVEVSKSB7XG4gICAgICAgICAgYnIgPSB0ZXh0Tm9kZSgnXFxuJyk7XG4gICAgICAgICAgci5pbnNlcnROb2RlKGJyKTtcbiAgICAgICAgICByID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICByLnNldFN0YXJ0KGJyLCAxKTtcbiAgICAgICAgICBzLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgIHMuYWRkUmFuZ2Uocik7XG4gICAgICAgICAgcmV0dXJuIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChyLnN0YXJ0Q29udGFpbmVyLnBhcmVudE5vZGUgPT09IGVsKSB7XG4gICAgICAgICAgc3AgPSBjb2RlU3BhbignXFxuJywgJ2NvZGVFeHByJyk7XG4gICAgICAgICAgc3Auc2V0QXR0cmlidXRlKCdnZW5lcmF0ZWROTCcsICcnKTtcbiAgICAgICAgICBieCA9IGJveChzLmdldFJhbmdlQXQoMCksICdjb2RlTWFpbkV4cHInLCB0cnVlKTtcbiAgICAgICAgICBieC5hcHBlbmRDaGlsZChzcCk7XG4gICAgICAgICAgbWFrZU91dHB1dEJveChieCk7XG4gICAgICAgICAgciA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgci5zZXRTdGFydChzcCwgMCk7XG4gICAgICAgICAgcy5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICByZXR1cm4gcy5hZGRSYW5nZShyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGFsbG93RXZlbnRzKSB7XG4gICAgICAgICAgcmV0dXJuIGZpbmRDdXJyZW50Q29kZUhvbGRlcigpO1xuICAgICAgICB9XG4gICAgICB9KSwgdHJ1ZSk7XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoYWxsb3dFdmVudHMpIHtcbiAgICAgICAgICByZXR1cm4gZmluZEN1cnJlbnRDb2RlSG9sZGVyKCk7XG4gICAgICAgIH1cbiAgICAgIH0pLCB0cnVlKTtcbiAgICAgIGlmICh3aW5kb3cubGVpc3VyZUF1dG9SdW5BbGwpIHtcbiAgICAgICAgYXV0b1J1bihlbCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB3aW5kb3cuc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHJ1blRlc3RzKGVsKTtcbiAgICAgICAgfSksIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVsLmF1dG9ydW5TdGF0ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjaGVja0RlbGV0ZUV4cHIgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIG91dDtcblxuICAgIGlmIChpc091dHB1dChub2RlICYmIG5vZGUub3V0cHV0KSkge1xuICAgICAgb3V0ID0gbm9kZS5vdXRwdXQ7XG4gICAgICByZXR1cm4gd2luZG93LnNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIW5vZGUudGV4dENvbnRlbnQudHJpbSgpKSB7XG4gICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgobm9kZS5wYXJlbnROb2RlID09IG51bGwpICYmICgob3V0ICE9IG51bGwgPyBvdXQucGFyZW50Tm9kZSA6IHZvaWQgMCkgIT0gbnVsbCkpIHtcbiAgICAgICAgICByZXR1cm4gb3V0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQob3V0KTtcbiAgICAgICAgfVxuICAgICAgfSksIDEpO1xuICAgIH1cbiAgfTtcblxuICBza2lwTGVmdE92ZXJPdXRwdXRCb3ggPSBmdW5jdGlvbihlbCwgcikge1xuICAgIHZhciBib3gsIHM7XG5cbiAgICBlbC5ub3JtYWxpemUoKTtcbiAgICBib3ggPSBwcmV2aW91c0JveFJhbmdlSW50ZXJuYWwocikgfHwgcHJldmlvdXNCb3hSYW5nZVN0YXJ0KHIpO1xuICAgIGlmIChpc091dHB1dChib3gpKSB7XG4gICAgICBzID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgci5zZWxlY3ROb2RlKGJveCk7XG4gICAgICByLmNvbGxhcHNlKHRydWUpO1xuICAgICAgcy5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgIHMuYWRkUmFuZ2Uocik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBwcmV2aW91c0JveFJhbmdlSW50ZXJuYWwgPSBmdW5jdGlvbihyKSB7XG4gICAgcmV0dXJuIHIuc3RhcnRDb250YWluZXIubm9kZVR5cGUgPT09IDEgJiYgci5zdGFydE9mZnNldCA+IDAgJiYgci5zdGFydENvbnRhaW5lci5jaGlsZE5vZGVzW3Iuc3RhcnRPZmZzZXQgLSAxXTtcbiAgfTtcblxuICBwcmV2aW91c0JveFJhbmdlU3RhcnQgPSBmdW5jdGlvbihyKSB7XG4gICAgcmV0dXJuIHIuc3RhcnRDb250YWluZXIubm9kZVR5cGUgPT09IDMgJiYgci5zdGFydE9mZnNldCA9PT0gMCAmJiBwcmV2aW91c1NpYmxpbmcoci5zdGFydENvbnRhaW5lcik7XG4gIH07XG5cbiAgaWdub3JlRGVsZXRlT3V0cHV0Qm94ID0gZnVuY3Rpb24oZWwsIHIpIHtcbiAgICB2YXIgbjtcblxuICAgIGVsLm5vcm1hbGl6ZSgpO1xuICAgIGlmIChyLnN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlID09PSAzICYmIHIuc3RhcnRPZmZzZXQgPT09IHIuc3RhcnRDb250YWluZXIubGVuZ3RoKSB7XG4gICAgICBuID0gci5zdGFydENvbnRhaW5lcjtcbiAgICAgIHdoaWxlIChuICYmIG4ubmV4dFNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgbiA9IG4ucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc091dHB1dChuICE9IG51bGwgPyBuLm5leHRTaWJsaW5nIDogdm9pZCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBpc091dHB1dCA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgcmV0dXJuIChlbCAhPSBudWxsID8gZWwubm9kZVR5cGUgOiB2b2lkIDApID09PSAxICYmIGVsLmhhc0F0dHJpYnV0ZSgnTGVpc3VyZU91dHB1dCcpO1xuICB9O1xuXG4gIGlzTGVpc3VyZUNvZGUgPSBmdW5jdGlvbihlbCkge1xuICAgIHJldHVybiAoZWwgIT0gbnVsbCA/IGVsLm5vZGVUeXBlIDogdm9pZCAwKSA9PT0gMSAmJiBlbC5nZXRBdHRyaWJ1dGUoJ2xlaXN1cmVOb2RlJykgPT09ICdjb2RlJztcbiAgfTtcblxuICBwZWVyTm90aWZ5U2VsZWN0aW9uID0gZnVuY3Rpb24oZWwsIHN0cikge307XG5cbiAgcHJpbnRhYmxlQ29udHJvbENoYXJhY3RlcnMgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIF9pLCBfbGVuLCBfcmVmMywgX3Jlc3VsdHM7XG5cbiAgICBfcmVmMyA9IFwiXFxyXFxpXFxuXFxiXCI7XG4gICAgX3Jlc3VsdHMgPSBbXTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBjID0gX3JlZjNbX2ldO1xuICAgICAgX3Jlc3VsdHMucHVzaChjLmNoYXJDb2RlQXQoMCkpO1xuICAgIH1cbiAgICByZXR1cm4gX3Jlc3VsdHM7XG4gIH0pKCk7XG5cbiAgcHJpbnRhYmxlID0gZnVuY3Rpb24oY29kZSkge1xuICAgIHJldHVybiAoY29kZSA+IDB4ZiAmJiBjb2RlIDwgMzcpIHx8IGNvZGUgPiA0MCB8fCBfX2luZGV4T2YuY2FsbChwcmludGFibGVDb250cm9sQ2hhcmFjdGVycywgY29kZSkgPj0gMDtcbiAgfTtcblxuICBub25wcmludGFibGUgPSBudWxsO1xuXG4gIChmdW5jdGlvbigpIHtcbiAgICB2YXIgaSwgcywgX2k7XG5cbiAgICBzID0gJyc7XG4gICAgZm9yIChpID0gX2kgPSAwOyAwIDw9IDB4ZiA/IF9pIDw9IDB4ZiA6IF9pID49IDB4ZjsgaSA9IDAgPD0gMHhmID8gKytfaSA6IC0tX2kpIHtcbiAgICAgIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTtcbiAgICB9XG4gICAgcy5yZXBsYWNlKC9bXFxpXFxyXFxmXS9nLCAnJyk7XG4gICAgcmV0dXJuIG5vbnByaW50YWJsZSA9IG5ldyBSZWdFeHAoXCJbXCIgKyBzICsgXCJdXCIpO1xuICB9KSgpO1xuXG4gIGhhbmRsZUtleSA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciBib3g7XG5cbiAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgY2FzZSBcIkMtRU5URVJcIjpcbiAgICAgIGNhc2UgXCJUQUJcIjpcbiAgICAgICAgYm94ID0gZ2V0Qm94KHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5mb2N1c05vZGUpO1xuICAgICAgICBpZiAoKGJveC5nZXRBdHRyaWJ1dGUoJ2NvZGVNYWluRXhwcicpKSAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGV2YWxPdXRwdXQoYm94Lm91dHB1dCk7XG4gICAgICAgIH0gZWxzZSBpZiAoKGJveC5nZXRBdHRyaWJ1dGUoJ2NvZGVNYWluJykpICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gYWNjZXB0Q29kZShib3gpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIk0tRU5URVJcIjpcbiAgICAgICAgYm94ID0gZ2V0Qm94KHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5mb2N1c05vZGUpO1xuICAgICAgICBpZiAoKGJveC5nZXRBdHRyaWJ1dGUoJ2NvZGVNYWluRXhwcicpKSAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGNsZWFyT3V0cHV0Qm94KGJveC5vdXRwdXQpO1xuICAgICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNsZWFyQXN0ID0gZnVuY3Rpb24oYm94KSB7XG4gICAgdmFyIGNib3g7XG5cbiAgICBjYm94ID0gZ2V0Qm94KGJveCk7XG4gICAgcmV0dXJuIGNib3ggIT0gbnVsbCA/IGNib3guYXN0ID0gbnVsbCA6IHZvaWQgMDtcbiAgfTtcblxuICBvbGRCcmFja2V0cyA9IFtudWxsLCBOaWxdO1xuXG4gIGNsZWFuRW1wdHlOb2RlcyA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgdmFyIG5leHQsIHByZXYsIF9yZWYzO1xuXG4gICAgaWYgKGVsLm5vZGVUeXBlID09PSAzICYmIChlbC5wYXJlbnROb2RlICE9IG51bGwpKSB7XG4gICAgICByZXR1cm4gY2xlYW5FbXB0eU5vZGVzKGVsLnBhcmVudE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmV2ID0gZWwucHJldmlvdXNTaWJsaW5nO1xuICAgICAgbmV4dCA9IGVsLm5leHRTaWJsaW5nO1xuICAgICAgaWYgKGVsLm5vZGVUeXBlID09PSAxICYmIGVsLnRleHRDb250ZW50LnRyaW0oKSA9PT0gJycgJiYgKChfcmVmMyA9IGVsLnBhcmVudE5vZGUpICE9IG51bGwgPyBfcmVmMy5oYXNBdHRyaWJ1dGUoJ2RvYycpIDogdm9pZCAwKSkge1xuICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXh0ID09PSBuZXh0U2libGluZyhwcmV2KSkge1xuICAgICAgICByZXR1cm4gbWVyZ2VMZWlzdXJlQ29kZShwcmV2LCBuZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcHJlc2VudExlaXN1cmVDb2RlID0gZnVuY3Rpb24obm9kZSwgZG9FdmFsKSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRFZGl0YWJsZScsICd0cnVlJyk7XG4gICAgTm90ZWJvb2suYmluZE5vdGVib29rKG5vZGUpO1xuICAgIE5vdGVib29rLmNoYW5nZVRoZW1lKG5vZGUsICd0aGluJyk7XG4gICAgaWYgKGRvRXZhbCkge1xuICAgICAgcmV0dXJuIGV2YWxEb2Mobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBpbml0Tm90ZWJvb2sobm9kZSk7XG4gICAgfVxuICB9O1xuXG4gIG1lcmdlTGVpc3VyZUNvZGUgPSBmdW5jdGlvbihlbDEsIGVsMikge1xuICAgIHZhciBuZXdDb2RlLCByO1xuXG4gICAgaWYgKGVsMSAmJiBlbDIpIHtcbiAgICAgIGlmIChlbDEubm9kZVR5cGUgPT09IDEgJiYgZWwyLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICAgIGVsMS5hcHBlbmRDaGlsZChlbDIpO1xuICAgICAgICByZXR1cm4gZWwxLm5vcm1hbGl6ZSgpO1xuICAgICAgfSBlbHNlIGlmIChlbDEubm9kZVR5cGUgPT09IDMgJiYgZWwyLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgIGVsMi5pbnNlcnRCZWZvcmUoZWwxLCBlbDIuZmlyc3RDaGlsZCk7XG4gICAgICAgIHJldHVybiBlbDIubm9ybWFsaXplKCk7XG4gICAgICB9IGVsc2UgaWYgKGVsMS5oYXNBdHRyaWJ1dGUoJ2xlaXN1cmVOb2RlJykgJiYgZWwxLmdldEF0dHJpYnV0ZSgnbGVpc3VyZU5vZGUnKSA9PT0gZWwyLmdldEF0dHJpYnV0ZSgnbGVpc3VyZU5vZGUnKSkge1xuICAgICAgICBuZXdDb2RlID0gdGV4dE5vZGUoZWwxLm1kID0gZWwxLmdldEF0dHJpYnV0ZSgnbGVpc3VyZU5vZGUnKSA9PT0gJ2NvZGUnID8gXCJcIiArIChnZXRFbGVtZW50Q29kZShlbDEpKSArIFwiXFxuXCIgKyAoZ2V0RWxlbWVudENvZGUoZWwyKSkgOiBcIlwiICsgZWwxLm1kICsgXCJcXG5cIiArIGVsMi5tZCk7XG4gICAgICAgIHIgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICByLnNlbGVjdE5vZGVDb250ZW50cyhlbDIpO1xuICAgICAgICBlbDEuYXBwZW5kQ2hpbGQodGV4dE5vZGUoJ1xcbicpKTtcbiAgICAgICAgZWwxLmFwcGVuZENoaWxkKHIuZXh0cmFjdENvbnRlbnRzKCkpO1xuICAgICAgICByZXR1cm4gZWwyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgaGlnaGxpZ2h0UG9zaXRpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGFzdCwgYiwgYnJhY2tldHMsIGNoYW5nZWQsIGksIG5vZGUsIHBhcmVudCwgcG9zLCByLCByYW5nZXMsIHMsIHNwYW4sIF9pLCBfaiwgX2ssIF9sZW4sIF9sZW4xLCBfbGVuMiwgX3JlZjMsIF9yZWY0LCBfcmVmNTtcblxuICAgIHBhcmVudCA9IG51bGw7XG4gICAgcyA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAocy5yYW5nZUNvdW50KSB7XG4gICAgICBpZiAoY2xlYW5FbXB0eU5vZGVzKHMuZ2V0UmFuZ2VBdCgwKS5zdGFydENvbnRhaW5lcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9jdXNCb3gocy5mb2N1c05vZGUpO1xuICAgICAgcGFyZW50ID0gZ2V0Qm94KHMuZm9jdXNOb2RlKTtcbiAgICAgIGlmICgoX3JlZjMgPSBzLmdldFJhbmdlQXQoMCkpICE9IG51bGwgPyBfcmVmMy5jb2xsYXBzZWQgOiB2b2lkIDApIHtcbiAgICAgICAgaWYgKCFwYXJlbnQgfHwgaXNPdXRwdXQocGFyZW50KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyZW50LnBhcmVudE5vZGUgJiYgKGFzdCA9IGdldEFzdChwYXJlbnQpKSkge1xuICAgICAgICAgIHIgPSBzLmdldFJhbmdlQXQoMCk7XG4gICAgICAgICAgci5zZXRTdGFydChwYXJlbnQsIDApO1xuICAgICAgICAgIHBvcyA9IGdldFJhbmdlVGV4dChyKS5sZW5ndGg7XG4gICAgICAgICAgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgIGlmIChmYWxzZSkge1xuICAgICAgICAgICAgYnJhY2tldHMgPSBMZWlzdXJlLmJyYWNrZXQoYXN0LmxlaXN1cmVCYXNlLCBwb3MpO1xuICAgICAgICAgICAgaWYgKG9sZEJyYWNrZXRzWzBdICE9PSBwYXJlbnQgfHwgIW9sZEJyYWNrZXRzWzFdLmVxdWFscyhicmFja2V0cykpIHtcbiAgICAgICAgICAgICAgb2xkQnJhY2tldHMgPSBbcGFyZW50LCBicmFja2V0c107XG4gICAgICAgICAgICAgIF9yZWY0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltMZWlzdXJlQnJhY2tldHNdXCIpO1xuICAgICAgICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWY0Lmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IF9yZWY0W19pXTtcbiAgICAgICAgICAgICAgICB1bndyYXAobm9kZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX3JlZjUgPSBwYXJlbnQucXVlcnlTZWxlY3RvckFsbChcIi5wYXJ0aWFsQXBwbHlcIik7XG4gICAgICAgICAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IF9yZWY1Lmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBfcmVmNVtfal07XG4gICAgICAgICAgICAgICAgdW53cmFwKG5vZGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBhcmVudC5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgbWFya1BhcnRpYWxBcHBsaWVzKHBhcmVudCk7XG4gICAgICAgICAgICAgIGIgPSBicmFja2V0cztcbiAgICAgICAgICAgICAgcmFuZ2VzID0gW107XG4gICAgICAgICAgICAgIHdoaWxlIChiICE9PSBOaWwpIHtcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChtYWtlUmFuZ2UocGFyZW50LCBiLmhlYWQoKS5oZWFkKCksIGIuaGVhZCgpLnRhaWwoKS5oZWFkKCkpKTtcbiAgICAgICAgICAgICAgICBiID0gYi50YWlsKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yIChpID0gX2sgPSAwLCBfbGVuMiA9IHJhbmdlcy5sZW5ndGg7IF9rIDwgX2xlbjI7IGkgPSArK19rKSB7XG4gICAgICAgICAgICAgICAgciA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKCdMZWlzdXJlQnJhY2tldHMnLCAnJyk7XG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgaSA9PT0gMCA/ICdMZWlzdXJlRnVuYycgOiAnTGVpc3VyZUFyZycpO1xuICAgICAgICAgICAgICAgIHdyYXBSYW5nZShyLCBzcGFuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBLZXlib2FyZEV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoaGlkZVNsaWRlcigpKSB7XG4gICAgICAgICAgICAgIHBvcyArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoZSBpbnN0YW5jZW9mIE1vdXNlRXZlbnQgJiYgZS50eXBlID09PSAnbW91c2Vkb3duJyAmJiAoZS50YXJnZXQgPT09IHBhcmVudCB8fCBwYXJlbnQuY29udGFpbnMoZS50YXJnZXQpKSAmJiBzaG93U2xpZGVyQnV0dG9uKHBhcmVudCwgcG9zLCBlKSkge1xuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5FVlQgPSBlO1xuICAgICAgICAgICAgcy5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgIHMuYWRkUmFuZ2UobWFrZVJhbmdlKHBhcmVudCwgcG9zKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcGVlck5vdGlmeVNlbGVjdGlvbihwYXJlbnQsIHMudG9TdHJpbmcoKSk7XG4gICAgfVxuICB9O1xuXG4gIG51bWJlckVuZCA9IC8oPzpefC4qW14wLTkuXSkoWzAtOV0rXFwuP1swLTldKnxcXC5bMC05XSopJC87XG5cbiAgbnVtYmVyU3RhcnQgPSAvXihbMC05XStcXC5bMC05XSt8WzAtOV0rfFxcLlswLTldKykvO1xuXG4gIHNsaWRlciA9IFtdO1xuXG4gIHNob3dTbGlkZXJCdXR0b24gPSBmdW5jdGlvbihwYXJlbnQsIHBvcywgZSkge1xuICAgIHZhciBjaGFuZ2VkLCBsZW4sIG0sIG9sZFBvcywgciwgc1BhcmVudCwgc1Bvcywgc1ZhbHVlLCBzcGFuLCB0ZXh0O1xuXG4gICAgaWYgKHNsaWRlci5sZW5ndGgpIHtcbiAgICAgIGhpZGVTbGlkZXIoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dCA9IHBhcmVudC50ZXh0Q29udGVudDtcbiAgICAgIG9sZFBvcyA9IHBvcztcbiAgICAgIGNoYW5nZWQgPSAwO1xuICAgICAgaWYgKG0gPSB0ZXh0LnN1YnN0cmluZygwLCBwb3MpLm1hdGNoKG51bWJlckVuZCkpIHtcbiAgICAgICAgcG9zIC09IG1bMV0ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKG0gPSB0ZXh0LnN1YnN0cmluZyhwb3MpLm1hdGNoKG51bWJlclN0YXJ0KSkge1xuICAgICAgICBsZW4gPSBtWzFdLmxlbmd0aDtcbiAgICAgICAgaWYgKG9sZFBvcyA8PSBwb3MgKyBsZW4pIHtcbiAgICAgICAgICBzUGFyZW50ID0gc2xpZGVyWzBdLCBzUG9zID0gc2xpZGVyWzFdLCBzVmFsdWUgPSBzbGlkZXJbMl07XG4gICAgICAgICAgaWYgKHBhcmVudCAhPT0gc1BhcmVudCB8fCBwb3MgIT09IHNQb3MgfHwgbVsxXSAhPT0gc1ZhbHVlKSB7XG4gICAgICAgICAgICBoaWRlU2xpZGVyKCk7XG4gICAgICAgICAgICByID0gbWFrZVJhbmdlKHBhcmVudCwgcG9zLCBwb3MgKyBtWzFdLmxlbmd0aCk7XG4gICAgICAgICAgICBzcGFuID0gY3JlYXRlTm9kZShcIjxzcGFuIGNsYXNzPSdsZWlzdXJlUmFuZ2VOdW1iZXIgdWktd2lkZ2V0LWNvbnRlbnQnPjwvc3Bhbj5cIik7XG4gICAgICAgICAgICB3cmFwUmFuZ2Uociwgc3Bhbik7XG4gICAgICAgICAgICBjaGFuZ2VkID0gMTtcbiAgICAgICAgICAgIHNwYW4ubm9ybWFsaXplKCk7XG4gICAgICAgICAgICBzbGlkZXIgPSBbcGFyZW50LCBwb3MsIG1bMV0sIHNwYW5dO1xuICAgICAgICAgICAgY3JlYXRlU2xpZGVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGhpZGVTbGlkZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgaXNTbGlkZXIgPSBmdW5jdGlvbihlbCkge1xuICAgIHdoaWxlIChlbCAhPT0gZG9jdW1lbnQpIHtcbiAgICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ3NsaWRlcicpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZWwgPSBlbC5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgY3JlYXRlU2xpZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGQsIGRpdiwgaW5zaWRlLCBtYXgsIG1pbiwgcGFyZW50LCBwb3MsIHNsLCBzbGlkaW5nLCBzcGFuLCB2YWx1ZTtcblxuICAgIHBhcmVudCA9IHNsaWRlclswXSwgcG9zID0gc2xpZGVyWzFdLCB2YWx1ZSA9IHNsaWRlclsyXSwgc3BhbiA9IHNsaWRlclszXSwgZGl2ID0gc2xpZGVyWzRdO1xuICAgIGlmIChkaXYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW5zaWRlID0gZmFsc2U7XG4gICAgc2xpZGluZyA9IGZhbHNlO1xuICAgIGQgPSBjcmVhdGVOb2RlKFwiPGRpdiBzdHlsZT0nei1pbmRleDogMTsgcG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogMjAwcHg7IGJhY2tncm91bmQ6IHdoaXRlOyBib3JkZXI6IHNvbGlkIGdyZWVuIDFweCcgc2xpZGVyIGNvbnRlbnRFZGl0YWJsZT0nZmFsc2UnPjwvZGl2PlwiKTtcbiAgICBzbGlkZXIucHVzaChkKTtcbiAgICBkLnN0eWxlLnRvcCA9IFwiXCIgKyAoc3Bhbi5vZmZzZXRUb3AgKyBzcGFuLm9mZnNldEhlaWdodCArIDUpICsgXCJweFwiO1xuICAgIGQuc3R5bGUubWluVG9wID0gJzBweCc7XG4gICAgZC5zdHlsZS5sZWZ0ID0gXCJcIiArIChNYXRoLm1heCgwLCAoc3Bhbi5vZmZzZXRMZWZ0ICsgc3Bhbi5vZmZzZXRXaWR0aCkgLyAyIC0gMTAwKSkgKyBcInB4XCI7XG4gICAgZC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoIWluc2lkZSkge1xuICAgICAgICByZXR1cm4gaW5zaWRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUudG9FbGVtZW50ICE9PSBkICYmICFkLmNvbnRhaW5zKGUudG9FbGVtZW50KSkge1xuICAgICAgICBpbnNpZGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFzbGlkaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIGhpZGVTbGlkZXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHZhbHVlID0gTnVtYmVyKHZhbHVlKTtcbiAgICBtaW4gPSB2YWx1ZSA8IDAgPyB2YWx1ZSAqIDIgOiB2YWx1ZSAvIDI7XG4gICAgbWF4ID0gdmFsdWUgPT09IDAgPyAxMCA6IHZhbHVlICogMjtcbiAgICBzbCA9ICQoZCkuc2xpZGVyKHtcbiAgICAgIGFuaW1hdGU6ICdmYXN0JyxcbiAgICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgc2xpZGluZyA9IHRydWU7XG4gICAgICAgIHJldHVybiBkZWxheShmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gYWxsb3dFdmVudHMgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgc3RvcDogZnVuY3Rpb24oZXZlbnQsIHVpKSB7XG4gICAgICAgIHNldE1pbk1heChzbCk7XG4gICAgICAgIGFsbG93RXZlbnRzID0gdHJ1ZTtcbiAgICAgICAgc2xpZGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoIWluc2lkZSkge1xuICAgICAgICAgIHJldHVybiBoaWRlU2xpZGVyKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzbGlkZTogZnVuY3Rpb24oZXZlbnQsIHVpKSB7XG4gICAgICAgIHZhciBhc3QsIF9yZWYzO1xuXG4gICAgICAgIGlmIChzcGFuLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICBzcGFuLmZpcnN0Q2hpbGQubm9kZVZhbHVlID0gU3RyaW5nKHVpLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgICAgIHBhcmVudC5hc3QgPSBudWxsO1xuICAgICAgICAgIGFjY2VwdENvZGUocGFyZW50KTtcbiAgICAgICAgICBhc3QgPSBnZXRBc3QocGFyZW50KTtcbiAgICAgICAgICBpZiAoKF9yZWYzID0gcGFyZW50LmFzdCkgIT0gbnVsbCA/IF9yZWYzLmxlaXN1cmVOYW1lIDogdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlKFwic2VsLVwiICsgcGFyZW50LmFzdC5sZWlzdXJlTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1ha2VJZChwYXJlbnQpO1xuICAgICAgICAgIGlmICghcGFyZW50LmdldEF0dHJpYnV0ZShwYXJlbnQub3V0cHV0LCAnbGVpc3VyZVVwZGF0ZScpKSB7XG4gICAgICAgICAgICBzZXRVcGRhdGUocGFyZW50Lm91dHB1dCwgXCJpZC1cIiArIHBhcmVudC5pZCArIFwiIGNvbXBpbGVcIiwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZShcImlkLVwiICsgcGFyZW50LmlkKTtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlKFwiY29tcGlsZVwiKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0pO1xuICAgIHNldE1pbk1heChzbCwgdmFsdWUpO1xuICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoZCwgcGFyZW50LmZpcnN0Q2hpbGQpO1xuICAgIHJldHVybiBkLmZvY3VzKCk7XG4gIH07XG5cbiAgcHNnbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA8IDApIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9O1xuXG4gIHNldE1pbk1heCA9IGZ1bmN0aW9uKHNsLCB2YWx1ZSkge1xuICAgIHZhciBtYXgsIG1pbiwgc3RlcCwgX3JlZjM7XG5cbiAgICB2YWx1ZSA9IHZhbHVlIHx8IHNsLnNsaWRlcihcInZhbHVlXCIpO1xuICAgIG1pbiA9IDA7XG4gICAgbWF4ID0gKDEgPD0gKF9yZWYzID0gTWF0aC5hYnModmFsdWUpKSAmJiBfcmVmMyA8IDUwKSB8fCB2YWx1ZSA9PT0gMCA/IDEwMCAqIHBzZ24odmFsdWUpIDogdmFsdWUgKiAyO1xuICAgIGlmIChNYXRoLnJvdW5kKHZhbHVlKSA9PT0gdmFsdWUpIHtcbiAgICAgIHN0ZXAgPSBNYXRoLnJvdW5kKChtYXggLSBtaW4pIC8gMTAwKTtcbiAgICAgIHN0ZXAgPSBzdGVwIC0gc3RlcCAlIChtYXggLSBtaW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGVwID0gKG1heCAtIG1pbikgLyAxMDA7XG4gICAgfVxuICAgIHNsLnNsaWRlcihcIm9wdGlvblwiLCBcIm1pblwiLCBtaW4pO1xuICAgIHNsLnNsaWRlcihcIm9wdGlvblwiLCBcIm1heFwiLCBtYXgpO1xuICAgIHJldHVybiBzbC5zbGlkZXIoXCJvcHRpb25cIiwgXCJzdGVwXCIsIHN0ZXApO1xuICB9O1xuXG4gIGhpZGVTbGlkZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGl2LCBwYXJlbnQsIHNQb3MsIHNWYWx1ZSwgc3BhbjtcblxuICAgIGlmIChzbGlkZXIubGVuZ3RoKSB7XG4gICAgICBwYXJlbnQgPSBzbGlkZXJbMF0sIHNQb3MgPSBzbGlkZXJbMV0sIHNWYWx1ZSA9IHNsaWRlclsyXSwgc3BhbiA9IHNsaWRlclszXSwgZGl2ID0gc2xpZGVyWzRdO1xuICAgICAgdW53cmFwKHNwYW4pO1xuICAgICAgaWYgKGRpdikge1xuICAgICAgICByZW1vdmUoZGl2KTtcbiAgICAgIH1cbiAgICAgIHBhcmVudC5ub3JtYWxpemUoKTtcbiAgICAgIHNsaWRlciA9IFtdO1xuICAgICAgcmV0dXJuIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfTtcblxuICB3cmFwUmFuZ2UgPSBmdW5jdGlvbihyYW5nZSwgbm9kZSkge1xuICAgIHZhciBjb250ZW50cywgZXJyO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiByYW5nZS5zdXJyb3VuZENvbnRlbnRzKG5vZGUpO1xuICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgZXJyID0gX2Vycm9yO1xuICAgICAgY29udGVudHMgPSByYW5nZS5jbG9uZUNvbnRlbnRzKCk7XG4gICAgICByZXBsYWNlUmFuZ2UocmFuZ2UsIG5vZGUpO1xuICAgICAgcmV0dXJuIG5vZGUuYXBwZW5kQ2hpbGQoY29udGVudHMpO1xuICAgIH1cbiAgfTtcblxuICByZXBsYWNlUmFuZ2UgPSBmdW5jdGlvbihyYW5nZSwgbm9kZSkge1xuICAgIHJhbmdlLmRlbGV0ZUNvbnRlbnRzKCk7XG4gICAgcmV0dXJuIHJhbmdlLmluc2VydE5vZGUobm9kZSk7XG4gIH07XG5cbiAgZ2V0UmFuZ2VUZXh0ID0gZnVuY3Rpb24ocikge1xuICAgIHJldHVybiByLmNsb25lQ29udGVudHMoKS50ZXh0Q29udGVudDtcbiAgfTtcblxuICBnZXRCb3ggPSBmdW5jdGlvbihub2RlKSB7XG4gICAgd2hpbGUgKChub2RlICE9IG51bGwpICYmICgodHlwZW9mIG5vZGUuZ2V0QXR0cmlidXRlID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLmdldEF0dHJpYnV0ZSgnTGVpc3VyZUJveCcpIDogdm9pZCAwKSA9PSBudWxsKSkge1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgY2hlY2tNdXRhdGVGcm9tTW9kaWZpY2F0aW9uID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgdmFyIGIsIGIyO1xuXG4gICAgYiA9IGdldEJveChldnQudGFyZ2V0KTtcbiAgICBiMiA9IGdldEJveCh3aW5kb3cuZ2V0U2VsZWN0aW9uKCkuZm9jdXNOb2RlKTtcbiAgICBpZiAoYiAmJiBiID09PSBiMikge1xuICAgICAgaWYgKChpc0RlZihiKSkgJiYgYi5jbGFzc0xpc3QuY29udGFpbnMoJ2NvZGVNYWluRXhwcicpKSB7XG4gICAgICAgIHRvRGVmQm94KGIpO1xuICAgICAgfSBlbHNlIGlmICghKGlzRGVmKGIpKSAmJiBiLmNsYXNzTGlzdC5jb250YWlucygnY29kZU1haW4nKSkge1xuICAgICAgICB0b0V4cHJCb3goYik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVwbGljYXRlKGIpO1xuICAgIH1cbiAgfTtcblxuICByZXBsaWNhdGUgPSBmdW5jdGlvbihiKSB7XG4gICAgaWYgKGIucmVwbGljYXRvcikge1xuICAgICAgcmV0dXJuIGRlbGF5KGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYi5yZXBsaWNhdG9yLnJlcGxpY2F0ZShiKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBidXR0b25DbGFzc2VzID0gJ3VpLWJ1dHRvbiB1aS13aWRnZXQgdWktc3RhdGUtZGVmYXVsdCB1aS1jb3JuZXItYWxsIHVpLWJ1dHRvbi10ZXh0LW9ubHknLnNwbGl0KCcgJyk7XG5cbiAgYm94Q2xhc3NlcyA9IHtcbiAgICBjb2RlTWFpbkV4cHI6IFsnY29kZU1haW5FeHByJywgJ3VpLXdpZGdldCcsICd1aS13aWRnZXQtY29udGVudCcsICd1aS1jb3JuZXItYWxsJ10sXG4gICAgY29kZU1haW46IFsnY29kZU1haW4nLCAndWktd2lkZ2V0JywgJ3VpLXdpZGdldC1jb250ZW50JywgJ3VpLWNvcm5lci1hbGwnXSxcbiAgICBjb2RlTWFpblRlc3Q6IFsnY29kZU1haW5UZXN0J10sXG4gICAgb3V0cHV0OiBbJ291dHB1dCcsICd1aS1jb3JuZXItYWxsJ11cbiAgfTtcblxuICBhZGRCb3hDbGFzc2VzID0gZnVuY3Rpb24oYm94LCB0eXBlKSB7XG4gICAgdmFyIGNsLCBfaSwgX2xlbiwgX3JlZjMsIF9yZXN1bHRzO1xuXG4gICAgYm94LnNldEF0dHJpYnV0ZSh0eXBlLCAnJyk7XG4gICAgX3JlZjMgPSBib3hDbGFzc2VzW3R5cGVdO1xuICAgIF9yZXN1bHRzID0gW107XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgY2wgPSBfcmVmM1tfaV07XG4gICAgICBfcmVzdWx0cy5wdXNoKGJveC5jbGFzc0xpc3QuYWRkKGNsKSk7XG4gICAgfVxuICAgIHJldHVybiBfcmVzdWx0cztcbiAgfTtcblxuICByZW1vdmVCb3hDbGFzc2VzID0gZnVuY3Rpb24oYm94LCB0eXBlKSB7XG4gICAgdmFyIGNsLCBfaSwgX2xlbiwgX3JlZjMsIF9yZXN1bHRzO1xuXG4gICAgYm94LnJlbW92ZUF0dHJpYnV0ZSh0eXBlKTtcbiAgICBfcmVmMyA9IGJveENsYXNzZXNbdHlwZV07XG4gICAgX3Jlc3VsdHMgPSBbXTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBjbCA9IF9yZWYzW19pXTtcbiAgICAgIF9yZXN1bHRzLnB1c2goYm94LmNsYXNzTGlzdC5yZW1vdmUoY2wpKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZXN1bHRzO1xuICB9O1xuXG4gIHRvRXhwckJveCA9IGZ1bmN0aW9uKGIpIHtcbiAgICB2YXIgbm9kZSwgX2ksIF9qLCBfbGVuLCBfbGVuMSwgX3JlZjMsIF9yZWY0O1xuXG4gICAgcmVtb3ZlQm94Q2xhc3NlcyhiLCAnY29kZU1haW4nKTtcbiAgICBhZGRCb3hDbGFzc2VzKGIsICdjb2RlTWFpbkV4cHInKTtcbiAgICBfcmVmMyA9IGIucXVlcnlTZWxlY3RvckFsbCgnW2NvZGVuYW1lXScpO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIG5vZGUgPSBfcmVmM1tfaV07XG4gICAgICB1bndyYXAobm9kZSk7XG4gICAgfVxuICAgIF9yZWY0ID0gYi5xdWVyeVNlbGVjdG9yQWxsKCcuYXN0YnV0dG9uJyk7XG4gICAgZm9yIChfaiA9IDAsIF9sZW4xID0gX3JlZjQubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICBub2RlID0gX3JlZjRbX2pdO1xuICAgICAgcmVtb3ZlKG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gbWFrZU91dHB1dEJveChiKTtcbiAgfTtcblxuICB0b0RlZkJveCA9IGZ1bmN0aW9uKGIpIHtcbiAgICBpZiAoYi5vdXRwdXQpIHtcbiAgICAgIHJlbW92ZShiLm91dHB1dCk7XG4gICAgfVxuICAgIHJlbW92ZUJveENsYXNzZXMoYiwgJ2NvZGVNYWluRXhwcicpO1xuICAgIGFkZEJveENsYXNzZXMoYiwgJ2NvZGVNYWluJyk7XG4gICAgcmV0dXJuIGFkZERlZkNvbnRyb2xzKGIpO1xuICB9O1xuXG4gIGFkZERlZkNvbnRyb2xzID0gZnVuY3Rpb24oYm94KSB7XG4gICAgdmFyIGJ0bjtcblxuICAgIGJ0biA9IGNyZWF0ZU5vZGUoXCI8YnV0dG9uIG9uY2xpY2s9J05vdGVib29rLnNob3dBc3QodGhpcy5wYXJlbnROb2RlKScgY2xhc3M9J2FzdGJ1dHRvbicgdGl0bGU9J1Nob3cgQVNUJz48L2J1dHRvbj5cIik7XG4gICAgbWFya3VwQnV0dG9uKGJ0bik7XG4gICAgcmV0dXJuIGJveC5hcHBlbmRDaGlsZChidG4pO1xuICB9O1xuXG4gIHJlbW92ZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgX3JlZjM7XG5cbiAgICByZXR1cm4gKF9yZWYzID0gbm9kZS5wYXJlbnROb2RlKSAhPSBudWxsID8gX3JlZjMucmVtb3ZlQ2hpbGQobm9kZSkgOiB2b2lkIDA7XG4gIH07XG5cbiAgc2hvd0FzdCA9IGZ1bmN0aW9uKGJveCkge1xuICAgIHZhciBuYW1lLCBub2RlLCBvdXRwdXQ7XG5cbiAgICBuYW1lID0gKGdldEFzdChib3gpKS5sZWlzdXJlTmFtZTtcbiAgICBpZiAoYm94LmFzdE91dCAhPSBudWxsKSB7XG4gICAgICByZW1vdmUoYm94LmFzdE91dC5vdXRwdXQpO1xuICAgICAgcmVtb3ZlKGJveC5hc3RPdXQpO1xuICAgICAgcmV0dXJuIGJveC5hc3RPdXQgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgICBub2RlID0gY29kZUJveCgnY29kZU1haW5FeHByJyk7XG4gICAgICBib3guYXN0T3V0ID0gbm9kZTtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdsZWlzdXJlT3V0cHV0JywgJycpO1xuICAgICAgYm94LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIGJveC5uZXh0U2libGluZyk7XG4gICAgICBub2RlLnRleHRDb250ZW50ID0gXCIjQHVwZGF0ZSBzZWwtXCIgKyBuYW1lICsgXCJcXG50cmVlRm9yTm90ZWJvb2sgXCIgKyBuYW1lO1xuICAgICAgb3V0cHV0ID0gbWFrZU91dHB1dEJveChub2RlKTtcbiAgICAgIHRvZ2dsZUVkaXQob3V0cHV0KTtcbiAgICAgIHJldHVybiBldmFsT3V0cHV0KG91dHB1dCwgdHJ1ZSk7XG4gICAgfVxuICB9O1xuXG4gIGhpZ2hsaWdodE5vdGVib29rRnVuY3Rpb24gPSBmdW5jdGlvbihmdW5jTmFtZSwgc3RhcnQsIHN0b3ApIHtcbiAgICB2YXIgYm94LCBvZmZzZXQsIHNlbDtcblxuICAgIGJveCA9IGRvY3VtZW50LmJvZHkucXVlcnlTZWxlY3RvcihcIltsZWlzdXJlZnVuYz1cIiArIGZ1bmNOYW1lICsgXCJdXCIpO1xuICAgIG9mZnNldCA9IDA7XG4gICAgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICByZXR1cm4gc2VsLmFkZFJhbmdlKG1ha2VSYW5nZShib3gsIHN0YXJ0ICsgb2Zmc2V0LCBzdG9wICsgb2Zmc2V0KSk7XG4gIH07XG5cbiAgaXNEZWYgPSBmdW5jdGlvbihib3gpIHtcbiAgICB2YXIgZGVmVHlwZSwgbGVhZGluZywgbSwgbWF0Y2hlZCwgbmFtZSwgdHh0O1xuXG4gICAgdHh0ID0gYm94LnRleHRDb250ZW50O1xuICAgIGlmICgobSA9IHR4dC5tYXRjaChMX2RlZlBhdCgpKSkpIHtcbiAgICAgIG1hdGNoZWQgPSBtWzBdLCBsZWFkaW5nID0gbVsxXSwgbmFtZSA9IG1bMl0sIGRlZlR5cGUgPSBtWzNdO1xuICAgICAgcmV0dXJuIChkZWZUeXBlICE9IG51bGwgPyBkZWZUeXBlLmxlbmd0aCA6IHZvaWQgMCkgPiAwO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgaW5pdE5vdGVib29rID0gZnVuY3Rpb24oZWwpIHtcbiAgICB2YXIgcGdtO1xuXG4gICAgZWwucmVwbGFjaW5nID0gdHJ1ZTtcbiAgICByZW1vdmVPbGREZWZzKGVsKTtcbiAgICBwZ20gPSBtYXJrdXBEZWZzKGVsLCBmaW5kRGVmcyhlbCkpO1xuICAgIGVsLm5vcm1hbGl6ZSgpO1xuICAgIGVsLnJlcGxhY2luZyA9IGZhbHNlO1xuICAgIGlmICghZWwuaGFzQXR0cmlidXRlKCdub0xlaXN1cmVCYXInKSkge1xuICAgICAgaW5zZXJ0Q29udHJvbHMoZWwpO1xuICAgICAgZWwudGVzdFJlc3VsdHMuaW5uZXJIVE1MID0gcGdtWzJdO1xuICAgIH1cbiAgICBzbmFwc2hvdChlbCwgcGdtKTtcbiAgICByZXR1cm4gcGdtO1xuICB9O1xuXG4gIG1ha2VMYWJlbCA9IGZ1bmN0aW9uKHRleHQsIGMpIHtcbiAgICB2YXIgbm9kZTtcblxuICAgIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdTUEFOJyk7XG4gICAgbm9kZS5pbm5lckhUTUwgPSB0ZXh0O1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKCdjbGFzcycsIGMpO1xuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIG1ha2VPcHRpb24gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG9wdDtcblxuICAgIG9wdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ09QVElPTicpO1xuICAgIG9wdC50ZXh0ID0gbmFtZTtcbiAgICByZXR1cm4gb3B0O1xuICB9O1xuXG4gIGNyZWF0ZU5vZGUgPSBmdW5jdGlvbih0eHQpIHtcbiAgICB2YXIgc2NyYXRjaDtcblxuICAgIHNjcmF0Y2ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICBzY3JhdGNoLmlubmVySFRNTCA9IHR4dDtcbiAgICByZXR1cm4gc2NyYXRjaC5maXJzdENoaWxkO1xuICB9O1xuXG4gIGNyZWF0ZUZyYWdtZW50ID0gZnVuY3Rpb24odHh0KSB7XG4gICAgdmFyIGZyYWcsIHNjcmF0Y2g7XG5cbiAgICBzY3JhdGNoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG4gICAgc2NyYXRjaC5pbm5lckhUTUwgPSB0eHQ7XG4gICAgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICB3aGlsZSAoc2NyYXRjaC5maXJzdENoaWxkKSB7XG4gICAgICBmcmFnLmFwcGVuZENoaWxkKHNjcmF0Y2guZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIHJldHVybiBmcmFnO1xuICB9O1xuXG4gIGluc2VydENvbnRyb2xzID0gZnVuY3Rpb24oZWwpIHtcbiAgICB2YXIgY29udHJvbERpdiwgc2F2ZUJ1dHRvbiwgc3BhY2VyLCB0ZXN0QnV0dG9uLCB0aGVtZVNlbGVjdCwgdmlld1NlbGVjdCwgX3JlZjMsIF9yZWY0O1xuXG4gICAgY29udHJvbERpdiA9IGNyZWF0ZU5vZGUoXCI8ZGl2IExlaXN1cmVPdXRwdXQgY29udGVudEVkaXRhYmxlPSdmYWxzZScgY2xhc3M9J2xlaXN1cmVfYmFyJz48ZGl2IGNsYXNzPVxcXCJsZWlzdXJlX2Jhcl9jb250ZW50c1xcXCI+XFxuICA8YnV0dG9uIGxlaXN1cmVJZD0nc2F2ZUJ1dHRvbicgY2xhc3M9XFxcImxlaXN1cmVfc3RhcnRcXFwiPlNhdmU8L2J1dHRvbj5cXG4gIDxidXR0b24gbGVpc3VyZUlkPSd0ZXN0QnV0dG9uJz5SdW4gVGVzdHM8L2J1dHRvbj4gPHNwYW4gbGVpc3VyZUlkPSd0ZXN0UmVzdWx0cycgY2xhc3M9XFxcIm5vdHJ1blxcXCI+PC9zcGFuPlxcbiAgPGlucHV0IHR5cGU9J2NoZWNrYm94JyBsZWlzdXJlSWQ9J2F1dG9ydW5UZXN0cyc+PGI+QXV0bzwvYj48L2lucHV0PlxcbiAgPHNwYW4gY2xhc3M9XFxcImxlaXN1cmVfdGhlbWVcXFwiPlRoZW1lOiA8L3NwYW4+XFxuICA8c2VsZWN0IGxlaXN1cmVJZD0ndGhlbWVTZWxlY3QnPlxcbiAgICA8b3B0aW9uIHZhbHVlPXRoaW4+VGhpbjwvb3B0aW9uPlxcbiAgICA8b3B0aW9uIHZhbHVlPWdhdWR5PkdhdWR5PC9vcHRpb24+XFxuICAgIDxvcHRpb24gdmFsdWU9Y3RodWxodT5DdGh1bGh1PC9vcHRpb24+XFxuICA8L3NlbGVjdD5cXG4gIDxzcGFuPlZpZXc6IDwvc3Bhbj5cXG4gIDxzZWxlY3QgbGVpc3VyZUlkPSd2aWV3U2VsZWN0Jz5cXG4gICAgPG9wdGlvbiB2YWx1ZT1jb2Rpbmc+Q29kaW5nPC9vcHRpb24+XFxuICAgIDxvcHRpb24gdmFsdWU9ZGVidWdnaW5nPkRlYnVnZ2luZzwvb3B0aW9uPlxcbiAgICA8b3B0aW9uIHZhbHVlPXRlc3Rpbmc+VGVzdGluZzwvb3B0aW9uPlxcbiAgICA8b3B0aW9uIHZhbHVlPXJ1bm5pbmc+UnVubmluZzwvb3B0aW9uPlxcbiAgPC9zZWxlY3Q+XFxuPC9kaXY+XCIpO1xuICAgIHNwYWNlciA9IGNyZWF0ZU5vZGUoXCI8ZGl2IExlaXN1cmVPdXRwdXQgIGNvbnRlbnRFZGl0YWJsZT0nZmFsc2UnIGNsYXNzPSdsZWlzdXJlX3NwYWNlJz48L2Rpdj5cIik7XG4gICAgZWwuaW5zZXJ0QmVmb3JlKHNwYWNlciwgZWwuZmlyc3RDaGlsZCk7XG4gICAgZWwuaW5zZXJ0QmVmb3JlKGNvbnRyb2xEaXYsIGVsLmZpcnN0Q2hpbGQpO1xuICAgIF9yZWYzID0gZ2V0RWxlbWVudHMoZWwsIFsnZG93bmxvYWRMaW5rJywgJ3ZpZXdMaW5rJywgJ3NhdmVCdXR0b24nLCAndGVzdEJ1dHRvbicsICd0ZXN0UmVzdWx0cycsICdhdXRvcnVuVGVzdHMnLCAndGhlbWVTZWxlY3QnLCAndmlld1NlbGVjdCddKSwgZWwubGVpc3VyZURvd25sb2FkTGluayA9IF9yZWYzWzBdLCBlbC5sZWlzdXJlVmlld0xpbmsgPSBfcmVmM1sxXSwgc2F2ZUJ1dHRvbiA9IF9yZWYzWzJdLCB0ZXN0QnV0dG9uID0gX3JlZjNbM10sIGVsLnRlc3RSZXN1bHRzID0gX3JlZjNbNF0sIGVsLmF1dG9ydW4gPSBfcmVmM1s1XSwgdGhlbWVTZWxlY3QgPSBfcmVmM1s2XSwgdmlld1NlbGVjdCA9IF9yZWYzWzddO1xuICAgIGNvbnRyb2xEaXYuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldnQpIHtcbiAgICAgIGlmIChkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5jb250YWlucygnaGlkZUNvbnRyb2xzJykpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZUNvbnRyb2xzJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdoaWRlQ29udHJvbHMnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzYXZlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICByZXR1cm4gc2F2ZVByb2dyYW0oZWwpO1xuICAgIH0pO1xuICAgIHRlc3RCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBydW5UZXN0cyhlbCk7XG4gICAgfSk7XG4gICAgdGhlbWVTZWxlY3QudmFsdWUgPSAoX3JlZjQgPSBlbC5sZWlzdXJlVGhlbWUpICE9IG51bGwgPyBfcmVmNCA6ICd0aGluJztcbiAgICB0aGVtZVNlbGVjdC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgIHJldHVybiBjaGFuZ2VUaGVtZShlbCwgZXZ0LnRhcmdldC52YWx1ZSk7XG4gICAgfSk7XG4gICAgdmlld1NlbGVjdC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgIHJldHVybiBjaGFuZ2VWaWV3KGVsLCBldnQudGFyZ2V0LnZhbHVlKTtcbiAgICB9KTtcbiAgICBlbC5hdXRvcnVuLmNoZWNrZWQgPSBlbC5hdXRvcnVuU3RhdGU7XG4gICAgZWwuYXV0b3J1bi5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgIGVsLmF1dG9ydW5TdGF0ZSA9IGVsLmF1dG9ydW4uY2hlY2tlZDtcbiAgICAgIGlmIChlbC5hdXRvcnVuU3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHJ1blRlc3RzKGVsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbWFya3VwQnV0dG9ucyhjb250cm9sRGl2KTtcbiAgfTtcblxuICBzYXZlUHJvZ3JhbSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB3cml0ZShmaWxlbmFtZSwgZ2V0TUREb2N1bWVudCgpLCAoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYWxlcnQoXCJTYXZpbmcgXCIgKyBmaWxlbmFtZSk7XG4gICAgfSksIGZ1bmN0aW9uKGVycikge1xuICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgIGFsZXJ0KGVyci5zdGFjayk7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSk7XG4gIH07XG5cbiAgc2hvd0ZpbGVuYW1lID0gZnVuY3Rpb24oZWwpIHtcbiAgICBpZiAoZWwgJiYgZmlsZW5hbWUpIHtcbiAgICAgIGVsLmlubmVySFRNTCA9IFwiU2F2ZTogXCIgKyAoZmlsZW5hbWUucGF0aE5hbWUoKSk7XG4gICAgICByZXR1cm4gZWwudGl0bGUgPSBmaWxlbmFtZS50b1N0cmluZygpO1xuICAgIH1cbiAgfTtcblxuICBzaG93RmlsZW5hbWVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5vZGUsIF9pLCBfbGVuLCBfcmVmMywgX3Jlc3VsdHM7XG5cbiAgICBfcmVmMyA9IGRvY3VtZW50LmJvZHkucXVlcnlTZWxlY3RvckFsbCgnW2xlaXN1cmVJZD1zYXZlQnV0dG9uXScpO1xuICAgIF9yZXN1bHRzID0gW107XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgbm9kZSA9IF9yZWYzW19pXTtcbiAgICAgIF9yZXN1bHRzLnB1c2goc2hvd0ZpbGVuYW1lKG5vZGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZXN1bHRzO1xuICB9O1xuXG4gIHNldEZpbGVuYW1lID0gZnVuY3Rpb24obmV3TmFtZSkge1xuICAgIGNvbnNvbGUubG9nKFwiU0VUIEZJTEVOQU1FOiBcIiArIG5ld05hbWUpO1xuICAgIGZpbGVuYW1lID0gbmV3TmFtZSBpbnN0YW5jZW9mIFVSSSA/IG5ld05hbWUgOiBuZXcgVVJJKGRvY3VtZW50LmxvY2F0aW9uLmhyZWYsIG5ld05hbWUpO1xuICAgIHJldHVybiBzaG93RmlsZW5hbWVzKCk7XG4gIH07XG5cbiAgbWFya3VwQnV0dG9ucyA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgdmFyIGJ0biwgX2ksIF9sZW4sIF9yZWYzLCBfcmVzdWx0cztcblxuICAgIF9yZWYzID0gZWwucXVlcnlTZWxlY3RvckFsbCgnYnV0dG9uJyk7XG4gICAgX3Jlc3VsdHMgPSBbXTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBidG4gPSBfcmVmM1tfaV07XG4gICAgICBfcmVzdWx0cy5wdXNoKG1hcmt1cEJ1dHRvbihidG4pKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZXN1bHRzO1xuICB9O1xuXG4gIG1hcmt1cEJ1dHRvbiA9IGZ1bmN0aW9uKGJ0bikge1xuICAgIHZhciBjbCwgX2ksIF9sZW4sIF9yZXN1bHRzO1xuXG4gICAgX3Jlc3VsdHMgPSBbXTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGJ1dHRvbkNsYXNzZXMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIGNsID0gYnV0dG9uQ2xhc3Nlc1tfaV07XG4gICAgICBfcmVzdWx0cy5wdXNoKGJ0bi5jbGFzc0xpc3QuYWRkKGNsKSk7XG4gICAgfVxuICAgIHJldHVybiBfcmVzdWx0cztcbiAgfTtcblxuICBnZXRFbGVtZW50cyA9IGZ1bmN0aW9uKGVsLCBpZHMpIHtcbiAgICB2YXIgZWxzLCBpZCwgbm9kZSwgX2ksIF9qLCBfbGVuLCBfbGVuMSwgX3JlZjMsIF9yZXN1bHRzO1xuXG4gICAgZWxzID0ge307XG4gICAgX3JlZjMgPSBlbC5xdWVyeVNlbGVjdG9yQWxsKCdbbGVpc3VyZUlkXScpO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIG5vZGUgPSBfcmVmM1tfaV07XG4gICAgICBlbHNbbm9kZS5nZXRBdHRyaWJ1dGUoJ2xlaXN1cmVJZCcpXSA9IG5vZGU7XG4gICAgfVxuICAgIF9yZXN1bHRzID0gW107XG4gICAgZm9yIChfaiA9IDAsIF9sZW4xID0gaWRzLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgaWQgPSBpZHNbX2pdO1xuICAgICAgX3Jlc3VsdHMucHVzaChlbHNbaWRdKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZXN1bHRzO1xuICB9O1xuXG4gIGVzY2FwZUh0bWwgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvWzw+XS9nLCBmdW5jdGlvbihjKSB7XG4gICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgcmV0dXJuICcmbHQ7JztcbiAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgIHJldHVybiAnJmd0Oyc7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfTtcblxuICBsb2FkUHJvZ3JhbSA9IGZ1bmN0aW9uKGVsLCBmaWxlcykge1xuICAgIHZhciBmcjtcblxuICAgIGVsID0gZ2V0Qm94O1xuICAgIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBmci5vbmxvYWRlbmQgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIGVsLmlubmVySFRNTCA9IGVzY2FwZUh0bWwoZnIucmVzdWx0KTtcbiAgICAgIHJldHVybiBpbml0Tm90ZWJvb2soZWwpO1xuICAgIH07XG4gICAgcmV0dXJuIGZyLnJlYWRBc0JpbmFyeVN0cmluZyhmaWxlcy5pdGVtKDApKTtcbiAgfTtcblxuICBjb25maWd1cmVTYXZlTGluayA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgdmFyIGJsb2IsIGJ1aWxkZXI7XG5cbiAgICB3aW5kb3cuVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMO1xuICAgIGJ1aWxkZXIgPSBuZXcgV2ViS2l0QmxvYkJ1aWxkZXIoKTtcbiAgICBidWlsZGVyLmFwcGVuZChnZXRFbGVtZW50Q29kZShlbCkpO1xuICAgIGJsb2IgPSBidWlsZGVyLmdldEJsb2IoJ3RleHQvcGxhaW4nKTtcbiAgICBlbC5sZWlzdXJlRG93bmxvYWRMaW5rLmhyZWYgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICByZXR1cm4gZWwubGVpc3VyZVZpZXdMaW5rLmhyZWYgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgfTtcblxuICBnZXRFbGVtZW50Q29kZSA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgdmFyIHI7XG5cbiAgICByID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICByLnNlbGVjdE5vZGUoZWwpO1xuICAgIGMgPSByLmNsb25lQ29udGVudHMoKS5maXJzdENoaWxkO1xuICAgIHJlbW92ZU9sZERlZnMoYyk7XG4gICAgcmV0dXJuIGMudGV4dENvbnRlbnQ7XG4gIH07XG5cbiAgcnVuVGVzdHMgPSBmdW5jdGlvbihlbCkge1xuICAgIHZhciBmYWlsZWQsIHBhc3NlZCwgcmVzdWx0c0NsYXNzLCB0ZXN0LCBfaSwgX2xlbiwgX3JlZjM7XG5cbiAgICBwYXNzZWQgPSAwO1xuICAgIGZhaWxlZCA9IDA7XG4gICAgX3JlZjMgPSBlbC5xdWVyeVNlbGVjdG9yQWxsKCcuY29kZU1haW5UZXN0Jyk7XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgdGVzdCA9IF9yZWYzW19pXTtcbiAgICAgIGlmIChydW5UZXN0KHRlc3QpKSB7XG4gICAgICAgIHBhc3NlZCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmFpbGVkKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbC50ZXN0UmVzdWx0cykge1xuICAgICAgcmVzdWx0c0NsYXNzID0gZWwudGVzdFJlc3VsdHMuY2xhc3NMaXN0O1xuICAgICAgcmVzdWx0c0NsYXNzLnJlbW92ZSgnbm90cnVuJyk7XG4gICAgICBpZiAoIWZhaWxlZCkge1xuICAgICAgICByZXN1bHRzQ2xhc3MucmVtb3ZlKCdmYWlsZWQnKTtcbiAgICAgICAgcmVzdWx0c0NsYXNzLmFkZCgncGFzc2VkJyk7XG4gICAgICAgIHJldHVybiBlbC50ZXN0UmVzdWx0cy5pbm5lckhUTUwgPSBwYXNzZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRzQ2xhc3MucmVtb3ZlKCdwYXNzZWQnKTtcbiAgICAgICAgcmVzdWx0c0NsYXNzLmFkZCgnZmFpbGVkJyk7XG4gICAgICAgIHJldHVybiBlbC50ZXN0UmVzdWx0cy5pbm5lckhUTUwgPSBcIlwiICsgcGFzc2VkICsgXCIvXCIgKyBmYWlsZWQ7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNoYW5nZVRoZW1lID0gZnVuY3Rpb24oZWwsIHZhbHVlKSB7XG4gICAgdmFyIHRoZW1lO1xuXG4gICAgdGhlbWUgPSB2YWx1ZTtcbiAgICBlbC5sZWlzdXJlVGhlbWUgPSB0aGVtZTtcbiAgICByZXR1cm4gZWwuY2xhc3NOYW1lID0gdGhlbWU7XG4gIH07XG5cbiAgY2hhbmdlVmlldyA9IGZ1bmN0aW9uKGVsLCB2YWx1ZSkge1xuICAgIGRlYnVnID0gdmFsdWUgPT09ICdkZWJ1Z2dpbmcnO1xuICAgIHJldHVybiBhbGVydCgnbmV3IHZpZXc6ICcgKyB2YWx1ZSArIFwiLCBkZWJ1ZzogXCIgKyBkZWJ1Zyk7XG4gIH07XG5cbiAgdW53cmFwID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHZhciBwYXJlbnQ7XG5cbiAgICBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCAhPSBudWxsKSB7XG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUobm9kZS5maXJzdENoaWxkLCBub2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJlbnQucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgfVxuICB9O1xuXG4gIHJlbW92ZU9sZERlZnMgPSBmdW5jdGlvbihlbCkge1xuICAgIHZhciBleHRyYWN0ZWQsIG0sIG5vZGUsIHR4dCwgX2ksIF9qLCBfaywgX2wsIF9sZW4sIF9sZW4xLCBfbGVuMiwgX2xlbjMsIF9yZWYzLCBfcmVmNCwgX3JlZjU7XG5cbiAgICBlbC5sZWlzdXJlRG93bmxvYWRMaW5rID0gbnVsbDtcbiAgICBlbC5sZWlzdXJlVmlld0xpbmsgPSBudWxsO1xuICAgIGV4dHJhY3RlZCA9IFtdO1xuICAgIF9yZWYzID0gZWwucXVlcnlTZWxlY3RvckFsbChcIltMZWlzdXJlT3V0cHV0XVwiKTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBub2RlID0gX3JlZjNbX2ldO1xuICAgICAgcmVtb3ZlKG5vZGUpO1xuICAgIH1cbiAgICBfcmVmNCA9IGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZ2VuZXJhdGVkbmxdXCIpO1xuICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IF9yZWY0Lmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgbm9kZSA9IF9yZWY0W19qXTtcbiAgICAgIHR4dCA9IG5vZGUubGFzdENoaWxkO1xuICAgICAgaWYgKHR4dC5ub2RlVHlwZSA9PT0gMyAmJiB0eHQuZGF0YVt0eHQuZGF0YS5sZW5ndGggLSAxXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgdHh0LmRhdGEgPSB0eHQuZGF0YS5zdWJzdHJpbmcoMCwgdHh0LmRhdGEubGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9yZWY1ID0gZWwucXVlcnlTZWxlY3RvckFsbChcIltMZWlzdXJlXVwiKTtcbiAgICBmb3IgKF9rID0gMCwgX2xlbjIgPSBfcmVmNS5sZW5ndGg7IF9rIDwgX2xlbjI7IF9rKyspIHtcbiAgICAgIG5vZGUgPSBfcmVmNVtfa107XG4gICAgICBpZiAoYWRkc0xpbmUobm9kZSkgJiYgKG5vZGUuZmlyc3RDaGlsZCAhPSBudWxsKSkge1xuICAgICAgICBleHRyYWN0ZWQucHVzaChub2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgdW53cmFwKG5vZGUpO1xuICAgIH1cbiAgICBmb3IgKF9sID0gMCwgX2xlbjMgPSBleHRyYWN0ZWQubGVuZ3RoOyBfbCA8IF9sZW4zOyBfbCsrKSB7XG4gICAgICBub2RlID0gZXh0cmFjdGVkW19sXTtcbiAgICAgIGlmICgobm9kZS5wYXJlbnROb2RlICE9IG51bGwpICYmICFhZGRzTGluZShub2RlKSAmJiAobm9kZS5wcmV2aW91c1NpYmxpbmcgIT0gbnVsbCkgJiYgIWFkZHNMaW5lKG5vZGUucHJldmlvdXNTaWJsaW5nKSkge1xuICAgICAgICBub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRleHQoJ1xcbicpLCBub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWwudGV4dENvbnRlbnQgPSBlbC50ZXh0Q29udGVudC5yZXBsYWNlKC9cXHVGRUZGL2csICcnKTtcbiAgICB0eHQgPSBlbC5sYXN0Q2hpbGQ7XG4gICAgaWYgKCh0eHQgIT0gbnVsbCA/IHR4dC5ub2RlVHlwZSA6IHZvaWQgMCkgPT09IDMgJiYgKG0gPSB0eHQuZGF0YS5tYXRjaCgvKF58W15cXG5dKShcXG4rKSQvKSkpIHtcbiAgICAgIHJldHVybiB0eHQuZGF0YSA9IHR4dC5kYXRhLnN1YnN0cmluZygwLCB0eHQuZGF0YS5sZW5ndGggLSBtWzJdLmxlbmd0aCk7XG4gICAgfVxuICB9O1xuXG4gIG1hcmt1cERlZnMgPSBmdW5jdGlvbihlbCwgZGVmcykge1xuICAgIHZhciBhdXRvLCBib2QsIGJvZHksIGJ4LCBkZWYsIGksIG1haW4sIG5hbWUsIG5vdGVib29rQXV0b05vZGVzLCBwZ20sIHMsIHRlc3QsIHRlc3RzLCB0b3RhbFRlc3RzLCBfaSwgX2osIF9sZW4sIF9sZW4xLCBfcmVmMywgX3JlZjQ7XG5cbiAgICBwZ20gPSAnJztcbiAgICBhdXRvID0gJyc7XG4gICAgdG90YWxUZXN0cyA9IDA7XG4gICAgbm90ZWJvb2tBdXRvTm9kZXMgPSBbXTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGRlZnMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIGkgPSBkZWZzW19pXTtcbiAgICAgIG1haW4gPSBpLm1haW4sIG5hbWUgPSBpLm5hbWUsIGRlZiA9IGkuZGVmLCBib2R5ID0gaS5ib2R5LCB0ZXN0cyA9IGkudGVzdHM7XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICBieCA9IGJveChtYWluLCAnY29kZU1haW4nLCB0cnVlKTtcbiAgICAgICAgYnguYXBwZW5kQ2hpbGQoY29kZVNwYW4obmFtZSwgJ2NvZGVOYW1lJykpO1xuICAgICAgICBieC5hcHBlbmRDaGlsZCh0ZXh0Tm9kZShkZWYpKTtcbiAgICAgICAgYm9kID0gY29kZVNwYW4odGV4dE5vZGUoYm9keSksICdjb2RlQm9keScpO1xuICAgICAgICBib2QuYXBwZW5kQ2hpbGQodGV4dE5vZGUoJ1xcbicpKTtcbiAgICAgICAgYm9kLnNldEF0dHJpYnV0ZSgnZ2VuZXJhdGVkTkwnLCAnJyk7XG4gICAgICAgIGJ4LmFwcGVuZENoaWxkKGJvZCk7XG4gICAgICAgIGJ4LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGV2YWxEb2MoZWwpO1xuICAgICAgICB9KSwgdHJ1ZSk7XG4gICAgICAgIG1hcmtQYXJ0aWFsQXBwbGllcyhieCk7XG4gICAgICAgIGFkZERlZkNvbnRyb2xzKGJ4KTtcbiAgICAgICAgcGdtICs9IFwiXCIgKyBuYW1lICsgXCIgXCIgKyBkZWYgKyBcIiBcIiArIGJvZHkgKyBcIlxcblwiO1xuICAgICAgfSBlbHNlIGlmIChtYWluICE9IG51bGwpIHtcbiAgICAgICAgYnggPSBib3gobWFpbiwgJ2NvZGVNYWluRXhwcicsIHRydWUpO1xuICAgICAgICBzID0gY29kZVNwYW4odGV4dE5vZGUoYm9keSksICdjb2RlRXhwcicpO1xuICAgICAgICBzLnNldEF0dHJpYnV0ZSgnZ2VuZXJhdGVkTkwnLCAnJyk7XG4gICAgICAgIHMuYXBwZW5kQ2hpbGQodGV4dE5vZGUoJ1xcbicpKTtcbiAgICAgICAgYnguYXBwZW5kQ2hpbGQocyk7XG4gICAgICAgIG1hcmtQYXJ0aWFsQXBwbGllcyhieCk7XG4gICAgICAgIGlmICgoKF9yZWYzID0gbWFpbi5sZWlzdXJlQXV0bykgIT0gbnVsbCA/IF9yZWYzLm1vZGUgOiB2b2lkIDApID09PSAnc2lsZW50Jykge1xuICAgICAgICAgIGF1dG8gKz0gXCJcIiArIGJvZHkgKyBcIlxcblwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICgoKF9yZWY0ID0gbWFpbi5sZWlzdXJlQXV0bykgIT0gbnVsbCA/IF9yZWY0Lm1vZGUgOiB2b2lkIDApID09PSAnbm90ZWJvb2snKSB7XG4gICAgICAgICAgICBub3RlYm9va0F1dG9Ob2Rlcy5wdXNoKGJ4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWFrZU91dHB1dEJveChieCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IHRlc3RzLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgICB0ZXN0ID0gdGVzdHNbX2pdO1xuICAgICAgICByZXBsYWNlUmFuZ2UodGVzdCwgbWFrZVRlc3RCb3godGVzdC5sZWlzdXJlVGVzdCkpO1xuICAgICAgICB0b3RhbFRlc3RzKys7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbcGdtLCBhdXRvLCB0b3RhbFRlc3RzLCBub3RlYm9va0F1dG9Ob2Rlc107XG4gIH07XG5cbiAgZ2V0RGVmTmFtZSA9IGZ1bmN0aW9uKGFzdCkge1xuICAgIGlmIChhc3QgaW5zdGFuY2VvZiBMZWlzdXJlX2Fubm8gJiYgZ2V0QW5ub05hbWUoYXN0KSA9PT0gJ2RlZmluaXRpb24nKSB7XG4gICAgICByZXR1cm4gZ2V0QW5ub0RhdGEoYXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIGdldEFzdCA9IGZ1bmN0aW9uKGJ4LCBkZWYpIHtcbiAgICB2YXIgZGVmTmFtZSwgX3JlZjM7XG5cbiAgICBpZiAoYnguYXN0ICE9IG51bGwpIHtcbiAgICAgIHBhdGNoRnVuY0FzdChieC5hc3QpO1xuICAgICAgYnguc2V0QXR0cmlidXRlKCdsZWlzdXJlRnVuYycsIChfcmVmMyA9IGJ4LmFzdC5sZWlzdXJlTmFtZSkgIT0gbnVsbCA/IF9yZWYzIDogJycpO1xuICAgICAgcmV0dXJuIGJ4LmFzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmID0gZGVmIHx8IGJ4LnRleHRDb250ZW50O1xuICAgICAgZGVmTmFtZSA9IGdldERlZk5hbWUocnVuTW9uYWQocnooTF9uZXdQYXJzZUxpbmUpKGx6KE5pbCkpKGx6KGRlZikpKSk7XG4gICAgICBzZXRBc3QoYngsIChkZWZOYW1lID8ge1xuICAgICAgICBsZWlzdXJlTmFtZTogZGVmTmFtZSxcbiAgICAgICAgbGVpc3VyZVNvdXJjZTogZGVmXG4gICAgICB9IDoge30pKTtcbiAgICAgIHJldHVybiBieC5hc3Q7XG4gICAgfVxuICB9O1xuXG4gIHNldEFzdCA9IGZ1bmN0aW9uKGJ4LCBhc3QpIHtcbiAgICBieC5hc3QgPSBhc3Q7XG4gICAgcmV0dXJuIHBhdGNoRnVuY0FzdChhc3QpO1xuICB9O1xuXG4gIHBhdGNoRnVuY0FzdCA9IGZ1bmN0aW9uKGFzdCkge1xuICAgIHZhciBwYXJlbnQ7XG5cbiAgICBpZiAoKGFzdCAhPSBudWxsID8gYXN0LmxlaXN1cmVOYW1lIDogdm9pZCAwKSAhPSBudWxsKSB7XG4gICAgICBwYXJlbnQgPSB3aW5kb3dbbmFtZVN1Yihhc3QubGVpc3VyZU5hbWUpXTtcbiAgICAgIGlmIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICBwYXJlbnQuYXN0ID0gYXN0O1xuICAgICAgICBwYXJlbnQuc3JjID0gYXN0LmxlaXN1cmVTb3VyY2U7XG4gICAgICAgIHJldHVybiB1cGRhdGUoXCJhc3QtXCIgKyBhc3QubGVpc3VyZU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBtYXJrUGFydGlhbEFwcGxpZXMgPSBmdW5jdGlvbihieCwgZGVmKSB7fTtcblxuICB0ZXh0Tm9kZSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG4gIH07XG5cbiAgbm9kZUZvciA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICBpZiAodHlwZW9mIHRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdGV4dE5vZGUodGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgfTtcblxuICBldmFsT3V0cHV0ID0gZnVuY3Rpb24oZXhCb3gsIG5vZm9jdXMsIGNvbnQpIHtcbiAgICB2YXIgc2VsZWN0b3IsIHN0b3BVcGRhdGVzLCB1cGRhdGVTZWxlY3RvciwgX3JlZjM7XG5cbiAgICBleEJveCA9IGdldEJveChleEJveCk7XG4gICAgaWYgKCFub2ZvY3VzKSB7XG4gICAgICBmb2N1c0JveChleEJveCk7XG4gICAgfVxuICAgIGNsZWFuT3V0cHV0KGV4Qm94LCB0cnVlKTtcbiAgICBzZWxlY3RvciA9IGZpbmRVcGRhdGVTZWxlY3RvcihleEJveC5zb3VyY2UpO1xuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgZXhCb3guc2V0QXR0cmlidXRlKCdsZWlzdXJlVXBkYXRlJywgc2VsZWN0b3IpO1xuICAgIH1cbiAgICBtYWtlT3V0cHV0Q29udHJvbHMoZXhCb3gpO1xuICAgIF9yZWYzID0gZ2V0RWxlbWVudHMoZXhCb3guZmlyc3RDaGlsZCwgWydjaG9vc2VVcGRhdGUnLCAnc3RvcFVwZGF0ZXMnXSksIHVwZGF0ZVNlbGVjdG9yID0gX3JlZjNbMF0sIHN0b3BVcGRhdGVzID0gX3JlZjNbMV07XG4gICAgdXBkYXRlU2VsZWN0b3IuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICByZXR1cm4gc2V0VXBkYXRlKGV4Qm94LCBldnQudGFyZ2V0LnZhbHVlLCB0cnVlKTtcbiAgICB9KTtcbiAgICB1cGRhdGVTZWxlY3Rvci5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgYyA9IGUuY2hhckNvZGUgfHwgZS5rZXlDb2RlIHx8IGUud2hpY2g7XG4gICAgICBpZiAoYyA9PT0gRU5URVIpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gdXBkYXRlU2VsZWN0b3IuYmx1cigpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHVwZGF0ZVNlbGVjdG9yLnZhbHVlID0gKGV4Qm94LmdldEF0dHJpYnV0ZSgnbGVpc3VyZVVwZGF0ZScpKSB8fCAnJztcbiAgICBleEJveC51cGRhdGVTZWxlY3RvciA9IHVwZGF0ZVNlbGVjdG9yO1xuICAgIHJldHVybiBldmFsQm94KGV4Qm94LnNvdXJjZSwgZXhCb3gsIGNvbnQpO1xuICB9O1xuXG4gIGZpbmRVcGRhdGVTZWxlY3RvciA9IGZ1bmN0aW9uKGJveCkge1xuICAgIHZhciBkZWYsIGRlZlR5cGUsIGxlYWRpbmcsIG1hdGNoZWQsIG5hbWUsIHU7XG5cbiAgICBpZiAoZGVmID0gYm94LnRleHRDb250ZW50Lm1hdGNoKHJ6KExfZGVmUGF0KSkpIHtcbiAgICAgIG1hdGNoZWQgPSBkZWZbMF0sIGxlYWRpbmcgPSBkZWZbMV0sIG5hbWUgPSBkZWZbMl0sIGRlZlR5cGUgPSBkZWZbM107XG4gICAgICBpZiAodSA9IGxlYWRpbmcubWF0Y2godXBkYXRlUGF0KSkge1xuICAgICAgICByZXR1cm4gdVszXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZ2V0RXhwclNvdXJjZSA9IGZ1bmN0aW9uKGJveCkge1xuICAgIHZhciBiLCBzO1xuXG4gICAgcyA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICBiID0gZ2V0Qm94KHMuZm9jdXNOb2RlKTtcbiAgICBpZiAoYiAhPT0gYm94IHx8ICFzLnJhbmdlQ291bnQgfHwgcy5nZXRSYW5nZUF0KDApLmNvbGxhcHNlZCkge1xuICAgICAgcmV0dXJuIGJveC50ZXh0Q29udGVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdldFJhbmdlVGV4dChzLmdldFJhbmdlQXQoMCkpO1xuICAgIH1cbiAgfTtcblxuICBzZXRVcGRhdGUgPSBmdW5jdGlvbihlbCwgY2hhbm5lbCwgcHJlc2VydmVTb3VyY2UpIHtcbiAgICB2YXIgYXN0LCBkZWYsIGRlZlR5cGUsIGluZGV4LCBsZWFkaW5nLCBtYXRjaGVkLCBuYW1lLCByLCB0eHQsIHU7XG5cbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2xlaXN1cmVVcGRhdGUnLCBjaGFubmVsKTtcbiAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZCgndWktc3RhdGUtaGlnaGxpZ2h0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ3VpLXN0YXRlLWhpZ2hsaWdodCcpO1xuICAgIH1cbiAgICBhc3QgPSBnZXRBc3QoZWwuc291cmNlKTtcbiAgICB0eHQgPSBlbC5zb3VyY2UudGV4dENvbnRlbnQ7XG4gICAgaWYgKCFwcmVzZXJ2ZVNvdXJjZSAmJiAoZGVmID0gdHh0Lm1hdGNoKHJ6KExfZGVmUGF0KSkpKSB7XG4gICAgICBtYXRjaGVkID0gZGVmWzBdLCBsZWFkaW5nID0gZGVmWzFdLCBuYW1lID0gZGVmWzJdLCBkZWZUeXBlID0gZGVmWzNdO1xuICAgICAgaW5kZXggPSBkZWYuaW5kZXg7XG4gICAgICBpZiAodSA9IGxlYWRpbmcubWF0Y2godXBkYXRlUGF0KSkge1xuICAgICAgICBpbmRleCArPSB1LmluZGV4ICsgdVsxXS5sZW5ndGggKyB1WzJdLmxlbmd0aDtcbiAgICAgICAgciA9IG1ha2VSYW5nZShlbC5zb3VyY2UsIGluZGV4LCBpbmRleCArIHVbM10ubGVuZ3RoKTtcbiAgICAgICAgci5kZWxldGVDb250ZW50cygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgciA9IG1ha2VSYW5nZShlbC5zb3VyY2UsIGluZGV4ICsgbGVhZGluZy5sZW5ndGgsIGluZGV4ICsgbGVhZGluZy5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgci5pbnNlcnROb2RlKHRleHROb2RlKGNoYW5uZWwpKTtcbiAgICAgIHJldHVybiBlbC5zb3VyY2Uubm9ybWFsaXplKCk7XG4gICAgfVxuICB9O1xuXG4gIGhhc01vbmFkT3V0cHV0ID0gZnVuY3Rpb24oYm94KSB7XG4gICAgdmFyIF9yZWYzLCBfcmVmNDtcblxuICAgIHJldHVybiAoKF9yZWYzID0gYm94LmZpcnN0RWxlbWVudENoaWxkKSAhPSBudWxsID8gKF9yZWY0ID0gX3JlZjMubmV4dEVsZW1lbnRTaWJsaW5nKSAhPSBudWxsID8gX3JlZjQubmV4dEVsZW1lbnRTaWJsaW5nIDogdm9pZCAwIDogdm9pZCAwKSAhPSBudWxsO1xuICB9O1xuXG4gIGNoZWNrSGlkZVNvdXJjZSA9IGZ1bmN0aW9uKGJveCkge1xuICAgIHZhciBocztcblxuICAgIGlmICghYm94LmhpZGVPdXRwdXRTb3VyY2UgJiYgaGFzTW9uYWRPdXRwdXQoYm94KSkge1xuICAgICAgYm94LmhpZGVPdXRwdXRTb3VyY2UgPSB0cnVlO1xuICAgICAgaHMgPSBjcmVhdGVOb2RlKFwiPGJ1dHRvbiBjbGFzcz0nZWRpdFRvZ2dsZScgc3R5bGU9J2Zsb2F0OnJpZ2h0Jz48L2J1dHRvbj5cIik7XG4gICAgICBtYXJrdXBCdXR0b24oaHMpO1xuICAgICAgaHMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRvZ2dsZUVkaXQoaHMpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYm94LmZpcnN0RWxlbWVudENoaWxkLmFwcGVuZENoaWxkKGhzKTtcbiAgICB9XG4gIH07XG5cbiAgbWFrZU91dHB1dENvbnRyb2xzID0gZnVuY3Rpb24oZXhCb3gpIHtcbiAgICBpZiAoZXhCb3guZmlyc3RDaGlsZC5maXJzdENoaWxkID09PSBleEJveC5maXJzdENoaWxkLmxhc3RDaGlsZCkge1xuICAgICAgZXhCb3guZmlyc3RDaGlsZC5pbnNlcnRCZWZvcmUoY3JlYXRlRnJhZ21lbnQoXCI8YnV0dG9uIG9uY2xpY2s9J05vdGVib29rLmNsZWFyT3V0cHV0Qm94KHRoaXMpJz5YPC9idXR0b24+XCIpLCBleEJveC5maXJzdENoaWxkLmZpcnN0Q2hpbGQpO1xuICAgICAgZXhCb3guZmlyc3RDaGlsZC5hcHBlbmRDaGlsZChjcmVhdGVGcmFnbWVudChcIjxidXR0b24gb25jbGljaz0nTm90ZWJvb2subWFrZVRlc3RDYXNlKHRoaXMpJyBsZWlzdXJlSWQ9J21ha2VUZXN0Q2FzZSc+TWFrZSB0ZXN0XFxuY2FzZTwvYnV0dG9uPjxiPlVwZGF0ZTogPC9iPjxpbnB1dCB0eXBlPSd0ZXh0J1xcbnBsYWNlaG9sZGVyPSdDbGljayBmb3IgdXBkYXRpbmcnIGxpc3Q9J2NoYW5uZWxMaXN0JyBsZWlzdXJlSWQ9J2Nob29zZVVwZGF0ZSc+PC9pbnB1dD48YnV0dG9uXFxub25jbGljaz0nTm90ZWJvb2suY2xlYXJVcGRhdGVzKHRoaXMpJyBsZWlzdXJlSWQ9J3N0b3BVcGRhdGVzJz5TdG9wIFVwZGF0ZXM8L2J1dHRvbj5cIikpO1xuICAgICAgbWFya3VwQnV0dG9ucyhleEJveCk7XG4gICAgICByZXR1cm4gZXhCb3guY2xhc3NMaXN0LmFkZCgnZmF0Q29udHJvbHMnKTtcbiAgICB9XG4gIH07XG5cbiAgc2hvd091dHB1dFNvdXJjZSA9IGZ1bmN0aW9uKG91dHB1dCkge1xuICAgIG91dHB1dC5jbGFzc0xpc3QucmVtb3ZlKCdoaWRpbmdTb3VyY2UnKTtcbiAgICByZXR1cm4gb3V0cHV0LnNvdXJjZS5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gIH07XG5cbiAgaGlkZU91dHB1dFNvdXJjZSA9IGZ1bmN0aW9uKG91dHB1dCkge1xuICAgIGNvbnNvbGUubG9nKFwiSElERTogXCIgKyBvdXRwdXQpO1xuICAgIG91dHB1dC5jbGFzc0xpc3QuYWRkKCdoaWRpbmdTb3VyY2UnKTtcbiAgICByZXR1cm4gb3V0cHV0LnNvdXJjZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9O1xuXG4gIHRvZ2dsZUVkaXQgPSBmdW5jdGlvbih0b2dnbGVCdXR0b24pIHtcbiAgICB2YXIgb3V0cHV0O1xuXG4gICAgb3V0cHV0ID0gZ2V0Qm94KHRvZ2dsZUJ1dHRvbik7XG4gICAgaWYgKG91dHB1dC5jbGFzc0xpc3QuY29udGFpbnMoJ2hpZGluZ1NvdXJjZScpKSB7XG4gICAgICByZXR1cm4gc2hvd091dHB1dFNvdXJjZShvdXRwdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaGlkZU91dHB1dFNvdXJjZShvdXRwdXQpO1xuICAgIH1cbiAgfTtcblxuICBjbGVhclVwZGF0ZXMgPSBmdW5jdGlvbih3aWRnZXQsIHByZXNlcnZlU291cmNlKSB7XG4gICAgdmFyIGV4Qm94O1xuXG4gICAgZXhCb3ggPSBnZXRCb3god2lkZ2V0KTtcbiAgICBleEJveC51cGRhdGVTZWxlY3Rvci52YWx1ZSA9ICcnO1xuICAgIHJldHVybiBzZXRVcGRhdGUoZXhCb3gsICcnLCBwcmVzZXJ2ZVNvdXJjZSk7XG4gIH07XG5cbiAgdXBkYXRlID0gZnVuY3Rpb24odHlwZSwgZW52KSB7XG4gICAgdmFyIG5vZGUsIF9pLCBfbGVuLCBfcmVmMywgX3Jlc3VsdHM7XG5cbiAgICBlbnYgPSBlbnYgIT0gbnVsbCA/IGVudiA6IGRlZmF1bHRFbnY7XG4gICAgX3JlZjMgPSBlbnYub3duZXIucXVlcnlTZWxlY3RvckFsbChcIltsZWlzdXJlVXBkYXRlfj0nXCIgKyB0eXBlICsgXCInXVwiKTtcbiAgICBfcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIG5vZGUgPSBfcmVmM1tfaV07XG4gICAgICBfcmVzdWx0cy5wdXNoKGV2YWxPdXRwdXQobm9kZSwgdHJ1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gX3Jlc3VsdHM7XG4gIH07XG5cbiAgY2xlYXJPdXRwdXRCb3ggPSBmdW5jdGlvbihleEJveCkge1xuICAgIGNsZWFyVXBkYXRlcyhleEJveCwgdHJ1ZSk7XG4gICAgcmV0dXJuIGNsZWFuT3V0cHV0KGV4Qm94KTtcbiAgfTtcblxuICBjbGVhbk91dHB1dCA9IGZ1bmN0aW9uKGV4Qm94LCBwcmVzZXJ2ZUNvbnRyb2xzKSB7XG4gICAgdmFyIGZjLCBfcmVzdWx0cztcblxuICAgIGV4Qm94ID0gZ2V0Qm94KGV4Qm94KTtcbiAgICBleEJveC5jbGFzc0xpc3QucmVtb3ZlKCdmYXRDb250cm9scycpO1xuICAgIGlmICghcHJlc2VydmVDb250cm9scykge1xuICAgICAgZXhCb3guaGlkZU91dHB1dFNvdXJjZSA9IG51bGw7XG4gICAgICBmYyA9IGV4Qm94LmZpcnN0Q2hpbGQ7XG4gICAgICBmYy5yZW1vdmVDaGlsZChmYy5maXJzdENoaWxkKTtcbiAgICAgIHdoaWxlIChmYy5maXJzdENoaWxkICE9PSBmYy5sYXN0Q2hpbGQpIHtcbiAgICAgICAgZmMucmVtb3ZlQ2hpbGQoZmMubGFzdENoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX3Jlc3VsdHMgPSBbXTtcbiAgICB3aGlsZSAoZXhCb3guZmlyc3RDaGlsZCAhPT0gZXhCb3gubGFzdENoaWxkKSB7XG4gICAgICBfcmVzdWx0cy5wdXNoKGV4Qm94LnJlbW92ZUNoaWxkKGV4Qm94Lmxhc3RDaGlsZCkpO1xuICAgIH1cbiAgICByZXR1cm4gX3Jlc3VsdHM7XG4gIH07XG5cbiAgbWFrZVRlc3RDYXNlID0gZnVuY3Rpb24oZXhCb3gpIHtcbiAgICB2YXIgYm94LCBvdXRwdXQsIHNvdXJjZSwgdGVzdDtcblxuICAgIG91dHB1dCA9IGdldEJveChleEJveCk7XG4gICAgc291cmNlID0gb3V0cHV0LnNvdXJjZTtcbiAgICB0ZXN0ID0ge1xuICAgICAgZXhwcjogc291cmNlLnRleHRDb250ZW50LnRyaW0oKSxcbiAgICAgIGV4cGVjdGVkOiBlc2NhcGVIdG1sKFBhcnNlLnByaW50KG91dHB1dC5yZXN1bHQpKVxuICAgIH07XG4gICAgYm94ID0gbWFrZVRlc3RCb3godGVzdCwgb3duZXIoZXhCb3gpKTtcbiAgICBzb3VyY2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYm94LCBzb3VyY2UpO1xuICAgIHJlbW92ZShzb3VyY2UpO1xuICAgIHJlbW92ZShvdXRwdXQpO1xuICAgIGJveC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0ZXh0Tm9kZSgnXFx1RkVGRicpLCBib3gpO1xuICAgIGJveC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0ZXh0Tm9kZSgnXFx1RkVGRicpLCBib3gubmV4dFNpYmxpbmcpO1xuICAgIGlmIChvd25lcihib3gpLmF1dG9ydW5TdGF0ZSkge1xuICAgICAgcmV0dXJuIGNsaWNrVGVzdChib3gpO1xuICAgIH1cbiAgfTtcblxuICBtYWtlVGVzdEJveCA9IGZ1bmN0aW9uKHRlc3QsIG93bmVyLCBzcmMpIHtcbiAgICB2YXIgYngsIHM7XG5cbiAgICBzcmMgPSBzcmMgIT0gbnVsbCA/IHNyYyA6IFwiI0B0ZXN0IFwiICsgKEpTT04uc3RyaW5naWZ5KHRlc3QuZXhwcikpICsgXCJcXG4jQGV4cGVjdGVkIFwiICsgKEpTT04uc3RyaW5naWZ5KHRlc3QuZXhwZWN0ZWQpKTtcbiAgICBzID0gY29kZVNwYW4oc3JjLCAnY29kZVRlc3QnKTtcbiAgICBzLmFwcGVuZENoaWxkKHRleHROb2RlKCdcXG4nKSk7XG4gICAgcy5zZXRBdHRyaWJ1dGUoJ2dlbmVyYXRlZE5MJywgJycpO1xuICAgIGJ4ID0gY29kZUJveCgnY29kZU1haW5UZXN0Jyk7XG4gICAgYngudGVzdFNyYyA9IHM7XG4gICAgYnguc2V0QXR0cmlidXRlKCdjbGFzcycsICdjb2RlTWFpblRlc3Qgbm90cnVuJyk7XG4gICAgYnguc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCAnZmFsc2UnKTtcbiAgICBieC5hcHBlbmRDaGlsZChzKTtcbiAgICBieC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjbGlja1Rlc3QoYngpO1xuICAgIH0pLCB0cnVlKTtcbiAgICBieC50ZXN0ID0gdGVzdDtcbiAgICByZXR1cm4gYng7XG4gIH07XG5cbiAgY2xpY2tUZXN0ID0gZnVuY3Rpb24oYngpIHtcbiAgICB2YXIgZXhwckJveCwgciwgc3A7XG5cbiAgICBpZiAoYnguY2xhc3NMaXN0LmNvbnRhaW5zKCdub3RydW4nKSkge1xuICAgICAgcmV0dXJuIHJ1blRlc3QoYngpO1xuICAgIH0gZWxzZSB7XG4gICAgICByID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgIHIuc2V0U3RhcnRCZWZvcmUoYngpO1xuICAgICAgci5zZXRFbmRBZnRlcihieCk7XG4gICAgICByLmRlbGV0ZUNvbnRlbnRzKCk7XG4gICAgICBzcCA9IGNvZGVTcGFuKGJ4LnRlc3QuZXhwciwgJ2NvZGVFeHByJyk7XG4gICAgICBzcC5zZXRBdHRyaWJ1dGUoJ2dlbmVyYXRlZE5MJywgJycpO1xuICAgICAgZXhwckJveCA9IGJveChyLCAnY29kZU1haW5FeHByJywgdHJ1ZSk7XG4gICAgICBleHByQm94LmFwcGVuZENoaWxkKHNwKTtcbiAgICAgIHJldHVybiBtYWtlT3V0cHV0Qm94KGV4cHJCb3gpO1xuICAgIH1cbiAgfTtcblxuICBydW5UZXN0ID0gZnVuY3Rpb24oYngpIHtcbiAgICB2YXIgcGFzc2VkLCB0ZXN0O1xuXG4gICAgdGVzdCA9IGJ4LnRlc3Q7XG4gICAgcGFzc2VkID0gdHJ1ZTtcbiAgICBwcm9jZXNzTGluZShwcmVwRXhwcih0ZXN0LmV4cHIpLCB7XG4gICAgICB2YWx1ZXM6IHt9LFxuICAgICAgcmVxdWlyZTogcmVxLFxuICAgICAgd3JpdGU6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICByZXR1cm4gY29uc29sZS5sb2coc3RyKTtcbiAgICAgIH0sXG4gICAgICBkZWJ1ZzogZGVidWcsXG4gICAgICBwcm9tcHQ6IGZ1bmN0aW9uKG1zZywgY29udCkge1xuICAgICAgICByZXR1cm4gY29udChudWxsKTtcbiAgICAgIH0sXG4gICAgICBwcm9jZXNzUmVzdWx0OiBmdW5jdGlvbihyZXN1bHQsIGFzdCkge1xuICAgICAgICByZXR1cm4gcGFzc2VkID0gc2hvd1Jlc3VsdChieCwgZXNjYXBlSHRtbChTdHJpbmcocmVzdWx0KSksIGVzY2FwZUh0bWwodGVzdC5leHBlY3RlZCkpO1xuICAgICAgfSxcbiAgICAgIGVycjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBwYXNzZWQgPSBmYWxzZTtcbiAgICAgIH0sXG4gICAgICBwcmVzZW50VmFsdWU6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgICB9XG4gICAgfSwgaWRlbnRpdHkpO1xuICAgIHJldHVybiBwYXNzZWQ7XG4gIH07XG5cbiAgc2hvd1Jlc3VsdCA9IGZ1bmN0aW9uKGJ4LCBhY3R1YWwsIGV4cGVjdGVkKSB7XG4gICAgdmFyIGNsO1xuXG4gICAgY2wgPSBieC5jbGFzc0xpc3Q7XG4gICAgY2wucmVtb3ZlKCdub3RydW4nKTtcbiAgICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgICAgY2wucmVtb3ZlKCdmYWlsZWQnKTtcbiAgICAgIGNsLmFkZCgncGFzc2VkJyk7XG4gICAgICBieC50ZXN0U3JjLmlubmVySFRNTCA9IFwiI0B0ZXN0IFwiICsgKEpTT04uc3RyaW5naWZ5KGJ4LnRlc3QuZXhwcikpICsgXCJcXG4jQGV4cGVjdGVkIFwiICsgKEpTT04uc3RyaW5naWZ5KGJ4LnRlc3QuZXhwZWN0ZWQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2wucmVtb3ZlKCdwYXNzZWQnKTtcbiAgICAgIGNsLmFkZCgnZmFpbGVkJyk7XG4gICAgICBieC50ZXN0U3JjLmlubmVySFRNTCA9IFwiI0B0ZXN0IFwiICsgKEpTT04uc3RyaW5naWZ5KGJ4LnRlc3QuZXhwcikpICsgXCJcXG4jQGV4cGVjdGVkIFwiICsgKEpTT04uc3RyaW5naWZ5KGJ4LnRlc3QuZXhwZWN0ZWQpKSArIFwiXFxuI0ByZXN1bHQgXCIgKyAoSlNPTi5zdHJpbmdpZnkoYWN0dWFsKSk7XG4gICAgICBjb25zb2xlLmxvZyhcImV4cGVjdGVkIDxcIiArIGV4cGVjdGVkICsgXCI+IGJ1dCBnb3QgPFwiICsgYWN0dWFsICsgXCI+XCIpO1xuICAgIH1cbiAgICByZXR1cm4gYWN0dWFsID09PSBleHBlY3RlZDtcbiAgfTtcblxuICBwcmVwRXhwciA9IGZ1bmN0aW9uKHR4dCkge1xuICAgIHJldHVybiB0eHQ7XG4gIH07XG5cbiAgZW52Rm9yID0gZnVuY3Rpb24oYm94KSB7XG4gICAgdmFyIGVudiwgZXhCb3gsIHdpZGdldDtcblxuICAgIGV4Qm94ID0gZ2V0Qm94KGJveCk7XG4gICAgd2lkZ2V0ID0gbnVsbDtcbiAgICBlbnYgPSB7XG4gICAgICBmaWxlU2V0dGluZ3M6IHt9LFxuICAgICAgZGVidWc6IGRlYnVnLFxuICAgICAgZmluaXNoZWRFdmVudDogZnVuY3Rpb24oZXZ0LCBjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiB1cGRhdGUoY2hhbm5lbCAhPSBudWxsID8gY2hhbm5lbCA6ICdhcHAnLCB0aGlzKTtcbiAgICAgIH0sXG4gICAgICBvd25lcjogb3duZXIoYm94KSxcbiAgICAgIGJveDogYm94LFxuICAgICAgcmVxdWlyZTogcmVxLFxuICAgICAgd3JpdGU6IGZ1bmN0aW9uKG1zZykge1xuICAgICAgICB2YXIgZGl2O1xuXG4gICAgICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBkaXYuY2xhc3NMaXN0LmFkZCgnb3V0cHV0RGl2Jyk7XG4gICAgICAgIGRpdi5pbm5lckhUTUwgPSBcIlwiICsgbXNnICsgXCJcXG5cIjtcbiAgICAgICAgZXhCb3guYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgICAgY2hlY2tIaWRlU291cmNlKGV4Qm94KTtcbiAgICAgICAgcmV0dXJuIG1hcmt1cEJ1dHRvbnMoZXhCb3gpO1xuICAgICAgfSxcbiAgICAgIGdldFdpZGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghd2lkZ2V0KSB7XG4gICAgICAgICAgd2lkZ2V0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKTtcbiAgICAgICAgICBleEJveC5hcHBlbmRDaGlsZCh3aWRnZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3aWRnZXQ7XG4gICAgICB9LFxuICAgICAgZGVzdHJveVdpZGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh3aWRnZXQpIHtcbiAgICAgICAgICByZXR1cm4gcmVtb3ZlKHdpZGdldCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwcm9tcHQ6IGZ1bmN0aW9uKG1zZywgY29udCkge1xuICAgICAgICByZXR1cm4gY29udCh3aW5kb3cucHJvbXB0KG1zZykpO1xuICAgICAgfSxcbiAgICAgIHByb2Nlc3NSZXN1bHQ6IGZ1bmN0aW9uKHJlc3VsdCwgYXN0KSB7XG4gICAgICAgIGJveC5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgIHJldHVybiBzZXRBc3QoYm94LCBhc3QpO1xuICAgICAgfSxcbiAgICAgIHByZXNlbnRWYWx1ZTogcHJlc2VudFZhbHVlLFxuICAgICAgZXJyOiBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgdmFyIGJ0biwgX3JlZjM7XG5cbiAgICAgICAgYnRuID0gYm94LnF1ZXJ5U2VsZWN0b3IoJ1tsZWlzdXJlSWQ9XCJtYWtlVGVzdENhc2VcIl0nKTtcbiAgICAgICAgaWYgKGJ0bikge1xuICAgICAgICAgIHJlbW92ZShidG4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlKFwiPGRpdiBjbGFzcz0nZXJyb3JEaXYnPlwiICsgZXNjYXBlSHRtbChcIkVSUk9SOiBcIiArIChlcnIubGVpc3VyZUNvbnRleHQgPyBcIlwiICsgZXJyICsgXCI6XFxuXCIgKyAobGVpc3VyZUNvbnRleHRTdHJpbmcoZXJyKSkgKyBcIlxcblwiIDogJycpICsgKChfcmVmMyA9IGVyci5zdGFjaykgIT0gbnVsbCA/IF9yZWYzIDogZXJyKSkgKyBcIjwvZGl2PlwiKTtcbiAgICAgIH0sXG4gICAgICBjbGVhbnVwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95V2lkZ2V0KCk7XG4gICAgICAgIGlmIChyb290Lmxhc3RFbnYgPT09IGVudikge1xuICAgICAgICAgIHJldHVybiByb290Lmxhc3RFbnYgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBlbnYuX19wcm90b19fID0gZGVmYXVsdEVudjtcbiAgICBlbnYuZmlsZVNldHRpbmdzLnVyaSA9IG5ldyBVUkkoZG9jdW1lbnQubG9jYXRpb24uaHJlZik7XG4gICAgcm9vdC5sYXN0RW52ID0gZW52O1xuICAgIHJldHVybiBlbnY7XG4gIH07XG5cbiAgbGVpc3VyZUNvbnRleHRTdHJpbmcgPSBmdW5jdGlvbihlcnIpIHtcbiAgICB2YXIgZnVuYywgb2Zmc2V0O1xuXG4gICAgcmV0dXJuICgoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX2ksIF9sZW4sIF9yZWYzLCBfcmVmNCwgX3Jlc3VsdHM7XG5cbiAgICAgIF9yZWYzID0gZXJyLmxlaXN1cmVDb250ZXh0LnRvQXJyYXkoKTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIF9yZWY0ID0gX3JlZjNbX2ldLCBmdW5jID0gX3JlZjRbMF0sIG9mZnNldCA9IF9yZWY0WzFdO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKGxpbmtTb3VyY2UoZnVuYywgb2Zmc2V0KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfSkoKSkuam9pbignXFxuJyk7XG4gIH07XG5cbiAgbGlua1NvdXJjZSA9IGZ1bmN0aW9uKGZ1bmNOYW1lLCBvZmZzZXQpIHt9O1xuXG4gIHNob3dTb3VyY2UgPSBmdW5jdGlvbihmdW5jTmFtZSwgb2Zmc2V0KSB7fTtcblxuICBtYWtlT3V0cHV0Qm94ID0gZnVuY3Rpb24oc291cmNlKSB7XG4gICAgdmFyIGNsLCBub2RlLCBfaSwgX2xlbiwgX3JlZjM7XG5cbiAgICBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ0xlaXN1cmVPdXRwdXQnLCAnJyk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ0xlaXN1cmUnLCAnJyk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ0xlaXN1cmVCb3gnLCAnJyk7XG4gICAgX3JlZjMgPSBib3hDbGFzc2VzLm91dHB1dDtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBjbCA9IF9yZWYzW19pXTtcbiAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZChjbCk7XG4gICAgfVxuICAgIG5vZGUuc2V0QXR0cmlidXRlKCdjb250ZW50RWRpdGFibGUnLCAnZmFsc2UnKTtcbiAgICBub2RlLnNvdXJjZSA9IHNvdXJjZTtcbiAgICBzb3VyY2Uub3V0cHV0ID0gbm9kZTtcbiAgICBub2RlLmlubmVySFRNTCA9IFwiPGRpdiBjbGFzcz0nY29udHJvbHMnPjxidXR0b24gb25jbGljaz0nTm90ZWJvb2suZXZhbE91dHB1dCh0aGlzKSc+LSZndDs8L2J1dHRvbj48L2Rpdj5cIjtcbiAgICBtYXJrdXBCdXR0b25zKG5vZGUpO1xuICAgIHNvdXJjZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCBzb3VyY2UubmV4dFNpYmxpbmcpO1xuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIGNvZGVTcGFuID0gZnVuY3Rpb24odGV4dCwgYm94VHlwZSkge1xuICAgIHZhciBub2RlO1xuXG4gICAgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShib3hUeXBlLCAnJyk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ0xlaXN1cmUnLCAnJyk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgYm94VHlwZSk7XG4gICAgaWYgKHRleHQpIHtcbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQobm9kZUZvcih0ZXh0KSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIGNvZGVCb3ggPSBmdW5jdGlvbihib3hUeXBlKSB7XG4gICAgdmFyIG5vZGU7XG5cbiAgICBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgYWRkQm94Q2xhc3Nlcyhub2RlLCBib3hUeXBlKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZSgnTGVpc3VyZUJveCcsICcnKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZSgnTGVpc3VyZScsICcnKTtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBmdW5jdGlvbihlKSB7XG4gICAgICByZXR1cm4gY2hlY2tNdXRhdGVGcm9tTW9kaWZpY2F0aW9uKGUpO1xuICAgIH0pO1xuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIGJveCA9IGZ1bmN0aW9uKHJhbmdlLCBib3hUeXBlLCBlbXB0eSkge1xuICAgIHZhciBub2RlO1xuXG4gICAgbm9kZSA9IGNvZGVCb3goYm94VHlwZSk7XG4gICAgaWYgKGVtcHR5KSB7XG4gICAgICByYW5nZS5kZWxldGVDb250ZW50cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHJhbmdlLmV4dHJhY3RDb250ZW50cygpKTtcbiAgICB9XG4gICAgcmFuZ2UuaW5zZXJ0Tm9kZShub2RlKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICBsaW5lUGF0ID0gbmV3IFJlZ0V4cChcIihcIiArIChyeihMX2xpbmVQYXQpLnNvdXJjZSkgKyBcIilcIik7XG5cbiAgZmluZERlZnMgPSBmdW5jdGlvbihlbCkge1xuICAgIHZhciBkZWYsIHJhbmdlcywgcmVzdCwgcm5nLCB0eHQ7XG5cbiAgICB0eHQgPSBlbC50ZXh0Q29udGVudDtcbiAgICByZXN0ID0gdHh0O1xuICAgIHJhbmdlcyA9IFtdO1xuICAgIHdoaWxlICgoZGVmID0gcmVzdC5tYXRjaChyeihMX3VuYW5jaG9yZWREZWZQYXQpKSkgJiYgZGVmWzFdLmxlbmd0aCAhPT0gcmVzdC5sZW5ndGgpIHtcbiAgICAgIHJuZyA9IGdldFJhbmdlcyhlbCwgdHh0LCByZXN0LCBkZWYsIHR4dC5sZW5ndGggLSByZXN0Lmxlbmd0aCk7XG4gICAgICBpZiAocm5nKSB7XG4gICAgICAgIHJlc3QgPSBybmcubmV4dDtcbiAgICAgICAgaWYgKHJuZykge1xuICAgICAgICAgIHJhbmdlcy5wdXNoKHJuZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmFuZ2VzO1xuICB9O1xuXG4gIHRlc3RQYXQgPSAvKCNAdGVzdChbXlxcbl0qKVxcbiNAZXhwZWN0ZWQoW15cXG5dKikpXFxuL207XG5cbiAgZ2V0UmFuZ2VzID0gZnVuY3Rpb24oZWwsIHR4dCwgcmVzdCwgZGVmLCByZXN0T2ZmKSB7XG4gICAgdmFyIGJvZHksIGJvZHlTdGFydCwgZGVmVHlwZSwgZW5kUGF0LCBleCwgZXhFbmQsIGxlYWRPZmYsIGxlYWRpbmcsIGxlYWRpbmdTcGFjZXMsIGxtLCBtLCBtMiwgbWFpbkVuZCwgbWFpblN0YXJ0LCBtYXRjaFN0YXJ0LCBtYXRjaGVkLCBuYW1lLCBuYW1lRW5kLCBuYW1lUmF3LCBuZXh0LCBvdXRlclJhbmdlLCByLCByZXN0MSwgdCwgdE9mZiwgdGVzdHMsIHRleHRTdGFydCwgX3JlZjMsIF9yZWY0LCBfcmVmNSwgX3JlZjY7XG5cbiAgICBfcmVmMyA9IG0gPSBkZWYsIG1hdGNoZWQgPSBfcmVmM1swXSwgbGVhZGluZyA9IF9yZWYzWzFdLCBuYW1lUmF3ID0gX3JlZjNbMl0sIGRlZlR5cGUgPSBfcmVmM1szXTtcbiAgICBpZiAoIXJlc3QudHJpbSgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKG0gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFttYWtlUmFuZ2UoZWwsIHJlc3RPZmYsIHR4dC5sZW5ndGgpLCBudWxsLCBudWxsLCBbXSwgJyddO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZXN0cyA9IFtdO1xuICAgICAgbWF0Y2hTdGFydCA9IHJlc3RPZmYgKyBtLmluZGV4O1xuICAgICAgaWYgKGRlZlR5cGUgPT0gbnVsbCkge1xuICAgICAgICBuYW1lID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAobmFtZVJhd1swXSA9PT0gJyAnKSB7XG4gICAgICAgIG5hbWUgPSBudWxsO1xuICAgICAgICBkZWZUeXBlID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5hbWUgPSBuYW1lUmF3LnRyaW0oKSB8fCBudWxsO1xuICAgICAgfVxuICAgICAgcmVzdDEgPSByZXN0LnN1YnN0cmluZygoZGVmVHlwZSA/IG1hdGNoZWQgOiBsZWFkaW5nKS5sZW5ndGgpO1xuICAgICAgZW5kUGF0ID0gcmVzdDEubWF0Y2goL1xcbitbXlxcc118XFxuPyQvKTtcbiAgICAgIG5leHQgPSBlbmRQYXQgPyByZXN0MS5zdWJzdHJpbmcoZW5kUGF0LmluZGV4KSA6IHJlc3QxO1xuICAgICAgbWFpbkVuZCA9IHR4dC5sZW5ndGggLSBuZXh0Lmxlbmd0aDtcbiAgICAgIHQgPSBsZWFkaW5nO1xuICAgICAgbGVhZE9mZiA9IHRPZmYgPSByZXN0T2ZmO1xuICAgICAgd2hpbGUgKG0yID0gdC5tYXRjaCh0ZXN0UGF0KSkge1xuICAgICAgICByID0gbWFrZVJhbmdlKGVsLCB0T2ZmICsgbTIuaW5kZXgsIHRPZmYgKyBtMi5pbmRleCArIG0yWzFdLmxlbmd0aCk7XG4gICAgICAgIHIubGVpc3VyZVRlc3QgPSB7XG4gICAgICAgICAgZXhwcjogSlNPTi5wYXJzZShtMlsyXSksXG4gICAgICAgICAgZXhwZWN0ZWQ6IEpTT04ucGFyc2UobTJbM10pXG4gICAgICAgIH07XG4gICAgICAgIHRlc3RzLnB1c2gocik7XG4gICAgICAgIHRPZmYgKz0gbTIuaW5kZXggKyBtMlsxXS5sZW5ndGg7XG4gICAgICAgIHQgPSBsZWFkaW5nLnN1YnN0cmluZyh0T2ZmIC0gbGVhZE9mZik7XG4gICAgICB9XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICBtYWluU3RhcnQgPSBtYXRjaFN0YXJ0ICsgKChfcmVmNCA9IGxlYWRpbmcgIT0gbnVsbCA/IGxlYWRpbmcubGVuZ3RoIDogdm9pZCAwKSAhPSBudWxsID8gX3JlZjQgOiAwKTtcbiAgICAgICAgbmFtZUVuZCA9IG1haW5TdGFydCArIG5hbWUubGVuZ3RoO1xuICAgICAgICBsZWFkaW5nU3BhY2VzID0gKHJlc3QxLm1hdGNoKC9eXFxzKi8pKVswXS5sZW5ndGg7XG4gICAgICAgIGJvZHlTdGFydCA9IHR4dC5sZW5ndGggLSAocmVzdDEubGVuZ3RoIC0gbGVhZGluZ1NwYWNlcyk7XG4gICAgICAgIG91dGVyUmFuZ2UgPSBtYWtlUmFuZ2UoZWwsIG1haW5TdGFydCwgbWFpbkVuZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWFpbjogb3V0ZXJSYW5nZSxcbiAgICAgICAgICBuYW1lOiB0eHQuc3Vic3RyaW5nKG1haW5TdGFydCwgbmFtZUVuZCksXG4gICAgICAgICAgZGVmOiBkZWZUeXBlLFxuICAgICAgICAgIGJvZHk6IHR4dC5zdWJzdHJpbmcoYm9keVN0YXJ0LCBtYWluRW5kKSxcbiAgICAgICAgICB0ZXN0czogdGVzdHMsXG4gICAgICAgICAgbmV4dDogbmV4dFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFpblN0YXJ0ID0gZGVmVHlwZSA9PT0gJz0nID8gcmVzdE9mZiArIG0uaW5kZXggKyBtWzBdLmxlbmd0aCA6IG1hdGNoU3RhcnQgKyAoKF9yZWY1ID0gbGVhZGluZyAhPSBudWxsID8gbGVhZGluZy5sZW5ndGggOiB2b2lkIDApICE9IG51bGwgPyBfcmVmNSA6IDApO1xuICAgICAgICBleCA9IHR4dC5zdWJzdHJpbmcobWFpblN0YXJ0LCBtYWluRW5kKS5tYXRjaCgvXiguKlteIFxcbl0pWyBcXG5dKiQvKTtcbiAgICAgICAgZXhFbmQgPSBleCA/IG1haW5TdGFydCArIGV4WzFdLmxlbmd0aCA6IG1haW5FbmQ7XG4gICAgICAgIGJvZHkgPSB0eHQuc3Vic3RyaW5nKG1haW5TdGFydCwgZXhFbmQpO1xuICAgICAgICBpZiAoYm9keS50cmltKCkpIHtcbiAgICAgICAgICB0ZXh0U3RhcnQgPSByZXN0T2ZmICsgbS5pbmRleCArICh0ID8gbGVhZGluZy5sZW5ndGggLSB0Lmxlbmd0aCA6IDApO1xuICAgICAgICAgIGlmICgodCAhPSBudWxsKSAmJiAobG0gPSB0Lm1hdGNoKC9eWyBcXG5dKy8pKSkge1xuICAgICAgICAgICAgdGV4dFN0YXJ0ICs9IGxtWzBdLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG0gPSB0Lm1hdGNoKC8oPzpefFxcbikjQGF1dG8oICtbXlxcbl0qKT8oXFxufCQpLykpIHtcbiAgICAgICAgICAgIG91dGVyUmFuZ2UgPSBtYWtlUmFuZ2UoZWwsIHRleHRTdGFydCwgZXhFbmQpO1xuICAgICAgICAgICAgb3V0ZXJSYW5nZS5sZWlzdXJlQXV0byA9IEpTT04ucGFyc2UoXCJ7XCIgKyAoKF9yZWY2ID0gbVsxXSkgIT0gbnVsbCA/IF9yZWY2IDogJycpICsgXCJ9XCIpO1xuICAgICAgICAgICAgaWYgKG91dGVyUmFuZ2UubGVpc3VyZUF1dG8ubW9kZSA9PT0gJ25vdGVib29rJykge1xuICAgICAgICAgICAgICBvdXRlclJhbmdlLmxlaXN1cmVOb2RlID0gZWw7XG4gICAgICAgICAgICAgIG91dGVyUmFuZ2UubGVpc3VyZVN0YXJ0ID0gdGV4dFN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgbWFpbjogb3V0ZXJSYW5nZSxcbiAgICAgICAgICAgICAgbmFtZTogbnVsbCxcbiAgICAgICAgICAgICAgZGVmOiBudWxsLFxuICAgICAgICAgICAgICBib2R5OiB0eHQuc3Vic3RyaW5nKHRleHRTdGFydCwgZXhFbmQpLFxuICAgICAgICAgICAgICB0ZXN0czogdGVzdHMsXG4gICAgICAgICAgICAgIGZ1bGxUZXh0OiB0eHQuc3Vic3RyaW5nKHRleHRTdGFydCwgZXhFbmQpLFxuICAgICAgICAgICAgICBuZXh0OiBuZXh0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXRlclJhbmdlID0gbWFrZVJhbmdlKGVsLCB0ZXh0U3RhcnQsIGV4RW5kKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIG1haW46IG91dGVyUmFuZ2UsXG4gICAgICAgICAgICAgIG5hbWU6IG51bGwsXG4gICAgICAgICAgICAgIGRlZjogbnVsbCxcbiAgICAgICAgICAgICAgYm9keTogdHh0LnN1YnN0cmluZyh0ZXh0U3RhcnQsIGV4RW5kKSxcbiAgICAgICAgICAgICAgdGVzdHM6IHRlc3RzLFxuICAgICAgICAgICAgICBuZXh0OiBuZXh0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWFpbjogbnVsbCxcbiAgICAgICAgICAgIG5hbWU6IG51bGwsXG4gICAgICAgICAgICBkZWY6IG51bGwsXG4gICAgICAgICAgICBib2R5OiBudWxsLFxuICAgICAgICAgICAgdGVzdHM6IHRlc3RzLFxuICAgICAgICAgICAgbmV4dDogbmV4dFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgbWFrZVJhbmdlID0gZnVuY3Rpb24oZWwsIG9mZjEsIG9mZjIpIHtcbiAgICB2YXIgbm9kZSwgb2Zmc2V0LCByYW5nZSwgX3JlZjMsIF9yZWY0O1xuXG4gICAgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIF9yZWYzID0gZ3JwKGVsLCBvZmYxLCBmYWxzZSksIG5vZGUgPSBfcmVmM1swXSwgb2Zmc2V0ID0gX3JlZjNbMV07XG4gICAgaWYgKChvZmZzZXQgIT0gbnVsbCkgJiYgb2Zmc2V0ID4gMCkge1xuICAgICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgb2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2Uuc2V0U3RhcnRCZWZvcmUobm9kZSk7XG4gICAgfVxuICAgIGlmIChvZmYyICE9IG51bGwpIHtcbiAgICAgIF9yZWY0ID0gZ3JwKGVsLCBvZmYyLCB0cnVlKSwgbm9kZSA9IF9yZWY0WzBdLCBvZmZzZXQgPSBfcmVmNFsxXTtcbiAgICAgIGlmIChvZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICByYW5nZS5zZXRFbmQobm9kZSwgb2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmdlLnNldEVuZEFmdGVyKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG5cbiAgZ3JwID0gZnVuY3Rpb24obm9kZSwgY2hhck9mZnNldCwgZW5kKSB7XG4gICAgdmFyIGNoaWxkLCBvZmZzZXQsIHJldCwgX3JlZjM7XG5cbiAgICBfcmVmMyA9IHJldCA9IGdldFJhbmdlUG9zaXRpb24obm9kZS5maXJzdENoaWxkLCBjaGFyT2Zmc2V0LCBlbmQpLCBjaGlsZCA9IF9yZWYzWzBdLCBvZmZzZXQgPSBfcmVmM1sxXTtcbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSBlbHNlIGlmIChub2RlLmxhc3RDaGlsZCkge1xuICAgICAgcmV0dXJuIG5vZGVFbmQobm9kZS5sYXN0Q2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW25vZGUsIGVuZCA/IDEgOiAwXTtcbiAgICB9XG4gIH07XG5cbiAgZ2V0UmFuZ2VQb3NpdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIGNoYXJPZmZzZXQsIGVuZCkge1xuICAgIHZhciBuZXdOb2RlLCBuZXdPZmYsIHJldCwgX3JlZjM7XG5cbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHJldHVybiBbbnVsbCwgY2hhck9mZnNldF07XG4gICAgfSBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICBpZiAobm9kZS5sZW5ndGggPiAoZW5kID8gY2hhck9mZnNldCAtIDEgOiBjaGFyT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gW25vZGUsIGNoYXJPZmZzZXRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gY29udGludWVSYW5nZVBvc2l0aW9uKG5vZGUsIGNoYXJPZmZzZXQgLSBub2RlLmxlbmd0aCwgZW5kKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUubm9kZU5hbWUgPT09ICdCUicpIHtcbiAgICAgIGlmIChjaGFyT2Zmc2V0ID09PSAoZW5kID8gMSA6IDApKSB7XG4gICAgICAgIHJldHVybiBbbm9kZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29udGludWVSYW5nZVBvc2l0aW9uKG5vZGUsIGNoYXJPZmZzZXQsIGVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLmZpcnN0Q2hpbGQgIT0gbnVsbCkge1xuICAgICAgX3JlZjMgPSBnZXRSYW5nZVBvc2l0aW9uKG5vZGUuZmlyc3RDaGlsZCwgY2hhck9mZnNldCwgZW5kKSwgbmV3Tm9kZSA9IF9yZWYzWzBdLCBuZXdPZmYgPSBfcmVmM1sxXTtcbiAgICAgIGlmIChuZXdOb2RlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtuZXdOb2RlLCBuZXdPZmZdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbnRpbnVlUmFuZ2VQb3NpdGlvbihub2RlLCBuZXdPZmYsIGVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjb250aW51ZVJhbmdlUG9zaXRpb24obm9kZSwgY2hhck9mZnNldCwgZW5kKTtcbiAgICB9XG4gIH07XG5cbiAgY29udGludWVSYW5nZVBvc2l0aW9uID0gZnVuY3Rpb24obm9kZSwgY2hhck9mZnNldCwgZW5kKSB7XG4gICAgdmFyIG5ld09mZjtcblxuICAgIG5ld09mZiA9IGNoYXJPZmZzZXQgLSAoKGFkZHNMaW5lKG5vZGUpKSB8fCAoKG5vZGUubmV4dFNpYmxpbmcgIT0gbnVsbCkgJiYgKGFkZHNMaW5lKG5vZGUubmV4dFNpYmxpbmcpKSkgPyAxIDogMCk7XG4gICAgaWYgKGVuZCAmJiAobmV3T2ZmID09PSAxIHx8IGNoYXJPZmZzZXQgPT09IDEpKSB7XG4gICAgICByZXR1cm4gbm9kZUVuZChub2RlKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUubmV4dFNpYmxpbmcgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGdldFJhbmdlUG9zaXRpb24obm9kZS5uZXh0U2libGluZywgbmV3T2ZmLCBlbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY29udGludWVSYW5nZVBvc2l0aW9uKG5vZGUucGFyZW50Tm9kZSwgbmV3T2ZmLCBlbmQpO1xuICAgIH1cbiAgfTtcblxuICBub2RlRW5kID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiBbbm9kZSwgbm9kZS5ub2RlVHlwZSA9PT0gMyA/IG5vZGUubGVuZ3RoIDogbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDFdO1xuICB9O1xuXG4gIGFkZHNMaW5lID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiAobm9kZSAhPSBudWxsID8gbm9kZS5ub2RlVHlwZSA6IHZvaWQgMCkgPT09IDEgJiYgKG5vZGUubm9kZU5hbWUgPT09ICdCUicgfHwgKGdldENvbXB1dGVkU3R5bGUobm9kZSwgbnVsbCkuZGlzcGxheSA9PT0gJ2Jsb2NrJyAmJiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoID4gMCkpO1xuICB9O1xuXG4gIHJlcSA9IGZ1bmN0aW9uKGZpbGUsIGNvbnQpIHtcbiAgICB2YXIgbmFtZSwgcztcblxuICAgIGlmICghKGZpbGUubWF0Y2goL1xcLmpzJC8pKSkge1xuICAgICAgZmlsZSA9IFwiXCIgKyBmaWxlICsgXCIuanNcIjtcbiAgICB9XG4gICAgbmFtZSA9IGZpbGUuc3Vic3RyaW5nKDAsIGZpbGUubGVuZ3RoIC0gMyk7XG4gICAgcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgIHMuc2V0QXR0cmlidXRlKCdzcmMnLCBmaWxlKTtcbiAgICBzLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbigpIHtcbiAgICAgIExlaXN1cmUucHJvY2Vzc0RlZnMoZ2xvYmFsW25hbWVdLCBnbG9iYWwpO1xuICAgICAgaWYgKGNvbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnQocnooTF9mYWxzZSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHMpO1xuICB9O1xuXG4gIHBvc3RMb2FkUXVldWUgPSBbXTtcblxuICBsb2FkZWQgPSBmYWxzZTtcblxuICBxdWV1ZUFmdGVyTG9hZCA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICBpZiAobG9hZGVkKSB7XG4gICAgICByZXR1cm4gZnVuYygpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcG9zdExvYWRRdWV1ZS5wdXNoKGZ1bmMpO1xuICAgIH1cbiAgfTtcblxuICAvKlxuICAjIGhhbmRsZSBmb2N1cyBtYW51YWxseSwgYmVjYXVzZSBncmFiYmluZyBmb2N1cyBhbmQgYmx1ciBldmVudHMgZG9lc24ndCBzZWVtIHRvIHdvcmsgZm9yIHRoZSBwYXJlbnRcbiAgKi9cblxuXG4gIGRvY0ZvY3VzID0gbnVsbDtcblxuICBjb2RlRm9jdXMgPSBudWxsO1xuXG4gIGZpbmRDdXJyZW50Q29kZUhvbGRlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfcmVmMztcblxuICAgIHJldHVybiBmb2N1c0JveCgoX3JlZjMgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkpICE9IG51bGwgPyBfcmVmMy5mb2N1c05vZGUgOiB2b2lkIDApO1xuICB9O1xuXG4gIGZvY3VzQm94ID0gZnVuY3Rpb24oYm94KSB7XG4gICAgdmFyIG5ld0NvZGUsIG9sZCwgX3JlZjM7XG5cbiAgICBuZXdDb2RlID0gbnVsbDtcbiAgICB3aGlsZSAoYm94ICYmIChib3gubm9kZVR5cGUgIT09IDEgfHwgIWlzTGVpc3VyZUNvZGUoYm94KSkpIHtcbiAgICAgIGlmIChib3gubm9kZVR5cGUgPT09IDEgJiYgKChib3guZ2V0QXR0cmlidXRlKCdMZWlzdXJlQm94JykpICE9IG51bGwpKSB7XG4gICAgICAgIG5ld0NvZGUgPSBib3g7XG4gICAgICB9XG4gICAgICBib3ggPSBib3gucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgaWYgKGJveCAhPT0gZG9jRm9jdXMpIHtcbiAgICAgIGlmIChkb2NGb2N1cyAhPSBudWxsKSB7XG4gICAgICAgIGRvY0ZvY3VzLmNsYXNzTGlzdC5yZW1vdmUoJ2ZvY3VzZWQnKTtcbiAgICAgIH1cbiAgICAgIGRvY0ZvY3VzID0gYm94O1xuICAgICAgaWYgKGJveCAhPSBudWxsKSB7XG4gICAgICAgIGlmICgoX3JlZjMgPSBib3guY2xhc3NMaXN0KSAhPSBudWxsKSB7XG4gICAgICAgICAgX3JlZjMuYWRkKCdmb2N1c2VkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5ld0NvZGUgIT09IGNvZGVGb2N1cykge1xuICAgICAgb2xkID0gY29kZUZvY3VzO1xuICAgICAgY29kZUZvY3VzID0gbmV3Q29kZTtcbiAgICAgIGlmIChvbGQpIHtcbiAgICAgICAgcmV0dXJuIGFjY2VwdENvZGUob2xkKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgb3duZXIgPSBmdW5jdGlvbihib3gpIHtcbiAgICB3aGlsZSAoYm94ICYmIChib3gubm9kZVR5cGUgIT09IDEgfHwgIWlzTGVpc3VyZUNvZGUoYm94KSkpIHtcbiAgICAgIGJveCA9IGJveC5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gYm94O1xuICB9O1xuXG4gIGhpZGRlblBhdCA9IC8oXnxcXG4pI0BoaWRkZW4gKihcXG58JCkvO1xuXG4gIGV2YWxCb3ggPSBmdW5jdGlvbihib3gsIGVudkJveCwgY29udCkge1xuICAgIHZhciBlbnY7XG5cbiAgICBlbnYgPSBlbnZCb3ggIT0gbnVsbCA/IGVudkZvcihlbnZCb3gpIDogbnVsbDtcbiAgICBwcm9jZXNzTGluZShib3gudGV4dENvbnRlbnQsIGVudiwgZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICBpZiAoZW52ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnYuY2xlYW51cCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgZW52LmNsZWFudXAoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIChjb250ICE9IG51bGwgPyBjb250IDogZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4geDtcbiAgICAgIH0pKHJlc3VsdCk7XG4gICAgfSk7XG4gICAgZ2V0QXN0KGJveCk7XG4gICAgaWYgKGJveC5vdXRwdXQgJiYgaGFzTW9uYWRPdXRwdXQoYm94Lm91dHB1dCkgJiYgYm94LnRleHRDb250ZW50Lm1hdGNoKGhpZGRlblBhdCkpIHtcbiAgICAgIHJldHVybiBoaWRlT3V0cHV0U291cmNlKGJveC5vdXRwdXQpO1xuICAgIH0gZWxzZSBpZiAoYm94LnRleHRDb250ZW50Lm1hdGNoKGhpZGRlblBhdCkpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmxvZyhcIk5PIE1PTkFELCBCVVQgTUFUQ0hFUyBISURERU5cIik7XG4gICAgfVxuICB9O1xuXG4gIGFjY2VwdENvZGUgPSBmdW5jdGlvbihib3gpIHtcbiAgICBpZiAoKGJveC5nZXRBdHRyaWJ1dGUoJ2NvZGVtYWluJykpICE9IG51bGwpIHtcbiAgICAgIGV2YWxCb3goYm94KTtcbiAgICAgIHVwZGF0ZSgnY29tcGlsZScpO1xuICAgICAgaWYgKG93bmVyKGJveCkuYXV0b3J1blN0YXRlKSB7XG4gICAgICAgIHJldHVybiBydW5UZXN0cyhvd25lcihib3gpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZXJyU3RyaW5nID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgcmV0dXJuIGVyci5zdGFjaztcbiAgfTtcblxuICBldmFsdWF0aW5nID0gZmFsc2U7XG5cbiAgZXZhbHVhdGlvblF1ZXVlID0gW107XG5cbiAgZXZhbE5vZGVzID0gZnVuY3Rpb24obm9kZXMpIHtcbiAgICBpZiAoZXZhbHVhdGluZykge1xuICAgICAgcmV0dXJuIGV2YWx1YXRpb25RdWV1ZS5wdXNoKG5vZGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNoYWluRXZhbE5vZGVzKG5vZGVzKTtcbiAgICB9XG4gIH07XG5cbiAgY2hhaW5FdmFsTm9kZXMgPSBmdW5jdGlvbihub2Rlcykge1xuICAgIGV2YWx1YXRpbmcgPSB0cnVlO1xuICAgIHJldHVybiBydW5BdXRvKG5vZGVzLCAwLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChldmFsdWF0aW9uUXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBjaGFpbkV2YWxOb2RlcyhldmFsdWF0aW9uUXVldWUuc2hpZnQoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZXZhbHVhdGluZyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIGV2YWxEb2MgPSBmdW5jdGlvbihlbCkge1xuICAgIHZhciBhdXRvLCBhdXRvTm9kZXMsIGUsIGVyciwgcGdtLCB4LCBfcmVmMztcblxuICAgIF9yZWYzID0gaW5pdE5vdGVib29rKGVsKSwgcGdtID0gX3JlZjNbMF0sIGF1dG8gPSBfcmVmM1sxXSwgeCA9IF9yZWYzWzJdLCBhdXRvTm9kZXMgPSBfcmVmM1szXTtcbiAgICB0cnkge1xuICAgICAgaWYgKGF1dG8gfHwgYXV0b05vZGVzKSB7XG4gICAgICAgIGF1dG8gPSBcImRvXFxuICBcIiArICgoYXV0byAhPSBudWxsID8gYXV0byA6ICcjJykudHJpbSgpLnJlcGxhY2UoL1xcbi9nLCAnXFxuICAnKSkgKyBcIlxcbiAgZGVsYXlcXG4gIGZpbmlzaExvYWRpbmdcIjtcbiAgICAgICAgZ2xvYmFsLm5vcmVkZWZzID0gZmFsc2U7XG4gICAgICAgIE5vdGVib29rLnF1ZXVlQWZ0ZXJMb2FkKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGV2YWxEb2NDb2RlKGVsLCBwZ20pO1xuICAgICAgICAgIGlmIChlbC5hdXRvcnVuU3RhdGUpIHtcbiAgICAgICAgICAgIHJ1blRlc3RzKGVsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGV2YWxOb2RlcyhhdXRvTm9kZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgZSA9IGVudkZvcihlbCk7XG4gICAgICAgIGUud3JpdGUgPSBmdW5jdGlvbigpIHt9O1xuICAgICAgICBlLmVyciA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIHJldHVybiBhbGVydCgnYnViYmEgJyArIGVyclN0cmluZyhlcnIpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NMaW5lKGF1dG8sIGUsIGlkZW50aXR5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBldmFsRG9jQ29kZShlbCwgcGdtKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgIGVyciA9IF9lcnJvcjtcbiAgICAgIHJldHVybiBzaG93RXJyb3IoZXJyLCBcIkVycm9yIGNvbXBpbGluZyBcIiArIHBnbSk7XG4gICAgfVxuICB9O1xuXG4gIHJ1bkF1dG8gPSBmdW5jdGlvbihub2RlcywgaW5kZXgsIGNvbnQpIHtcbiAgICB2YXIgbm9kZTtcblxuICAgIGlmIChpbmRleCA8IG5vZGVzLmxlbmd0aCkge1xuICAgICAgY29uc29sZS5sb2coXCJSVU5OSU5HIEFVVE86IFwiICsgaW5kZXgpO1xuICAgICAgbm9kZSA9IG5vZGVzW2luZGV4XTtcbiAgICAgIGNvbnNvbGUubG9nKFwiZXZhbE91dHB1dFwiLCBub2RlLCBub2RlLm91dHB1dCk7XG4gICAgICByZXR1cm4gZXZhbE91dHB1dChub2RlLm91dHB1dCwgZmFsc2UsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcnVuQXV0byhub2RlcywgaW5kZXggKyAxLCBjb250KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKGNvbnQgIT0gbnVsbCA/IGNvbnQgOiBmdW5jdGlvbigpIHt9KSgpO1xuICAgIH1cbiAgfTtcblxuICBwcm9jZXNzTGluZSA9IGZ1bmN0aW9uKHRleHQsIGVudiwgY29udCkge1xuICAgIHZhciBlcnI7XG5cbiAgICBpZiAodGV4dCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJ1bk1vbmFkKHJ6KExfbmV3UGFyc2VMaW5lKShseihOaWwpKShseih0ZXh0KSksIGVudiwgZnVuY3Rpb24oYXN0KSB7XG4gICAgICAgICAgdmFyIGVyciwgcmVzdWx0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChnZXRUeXBlKGFzdCkgPT09ICdwYXJzZUVycicpIHtcbiAgICAgICAgICAgICAgZW52LndyaXRlKGVudi5wcmVzZW50VmFsdWUoYXN0KSk7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgZW52LnByb2Nlc3NSZXN1bHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGVudi5wcm9jZXNzUmVzdWx0KGFzdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGNvbnQoYXN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IGV2YWwoXCIoXCIgKyAoZ2VuKGFzdCkpICsgXCIpXCIpO1xuICAgICAgICAgICAgICBlbnYud3JpdGUoZW52LnByZXNlbnRWYWx1ZShyZXN1bHQpKTtcbiAgICAgICAgICAgICAgaWYgKGlzTW9uYWQocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBydW5Nb25hZChyZXN1bHQsIGVudiwgZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICBlbnYucHJvY2Vzc1Jlc3VsdChyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVudi5wcm9jZXNzUmVzdWx0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgIGVudi5wcm9jZXNzUmVzdWx0KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb250KHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgIGVyciA9IF9lcnJvcjtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRVJST1I6IFwiICsgZXJyLnN0YWNrKTtcbiAgICAgICAgICAgIGVudi53cml0ZShlbnYucHJlc2VudFZhbHVlKGVyci5zdGFjaykpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnYucHJvY2Vzc1Jlc3VsdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIGVudi5wcm9jZXNzUmVzdWx0KGVyci5zdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udChlcnIuc3RhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZXJyID0gX2Vycm9yO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkVSUk9SOiBcIiArIGVyci5zdGFjayk7XG4gICAgICAgIGVudi53cml0ZShlbnYucHJlc2VudFZhbHVlKGVyci5zdGFjaykpO1xuICAgICAgICBpZiAodHlwZW9mIGVudi5wcm9jZXNzUmVzdWx0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBlbnYucHJvY2Vzc1Jlc3VsdChlcnIuc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250KGVyci5zdGFjayk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjb250KCcnKTtcbiAgICB9XG4gIH07XG5cbiAgc2hvd0Vycm9yID0gZnVuY3Rpb24oZSwgbXNnKSB7XG4gICAgY29uc29sZS5sb2cobXNnKTtcbiAgICBjb25zb2xlLmxvZyhlKTtcbiAgICBjb25zb2xlLmxvZyhlLnN0YWNrKTtcbiAgICByZXR1cm4gYWxlcnQoZS5zdGFjayk7XG4gIH07XG5cbiAgZXZhbERvY0NvZGUgPSBmdW5jdGlvbihlbCwgcGdtKSB7XG4gICAgcmV0dXJuIHJ1bk1vbmFkKHJ6KExfcnVuRmlsZSkobHoocGdtKSksIGRlZmF1bHRFbnYsIGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgdmFyIG5vZGUsIF9pLCBfbGVuLCBfcmVmMywgX3Jlc3VsdHM7XG5cbiAgICAgIF9yZWYzID0gZWwucXVlcnlTZWxlY3RvckFsbCgnW2NvZGVNYWluXScpO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgbm9kZSA9IF9yZWYzW19pXTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaChnZXRBc3Qobm9kZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH0pO1xuICB9O1xuXG4gIGRlZmluZSgnZ2V0RG9jdW1lbnQnLCBseihtYWtlU3luY01vbmFkKGZ1bmN0aW9uKGVudiwgY29udCkge1xuICAgIHJldHVybiBjb250KHBlZXJHZXREb2N1bWVudCgpKTtcbiAgfSkpKTtcblxuICBkZWZpbmUoJ2dldExpbmsnLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gMDtcbiAgfSk7XG5cbiAgZGVmaW5lKCdyZXBsYWNlRG9jdW1lbnQnLCBseihmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbWFrZVN5bmNNb25hZChmdW5jdGlvbihlbnYsIGNvbnQpIHtcbiAgICAgIHJlcGxhY2VDb250ZW50cyhyeihzdHIpKTtcbiAgICAgIHJldHVybiBjb250KHJ6KExfdHJ1ZSkpO1xuICAgIH0pO1xuICB9KSk7XG5cbiAgZGVmaW5lKCdnZHJpdmVPcGVuJywgbHoobWFrZU1vbmFkKGZ1bmN0aW9uKGVudiwgY29udCkge1xuICAgIHJldHVybiBHZHJpdmVTdG9yYWdlLnJ1bk9wZW4oZnVuY3Rpb24oanNvbikge1xuICAgICAgdmFyIF9yZWYzO1xuXG4gICAgICBpZiAoKGpzb24gIT0gbnVsbCA/IGpzb24uYWN0aW9uIDogdm9pZCAwKSA9PT0gJ3BpY2tlZCcgJiYgKChfcmVmMyA9IGpzb24uZG9jcykgIT0gbnVsbCA/IF9yZWYzLmxlbmd0aCA6IHZvaWQgMCkgPiAwKSB7XG4gICAgICAgIHJldHVybiBHZHJpdmVTdG9yYWdlLmxvYWRGaWxlKGpzb24uZG9jc1swXS5pZCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnQocnooX3NvbWUpKGx6KGpzb24uZG9jc1swXS50aXRsZSkpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29udChyeihfbm9uZSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KSkpO1xuXG4gIGRlZmluZSgnZ2V0RmlsZW5hbWUnLCBseihtYWtlU3luY01vbmFkKGZ1bmN0aW9uKGVudiwgY29udCkge1xuICAgIHZhciBfcmVmMztcblxuICAgIHJldHVybiBjb250KChfcmVmMyA9IGZpbGVuYW1lICE9IG51bGwgPyBmaWxlbmFtZS5wYXRoTmFtZSgpIDogdm9pZCAwKSAhPSBudWxsID8gX3JlZjMgOiAnJyk7XG4gIH0pKSk7XG5cbiAgZGVmaW5lKCdzZXRVUkknLCBseihmdW5jdGlvbih1cmkpIHtcbiAgICByZXR1cm4gbWFrZVN5bmNNb25hZChmdW5jdGlvbihlbnYsIGNvbnQpIHtcbiAgICAgIHNldEZpbGVuYW1lKHJ6KHVyaSkpO1xuICAgICAgcmV0dXJuIGNvbnQocnooTF90cnVlKSk7XG4gICAgfSk7XG4gIH0pKTtcblxuICBkZWZpbmUoJ2dldFVSSScsIGx6KG1ha2VTeW5jTW9uYWQoZnVuY3Rpb24oZW52LCBjb250KSB7XG4gICAgdmFyIF9yZWYzO1xuXG4gICAgcmV0dXJuIGNvbnQoKF9yZWYzID0gZmlsZW5hbWUgIT0gbnVsbCA/IGZpbGVuYW1lLnRvU3RyaW5nKCkgOiB2b2lkIDApICE9IG51bGwgPyBfcmVmMyA6ICcnKTtcbiAgfSkpKTtcblxuICBkZWZpbmUoJ2ZpbmlzaExvYWRpbmcnLCBseihtYWtlTW9uYWQoZnVuY3Rpb24oZW52LCBjb250KSB7XG4gICAgdmFyIGksIF9pLCBfbGVuO1xuXG4gICAgbG9hZGVkID0gdHJ1ZTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHBvc3RMb2FkUXVldWUubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIGkgPSBwb3N0TG9hZFF1ZXVlW19pXTtcbiAgICAgIHJ6KGkpO1xuICAgIH1cbiAgICBwb3N0TG9hZFF1ZXVlID0gW107XG4gICAgcmV0dXJuIGNvbnQocnooTF9mYWxzZSkpO1xuICB9KSkpO1xuXG4gIGRlZmluZSgnbWFya3VwQnV0dG9ucycsIGx6KG1ha2VTeW5jTW9uYWQoZnVuY3Rpb24oZW52LCBjb250KSB7XG4gICAgaWYgKGVudi5ib3gpIHtcbiAgICAgIG1hcmt1cEJ1dHRvbnMoZW52LmJveCk7XG4gICAgfVxuICAgIHJldHVybiBjb250KHJ6KExfZmFsc2UpKTtcbiAgfSkpKTtcblxuICBkZWZpbmUoJ2FsZXJ0JywgbHooZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG1ha2VTeW5jTW9uYWQoZnVuY3Rpb24oZW52LCBjb250KSB7XG4gICAgICB3aW5kb3cuYWxlcnQocnooc3RyKSk7XG4gICAgICByZXR1cm4gY29udChyeihMX2ZhbHNlKSk7XG4gICAgfSk7XG4gIH0pKTtcblxuICBkZWZpbmUoJ2JpbmRFdmVudCcsIGx6KGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VTeW5jTW9uYWQoZnVuY3Rpb24oZW52LCBjb250KSB7XG4gICAgICAgICAgdmFyIG5vZGU7XG5cbiAgICAgICAgICBub2RlID0gZW52LmJveC5xdWVyeVNlbGVjdG9yKHJ6KHNlbGVjdG9yKSk7XG4gICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICBub2RlID0gZG9jdW1lbnQuYm9keS5xdWVyeVNlbGVjdG9yKHJ6KHNlbGVjdG9yKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnNvbGUubG9nKFwiQURESU5HIEVWRU5UOiBcIiArIChyeihzZWxlY3RvcikpICsgXCIgXCIgKyAocnooZXZlbnROYW1lKSkgKyBcIiBOT0RFOiBcIiArIG5vZGUpO1xuICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lKCksIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFVkVOVDogXCIgKyAocnooc2VsZWN0b3IpKSArIFwiIFwiICsgKHJ6KGV2ZW50TmFtZSkpICsgXCIgXCIgKyAocnooZnVuYykpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJ1bk1vbmFkKHJ6KGZ1bmMpKGx6KGUpKSwgZW52Rm9yKGUudGFyZ2V0KSwgZnVuY3Rpb24oKSB7fSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNvbnQocnooTF9mYWxzZSkpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfTtcbiAgfSkpO1xuXG4gIGRlZmluZSgncXVpdCcsIGx6KHdpbmRvdy5jbG9zZSgpKSk7XG5cbiAgZGVmaW5lKCdjb25maWcnLCBseihmdW5jdGlvbihleHByKSB7XG4gICAgcmV0dXJuIG1ha2VTeW5jTW9uYWQoZnVuY3Rpb24oZW52LCBjb250KSB7XG4gICAgICBzd2l0Y2ggKHJ6KGV4cHIpKSB7XG4gICAgICAgIGNhc2UgJ2F1dG9UZXN0JzpcbiAgICAgICAgICBhdXRvUnVuKGVudi5vd25lciwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udChyeihMX2ZhbHNlKSk7XG4gICAgfSk7XG4gIH0pKTtcblxuICBkZWZpbmUoJ25vdGVib29rU2VsZWN0aW9uJywgbHooZnVuY3Rpb24oZnVuYykge1xuICAgIHJldHVybiBtYWtlU3luY01vbmFkKGZ1bmN0aW9uKGVudiwgY29udCkge1xuICAgICAgdmFyIGJ4LCBvZmZzZXQsIHAxLCBwMiwgciwgcjIsIHNlbDtcblxuICAgICAgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgYnggPSBnZXRCb3goc2VsLmZvY3VzTm9kZSk7XG4gICAgICBpZiAoKGJ4ICE9IG51bGwpICYmIGhhc0Z1bmMoYngsIGZ1bmMpKSB7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIHIgPSBzZWwuZ2V0UmFuZ2VBdCgwKTtcbiAgICAgICAgd2luZG93LnIgPSByO1xuICAgICAgICByMiA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIHIyLnNldFN0YXJ0KGJ4LCAwKTtcbiAgICAgICAgcjIuc2V0RW5kKHIuc3RhcnRDb250YWluZXIsIHIuc3RhcnRPZmZzZXQpO1xuICAgICAgICBwMSA9IHIyLmNsb25lQ29udGVudHMoKS50ZXh0Q29udGVudC5sZW5ndGggLSBvZmZzZXQ7XG4gICAgICAgIGlmICghci5jb2xsYXBzZWQpIHtcbiAgICAgICAgICByMi5zZXRFbmQoci5lbmRDb250YWluZXIsIHIuZW5kT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBwMiA9IHIyLmNsb25lQ29udGVudHMoKS50ZXh0Q29udGVudC5sZW5ndGggLSBvZmZzZXQ7XG4gICAgICAgIHJldHVybiBjb250KHJ6KF9zb21lMikobHoocDEpKShseihwMikpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb250KHJ6KF9ub25lKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pKTtcblxuICBoYXNGdW5jID0gZnVuY3Rpb24oYngsIGZ1bmMpIHtcbiAgICB2YXIgYXN0O1xuXG4gICAgYXN0ID0gZ2V0QXN0KGJ4KTtcbiAgICByZXR1cm4gYXN0ID09PSBmdW5jKCkuYXN0IHx8IGFzdCA9PT0gZnVuYy5hc3Q7XG4gIH07XG5cbiAgZGVmaW5lKCdub3RlYm9va0FzdCcsIGx6KGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICByZXR1cm4gbWFrZVN5bmNNb25hZChmdW5jdGlvbihlbnYsIGNvbnQpIHtcbiAgICAgIHZhciBhc3QsIG5vZGU7XG5cbiAgICAgIGlmIChmdW5jLmxlaXN1cmVOYW1lICE9IG51bGwpIHtcbiAgICAgICAgbm9kZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJbTGVpc3VyZUZ1bmM9XCIgKyBmdW5jLmxlaXN1cmVOYW1lICsgXCJdXCIpO1xuICAgICAgICBpZiAobm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgYXN0ID0gZ2V0QXN0KG5vZGUpO1xuICAgICAgICAgIHJldHVybiBjb250KHJ6KF9zb21lKShseihhc3QpKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250KHJ6KF9ub25lKSk7XG4gICAgfSk7XG4gIH0pKTtcblxuICBhdXRvUnVuID0gZnVuY3Rpb24oZWwsIHN0YXRlKSB7XG4gICAgdmFyIF9yZWYzO1xuXG4gICAgZWwuYXV0b3J1blN0YXRlID0gc3RhdGU7XG4gICAgcmV0dXJuIChfcmVmMyA9IGVsLmF1dG9ydW4pICE9IG51bGwgPyBfcmVmMy5jaGVja2VkID0gc3RhdGUgOiB2b2lkIDA7XG4gIH07XG5cbiAgaGVhZCA9IGZ1bmN0aW9uKGwpIHtcbiAgICByZXR1cm4gbChseihmdW5jdGlvbihoaCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHR0KSB7XG4gICAgICAgIHJldHVybiByeihoaCk7XG4gICAgICB9O1xuICAgIH0pKTtcbiAgfTtcblxuICB0YWlsID0gZnVuY3Rpb24obCkge1xuICAgIHJldHVybiBsKGx6KGZ1bmN0aW9uKGhoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odHQpIHtcbiAgICAgICAgcmV0dXJuIHJ6KHR0KTtcbiAgICAgIH07XG4gICAgfSkpO1xuICB9O1xuXG4gIGlkID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiByeih2KTtcbiAgfTtcblxuICBnZXRTdmdFbGVtZW50ID0gZnVuY3Rpb24oaWQpIHtcbiAgICB2YXIgZWwsIHN2ZztcblxuICAgIGlmICgoZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkpKSB7XG4gICAgICByZXR1cm4gZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN2ZyA9IGNyZWF0ZU5vZGUoXCI8c3ZnIGlkPSdISURERU5fU1ZHJyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZlcnNpb249JzEuMScgc3R5bGU9J3RvcDogLTEwMDAwMDsgcG9zaXRpb246IGFic29sdXRlJz48dGV4dCBpZD0nSElEREVOX1RFWFQnPmJ1YmJhPC90ZXh0Pjwvc3ZnPlwiKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3ZnKTtcbiAgICAgIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgfVxuICB9O1xuXG4gIHN2Z01lYXN1cmVUZXh0ID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHJldHVybiBmdW5jdGlvbihzdHlsZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgdmFyIGJ4LCB0eHQ7XG5cbiAgICAgICAgdHh0ID0gZ2V0U3ZnRWxlbWVudCgnSElEREVOX1RFWFQnKTtcbiAgICAgICAgaWYgKHJ6KHN0eWxlKSkge1xuICAgICAgICAgIHR4dC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgcnooc3R5bGUpKTtcbiAgICAgICAgfVxuICAgICAgICB0eHQubGFzdENoaWxkLnRleHRDb250ZW50ID0gcnoodGV4dCk7XG4gICAgICAgIGJ4ID0gdHh0LmdldEJCb3goKTtcbiAgICAgICAgcmV0dXJuIHJ6KGYpKGx6KGJ4LndpZHRoKSkobHooYnguaGVpZ2h0KSk7XG4gICAgICB9O1xuICAgIH07XG4gIH07XG5cbiAgcHJpbWNvbmNhdE5vZGVzID0gZnVuY3Rpb24obm9kZXMpIHtcbiAgICBpZiAobm9kZXMgPT09IHJ6KF9uaWwpKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChoZWFkKG5vZGVzKSkoaWQpICsgY29uY2F0Tm9kZXModGFpbChub2RlcykpO1xuICAgIH1cbiAgfTtcblxuICB0cmFuc2Zvcm1lZFBvaW50ID0gZnVuY3Rpb24ocHQsIHgsIHksIGN0bSwgaWN0bSkge1xuICAgIHB0LnggPSB4O1xuICAgIHB0LnkgPSB5O1xuICAgIHJldHVybiBwdC5tYXRyaXhUcmFuc2Zvcm0oY3RtKS5tYXRyaXhUcmFuc2Zvcm0oaWN0bSk7XG4gIH07XG5cbiAgc3ZnTWVhc3VyZSA9IGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICByZXR1cm4gcHJpbVN2Z01lYXN1cmUoY29udGVudCwgYmFzZVN0cm9rZVdpZHRoKTtcbiAgfTtcblxuICBzdmdCZXR0ZXJNZWFzdXJlID0gZnVuY3Rpb24oY29udGVudCkge1xuICAgIHJldHVybiBwcmltU3ZnTWVhc3VyZShjb250ZW50LCB0cmFuc2Zvcm1TdHJva2VXaWR0aCk7XG4gIH07XG5cbiAgcHJpbVN2Z01lYXN1cmUgPSBmdW5jdGlvbihjb250ZW50LCB0cmFuc2Zvcm1GdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGYpIHtcbiAgICAgIHZhciBiYm94LCBnLCBwYWQsIHN2ZztcblxuICAgICAgc3ZnID0gY3JlYXRlTm9kZShcIjxzdmcgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB2ZXJzaW9uPScxLjEnIHN0eWxlPSd0b3A6IC0xMDAwMDAnPjxnPlwiICsgKGNvbnRlbnQoKSkgKyBcIjwvZz48L3N2Zz5cIik7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHN2Zyk7XG4gICAgICBnID0gc3ZnLmZpcnN0Q2hpbGQ7XG4gICAgICBiYm94ID0gZy5nZXRCQm94KCk7XG4gICAgICBwYWQgPSBnZXRNYXhTdHJva2VXaWR0aChnLCBnLCBzdmcsIHRyYW5zZm9ybUZ1bmMpO1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzdmcpO1xuICAgICAgcmV0dXJuIHJ6KGYpKGx6KGJib3gueCAtIE1hdGguY2VpbChwYWQgLyAyKSkpKGx6KGJib3gueSAtIE1hdGguY2VpbChwYWQgLyAyKSkpKGx6KGJib3gud2lkdGggKyBwYWQpKShseihiYm94LmhlaWdodCArIHBhZCkpO1xuICAgIH07XG4gIH07XG5cbiAgYmFzZUVsZW1lbnRzID0gWydwYXRoJywgJ3JlY3QnLCAnY2lyY2xlJywgJ2VsbGlwc2UnLCAnbGluZScsICdwb2x5bGluZScsICdwb2x5Z29uJ107XG5cbiAgZ2V0TWF4U3Ryb2tlV2lkdGggPSBmdW5jdGlvbihlbCwgYmFzZSwgc3ZnLCB0cmFuc2Zvcm1GdW5jKSB7XG4gICAgdmFyIF9yZWYzLCBfcmVmNDtcblxuICAgIGlmIChfcmVmMyA9IGJhc2Uubm9kZU5hbWUsIF9faW5kZXhPZi5jYWxsKGJhc2VFbGVtZW50cywgX3JlZjMpID49IDApIHtcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgKF9yZWY0ID0gZ2V0Q29tcHV0ZWRTdHlsZShiYXNlKS5zdHJva2VXaWR0aCkgIT0gbnVsbCA/IF9yZWY0IDogJzAnLCBzdmcpO1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybUZ1bmMoZWwsIHN2Zy53aWR0aC5iYXNlVmFsLnZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGJhc2Uubm9kZU5hbWUgPT09ICd1c2UnKSB7XG4gICAgICByZXR1cm4gZ2V0TWF4U3Ryb2tlV2lkdGgoYmFzZSwgYmFzZS5pbnN0YW5jZVJvb3QuY29ycmVzcG9uZGluZ0VsZW1lbnQsIHN2ZywgdHJhbnNmb3JtRnVuYyk7XG4gICAgfSBlbHNlIGlmIChiYXNlLm5vZGVOYW1lID09PSAnZycpIHtcbiAgICAgIHJldHVybiBmb2xkTGVmdCgoZnVuY3Rpb24odiwgbikge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgodiwgZ2V0TWF4U3Ryb2tlV2lkdGgobiwgbiwgc3ZnLCB0cmFuc2Zvcm1GdW5jKSk7XG4gICAgICB9KSwgMCwgZWwuY2hpbGROb2Rlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfTtcblxuICBiYXNlU3Ryb2tlV2lkdGggPSBmdW5jdGlvbihlbCwgdykge1xuICAgIHJldHVybiB3O1xuICB9O1xuXG4gIHRyYW5zZm9ybVN0cm9rZVdpZHRoID0gZnVuY3Rpb24oZWwsIHcpIHtcbiAgICB2YXIgY3RtLCB0cDEsIHRwMiwgeCwgeTtcblxuICAgIGlmICh3ID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgY3RtID0gZWwuZ2V0U2NyZWVuQ1RNKCk7XG4gICAgICB0cDEgPSB0cmFuc2Zvcm1lZFBvaW50KHB0LCBieC54IC0gTWF0aC5jZWlsKHcpLCBieC55IC0gTWF0aC5jZWlsKHcpLCBjdG0sIGlzY3RtKTtcbiAgICAgIHRwMiA9IHRyYW5zZm9ybWVkUG9pbnQocHQsIGJ4LnggKyBieC53aWR0aCArIE1hdGguY2VpbCh3KSwgYngueSArIGJ4LmhlaWdodCArIE1hdGguY2VpbCh3KSwgY3RtLCBpc2N0bSk7XG4gICAgICB4ID0gdHAyLnggLSB0cDEueDtcbiAgICAgIHkgPSB0cDIueSAtIHRwMS55O1xuICAgICAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICB9XG4gIH07XG5cbiAgcHJldmlvdXNTaWJsaW5nID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHdoaWxlICgobm9kZSAhPSBudWxsID8gbm9kZS5wYXJlbnROb2RlIDogdm9pZCAwKSAmJiAhbm9kZS5wcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBub2RlICE9IG51bGwgPyBub2RlLnByZXZpb3VzU2libGluZyA6IHZvaWQgMDtcbiAgfTtcblxuICBuZXh0U2libGluZyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB3aGlsZSAoKG5vZGUgIT0gbnVsbCA/IG5vZGUucGFyZW50Tm9kZSA6IHZvaWQgMCkgJiYgIW5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBub2RlICE9IG51bGwgPyBub2RlLm5leHRTaWJsaW5nIDogdm9pZCAwO1xuICB9O1xuXG4gIGhpZGVDb250cm9sU2VjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb250cm9sU2VjdGlvbjtcblxuICAgIGNvbnRyb2xTZWN0aW9uID0gZG9jdW1lbnQuYm9keS5xdWVyeVNlbGVjdG9yKCdbbGVpc3VyZVNlY3Rpb249XCJMZWlzdXJlIENvbnRyb2xzXCJdJyk7XG4gICAgaWYgKCFjb250cm9sU2VjdGlvbikge1xuICAgICAgY29udHJvbFNlY3Rpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuaW5zZXJ0QmVmb3JlKGNvbnRyb2xTZWN0aW9uLCBkb2N1bWVudC5ib2R5LmZpcnN0Q2hpbGQpO1xuICAgICAgcm9vdC5tYXJrdXBFbGVtZW50KGNvbnRyb2xTZWN0aW9uLCBcIiMgTGVpc3VyZSBDb250cm9sc1xcblxcbiMjIEZpbGUgU2F2ZSBhbmQgTG9hZFxcbmBgYFxcbnNhdmVGaWxlXFxuXFxuc2F2ZUFzICdmaWxlbmFtZSdcXG5cXG5zYXZlQXMgcGlja0ZpbGVcXG5cXG5sb2FkRmlsZVxcblxcbmVtcHR5RmlsZVxcbmBgYFwiKTtcbiAgICAgIHVud3JhcChjb250cm9sU2VjdGlvbik7XG4gICAgfVxuICAgIGNvbnRyb2xTZWN0aW9uLmNsYXNzTGlzdC5hZGQobGVpc3VyZV9jb250cm9scyk7XG4gICAgcmV0dXJuIGNvbnRyb2xTZWN0aW9uLmNsYXNzTGlzdC5hZGQoaGlkZGVuKTtcbiAgfTtcblxuICBkZWZpbmUoJ3ByaW50VmFsdWUnLCBseihmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBtYWtlTW9uYWQoZnVuY3Rpb24oZW52LCBjb250KSB7XG4gICAgICBpZiAocnoodmFsdWUpICE9PSByeihMX25pbCkpIHtcbiAgICAgICAgZW52LndyaXRlKFwiXCIgKyAoZW52LnByZXNlbnRWYWx1ZShyeih2YWx1ZSkpKSArIFwiXFxuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnQoTF9mYWxzZSgpKTtcbiAgICB9KTtcbiAgfSkpO1xuXG4gIGRlZmF1bHRFbnYucmVxdWlyZSA9IHJlcTtcblxuICByb290LnN2Z01lYXN1cmVUZXh0ID0gc3ZnTWVhc3VyZVRleHQ7XG5cbiAgcm9vdC5zdmdNZWFzdXJlID0gc3ZnTWVhc3VyZTtcblxuICByb290LmluaXROb3RlYm9vayA9IGluaXROb3RlYm9vaztcblxuICByb290LmJpbmROb3RlYm9vayA9IGJpbmROb3RlYm9vaztcblxuICByb290LmJpbmRBbGwgPSBiaW5kQWxsO1xuXG4gIHJvb3QuZXZhbE91dHB1dCA9IGV2YWxPdXRwdXQ7XG5cbiAgcm9vdC5tYWtlVGVzdENhc2UgPSBtYWtlVGVzdENhc2U7XG5cbiAgcm9vdC5jbGVhbk91dHB1dCA9IGNsZWFuT3V0cHV0O1xuXG4gIHJvb3QuY2xlYXJPdXRwdXRCb3ggPSBjbGVhck91dHB1dEJveDtcblxuICByb290LmVudkZvciA9IGVudkZvcjtcblxuICByb290LnF1ZXVlQWZ0ZXJMb2FkID0gcXVldWVBZnRlckxvYWQ7XG5cbiAgcm9vdC5ldmFsRG9jID0gZXZhbERvYztcblxuICByb290LmdldEJveCA9IGdldEJveDtcblxuICByb290Lm1ha2VSYW5nZSA9IG1ha2VSYW5nZTtcblxuICByb290LmdycCA9IGdycDtcblxuICByb290LmNoYW5nZVRoZW1lID0gY2hhbmdlVGhlbWU7XG5cbiAgcm9vdC5zZXRTbmFwcGVyID0gc2V0U25hcHBlcjtcblxuICByb290LnVwZGF0ZSA9IHVwZGF0ZTtcblxuICByb290LmNsZWFyVXBkYXRlcyA9IGNsZWFyVXBkYXRlcztcblxuICByb290LnNob3dBc3QgPSBzaG93QXN0O1xuXG4gIHJvb3QudG9nZ2xlRWRpdCA9IHRvZ2dsZUVkaXQ7XG5cbiAgcm9vdC5zaG93U291cmNlID0gc2hvd1NvdXJjZTtcblxuICByb290LmJvb3ROb3RlYm9vayA9IGJvb3ROb3RlYm9vaztcblxuICByb290LmNyZWF0ZU5vZGUgPSBjcmVhdGVOb2RlO1xuXG4gIHJvb3QuRU5URVIgPSBFTlRFUjtcblxuICByb290LnRleHROb2RlID0gdGV4dE5vZGU7XG5cbiAgcm9vdC5jbGVhbkVtcHR5Tm9kZXMgPSBjbGVhbkVtcHR5Tm9kZXM7XG5cbiAgcm9vdC5pc0xlaXN1cmVDb2RlID0gaXNMZWlzdXJlQ29kZTtcblxuICByb290LmdldEVsZW1lbnRDb2RlID0gZ2V0RWxlbWVudENvZGU7XG5cbiAgcm9vdC5ydW5UZXN0cyA9IHJ1blRlc3RzO1xuXG4gIHJvb3QucHJldmlvdXNTaWJsaW5nID0gcHJldmlvdXNTaWJsaW5nO1xuXG4gIHJvb3QubmV4dFNpYmxpbmcgPSBuZXh0U2libGluZztcblxuICByb290LnByZXNlbnRMZWlzdXJlQ29kZSA9IHByZXNlbnRMZWlzdXJlQ29kZTtcblxuICByb290Lm1lcmdlTGVpc3VyZUNvZGUgPSBtZXJnZUxlaXN1cmVDb2RlO1xuXG4gIHJvb3QuaGlnaGxpZ2h0Tm90ZWJvb2tGdW5jdGlvbiA9IGhpZ2hsaWdodE5vdGVib29rRnVuY3Rpb247XG5cbiAgcm9vdC5FU0MgPSBFU0M7XG5cbiAgcm9vdC5IT01FID0gSE9NRTtcblxuICByb290LkVORCA9IEVORDtcblxuICByb290LlBBR0VfVVAgPSBQQUdFX1VQO1xuXG4gIHJvb3QuUEFHRV9ET1dOID0gUEFHRV9ET1dOO1xuXG4gIHJvb3QuTEVGVF9BUlJPVyA9IExFRlRfQVJST1c7XG5cbiAgcm9vdC5VUF9BUlJPVyA9IFVQX0FSUk9XO1xuXG4gIHJvb3QuUklHSFRfQVJST1cgPSBSSUdIVF9BUlJPVztcblxuICByb290LkRPV05fQVJST1cgPSBET1dOX0FSUk9XO1xuXG4gIHJvb3QuYXJyb3dzID0gYXJyb3dzO1xuXG4gIHJvb3QuY2xvc2VXaW5kb3cgPSBjbG9zZVdpbmRvdztcblxuICByb290Lm1hcmt1cEJ1dHRvbiA9IG1hcmt1cEJ1dHRvbjtcblxuICByb290Lm1hcmt1cEJ1dHRvbnMgPSBtYXJrdXBCdXR0b25zO1xuXG4gIHJvb3QuZ2V0QXN0ID0gZ2V0QXN0O1xuXG4gIHJvb3QuaW5zZXJ0Q29udHJvbHMgPSBpbnNlcnRDb250cm9scztcblxuICByb290LmRlbGF5ID0gZGVsYXk7XG5cbiAgcm9vdC5zZXRGaWxlbmFtZSA9IHNldEZpbGVuYW1lO1xuXG4gIHJvb3QudW53cmFwID0gdW53cmFwO1xuXG4gIHJvb3QucmVtb3ZlID0gcmVtb3ZlO1xuXG4gIHJvb3Qud3JhcFJhbmdlID0gd3JhcFJhbmdlO1xuXG4gIHJvb3QucmVwbGFjZUNvbnRlbnRzID0gcmVwbGFjZUNvbnRlbnRzO1xuXG4gIHJvb3QuZXZlbnQgPSBldmVudDtcblxufSkuY2FsbCh0aGlzKTtcblxuLypcbi8vQCBzb3VyY2VNYXBwaW5nVVJMPW5vdGVib29rLm1hcFxuKi9cblxufSkoc2VsZikiLCIoZnVuY3Rpb24ocHJvY2VzcyxnbG9iYWwpey8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS42LjJcbi8qXG5Db3B5cmlnaHQgKEMpIDIwMTMsIEJpbGwgQnVyZGljaywgVGlueSBDb25jZXB0czogaHR0cHM6Ly9naXRodWIuY29tL3pvdC9MZWlzdXJlXG5cbihsaWNlbnNlZCB3aXRoIFpMSUIgbGljZW5zZSlcblxuVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbndhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cblxuUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG5pbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG5mcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG5cbjEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG5jbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG5hcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuXG4yLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxubWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuXG4zLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuKi9cblxuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBNb25hZCwgTmlsLCBTaW1weUNvbnMsIGFjdG9ycywgYW10LCBhc3QySnNvbiwgYXN5bmNNb25hZCwgYmFzaWNDYWxsLCBib29sZWFuRm9yLCBjYWxsLCBjYWxsTW9uYWQsIGNvbnMsIGNvbnNGcm9tLCBjb250aW51ZU1vbmFkcywgY3VycnksIGRlZmF1bHRFbnYsIGRlZmluZSwgZW5zdXJlTGVpc3VyZUNsYXNzLCBmdW5jdGlvbkluZm8sIGdldERhdGFUeXBlLCBnZXRNb25hZFN5bmNNb2RlLCBnZXRUeXBlLCBnZXRWYWx1ZSwgaGFtdCwgaGVhZCwgaWRlbnRpdHksIGlzTW9uYWQsIGxhenksIGxlZnQsIGx6LCBtYWtlSGFtdCwgbWFrZU1vbmFkLCBtYWtlU3luY01vbmFkLCBtZW1vLCBtb25hZE1vZGVTeW5jLCBuYW1lU3ViLCBuZXdSdW5Nb25hZCwgbmV4dE1vbmFkLCBuZXh0Tm9kZSwgbm9uZSwgcGFyZW5zQ29udGVudCwgcGFyZW5zRW5kLCBwYXJlbnNTdGFydCwgcmVhZERpciwgcmVhZEZpbGUsIHJlcGxhY2VFcnIsIHJlc29sdmUsIHJpZ2h0LCByb290LCBydW5Nb25hZCwgcnosIHNldERhdGFUeXBlLCBzZXRUeXBlLCBzZXRWYWx1ZSwgc2V0V2FybkFzeW5jLCBzaW1weUNvbnMsIHNvbWUsIHN0YXRGaWxlLCBzdHJDb29yZCwgc3RyRnJvbUxpc3QsIHN0clRvTGlzdCwgc3ViY3VycnksIHRhaWwsIHRva2VuUG9zLCB0b2tlblN0cmluZywgdHJhbXBDdXJyeSwgdmFsdWVzLCB3YXJuQXN5bmMsIHdpdGhTeW5jTW9kZURvLCB3cml0ZUZpbGUsIF8sIF9mYWxzZSwgX2lkZW50aXR5LCBfcmVmLCBfcmVmMSwgX3RydWUsXG4gICAgX19zbGljZSA9IFtdLnNsaWNlO1xuXG4gIF9yZWYgPSByb290ID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Jhc2UnKSwgcmVhZEZpbGUgPSBfcmVmLnJlYWRGaWxlLCBzdGF0RmlsZSA9IF9yZWYuc3RhdEZpbGUsIHJlYWREaXIgPSBfcmVmLnJlYWREaXIsIHdyaXRlRmlsZSA9IF9yZWYud3JpdGVGaWxlLCBkZWZhdWx0RW52ID0gX3JlZi5kZWZhdWx0RW52LCBTaW1weUNvbnMgPSBfcmVmLlNpbXB5Q29ucywgc2ltcHlDb25zID0gX3JlZi5zaW1weUNvbnMsIHJlc29sdmUgPSBfcmVmLnJlc29sdmUsIGxhenkgPSBfcmVmLmxhenk7XG5cbiAgX3JlZjEgPSByZXF1aXJlKCcuL2FzdCcpLCBkZWZpbmUgPSBfcmVmMS5kZWZpbmUsIGNvbnMgPSBfcmVmMS5jb25zLCBOaWwgPSBfcmVmMS5OaWwsIGhlYWQgPSBfcmVmMS5oZWFkLCB0YWlsID0gX3JlZjEudGFpbCwgZ2V0VHlwZSA9IF9yZWYxLmdldFR5cGUsIGdldERhdGFUeXBlID0gX3JlZjEuZ2V0RGF0YVR5cGUsIGFzdDJKc29uID0gX3JlZjEuYXN0Mkpzb24sIGVuc3VyZUxlaXN1cmVDbGFzcyA9IF9yZWYxLmVuc3VyZUxlaXN1cmVDbGFzcywgc2V0VHlwZSA9IF9yZWYxLnNldFR5cGUsIHNldERhdGFUeXBlID0gX3JlZjEuc2V0RGF0YVR5cGUsIGZ1bmN0aW9uSW5mbyA9IF9yZWYxLmZ1bmN0aW9uSW5mbywgbmFtZVN1YiA9IF9yZWYxLm5hbWVTdWI7XG5cbiAgXyA9IHJlcXVpcmUoJy4vbG9kYXNoLm1pbicpO1xuXG4gIGFtdCA9IHJlcXVpcmUoJ3BlcnNpc3RlbnQtaGFzaC10cmllJyk7XG5cbiAgcnogPSByZXNvbHZlO1xuXG4gIGx6ID0gbGF6eTtcblxuICBjYWxsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3M7XG5cbiAgICBhcmdzID0gMSA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkgOiBbXTtcbiAgICByZXR1cm4gYmFzaWNDYWxsKGFyZ3MsIGRlZmF1bHRFbnYsIGlkZW50aXR5KTtcbiAgfTtcblxuICBjYWxsTW9uYWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncywgY29udCwgZW52LCBfaTtcblxuICAgIGFyZ3MgPSAzIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBfX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAwLCBfaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAyKSA6IChfaSA9IDAsIFtdKSwgZW52ID0gYXJndW1lbnRzW19pKytdLCBjb250ID0gYXJndW1lbnRzW19pKytdO1xuICAgIHJldHVybiBiYXNpY0NhbGwoYXJncywgZW52LCBjb250KTtcbiAgfTtcblxuICBiYXNpY0NhbGwgPSBmdW5jdGlvbihhcmdzLCBlbnYsIGNvbnQpIHtcbiAgICB2YXIgYXJnLCByZXMsIF9pLCBfbGVuLCBfcmVmMjtcblxuICAgIHJlcyA9IGdsb2JhbFtcIkxfXCIgKyBhcmdzWzBdXSgpO1xuICAgIF9yZWYyID0gYXJncy5zbGljZSgxKTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYyLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBhcmcgPSBfcmVmMltfaV07XG4gICAgICByZXMgPSAoZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiByZXMobHooYXJnKSk7XG4gICAgICB9KShhcmcpO1xuICAgIH1cbiAgICByZXR1cm4gcnVuTW9uYWQocmVzLCBlbnYsIGNvbnQpO1xuICB9O1xuXG4gIGNvbnNGcm9tID0gZnVuY3Rpb24oYXJyYXksIGkpIHtcbiAgICBpID0gaSB8fCAwO1xuICAgIGlmIChpIDwgYXJyYXkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gY29ucyhhcnJheVtpXSwgY29uc0Zyb20oYXJyYXksIGkgKyAxKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBMX25pbCgpO1xuICAgIH1cbiAgfTtcblxuICBpZGVudGl0eSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcblxuICBfaWRlbnRpdHkgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHJ6KHgpO1xuICB9O1xuXG4gIF90cnVlID0gc2V0VHlwZSgoZnVuY3Rpb24oYSkge1xuICAgIHJldHVybiBmdW5jdGlvbihiKSB7XG4gICAgICByZXR1cm4gcnooYSk7XG4gICAgfTtcbiAgfSksICd0cnVlJyk7XG5cbiAgX2ZhbHNlID0gc2V0VHlwZSgoZnVuY3Rpb24oYSkge1xuICAgIHJldHVybiBmdW5jdGlvbihiKSB7XG4gICAgICByZXR1cm4gcnooYik7XG4gICAgfTtcbiAgfSksICdmYWxzZScpO1xuXG4gIGxlZnQgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHNldFR5cGUoKGZ1bmN0aW9uKGxDYXNlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ockNhc2UpIHtcbiAgICAgICAgcmV0dXJuIHJ6KGxDYXNlKShseih4KSk7XG4gICAgICB9O1xuICAgIH0pLCAnbGVmdCcpO1xuICB9O1xuXG4gIHJpZ2h0ID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBzZXRUeXBlKChmdW5jdGlvbihsQ2FzZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHJDYXNlKSB7XG4gICAgICAgIHJldHVybiByeihyQ2FzZSkobHooeCkpO1xuICAgICAgfTtcbiAgICB9KSwgJ3JpZ2h0Jyk7XG4gIH07XG5cbiAgc29tZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gc2V0VHlwZSgoZnVuY3Rpb24oc29tZUNhc2UpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihub25lQ2FzZSkge1xuICAgICAgICByZXR1cm4gcnooc29tZUNhc2UpKGx6KHgpKTtcbiAgICAgIH07XG4gICAgfSksICdzb21lJyk7XG4gIH07XG5cbiAgbm9uZSA9IHNldFR5cGUoKGZ1bmN0aW9uKHNvbWVDYXNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG5vbmVDYXNlKSB7XG4gICAgICByZXR1cm4gcnoobm9uZUNhc2UpO1xuICAgIH07XG4gIH0pLCAnbm9uZScpO1xuXG4gIGJvb2xlYW5Gb3IgPSBmdW5jdGlvbihib29sKSB7XG4gICAgaWYgKGJvb2wpIHtcbiAgICAgIHJldHVybiByeihMX3RydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcnooTF9mYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIGRlZmluZSgnZXEnLCBseihmdW5jdGlvbihhKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGIpIHtcbiAgICAgIHJldHVybiBib29sZWFuRm9yKHJ6KGEpID09PSByeihiKSk7XG4gICAgfTtcbiAgfSkpO1xuXG4gIGRlZmluZSgnPT0nLCBseihmdW5jdGlvbihhKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGIpIHtcbiAgICAgIHJldHVybiBib29sZWFuRm9yKHJ6KGEpID09PSByeihiKSk7XG4gICAgfTtcbiAgfSkpO1xuXG4gIGRlZmluZSgnaGFzVHlwZScsIGx6KGZ1bmN0aW9uKGRhdGEpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZnVuYykge1xuICAgICAgaWYgKHR5cGVvZiByeihmdW5jKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGJvb2xlYW5Gb3IoZ2V0VHlwZShyeihkYXRhKSkgPT09IHJ6KGZ1bmMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBib29sZWFuRm9yKGdldFR5cGUocnooZGF0YSkpID09PSBnZXREYXRhVHlwZShyeihmdW5jKSkpO1xuICAgICAgfVxuICAgIH07XG4gIH0pKTtcblxuICBkZWZpbmUoJ2dldERhdGFUeXBlJywgbHooZnVuY3Rpb24oZnVuYykge1xuICAgIGlmICh0eXBlb2YgcnooZnVuYykgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gcnooZnVuYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZXREYXRhVHlwZShyeihmdW5jKSk7XG4gICAgfVxuICB9KSk7XG5cbiAgZGVmaW5lKCdhc3NlcnQnLCBseihmdW5jdGlvbihib29sKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG1zZykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGV4cHIpIHtcbiAgICAgICAgcmV0dXJuIHJ6KGJvb2wpKGV4cHIpKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyeihtc2cpKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH07XG4gIH0pKTtcblxuICBkZWZpbmUoJ2Fzc2VydExvZycsIGx6KGZ1bmN0aW9uKGJvb2wpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24obXNnKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZXhwcikge1xuICAgICAgICByZXR1cm4gcnooYm9vbCkoZXhwcikoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY29uc29sZS5sb2cobmV3IEVycm9yKHJ6KG1zZykpLnN0YWNrKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkxPR0dFRCBFUlJPUiAtLSBSRVNVTUlORyBFWEVDVVRJT04uLi5cIik7XG4gICAgICAgICAgcmV0dXJuIHJ6KGV4cHIpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfTtcbiAgfSkpO1xuXG4gIGRlZmluZSgnKycsIGx6KGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeSkge1xuICAgICAgcmV0dXJuIHJ6KHgpICsgcnooeSk7XG4gICAgfTtcbiAgfSkpO1xuXG4gIGRlZmluZSgnLScsIGx6KGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeSkge1xuICAgICAgcmV0dXJuIHJ6KHgpIC0gcnooeSk7XG4gICAgfTtcbiAgfSkpO1xuXG4gIGRlZmluZSgnKicsIGx6KGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeSkge1xuICAgICAgcmV0dXJuIHJ6KHgpICogcnooeSk7XG4gICAgfTtcbiAgfSkpO1xuXG4gIGRlZmluZSgnLycsIGx6KGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeSkge1xuICAgICAgcmV0dXJuIHJ6KHgpIC8gcnooeSk7XG4gICAgfTtcbiAgfSkpO1xuXG4gIGRlZmluZSgnJScsIGx6KGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeSkge1xuICAgICAgcmV0dXJuIHJ6KHgpICUgcnooeSk7XG4gICAgfTtcbiAgfSkpO1xuXG4gIGRlZmluZSgnPCcsIGx6KGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeSkge1xuICAgICAgcmV0dXJuIGJvb2xlYW5Gb3IocnooeCkgPCByeih5KSk7XG4gICAgfTtcbiAgfSkpO1xuXG4gIGRlZmluZSgnPD0nLCBseihmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHkpIHtcbiAgICAgIHJldHVybiBib29sZWFuRm9yKHJ6KHgpIDw9IHJ6KHkpKTtcbiAgICB9O1xuICB9KSk7XG5cbiAgZGVmaW5lKCc+JywgbHooZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBmdW5jdGlvbih5KSB7XG4gICAgICByZXR1cm4gYm9vbGVhbkZvcihyeih4KSA+IHJ6KHkpKTtcbiAgICB9O1xuICB9KSk7XG5cbiAgZGVmaW5lKCc+PScsIGx6KGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeSkge1xuICAgICAgcmV0dXJuIGJvb2xlYW5Gb3IocnooeCkgPj0gcnooeSkpO1xuICAgIH07XG4gIH0pKTtcblxuICBkZWZpbmUoJ2Zsb29yJywgbHooZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKHJ6KHgpKTtcbiAgfSkpO1xuXG4gIGRlZmluZSgnY2VpbCcsIGx6KGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHJ6KHgpKTtcbiAgfSkpO1xuXG4gIGRlZmluZSgnbWluJywgbHooZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBmdW5jdGlvbih5KSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4ocnooeCksIHJ6KHkpKTtcbiAgICB9O1xuICB9KSk7XG5cbiAgZGVmaW5lKCdtYXgnLCBseihmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHkpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heChyeih4KSwgcnooeSkpO1xuICAgIH07XG4gIH0pKTtcblxuICBkZWZpbmUoJ3JvdW5kJywgbHooZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHJ6KHgpKTtcbiAgfSkpO1xuXG4gIGRlZmluZSgnYWJzJywgbHooZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBNYXRoLmFicyhyeih4KSk7XG4gIH0pKTtcblxuICBkZWZpbmUoJ3NxcnQnLCBseihmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChyeih4KSk7XG4gIH0pKTtcblxuICBkZWZpbmUoJ2Fjb3MnLCBseihmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIE1hdGguYWNvcyhyeih4KSk7XG4gIH0pKTtcblxuICBkZWZpbmUoJ2FzaW4nLCBseihmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIE1hdGguYXNpbihyeih4KSk7XG4gIH0pKTtcblxuICBkZWZpbmUoJ2F0YW4nLCBseihmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIE1hdGguYXRhbihyeih4KSk7XG4gIH0pKTtcblxuICBkZWZpbmUoJ2F0YW4yJywgbHooZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBmdW5jdGlvbih5KSB7XG4gICAgICByZXR1cm4gTWF0aC5hdGFuMihyeih4KSwgcnooeSkpO1xuICAgIH07XG4gIH0pKTtcblxuICBkZWZpbmUoJ2NvcycsIGx6KGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gTWF0aC5jb3MocnooeCkpO1xuICB9KSk7XG5cbiAgZGVmaW5lKCdsb2cnLCBseihmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIE1hdGgubG9nKHJ6KHgpKTtcbiAgfSkpO1xuXG4gIGRlZmluZSgnc2luJywgbHooZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBNYXRoLnNpbihyeih4KSk7XG4gIH0pKTtcblxuICBkZWZpbmUoJ3RhbicsIGx6KGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gTWF0aC50YW4ocnooeCkpO1xuICB9KSk7XG5cbiAgZGVmaW5lKCdyYW5kJywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG1ha2VTeW5jTW9uYWQoZnVuY3Rpb24oZW52LCBjb250KSB7XG4gICAgICByZXR1cm4gY29udChNYXRoLnJhbmRvbSgpKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVmaW5lKCdyYW5kSW50JywgbHooZnVuY3Rpb24obG93KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGhpZ2gpIHtcbiAgICAgIHJldHVybiBtYWtlU3luY01vbmFkKGZ1bmN0aW9uKGVudiwgY29udCkge1xuICAgICAgICByZXR1cm4gY29udChNYXRoLmZsb29yKHJ6KGxvdykgKyBNYXRoLnJhbmRvbSgpICogcnooaGlnaCkpKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0pKTtcblxuICBkZWZpbmUoJ14nLCBseihmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHkpIHtcbiAgICAgIHJldHVybiBNYXRoLnBvdyhyeih4KSwgcnooeSkpO1xuICAgIH07XG4gIH0pKTtcblxuICBkZWZpbmUoJ19zaG93JywgbHooZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciBfcmVmMjtcblxuICAgIGlmICgoX3JlZjIgPSB0eXBlb2YgcnooZGF0YSkpID09PSAnc3RyaW5nJyB8fCBfcmVmMiA9PT0gJ251bWJlcicgfHwgX3JlZjIgPT09ICdib29sZWFuJykge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJ6KGRhdGEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFN0cmluZyhyeihkYXRhKSk7XG4gICAgfVxuICB9KSk7XG5cbiAgZGVmaW5lKCdzdHJTdHJpbmcnLCBseihmdW5jdGlvbihkYXRhKSB7XG4gICAgcmV0dXJuIFN0cmluZyhyeihkYXRhKSk7XG4gIH0pKTtcblxuICBkZWZpbmUoJ19zdHJBc2MnLCBseihmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gcnooc3RyKS5jaGFyQ29kZUF0KDApO1xuICB9KSk7XG5cbiAgZGVmaW5lKCdfc3RyQ2hyJywgbHooZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHJ6KGkpKTtcbiAgfSkpO1xuXG4gIGRlZmluZSgnX3N0ckF0JywgbHooZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICByZXR1cm4gcnooc3RyKVtzdHJDb29yZChyeihzdHIpLCByeihpbmRleCkpXTtcbiAgICB9O1xuICB9KSk7XG5cbiAgZGVmaW5lKCdfc3RyU3RhcnRzV2l0aCcsIGx6KGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICAgIHJldHVybiBib29sZWFuRm9yKHJ6KHN0cikuc3Vic3RyaW5nKDAsIHJ6KHByZWZpeCkubGVuZ3RoKSA9PT0gcnoocHJlZml4KSk7XG4gICAgfTtcbiAgfSkpO1xuXG4gIGRlZmluZSgnX3N0ckxlbicsIGx6KGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiByeihzdHIpLmxlbmd0aDtcbiAgfSkpO1xuXG4gIGRlZmluZSgnX3N0clRvTG93ZXJDYXNlJywgbHooZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIHJ6KHN0cikudG9Mb3dlckNhc2UoKTtcbiAgfSkpO1xuXG4gIGRlZmluZSgnX3N0clRvVXBwZXJDYXNlJywgbHooZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIHJ6KHN0cikudG9VcHBlckNhc2UoKTtcbiAgfSkpO1xuXG4gIGRlZmluZSgnX3N0clJlcGxhY2UnLCBseihmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ocGF0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocmVwbCkge1xuICAgICAgICByZXR1cm4gcnooc3RyKS5yZXBsYWNlKHJ6KHBhdCksIHJ6KHJlcGwpKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfSkpO1xuXG4gIHN0ckNvb3JkID0gZnVuY3Rpb24oc3RyLCBjb29yZCkge1xuICAgIGlmIChjb29yZCA8IDApIHtcbiAgICAgIHJldHVybiBzdHIubGVuZ3RoICsgY29vcmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjb29yZDtcbiAgICB9XG4gIH07XG5cbiAgZGVmaW5lKCdfc3RyU3Vic3RyaW5nJywgbHooZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXJ0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZW5kKSB7XG4gICAgICAgIHZhciBhLCBiO1xuXG4gICAgICAgIGEgPSBzdHJDb29yZChyeihzdHIpLCByeihzdGFydCkpO1xuICAgICAgICBiID0gc3RyQ29vcmQocnooc3RyKSwgcnooZW5kKSk7XG4gICAgICAgIGlmIChiIDwgYSAmJiByeihlbmQpID09PSAwKSB7XG4gICAgICAgICAgYiA9IHJ6KHN0cikubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByeihzdHIpLnN1YnN0cmluZyhhLCBiKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfSkpO1xuXG4gIGRlZmluZSgnX3N0clNwbGl0JywgbHooZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHBhdCkge1xuICAgICAgcmV0dXJuIGNvbnNGcm9tKHJ6KHN0cikuc3BsaXQocnoocGF0KSBpbnN0YW5jZW9mIFJlZ0V4cCA/IHJ6KHBhdCkgOiBuZXcgUmVnRXhwKHJ6KHBhdCkpKSk7XG4gICAgfTtcbiAgfSkpO1xuXG4gIGRlZmluZSgnX3N0ckNhdCcsIGx6KGZ1bmN0aW9uKGxpc3QpIHtcbiAgICByZXR1cm4gXy5tYXAocnoobGlzdCkudG9BcnJheSgpLCBmdW5jdGlvbihlbCkge1xuICAgICAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJ6KExfc2hvdykobHooZWwpKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKCcnKTtcbiAgfSkpO1xuXG4gIGRlZmluZSgnX3N0ckFkZCcsIGx6KGZ1bmN0aW9uKHMxKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHMyKSB7XG4gICAgICByZXR1cm4gcnooczEpICsgcnooczIpO1xuICAgIH07XG4gIH0pKTtcblxuICBkZWZpbmUoJ19zdHJNYXRjaCcsIGx6KGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBmdW5jdGlvbihwYXQpIHtcbiAgICAgIHZhciBncm91cHMsIG0sIHBvcztcblxuICAgICAgbSA9IHJ6KHN0cikubWF0Y2goKHJ6KHBhdCkgaW5zdGFuY2VvZiBSZWdFeHAgPyByeihwYXQpIDogbmV3IFJlZ0V4cChyeihwYXQpKSkpO1xuICAgICAgaWYgKG0pIHtcbiAgICAgICAgZ3JvdXBzID0gW107XG4gICAgICAgIHBvcyA9IDE7XG4gICAgICAgIHdoaWxlIChtW3Bvc10pIHtcbiAgICAgICAgICBncm91cHMucHVzaChtW3BvcysrXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBtLmluZGV4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJldHVybiBjb25zRnJvbShbbVswXSwgY29uc0Zyb20oZ3JvdXBzKSwgbS5pbmRleCwgbS5pbnB1dF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBjb25zRnJvbShbbVswXSwgY29uc0Zyb20oZ3JvdXBzKV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTmlsO1xuICAgICAgfVxuICAgIH07XG4gIH0pKTtcblxuICBkZWZpbmUoJ19zdHJUb0xpc3QnLCBseihmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gc3RyVG9MaXN0KHJ6KHN0cikpO1xuICB9KSk7XG5cbiAgc3RyVG9MaXN0ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKHN0ciA9PT0gJycpIHtcbiAgICAgIHJldHVybiBOaWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjb25zKHN0clswXSwgc3RyVG9MaXN0KHN0ci5zdWJzdHJpbmcoMSkpKTtcbiAgICB9XG4gIH07XG5cbiAgZGVmaW5lKCdfc3RyRnJvbUxpc3QnLCBseihmdW5jdGlvbihsaXN0KSB7XG4gICAgcmV0dXJuIHN0ckZyb21MaXN0KHJ6KGxpc3QpKTtcbiAgfSkpO1xuXG4gIHN0ckZyb21MaXN0ID0gZnVuY3Rpb24obGlzdCkge1xuICAgIGlmIChsaXN0IGluc3RhbmNlb2YgTGVpc3VyZV9uaWwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGhlYWQobGlzdCkgKyBzdHJGcm9tTGlzdCh0YWlsKGxpc3QpKTtcbiAgICB9XG4gIH07XG5cbiAgZGVmaW5lKCdfcmVnZXhwJywgbHooZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAocnooc3RyKSk7XG4gIH0pKTtcblxuICBkZWZpbmUoJ19yZWdleHBGbGFncycsIGx6KGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBmdW5jdGlvbihmbGFncykge1xuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocnooc3RyKSwgcnooZmxhZ3MpKTtcbiAgICB9O1xuICB9KSk7XG5cbiAgZGVmaW5lKCdfanNvblBhcnNlJywgbHooZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGZhaWxDb250KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3VjY2Vzc0NvbnQpIHtcbiAgICAgICAgdmFyIGVyciwgcDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHAgPSBKU09OLnBhcnNlKHJ6KHN0cikpO1xuICAgICAgICAgIHJldHVybiByeihzdWNjZXNzQ29udCkobHoocCkpO1xuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICBlcnIgPSBfZXJyb3I7XG4gICAgICAgICAgcmV0dXJuIHJ6KGZhaWxDb250KShseihlcnIpKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICB9KSk7XG5cbiAgZGVmaW5lKCdqc29uU3RyaW5naWZ5JywgbHooZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGZhaWxDb250KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3VjY2Vzc0NvbnQpIHtcbiAgICAgICAgdmFyIGVyciwgcztcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHMgPSBKU09OLnN0cmluZ2lmeShyeihvYmopKTtcbiAgICAgICAgICByZXR1cm4gcnooc3VjY2Vzc0NvbnQpKGx6KHMpKTtcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgZXJyID0gX2Vycm9yO1xuICAgICAgICAgIHJldHVybiByeihmYWlsQ29udCkobHooZXJyKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgfSkpO1xuXG4gIGRlZmluZSgnZ2V0UHJvcGVydGllcycsIGx6KGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICB2YXIgX3JlZjI7XG5cbiAgICBpZiAoKF9yZWYyID0gcnooZnVuYykpICE9IG51bGwgPyBfcmVmMi5wcm9wZXJ0aWVzIDogdm9pZCAwKSB7XG4gICAgICByZXR1cm4gcnooTF9zb21lKShseihyeihmdW5jKS5wcm9wZXJ0aWVzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByeihMX25vbmUpO1xuICAgIH1cbiAgfSkpO1xuXG4gIGRlZmluZSgnbG9nJywgbHooZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHJlcykge1xuICAgICAgY29uc29sZS5sb2coU3RyaW5nKHJ6KHN0cikpKTtcbiAgICAgIHJldHVybiByeihyZXMpO1xuICAgIH07XG4gIH0pKTtcblxuICBtYWtlTW9uYWQgPSBmdW5jdGlvbihndXRzKSB7XG4gICAgdmFyIG07XG5cbiAgICBtID0gZnVuY3Rpb24oKSB7fTtcbiAgICBtLl9fcHJvdG9fXyA9IE1vbmFkLnByb3RvdHlwZTtcbiAgICBtLmNtZCA9IGd1dHM7XG4gICAgbS50eXBlID0gJ21vbmFkJztcbiAgICByZXR1cm4gbTtcbiAgfTtcblxuICBtYWtlU3luY01vbmFkID0gZnVuY3Rpb24oZ3V0cykge1xuICAgIHZhciBtO1xuXG4gICAgbSA9IG1ha2VNb25hZChndXRzKTtcbiAgICBtLnN5bmMgPSB0cnVlO1xuICAgIHJldHVybiBtO1xuICB9O1xuXG4gIG5leHRNb25hZCA9IGZ1bmN0aW9uKGNvbnQpIHtcbiAgICByZXR1cm4gY29udDtcbiAgfTtcblxuICByZXBsYWNlRXJyID0gZnVuY3Rpb24oZXJyLCBtc2cpIHtcbiAgICBlcnIubWVzc2FnZSA9IG1zZztcbiAgICByZXR1cm4gZXJyO1xuICB9O1xuXG4gIGRlZmF1bHRFbnYud3JpdGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5zdGRvdXQud3JpdGUoc3RyKTtcbiAgfTtcblxuICBkZWZhdWx0RW52LmVyciA9IGZ1bmN0aW9uKGVycikge1xuICAgIHZhciBfcmVmMjtcblxuICAgIHJldHVybiB0aGlzLndyaXRlKFwiRU5WIEVycm9yOiBcIiArICgoX3JlZjIgPSBlcnIuc3RhY2spICE9IG51bGwgPyBfcmVmMiA6IGVycikpO1xuICB9O1xuXG4gIGRlZmF1bHRFbnYucHJvbXB0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBwcm9tcHRpbmchXCIpO1xuICB9O1xuXG4gIG1vbmFkTW9kZVN5bmMgPSBmYWxzZTtcblxuICBnZXRNb25hZFN5bmNNb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG1vbmFkTW9kZVN5bmM7XG4gIH07XG5cbiAgd2l0aFN5bmNNb2RlRG8gPSBmdW5jdGlvbihuZXdNb2RlLCBibG9jaykge1xuICAgIHZhciBlcnIsIG9sZE1vZGUsIF9yZWYyO1xuXG4gICAgb2xkTW9kZSA9IG1vbmFkTW9kZVN5bmM7XG4gICAgbW9uYWRNb2RlU3luYyA9IG5ld01vZGU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBibG9jaygpO1xuICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgZXJyID0gX2Vycm9yO1xuICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKFwiRVJSOiBcIiArICgoX3JlZjIgPSBlcnIuc3RhY2spICE9IG51bGwgPyBfcmVmMiA6IGVycikpO1xuICAgIH0gZmluYWxseSB7XG5cbiAgICB9XG4gIH07XG5cbiAgcnVuTW9uYWQgPSBmdW5jdGlvbihtb25hZCwgZW52LCBjb250KSB7XG4gICAgZW52ID0gZW52ICE9IG51bGwgPyBlbnYgOiByb290LmRlZmF1bHRFbnY7XG4gICAgcmV0dXJuIHdpdGhTeW5jTW9kZURvKHRydWUsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ld1J1bk1vbmFkKG1vbmFkLCBlbnYsIGNvbnQsIFtdKTtcbiAgICB9KTtcbiAgfTtcblxuICBpc01vbmFkID0gZnVuY3Rpb24obSkge1xuICAgIHJldHVybiB0eXBlb2YgbSA9PT0gJ2Z1bmN0aW9uJyAmJiAobS5jbWQgIT0gbnVsbCk7XG4gIH07XG5cbiAgY29udGludWVNb25hZHMgPSBmdW5jdGlvbihjb250U3RhY2ssIGVudikge1xuICAgIHJldHVybiBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIHJldHVybiB3aXRoU3luY01vZGVEbyhmYWxzZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXdSdW5Nb25hZChyZXN1bHQsIGVudiwgbnVsbCwgY29udFN0YWNrKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG5cbiAgYXN5bmNNb25hZCA9IHtcbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXCI8YXN5bmNNb25hZFJlc3VsdD5cIjtcbiAgICB9XG4gIH07XG5cbiAgd2FybkFzeW5jID0gZmFsc2U7XG5cbiAgc2V0V2FybkFzeW5jID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICByZXR1cm4gd2FybkFzeW5jID0gc3RhdGU7XG4gIH07XG5cbiAgbmV3UnVuTW9uYWQgPSBmdW5jdGlvbihtb25hZCwgZW52LCBjb250LCBjb250U3RhY2spIHtcbiAgICB2YXIgZXJyLCByZXN1bHQsIF9yZWYyO1xuXG4gICAgaWYgKGNvbnQpIHtcbiAgICAgIGNvbnRTdGFjay5wdXNoKGNvbnQpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKGlzTW9uYWQobW9uYWQpKSB7XG4gICAgICAgICAgaWYgKG1vbmFkLmJpbmRpbmcpIHtcbiAgICAgICAgICAgIGNvbnRTdGFjay5wdXNoKChmdW5jdGlvbihibmQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYm5kKGx6KHgpKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKHJ6KG1vbmFkLmJpbmRpbmcpKSk7XG4gICAgICAgICAgICBtb25hZCA9IHJ6KG1vbmFkLm1vbmFkKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIW1vbmFkLnN5bmMpIHtcbiAgICAgICAgICAgIG1vbmFkTW9kZVN5bmMgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh3YXJuQXN5bmMpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJhc3luYyBtb25hZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vbmFkLmNtZChlbnYsIGNvbnRpbnVlTW9uYWRzKGNvbnRTdGFjaywgZW52KSk7XG4gICAgICAgICAgICByZXR1cm4gYXN5bmNNb25hZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gbW9uYWQuY21kKGVudiwgaWRlbnRpdHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vbmFkTW9kZVN5bmMgPSB0cnVlO1xuICAgICAgICAgIHJlc3VsdCA9IG1vbmFkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29udFN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgbW9uYWQgPSBjb250U3RhY2sucG9wKCkocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgIGVyciA9IF9lcnJvcjtcbiAgICAgIGVyciA9IHJlcGxhY2VFcnIoZXJyLCBcIlxcbkVSUk9SIFJVTk5JTkcgTU9OQUQsIE1PTkFEOiBcIiArIG1vbmFkICsgXCIsIEVOVjogXCIgKyBlbnYgKyBcIi4uLlxcblwiICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgY29uc29sZS5sb2coKF9yZWYyID0gZXJyLnN0YWNrKSAhPSBudWxsID8gX3JlZjIgOiBlcnIpO1xuICAgICAgaWYgKGVudi5lcnJvckhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZW52LmVycm9ySGFuZGxlcnMucG9wKCkoZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgTW9uYWQgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gTW9uYWQoKSB7fVxuXG4gICAgTW9uYWQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXCJNb25hZDogXCIgKyAodGhpcy5jbWQudG9TdHJpbmcoKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBNb25hZDtcblxuICB9KSgpO1xuXG4gIGdsb2JhbC5MX3J1bk1vbmFkcyA9IGZ1bmN0aW9uKG1vbmFkQXJyYXkpIHtcbiAgICBtb25hZEFycmF5LnJldmVyc2UoKTtcbiAgICByZXR1cm4gbmV3UnVuTW9uYWQoMCwgZGVmYXVsdEVudiwgbnVsbCwgbW9uYWRBcnJheSk7XG4gIH07XG5cbiAgZGVmaW5lKCdkZWZpbmUnLCBseihmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFyaXR5KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3JjKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihkZWYpIHtcbiAgICAgICAgICByZXR1cm4gbWFrZVN5bmNNb25hZChmdW5jdGlvbihlbnYsIGNvbnQpIHtcbiAgICAgICAgICAgIGRlZmluZShyeihuYW1lKSwgZGVmLCByeihhcml0eSksIHJ6KHNyYykpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnQoKHR5cGVvZiBMX3RydWUgIT09IFwidW5kZWZpbmVkXCIgJiYgTF90cnVlICE9PSBudWxsID8gcnooTF90cnVlKSA6IF90cnVlKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH07XG4gIH0pKTtcblxuICBkZWZpbmUoJ2JpbmQnLCBseihmdW5jdGlvbihtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGJpbmRpbmcpIHtcbiAgICAgIHZhciBiaW5kTW9uYWQ7XG5cbiAgICAgIGJpbmRNb25hZCA9IG1ha2VNb25hZChmdW5jdGlvbihlbnYsIGNvbnQpIHt9KTtcbiAgICAgIGJpbmRNb25hZC5tb25hZCA9IG07XG4gICAgICBiaW5kTW9uYWQuYmluZGluZyA9IGJpbmRpbmc7XG4gICAgICByZXR1cm4gYmluZE1vbmFkO1xuICAgIH07XG4gIH0pKTtcblxuICB2YWx1ZXMgPSB7fTtcblxuICBkZWZpbmUoJ3Byb3RlY3QnLCBseihmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBtYWtlTW9uYWQoZnVuY3Rpb24oZW52LCBjb250KSB7XG4gICAgICB2YXIgaG5kO1xuXG4gICAgICBobmQgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgdmFyIF9yZWYyLCBfcmVmMztcblxuICAgICAgICBjb25zb2xlLmxvZyhcIlBST1RFQ1RFRCBFUlJPUjogXCIgKyAoKF9yZWYyID0gZXJyLnN0YWNrKSAhPSBudWxsID8gX3JlZjIgOiBlcnIpKTtcbiAgICAgICAgcmV0dXJuIGNvbnQobGVmdCgoX3JlZjMgPSBlcnIuc3RhY2spICE9IG51bGwgPyBfcmVmMyA6IGVycikpO1xuICAgICAgfTtcbiAgICAgIGVudi5lcnJvckhhbmRsZXJzLnB1c2goaG5kKTtcbiAgICAgIHJldHVybiBydW5Nb25hZChyeih2YWx1ZSksIGVudiwgKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICBpZiAoZW52LmVycm9ySGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGVudi5lcnJvckhhbmRsZXJzW2Vudi5lcnJvckhhbmRsZXJzLmxlbmd0aCAtIDFdID09PSBobmQpIHtcbiAgICAgICAgICAgIGVudi5lcnJvckhhbmRsZXJzLnBvcCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoXy5jb250YWlucyhlbnYuZXJyb3JIYW5kbGVycywgaG5kKSkge1xuICAgICAgICAgICAgd2hpbGUgKGVudi5lcnJvckhhbmRsZXJzW2Vudi5lcnJvckhhbmRsZXJzLmxlbmd0aCAtIDFdICE9PSBobmQpIHtcbiAgICAgICAgICAgICAgZW52LmVycm9ySGFuZGxlcnMucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250KHJpZ2h0KHJlc3VsdCkpO1xuICAgICAgfSksIFtdKTtcbiAgICB9KTtcbiAgfSkpO1xuXG4gIGFjdG9ycyA9IHt9O1xuXG4gIGRlZmluZSgnYWN0b3InLCBseihmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgIGFjdG9yc1tuYW1lXSA9IGZ1bmM7XG4gICAgICBmdW5jLmVudiA9IHtcbiAgICAgICAgdmFsdWVzOiB7fVxuICAgICAgfTtcbiAgICAgIHJldHVybiBmdW5jLmVudi5fX3Byb3RvX18gPSBkZWZhdWx0RW52O1xuICAgIH07XG4gIH0pKTtcblxuICBkZWZpbmUoJ3NlbmQnLCBseihmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG1zZykge1xuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcnVuTW9uYWQocnooYWN0b3JzW25hbWVdKShtc2cpLCByeihhY3RvcnNbbmFtZV0pLmVudik7XG4gICAgICB9KSwgMSk7XG4gICAgfTtcbiAgfSkpO1xuXG4gIGRlZmluZSgnaGFzVmFsdWUnLCBseihmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIG1ha2VTeW5jTW9uYWQoZnVuY3Rpb24oZW52LCBjb250KSB7XG4gICAgICByZXR1cm4gY29udChib29sZWFuRm9yKHZhbHVlc1tyeihuYW1lKV0gIT0gbnVsbCkpO1xuICAgIH0pO1xuICB9KSk7XG5cbiAgZGVmaW5lKCdnZXRWYWx1ZU9yJywgbHooZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHJldHVybiBtYWtlU3luY01vbmFkKGZ1bmN0aW9uKGVudiwgY29udCkge1xuICAgICAgICB2YXIgX3JlZjI7XG5cbiAgICAgICAgcmV0dXJuIGNvbnQoKF9yZWYyID0gdmFsdWVzW3J6KG5hbWUpXSkgIT0gbnVsbCA/IF9yZWYyIDogcnooZGVmYXVsdFZhbHVlKSk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9KSk7XG5cbiAgZGVmaW5lKCdnZXRWYWx1ZScsIGx6KGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gbWFrZVN5bmNNb25hZChmdW5jdGlvbihlbnYsIGNvbnQpIHtcbiAgICAgIGlmICghKHJ6KG5hbWUpIGluIHZhbHVlcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdmFsdWUgbmFtZWQgJ1wiICsgKHJ6KG5hbWUpKSArIFwiJ1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250KHZhbHVlc1tyeihuYW1lKV0pO1xuICAgIH0pO1xuICB9KSk7XG5cbiAgZGVmaW5lKCdzZXRWYWx1ZScsIGx6KGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBtYWtlU3luY01vbmFkKGZ1bmN0aW9uKGVudiwgY29udCkge1xuICAgICAgICB2YWx1ZXNbcnoobmFtZSldID0gcnoodmFsdWUpO1xuICAgICAgICByZXR1cm4gY29udChfdHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9KSk7XG5cbiAgZGVmaW5lKCdkZWxldGVWYWx1ZScsIGx6KGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gbWFrZVN5bmNNb25hZChmdW5jdGlvbihlbnYsIGNvbnQpIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZXNbcnoobmFtZSldO1xuICAgICAgcmV0dXJuIGNvbnQoX3RydWUpO1xuICAgIH0pO1xuICB9KSk7XG5cbiAgc2V0VmFsdWUgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlc1trZXldID0gdmFsdWU7XG4gIH07XG5cbiAgZ2V0VmFsdWUgPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gdmFsdWVzW2tleV07XG4gIH07XG5cbiAgZGVmaW5lKCdlbnZIYXMnLCBseihmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIG1ha2VTeW5jTW9uYWQoZnVuY3Rpb24oZW52LCBjb250KSB7XG4gICAgICByZXR1cm4gY29udChib29sZWFuRm9yKGVudi52YWx1ZXNbcnoobmFtZSldICE9IG51bGwpKTtcbiAgICB9KTtcbiAgfSkpO1xuXG4gIGRlZmluZSgnZW52R2V0T3InLCBseihmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGRlZmF1bHRWYWx1ZSkge1xuICAgICAgcmV0dXJuIG1ha2VTeW5jTW9uYWQoZnVuY3Rpb24oZW52LCBjb250KSB7XG4gICAgICAgIHZhciBfcmVmMjtcblxuICAgICAgICByZXR1cm4gY29udCgoX3JlZjIgPSBlbnYudmFsdWVzW3J6KG5hbWUpXSkgIT0gbnVsbCA/IF9yZWYyIDogcnooZGVmYXVsdFZhbHVlKSk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9KSk7XG5cbiAgZGVmaW5lKCdlbnZHZXQnLCBseihmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIG1ha2VTeW5jTW9uYWQoZnVuY3Rpb24oZW52LCBjb250KSB7XG4gICAgICBpZiAoIShyeihuYW1lKSBpbiBlbnYudmFsdWVzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB2YWx1ZSBuYW1lZCAnXCIgKyAocnoobmFtZSkpICsgXCInXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnQoZW52LnZhbHVlc1tyeihuYW1lKV0pO1xuICAgIH0pO1xuICB9KSk7XG5cbiAgZGVmaW5lKCdlbnZTZXQnLCBseihmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gbWFrZVN5bmNNb25hZChmdW5jdGlvbihlbnYsIGNvbnQpIHtcbiAgICAgICAgZW52LnZhbHVlc1tyeihuYW1lKV0gPSByeih2YWx1ZSk7XG4gICAgICAgIHJldHVybiBjb250KF90cnVlKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0pKTtcblxuICBkZWZpbmUoJ2VudkRlbGV0ZScsIGx6KGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gbWFrZVN5bmNNb25hZChmdW5jdGlvbihlbnYsIGNvbnQpIHtcbiAgICAgIGRlbGV0ZSBlbnYudmFsdWVzW3J6KG5hbWUpXTtcbiAgICAgIHJldHVybiBjb250KF90cnVlKTtcbiAgICB9KTtcbiAgfSkpO1xuXG4gIHNldFZhbHVlKCdtYWNyb3MnLCBOaWwpO1xuXG4gIGRlZmluZSgnZGVmTWFjcm8nLCBseihmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGRlZikge1xuICAgICAgcmV0dXJuIG1ha2VTeW5jTW9uYWQoZnVuY3Rpb24oZW52LCBjb250KSB7XG4gICAgICAgIHZhbHVlcy5tYWNyb3MgPSBjb25zKGNvbnMocnoobmFtZSksIHJ6KGRlZikpLCB2YWx1ZXMubWFjcm9zKTtcbiAgICAgICAgcmV0dXJuIGNvbnQoX3RydWUpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSkpO1xuXG4gIGRlZmluZSgnZnVuY3MnLCBseihtYWtlU3luY01vbmFkKGZ1bmN0aW9uKGVudiwgY29udCkge1xuICAgIGNvbnNvbGUubG9nKFwiTGVpc3VyZSBmdW5jdGlvbnM6XFxuXCIgKyAoXyhnbG9iYWwubGVpc3VyZUZ1bmNOYW1lcy50b0FycmF5KCkpLnNvcnQoKS5qb2luKCdcXG4nKSkpO1xuICAgIHJldHVybiBjb250KF90cnVlKTtcbiAgfSkpKTtcblxuICBkZWZpbmUoJ2Z1bmNTcmMnLCBseihmdW5jdGlvbihmdW5jKSB7XG4gICAgaWYgKHR5cGVvZiByeihmdW5jKSA9PT0gJ2Z1bmN0aW9uJyAmJiByeihmdW5jKS5zcmMpIHtcbiAgICAgIHJldHVybiBzb21lKHJ6KGZ1bmMpLnNyYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub25lO1xuICAgIH1cbiAgfSkpO1xuXG4gIGRlZmluZSgnYXN0Mkpzb24nLCBseihmdW5jdGlvbihhc3QpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXN0Mkpzb24ocnooYXN0KSkpO1xuICB9KSk7XG5cbiAgZGVmaW5lKCdvdmVycmlkZScsIGx6KGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24obmV3RnVuYykge1xuICAgICAgcmV0dXJuIG1ha2VTeW5jTW9uYWQoZnVuY3Rpb24oZW52LCBjb250KSB7XG4gICAgICAgIHZhciBuLCBvbGREZWY7XG5cbiAgICAgICAgbiA9IFwiTF9cIiArIChuYW1lU3ViKHJ6KG5hbWUpKSk7XG4gICAgICAgIG9sZERlZiA9IGdsb2JhbFtuXTtcbiAgICAgICAgaWYgKCFvbGREZWYpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBkZWZpbml0aW9uIGZvciBcIiArIChyeihuYW1lKSkpO1xuICAgICAgICB9XG4gICAgICAgIGdsb2JhbFtuXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiByeihuZXdGdW5jKShvbGREZWYpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY29udChfdHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9KSk7XG5cbiAgZGVmaW5lKCdwcmludCcsIGx6KGZ1bmN0aW9uKG1zZykge1xuICAgIHJldHVybiBtYWtlU3luY01vbmFkKGZ1bmN0aW9uKGVudiwgY29udCkge1xuICAgICAgdmFyIG07XG5cbiAgICAgIG0gPSByeihtc2cpO1xuICAgICAgZW52LndyaXRlKFwiXCIgKyAoZW52LnByZXNlbnRWYWx1ZShtKSkgKyBcIlxcblwiKTtcbiAgICAgIHJldHVybiBjb250KF90cnVlKTtcbiAgICB9KTtcbiAgfSkpO1xuXG4gIGRlZmluZSgnd3JpdGUnLCBseihmdW5jdGlvbihtc2cpIHtcbiAgICByZXR1cm4gbWFrZVN5bmNNb25hZChmdW5jdGlvbihlbnYsIGNvbnQpIHtcbiAgICAgIGVudi53cml0ZShlbnYucHJlc2VudFZhbHVlKHJ6KG1zZykpKTtcbiAgICAgIHJldHVybiBjb250KF90cnVlKTtcbiAgICB9KTtcbiAgfSkpO1xuXG4gIGRlZmluZSgncmVhZEZpbGUnLCBseihmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIG1ha2VNb25hZChmdW5jdGlvbihlbnYsIGNvbnQpIHtcbiAgICAgIHJldHVybiByZWFkRmlsZShyeihuYW1lKSwgZnVuY3Rpb24oZXJyLCBjb250ZW50cykge1xuICAgICAgICB2YXIgX3JlZjI7XG5cbiAgICAgICAgcmV0dXJuIGNvbnQoKGVyciA/IGxlZnQoKF9yZWYyID0gZXJyLnN0YWNrKSAhPSBudWxsID8gX3JlZjIgOiBlcnIpIDogcmlnaHQoY29udGVudHMpKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSkpO1xuXG4gIGRlZmluZSgncmVhZERpcicsIGx6KGZ1bmN0aW9uKGRpcikge1xuICAgIHJldHVybiBtYWtlTW9uYWQoZnVuY3Rpb24oZW52LCBjb250KSB7XG4gICAgICByZXR1cm4gcmVhZERpcihyeihkaXIpLCBmdW5jdGlvbihlcnIsIGZpbGVzKSB7XG4gICAgICAgIHZhciBfcmVmMjtcblxuICAgICAgICByZXR1cm4gY29udCgoZXJyID8gbGVmdCgoX3JlZjIgPSBlcnIuc3RhY2spICE9IG51bGwgPyBfcmVmMiA6IGVycikgOiByaWdodChmaWxlcykpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KSk7XG5cbiAgZGVmaW5lKCd3cml0ZUZpbGUnLCBseihmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiBtYWtlTW9uYWQoZnVuY3Rpb24oZW52LCBjb250KSB7XG4gICAgICAgIHJldHVybiB3cml0ZUZpbGUocnoobmFtZSksIHJ6KGRhdGEpLCBmdW5jdGlvbihlcnIsIGNvbnRlbnRzKSB7XG4gICAgICAgICAgdmFyIF9yZWYyO1xuXG4gICAgICAgICAgcmV0dXJuIGNvbnQoKGVyciA/IGxlZnQoKF9yZWYyID0gZXJyLnN0YWNrKSAhPSBudWxsID8gX3JlZjIgOiBlcnIpIDogcmlnaHQoY29udGVudHMpKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSkpO1xuXG4gIGRlZmluZSgnc3RhdEZpbGUnLCBseihmdW5jdGlvbihmaWxlKSB7XG4gICAgcmV0dXJuIG1ha2VNb25hZChmdW5jdGlvbihlbnYsIGNvbnQpIHtcbiAgICAgIHJldHVybiBzdGF0RmlsZShyeihmaWxlKSwgZnVuY3Rpb24oZXJyLCBzdGF0cykge1xuICAgICAgICB2YXIgX3JlZjI7XG5cbiAgICAgICAgcmV0dXJuIGNvbnQoKGVyciA/IGxlZnQoKF9yZWYyID0gZXJyLnN0YWNrKSAhPSBudWxsID8gX3JlZjIgOiBlcnIpIDogcmlnaHQoc3RhdHMpKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSkpO1xuXG4gIGRlZmluZSgncHJvbXB0JywgbHooZnVuY3Rpb24obXNnKSB7XG4gICAgcmV0dXJuIG1ha2VNb25hZChmdW5jdGlvbihlbnYsIGNvbnQpIHtcbiAgICAgIHJldHVybiBlbnYucHJvbXB0KFN0cmluZyhyeihtc2cpKSwgZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnQoaW5wdXQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pKTtcblxuICBkZWZpbmUoJ3JhbmQnLCBseihtYWtlU3luY01vbmFkKGZ1bmN0aW9uKGVudiwgY29udCkge1xuICAgIHJldHVybiBjb250KE1hdGgucmFuZG9tKCkpO1xuICB9KSkpO1xuXG4gIGRlZmluZSgnanMnLCBseihmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbWFrZVN5bmNNb25hZChmdW5jdGlvbihlbnYsIGNvbnQpIHtcbiAgICAgIHZhciBlcnIsIHJlc3VsdDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gZXZhbChyeihzdHIpKTtcbiAgICAgICAgcmV0dXJuIGNvbnQocmlnaHQocmVzdWx0KSk7XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZXJyID0gX2Vycm9yO1xuICAgICAgICByZXR1cm4gY29udChsZWZ0KGVycikpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KSk7XG5cbiAgZGVmaW5lKCdkZWxheScsIGx6KGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgICByZXR1cm4gbWFrZU1vbmFkKGZ1bmN0aW9uKGVudiwgY29udCkge1xuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY29udChfdHJ1ZSk7XG4gICAgICB9KSwgcnoodGltZW91dCkpO1xuICAgIH0pO1xuICB9KSk7XG5cbiAgZGVmaW5lKCdhbHREZWYnLCBseihmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFsdCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGFyaXR5KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihkZWYpIHtcbiAgICAgICAgICByZXR1cm4gbWFrZU1vbmFkKGZ1bmN0aW9uKGVudiwgY29udCkge1xuICAgICAgICAgICAgdmFyIGFsdHMsIGksIGluZm8sIG5ld0RlZiwgbm07XG5cbiAgICAgICAgICAgIGluZm8gPSBmdW5jdGlvbkluZm9bcnoobmFtZSldO1xuICAgICAgICAgICAgaWYgKCFpbmZvKSB7XG4gICAgICAgICAgICAgIGluZm8gPSBmdW5jdGlvbkluZm9bcnoobmFtZSldID0ge1xuICAgICAgICAgICAgICAgIHNyYzogJycsXG4gICAgICAgICAgICAgICAgYXJpdHk6IC0xLFxuICAgICAgICAgICAgICAgIGFsdHM6IHt9LFxuICAgICAgICAgICAgICAgIGFsdExpc3Q6IFtdXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWluZm8uYWx0c1tyeihhbHQpXSkge1xuICAgICAgICAgICAgICBpbmZvLmFsdExpc3QucHVzaChyeihhbHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZm8uYWx0c1tyeihhbHQpXSA9IHJ6KGRlZik7XG4gICAgICAgICAgICBhbHRzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgX2ksIF9sZW4sIF9yZWYyLCBfcmVzdWx0cztcblxuICAgICAgICAgICAgICBfcmVmMiA9IGluZm8uYWx0TGlzdDtcbiAgICAgICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgICAgIGkgPSBfcmVmMltfaV07XG4gICAgICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChpbmZvLmFsdHNbaV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBuZXdEZWYgPSBjdXJyeShyeihhcml0eSksIGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICAgICAgdmFyIGFyZywgb3B0LCByZXMsIF9pLCBfaiwgX2ssIF9sZW4sIF9sZW4xLCBfbGVuMjtcblxuICAgICAgICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGFsdHMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhbHQgPSBhbHRzW19pXTtcbiAgICAgICAgICAgICAgICBvcHQgPSBhbHQ7XG4gICAgICAgICAgICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gYXJncy5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3NbX2pdO1xuICAgICAgICAgICAgICAgICAgb3B0ID0gb3B0KGFyZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChnZXRUeXBlKG9wdCkgPT09ICdzb21lJykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdChseihmdW5jdGlvbih4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByeih4KTtcbiAgICAgICAgICAgICAgICAgIH0pKShseihfZmFsc2UpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGluZm8ubWFpbkRlZikge1xuICAgICAgICAgICAgICAgIHJlcyA9IHJ6KGluZm8ubWFpbkRlZik7XG4gICAgICAgICAgICAgICAgZm9yIChfayA9IDAsIF9sZW4yID0gYXJncy5sZW5ndGg7IF9rIDwgX2xlbjI7IF9rKyspIHtcbiAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3NbX2tdO1xuICAgICAgICAgICAgICAgICAgcmVzID0gcmVzKGFyZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZGVmYXVsdCBkZWZpbml0aW9uIGZvciBcIiArIChyeihuYW1lKSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBubSA9IFwiTF9cIiArIChuYW1lU3ViKHJ6KG5hbWUpKSk7XG4gICAgICAgICAgICBnbG9iYWxbbm1dID0gZ2xvYmFsLmxlaXN1cmVGdW5jTmFtZXNbbm1dID0gbmV3RGVmO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnQoZGVmKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcbiAgfSkpO1xuXG4gIGN1cnJ5ID0gZnVuY3Rpb24oYXJpdHksIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiAoc3ViY3VycnkoYXJpdHksIGZ1bmMsIFtdKSkoYXJnKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfTtcblxuICBzdWJjdXJyeSA9IGZ1bmN0aW9uKGFyaXR5LCBmdW5jLCBhcmdzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgICAgYXJncyA9IGFyZ3MgIT0gbnVsbCA/IGFyZ3MgOiBbXTtcbiAgICAgIGFyZ3MucHVzaChhcmcpO1xuICAgICAgaWYgKGFyaXR5ID09PSAxKSB7XG4gICAgICAgIHJldHVybiBmdW5jKGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN1YmN1cnJ5KGFyaXR5IC0gMSwgZnVuYywgYXJncyk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBtYWtlSGFtdCA9IGZ1bmN0aW9uKGhhbXQpIHtcbiAgICB2YXIgdDtcblxuICAgIHQgPSBzZXREYXRhVHlwZSgoZnVuY3Rpb24oKSB7fSksICdoYW10Jyk7XG4gICAgdC5oYW10ID0gaGFtdDtcbiAgICB0LnR5cGUgPSAnaGFtdCc7XG4gICAgcmV0dXJuIHQ7XG4gIH07XG5cbiAgaGFtdCA9IG1ha2VIYW10KGFtdC5UcmllKCkpO1xuXG4gIGRlZmluZSgnaGFtdCcsIGx6KGhhbXQpKTtcblxuICBkZWZpbmUoJ2hhbXRXaXRoJywgbHooZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oaGFtdCkge1xuICAgICAgICByZXR1cm4gbWFrZUhhbXQoYW10LmFzc29jKHJ6KGhhbXQpLmhhbXQsIHJ6KGtleSksIHJ6KHZhbHVlKSkpO1xuICAgICAgfTtcbiAgICB9O1xuICB9KSk7XG5cbiAgZGVmaW5lKCdoYW10RmV0Y2gnLCBseihmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oaGFtdCkge1xuICAgICAgcmV0dXJuIGFtdC5nZXQocnooaGFtdCkuaGFtdCwgcnooa2V5KSk7XG4gICAgfTtcbiAgfSkpO1xuXG4gIGRlZmluZSgnaGFtdEdldCcsIGx6KGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbihoYW10KSB7XG4gICAgICB2YXIgdjtcblxuICAgICAgdiA9IGFtdC5nZXQocnooaGFtdCkuaGFtdCwgcnooa2V5KSk7XG4gICAgICBpZiAodiAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBzb21lKHYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5vbmU7XG4gICAgICB9XG4gICAgfTtcbiAgfSkpO1xuXG4gIGRlZmluZSgnaGFtdFdpdGhvdXQnLCBseihmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oaGFtdCkge1xuICAgICAgcmV0dXJuIG1ha2VIYW10KGFtdC5kaXNzb2MocnooaGFtdCkuaGFtdCwgcnooa2V5KSkpO1xuICAgIH07XG4gIH0pKTtcblxuICBtZW1vID0gZnVuY3Rpb24oZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmdW5jLm1lbW8gfHwgKGZ1bmMubWVtbyA9IGZ1bmMoKSk7XG4gICAgfTtcbiAgfTtcblxuICBkZWZpbmUoJ2hhbXRQYWlycycsIGx6KGZ1bmN0aW9uKGhhbXQpIHtcbiAgICByZXR1cm4gbmV4dE5vZGUoc2ltcHlDb25zKHJ6KGhhbXQpLmhhbXQsIG51bGwpKTtcbiAgfSkpO1xuXG4gIG5leHROb2RlID0gZnVuY3Rpb24oc3RhY2spIHtcbiAgICB2YXIgY2hpbGQsIGssIGtleSwgbm9kZSwgdmFsdWUsIF9yZWYyLCBfcmVmMztcblxuICAgIGlmIChzdGFjayA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHJ6KExfbmlsKTtcbiAgICB9XG4gICAgbm9kZSA9IHN0YWNrLmhlYWQ7XG4gICAgc3RhY2sgPSBzdGFjay50YWlsO1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlICd0cmllJzpcbiAgICAgICAgX3JlZjIgPSBub2RlLmNoaWxkcmVuO1xuICAgICAgICBmb3IgKGsgaW4gX3JlZjIpIHtcbiAgICAgICAgICBjaGlsZCA9IF9yZWYyW2tdO1xuICAgICAgICAgIHN0YWNrID0gc2ltcHlDb25zKGNoaWxkLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5leHROb2RlKHN0YWNrKTtcbiAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgcmV0dXJuIHJ6KExfYWNvbnMpKGx6KG5vZGUua2V5KSkobHoobm9kZS52YWx1ZSkpKG1lbW8oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIG5leHROb2RlKHN0YWNrKTtcbiAgICAgICAgfSkpO1xuICAgICAgY2FzZSAnaGFzaG1hcCc6XG4gICAgICAgIF9yZWYzID0gbm9kZS52YWx1ZXM7XG4gICAgICAgIGZvciAoa2V5IGluIF9yZWYzKSB7XG4gICAgICAgICAgdmFsdWUgPSBfcmVmM1trZXldO1xuICAgICAgICAgIHN0YWNrID0gc2ltcHlDb25zKHZhbHVlLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5leHROb2RlKHN0YWNrKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBjb25zb2xlLmxvZyhcIlVOS05PV04gSEFNVCBOT0RFIFRZUEU6IFwiICsgbm9kZS50eXBlKTtcbiAgICB9XG4gIH07XG5cbiAgZGVmaW5lKCd0cmFtcG9saW5lQ2FsbCcsIGx6KGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICB2YXIgcmV0O1xuXG4gICAgcmV0ID0gcnooZnVuYyk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmICh0eXBlb2YgcmV0ID09PSAnZnVuY3Rpb24nICYmIHJldC50cmFtcG9saW5lKSB7XG4gICAgICAgIHJldCA9IHJldCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICB9XG4gIH0pKTtcblxuICBkZWZpbmUoJ3RyYW1wb2xpbmUnLCBseihmdW5jdGlvbihmdW5jKSB7XG4gICAgdmFyIGFyaXR5LCBmO1xuXG4gICAgZiA9IHJ6KGZ1bmMpO1xuICAgIGFyaXR5ID0gZnVuY3Rpb25JbmZvW2YubGVpc3VyZU5hbWVdLmFyaXR5O1xuICAgIHJldHVybiB0cmFtcEN1cnJ5KGYsIGFyaXR5KTtcbiAgfSkpO1xuXG4gIHRyYW1wQ3VycnkgPSBmdW5jdGlvbihmdW5jLCBhcml0eSkge1xuICAgIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICAgIHZhciBhLCByZXN1bHQ7XG5cbiAgICAgIGEgPSByeihhcmcpO1xuICAgICAgaWYgKGFyaXR5ID4gMSkge1xuICAgICAgICByZXR1cm4gdHJhbXBDdXJyeShmdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9KSwgYXJpdHkgLSAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBmdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJlc3VsdC50cmFtcG9saW5lID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIGVuc3VyZUxlaXN1cmVDbGFzcygndG9rZW4nKTtcblxuICBMZWlzdXJlX3Rva2VuLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIlRva2VuKFwiICsgKEpTT04uc3RyaW5naWZ5KHRva2VuU3RyaW5nKHRoaXMpKSkgKyBcIiwgXCIgKyAodG9rZW5Qb3ModGhpcykpICsgXCIpXCI7XG4gIH07XG5cbiAgdG9rZW5TdHJpbmcgPSBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQobHooZnVuY3Rpb24odHh0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgIHJldHVybiByeih0eHQpO1xuICAgICAgfTtcbiAgICB9KSk7XG4gIH07XG5cbiAgdG9rZW5Qb3MgPSBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQobHooZnVuY3Rpb24odHh0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgIHJldHVybiByeihwb3MpO1xuICAgICAgfTtcbiAgICB9KSk7XG4gIH07XG5cbiAgZW5zdXJlTGVpc3VyZUNsYXNzKCdwYXJlbnMnKTtcblxuICBMZWlzdXJlX3BhcmVucy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJQYXJlbnMoXCIgKyAocGFyZW5zU3RhcnQodGhpcykpICsgXCIsIFwiICsgKHBhcmVuc0VuZCh0aGlzKSkgKyBcIiwgXCIgKyAocGFyZW5zQ29udGVudCh0aGlzKSkgKyBcIilcIjtcbiAgfTtcblxuICBwYXJlbnNTdGFydCA9IGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gcChseihmdW5jdGlvbihzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24obCkge1xuICAgICAgICAgIHJldHVybiByeihzKTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfSkpO1xuICB9O1xuXG4gIHBhcmVuc0VuZCA9IGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gcChseihmdW5jdGlvbihzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24obCkge1xuICAgICAgICAgIHJldHVybiByeihlKTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfSkpO1xuICB9O1xuXG4gIHBhcmVuc0NvbnRlbnQgPSBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuIHAobHooZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgICByZXR1cm4gcnoobCk7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH0pKTtcbiAgfTtcblxuICBlbnN1cmVMZWlzdXJlQ2xhc3MoJ3RydWUnKTtcblxuICBMZWlzdXJlX3RydWUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwidHJ1ZVwiO1xuICB9O1xuXG4gIGVuc3VyZUxlaXN1cmVDbGFzcygnZmFsc2UnKTtcblxuICBMZWlzdXJlX2ZhbHNlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcImZhbHNlXCI7XG4gIH07XG5cbiAgZW5zdXJlTGVpc3VyZUNsYXNzKCdsZWZ0Jyk7XG5cbiAgTGVpc3VyZV9sZWZ0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIkxlZnQoXCIgKyAodGhpcyhseihfaWRlbnRpdHkpKShseihfaWRlbnRpdHkpKSkgKyBcIilcIjtcbiAgfTtcblxuICBlbnN1cmVMZWlzdXJlQ2xhc3MoJ3JpZ2h0Jyk7XG5cbiAgTGVpc3VyZV9yaWdodC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJSaWdodChcIiArICh0aGlzKGx6KF9pZGVudGl0eSkpKGx6KF9pZGVudGl0eSkpKSArIFwiKVwiO1xuICB9O1xuXG4gIHJvb3QuX3RydWUgPSBfdHJ1ZTtcblxuICByb290Ll9mYWxzZSA9IF9mYWxzZTtcblxuICByb290LnN0YXRlVmFsdWVzID0gdmFsdWVzO1xuXG4gIHJvb3QucnVuTW9uYWQgPSBydW5Nb25hZDtcblxuICByb290Lm5ld1J1bk1vbmFkID0gbmV3UnVuTW9uYWQ7XG5cbiAgcm9vdC5pc01vbmFkID0gaXNNb25hZDtcblxuICByb290LmlkZW50aXR5ID0gaWRlbnRpdHk7XG5cbiAgcm9vdC5zZXRWYWx1ZSA9IHNldFZhbHVlO1xuXG4gIHJvb3QuZ2V0VmFsdWUgPSBnZXRWYWx1ZTtcblxuICByb290Lm1ha2VNb25hZCA9IG1ha2VNb25hZDtcblxuICByb290Lm1ha2VTeW5jTW9uYWQgPSBtYWtlU3luY01vbmFkO1xuXG4gIHJvb3QucmVwbGFjZUVyciA9IHJlcGxhY2VFcnI7XG5cbiAgcm9vdC5sZWZ0ID0gbGVmdDtcblxuICByb290LnJpZ2h0ID0gcmlnaHQ7XG5cbiAgcm9vdC5nZXRNb25hZFN5bmNNb2RlID0gZ2V0TW9uYWRTeW5jTW9kZTtcblxuICByb290LmFzeW5jTW9uYWQgPSBhc3luY01vbmFkO1xuXG4gIHJvb3Quc2V0V2FybkFzeW5jID0gc2V0V2FybkFzeW5jO1xuXG4gIHJvb3QuY2FsbCA9IGNhbGw7XG5cbiAgcm9vdC5jYWxsTW9uYWQgPSBjYWxsTW9uYWQ7XG5cbiAgcm9vdC5iYXNpY0NhbGwgPSBiYXNpY0NhbGw7XG5cbiAgcm9vdC5ib29sZWFuRm9yID0gYm9vbGVhbkZvcjtcblxuICByb290Lm5ld0NvbnNGcm9tID0gY29uc0Zyb207XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93ICE9PSBudWxsKSB7XG4gICAgd2luZG93LnJ1bk1vbmFkID0gcnVuTW9uYWQ7XG4gICAgd2luZG93LnNldFR5cGUgPSBzZXRUeXBlO1xuICAgIHdpbmRvdy5zZXREYXRhVHlwZSA9IHNldERhdGFUeXBlO1xuICAgIHdpbmRvdy5kZWZhdWx0RW52ID0gZGVmYXVsdEVudjtcbiAgICB3aW5kb3cuaWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgfVxuXG59KS5jYWxsKHRoaXMpO1xuXG4vKlxuLy9AIHNvdXJjZU1hcHBpbmdVUkw9cnVudGltZS5tYXBcbiovXG5cbn0pKHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfcHJvY2Vzc1wiKSxzZWxmKSIsIkxfcnVuTW9uYWRzKFtcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkobGF6eShcImlmXCIpKShsYXp5KDApKShsYXp5KFwiaWYgPSBpZFwiKSkoTF9pZCl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShsYXp5KFwiYWZldGNoXCIpKShsYXp5KDIpKShsYXp5KFwiYWZldGNoIGsgYWxpc3QgID0gYWxpc3QgKFxcXFxoIHQgRCAuIGggXFxcXGtleSB2YWx1ZSAuIGVxIGtleSBrIHZhbHVlIChhZmV0Y2ggayB0KSkgbmlsXCIpKShsYXp5KGZ1bmN0aW9uKExfayl7cmV0dXJuIGZ1bmN0aW9uKExfYWxpc3Qpe3JldHVybiByZXNvbHZlKExfYWxpc3QpKGxhenkoZnVuY3Rpb24oTF9oKXtyZXR1cm4gZnVuY3Rpb24oTF90KXtyZXR1cm4gZnVuY3Rpb24oTF9EKXtyZXR1cm4gcmVzb2x2ZShMX2gpKGxhenkoZnVuY3Rpb24oTF9rZXkpe3JldHVybiBmdW5jdGlvbihMX3ZhbHVlKXtyZXR1cm4gcmVzb2x2ZShMX2VxKShMX2tleSkoTF9rKShMX3ZhbHVlKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYWZldGNoKShMX2spKExfdCl9KX19KSl9fX0pKShMX25pbCl9fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkobGF6eShcImFjb25zZlwiKSkobGF6eSgzKSkobGF6eShcImFjb25zZiBrZXkgdmFsdWUgbGlzdCA9IGFjb25zIGtleSB2YWx1ZSAoYXJlbW92ZSBrZXkgbGlzdClcIikpKGxhenkoZnVuY3Rpb24oTF9rZXkpe3JldHVybiBmdW5jdGlvbihMX3ZhbHVlKXtyZXR1cm4gZnVuY3Rpb24oTF9saXN0KXtyZXR1cm4gcmVzb2x2ZShMX2Fjb25zKShMX2tleSkoTF92YWx1ZSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2FyZW1vdmUpKExfa2V5KShMX2xpc3QpfSl9fX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKGxhenkoXCJhcmVtb3ZlXCIpKShsYXp5KDIpKShsYXp5KFwiYXJlbW92ZSBrZXkgbGlzdCA9IGlzTmlsIGxpc3RcXG4gIG5pbFxcbiAgZXEgKGhlYWQgKGhlYWQgbGlzdCkpIGtleVxcbiAgICBhcmVtb3ZlIGtleSAodGFpbCBsaXN0KVxcbiAgICBhY29uc1BhaXIgKGhlYWQgbGlzdCkgKGFyZW1vdmUga2V5ICh0YWlsIGxpc3QpKVwiKSkobGF6eShmdW5jdGlvbihMX2tleSl7cmV0dXJuIGZ1bmN0aW9uKExfbGlzdCl7cmV0dXJuIHJlc29sdmUoTF9pc05pbCkoTF9saXN0KShMX25pbCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2VxKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaGVhZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2hlYWQpKExfbGlzdCl9KX0pKExfa2V5KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYXJlbW92ZSkoTF9rZXkpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90YWlsKShMX2xpc3QpfSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYWNvbnNQYWlyKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaGVhZCkoTF9saXN0KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hcmVtb3ZlKShMX2tleSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3RhaWwpKExfbGlzdCl9KX0pfSl9KX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmTWFjcm8pKGxhenkoXCJ3aGVuXCIpKShsYXp5KGZ1bmN0aW9uKExfbGluZSl7cmV0dXJuIHJlc29sdmUoTF9saW5lKShsYXp5KGZ1bmN0aW9uKExfY29uZCl7cmV0dXJuIGZ1bmN0aW9uKExfcmVzdCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShMX2NvbmQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykobGF6eShcImRvXCIpKShMX3Jlc3QpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGxhenkoXCJuaWxcIikpKExfbmlsKX0pfSl9fSkpfSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2FkZFRva2VuR3JvdXApKGxhenkoXCJqc1tcIikpKGxhenkoXCJdXCIpKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZNYWNybykobGF6eShcImpzW1wiKSkobGF6eShmdW5jdGlvbihMX2xpc3Qpe3JldHVybiByZXNvbHZlKExfY29ucykobGF6eShcImpzXCIpKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGxhenkoXCJzdHJDYXRcIikpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykobGF6eShcImZsYXR0ZW5cIikpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2xpc3RpZnkpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9oZWFkKShMX2xpc3QpfSl9KShMX25pbCl9KShMX25pbCl9KX0pKExfbmlsKX0pfSkoTF9uaWwpfSl9KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShsYXp5KFwiaHRtbFwiKSkobGF6eSgxKSkobGF6eShcImh0bWwgeCA9IFxcXFxmIC4gZiB4XCIpKShsYXp5KHNldERhdGFUeXBlKGZ1bmN0aW9uKExfeCl7cmV0dXJuIHNldFR5cGUoZnVuY3Rpb24oTF9mKXtyZXR1cm4gcmVzb2x2ZShMX2YpKExfeCl9LCAnaHRtbCcpfSwgJ2h0bWwnKSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkobGF6eShcImlzemVyb1wiKSkobGF6eSgwKSkobGF6eShcImlzemVybyA9IGVxIDBcIikpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9lcSkobGF6eSgwKSl9KX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKGxhenkoXCJwb3NpdGl2ZVwiKSkobGF6eSgwKSkobGF6eShcInBvc2l0aXZlID0gMCA8XCIpKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfJHkpKGxhenkoMCkpfSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYWRkVG9rZW4pKGxhenkoXCItLVwiKSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYWRkVG9rZW4pKGxhenkoXCIrK1wiKSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShsYXp5KFwiLS1cIikpKGxhenkoMCkpKGxhenkoXCItLSA9IChmbGlwICgtKSkgMVwiKSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2ZsaXApKExfJF8pKGxhenkoMSkpfSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShsYXp5KFwiKytcIikpKGxhenkoMCkpKGxhenkoXCIrKyA9ICgxICspXCIpKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfJG8pKGxhenkoMSkpfSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShsYXp5KFwiaW50ZXJjYWxhdGVcIikpKGxhenkoMikpKGxhenkoXCJpbnRlcmNhbGF0ZSB4IGwgPSBjb25jYXQgKGludGVyc3BlcnNlIHggbClcIikpKGxhenkoZnVuY3Rpb24oTF94KXtyZXR1cm4gZnVuY3Rpb24oTF9sKXtyZXR1cm4gcmVzb2x2ZShMX2NvbmNhdCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2ludGVyc3BlcnNlKShMX3gpKExfbCl9KX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShsYXp5KFwidmlzaXRcIikpKGxhenkoMikpKGxhenkoXCJ2aXNpdCBmdW5jIGwgPSBcXFxcXFxcXFxcbiAgcmVzdWx0ID0gZnVuYyBmdW5jIGxcXG4gIC5cXG4gIGlzQ29ucyByZXN1bHRcXG4gICAgcmVzdWx0IFxcXFxoIHQgLiBjb25zICh2aXNpdCBmdW5jIGgpICh2aXNpdCBmdW5jIHQpXFxuICAgIHJlc3VsdFwiKSkobGF6eShmdW5jdGlvbihMX2Z1bmMpe3JldHVybiBmdW5jdGlvbihMX2wpe3JldHVybiAoZnVuY3Rpb24oKXtcblxudmFyIExfcmVzdWx0O1xuXG5MX3Jlc3VsdCA9IGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9mdW5jKShMX2Z1bmMpKExfbCl9O1xucmV0dXJuIHJlc29sdmUoTF9pc0NvbnMpKExfcmVzdWx0KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcmVzdWx0KShsYXp5KGZ1bmN0aW9uKExfaCl7cmV0dXJuIGZ1bmN0aW9uKExfdCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdmlzaXQpKExfZnVuYykoTF9oKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF92aXNpdCkoTF9mdW5jKShMX3QpfSl9fSkpfSkoTF9yZXN1bHQpfSkoKX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShsYXp5KFwic2ltcGxpZnlcIikpKGxhenkoMSkpKGxhenkoXCJzaW1wbGlmeSBleHByU3RyaW5nID0gZG9cXG4gIGxpc3QgPC0gc2NhbkxpbmVNIGV4cHJTdHJpbmdcXG4gIHZpc2l0IChcXFxcZnVuYyB4IC4gaXNUb2tlbiB4ICh0b2tlblN0cmluZyB4KSAoKGlzUGFyZW5zIHgpICh2aXNpdCBmdW5jIChwYXJlbnNDb250ZW50IHgpKSB4KSkgbGlzdFwiKSkobGF6eShmdW5jdGlvbihMX2V4cHJTdHJpbmcpe3JldHVybiByZXNvbHZlKExfYmluZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3NjYW5MaW5lTSkoTF9leHByU3RyaW5nKX0pKGxhenkoZnVuY3Rpb24oTF9saXN0KXtyZXR1cm4gcmVzb2x2ZShMX3Zpc2l0KShsYXp5KGZ1bmN0aW9uKExfZnVuYyl7cmV0dXJuIGZ1bmN0aW9uKExfeCl7cmV0dXJuIHJlc29sdmUoTF9pc1Rva2VuKShMX3gpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90b2tlblN0cmluZykoTF94KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pc1BhcmVucykoTF94KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdmlzaXQpKExfZnVuYykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3BhcmVuc0NvbnRlbnQpKExfeCl9KX0pKExfeCl9KX19KSkoTF9saXN0KX0pKX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKGxhenkoXCJkb2FsbFwiKSkobGF6eSgwKSkobGF6eShcImRvYWxsID0gZm9sZHIxIChcXFxcZWwgcmVzIC4gYmluZCBlbCBcXFxcXyAuIHJlcylcIikpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9mb2xkcjEpKGxhenkoZnVuY3Rpb24oTF9lbCl7cmV0dXJuIGZ1bmN0aW9uKExfcmVzKXtyZXR1cm4gcmVzb2x2ZShMX2JpbmQpKExfZWwpKGxhenkoZnVuY3Rpb24oTF9fKXtyZXR1cm4gcmVzb2x2ZShMX3Jlcyl9KSl9fSkpfSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShsYXp5KFwicmVxdWlyZUpTXCIpKShsYXp5KDEpKShsYXp5KFwicmVxdWlyZUpTIGZpbGUgPSBiaW5kIChnZXRWYWx1ZSAncmVxdWlyZWRGaWxlcycpXFxuICBcXFxcZmlsZXMgLiBjb250YWlucyBmaWxlcyBmaWxlXFxuICAgIGZhbHNlXFxuICAgIGJpbmQgKGxvYWRKUyBmaWxlKVxcbiAgICAgIFxcXFxyZXN1bHQgLiByZXN1bHRcXG4gICAgICAgIFxcXFx4IC4gbGVmdCB4XFxuICAgICAgICBcXFxcXyAuIGJpbmQgKHNldFZhbHVlICdyZXF1aXJlZEZpbGVzJyAoY29ucyBmaWxlIGZpbGVzKSlcXG4gICAgICAgICAgXFxcXF8gLiByaWdodCB0cnVlXCIpKShsYXp5KGZ1bmN0aW9uKExfZmlsZSl7cmV0dXJuIHJlc29sdmUoTF9iaW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZ2V0VmFsdWUpKGxhenkoXCJyZXF1aXJlZEZpbGVzXCIpKX0pKGxhenkoZnVuY3Rpb24oTF9maWxlcyl7cmV0dXJuIHJlc29sdmUoTF9jb250YWlucykoTF9maWxlcykoTF9maWxlKShMX2ZhbHNlKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYmluZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2xvYWRKUykoTF9maWxlKX0pKGxhenkoZnVuY3Rpb24oTF9yZXN1bHQpe3JldHVybiByZXNvbHZlKExfcmVzdWx0KShsYXp5KGZ1bmN0aW9uKExfeCl7cmV0dXJuIHJlc29sdmUoTF9sZWZ0KShMX3gpfSkpKGxhenkoZnVuY3Rpb24oTF9fKXtyZXR1cm4gcmVzb2x2ZShMX2JpbmQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zZXRWYWx1ZSkobGF6eShcInJlcXVpcmVkRmlsZXNcIikpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShMX2ZpbGUpKExfZmlsZXMpfSl9KShsYXp5KGZ1bmN0aW9uKExfX18wKXtyZXR1cm4gcmVzb2x2ZShMX3JpZ2h0KShMX3RydWUpfSkpfSkpfSkpfSl9KSl9KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShsYXp5KFwibG9hZEpTXCIpKShsYXp5KDEpKShsYXp5KFwibG9hZEpTIGZpbGUgPSBiaW5kIChyZWFkRmlsZSBmaWxlKVxcbiAgXFxcXHJlc3VsdCAuIHJlc3VsdFxcbiAgICBcXFxcZXJyIC4gZXJyXFxuICAgIFxcXFxjb250ZW50cyAuIGpzIGNvbnRlbnRzXCIpKShsYXp5KGZ1bmN0aW9uKExfZmlsZSl7cmV0dXJuIHJlc29sdmUoTF9iaW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcmVhZEZpbGUpKExfZmlsZSl9KShsYXp5KGZ1bmN0aW9uKExfcmVzdWx0KXtyZXR1cm4gcmVzb2x2ZShMX3Jlc3VsdCkobGF6eShmdW5jdGlvbihMX2Vycil7cmV0dXJuIHJlc29sdmUoTF9lcnIpfSkpKGxhenkoZnVuY3Rpb24oTF9jb250ZW50cyl7cmV0dXJuIHJlc29sdmUoTF9qcykoTF9jb250ZW50cyl9KSl9KSl9KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShsYXp5KFwiZmluZE9wdGlvblwiKSkobGF6eSgyKSkobGF6eShcImZpbmRPcHRpb24gZnVuYyBsaXN0ID0gZG9cXG4gIHJlc3VsdCA9IGZ1bmMgKGhlYWQgbGlzdClcXG4gIGlzTmlsIGxpc3RcXG4gICAgbm9uZVxcbiAgICBpc05vbmUgcmVzdWx0XFxuICAgICAgZmluZE9wdGlvbiBmdW5jICh0YWlsIGxpc3QpXFxuICAgICAgcmVzdWx0XCIpKShsYXp5KGZ1bmN0aW9uKExfZnVuYyl7cmV0dXJuIGZ1bmN0aW9uKExfbGlzdCl7cmV0dXJuIChmdW5jdGlvbigpe1xuXG52YXIgTF9yZXN1bHQ7XG5cbkxfcmVzdWx0ID0gZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2Z1bmMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9oZWFkKShMX2xpc3QpfSl9O1xucmV0dXJuIHJlc29sdmUoTF9pc05pbCkoTF9saXN0KShMX25vbmUpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pc05vbmUpKExfcmVzdWx0KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZmluZE9wdGlvbikoTF9mdW5jKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdGFpbCkoTF9saXN0KX0pfSkoTF9yZXN1bHQpfSl9KSgpfX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKGxhenkoXCJkbGVtcHR5XCIpKShsYXp5KDApKShsYXp5KFwiZGxlbXB0eSA9IGlkXCIpKShMX2lkKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKGxhenkoXCJkbFwiKSkobGF6eSgxKSkobGF6eShcImRsIGl0ZW0gPSBcXFxccmVzdCAuIGl0ZW06cmVzdFwiKSkobGF6eShzZXREYXRhVHlwZShmdW5jdGlvbihMX2l0ZW0pe3JldHVybiBzZXRUeXBlKGZ1bmN0aW9uKExfcmVzdCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShMX2l0ZW0pKExfcmVzdCl9LCAnZGwnKX0sICdkbCcpKSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShsYXp5KFwiZGxQdXNoXCIpKShsYXp5KDIpKShsYXp5KFwiZGxQdXNoIGxpc3QgaXRlbSA9IGRsQXBwZW5kIGxpc3QgKGRsIGl0ZW0pXCIpKShsYXp5KGZ1bmN0aW9uKExfbGlzdCl7cmV0dXJuIGZ1bmN0aW9uKExfaXRlbSl7cmV0dXJuIHJlc29sdmUoTF9kbEFwcGVuZCkoTF9saXN0KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGwpKExfaXRlbSl9KX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShsYXp5KFwiZGxBcHBlbmRcIikpKGxhenkoMikpKGxhenkoXCJkbEFwcGVuZCBhIGIgPSBcXFxccmVzdCAuIGEgKGIgcmVzdClcIikpKGxhenkoc2V0RGF0YVR5cGUoZnVuY3Rpb24oTF9hKXtyZXR1cm4gZnVuY3Rpb24oTF9iKXtyZXR1cm4gc2V0VHlwZShmdW5jdGlvbihMX3Jlc3Qpe3JldHVybiByZXNvbHZlKExfYSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2IpKExfcmVzdCl9KX0sICdkbEFwcGVuZCcpfX0sICdkbEFwcGVuZCcpKSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShsYXp5KFwicmVtb3ZlXCIpKShsYXp5KDIpKShsYXp5KFwicmVtb3ZlIHggbCA9IHJlbW92ZUlmIChlcSB4KSBsXCIpKShsYXp5KGZ1bmN0aW9uKExfeCl7cmV0dXJuIGZ1bmN0aW9uKExfbCl7cmV0dXJuIHJlc29sdmUoTF9yZW1vdmVJZikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2VxKShMX3gpfSkoTF9sKX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShsYXp5KFwicmVtb3ZlSWZcIikpKGxhenkoMikpKGxhenkoXCJyZW1vdmVJZiBmIGwgPSBmaWx0ZXIgKGNvbXBvc2Ugbm90IGYpIGxcIikpKGxhenkoZnVuY3Rpb24oTF9mKXtyZXR1cm4gZnVuY3Rpb24oTF9sKXtyZXR1cm4gcmVzb2x2ZShMX2ZpbHRlcikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbXBvc2UpKExfbm90KShMX2YpfSkoTF9sKX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShsYXp5KFwiYW55XCIpKShsYXp5KDIpKShsYXp5KFwiYW55IGYgbCA9IGZpbmQgZiBsIChcXFxcZWwgLiB0cnVlKSBmYWxzZVwiKSkobGF6eShmdW5jdGlvbihMX2Ype3JldHVybiBmdW5jdGlvbihMX2wpe3JldHVybiByZXNvbHZlKExfZmluZCkoTF9mKShMX2wpKGxhenkoZnVuY3Rpb24oTF9lbCl7cmV0dXJuIHJlc29sdmUoTF90cnVlKX0pKShMX2ZhbHNlKX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShsYXp5KFwiYWxsXCIpKShsYXp5KDIpKShsYXp5KFwiYWxsIGYgbCA9IG5vdCBhbnkgKGNvbXBvc2Ugbm90IGYpIGxcIikpKGxhenkoZnVuY3Rpb24oTF9mKXtyZXR1cm4gZnVuY3Rpb24oTF9sKXtyZXR1cm4gcmVzb2x2ZShMX25vdCkoTF9hbnkpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb21wb3NlKShMX25vdCkoTF9mKX0pKExfbCl9fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkobGF6eShcInRha2VcIikpKGxhenkoMikpKGxhenkoXCJ0YWtlIG4gbGlzdCA9IHBvc2l0aXZlIG5cXG4gIGxpc3RcXG4gICAgXFxcXGggdCBEIC4gY29ucyBoICh0YWtlICgtLSBuKSB0KVxcbiAgICBuaWxcXG4gIG5pbFwiKSkobGF6eShmdW5jdGlvbihMX24pe3JldHVybiBmdW5jdGlvbihMX2xpc3Qpe3JldHVybiByZXNvbHZlKExfcG9zaXRpdmUpKExfbikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2xpc3QpKGxhenkoZnVuY3Rpb24oTF9oKXtyZXR1cm4gZnVuY3Rpb24oTF90KXtyZXR1cm4gZnVuY3Rpb24oTF9EKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKExfaCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3Rha2UpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF8kXyRfKShMX24pfSkoTF90KX0pfX19KSkoTF9uaWwpfSkoTF9uaWwpfX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKGxhenkoXCJ0YWtlV2hpbGVcIikpKGxhenkoMikpKGxhenkoXCJ0YWtlV2hpbGUgcHJlZGljYXRlIGxpc3QgPSBsaXN0XFxuICBcXFxcaCB0IEQgLiBwcmVkaWNhdGUgKGhlYWQgbGlzdClcXG4gICAgY29ucyBoICh0YWtlV2hpbGUgcHJlZGljYXRlIHQpXFxuICAgIG5pbFxcbiAgbmlsXCIpKShsYXp5KGZ1bmN0aW9uKExfcHJlZGljYXRlKXtyZXR1cm4gZnVuY3Rpb24oTF9saXN0KXtyZXR1cm4gcmVzb2x2ZShMX2xpc3QpKGxhenkoZnVuY3Rpb24oTF9oKXtyZXR1cm4gZnVuY3Rpb24oTF90KXtyZXR1cm4gZnVuY3Rpb24oTF9EKXtyZXR1cm4gcmVzb2x2ZShMX3ByZWRpY2F0ZSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2hlYWQpKExfbGlzdCl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF9oKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdGFrZVdoaWxlKShMX3ByZWRpY2F0ZSkoTF90KX0pfSkoTF9uaWwpfX19KSkoTF9uaWwpfX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKGxhenkoXCJkcm9wXCIpKShsYXp5KDIpKShsYXp5KFwiZHJvcCB4IGxpc3QgPSBwb3NpdGl2ZSB4XFxuICBsaXN0XFxuICAgIFxcXFxoIHQgRCAuIGRyb3AgKC0tIHgpIHRcXG4gICAgbmlsXFxuICBsaXN0XCIpKShsYXp5KGZ1bmN0aW9uKExfeCl7cmV0dXJuIGZ1bmN0aW9uKExfbGlzdCl7cmV0dXJuIHJlc29sdmUoTF9wb3NpdGl2ZSkoTF94KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfbGlzdCkobGF6eShmdW5jdGlvbihMX2gpe3JldHVybiBmdW5jdGlvbihMX3Qpe3JldHVybiBmdW5jdGlvbihMX0Qpe3JldHVybiByZXNvbHZlKExfZHJvcCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMXyRfJF8pKExfeCl9KShMX3QpfX19KSkoTF9uaWwpfSkoTF9saXN0KX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShsYXp5KFwiZHJvcFdoaWxlXCIpKShsYXp5KDIpKShsYXp5KFwiZHJvcFdoaWxlIHByZWRpY2F0ZSBsaXN0ID0gbGlzdFxcbiAgXFxcXGggdCBEIC4gcHJlZGljYXRlIGhcXG4gICAgZHJvcFdoaWxlIHByZWRpY2F0ZSB0XFxuICAgIGxpc3RcXG4gIG5pbFwiKSkobGF6eShmdW5jdGlvbihMX3ByZWRpY2F0ZSl7cmV0dXJuIGZ1bmN0aW9uKExfbGlzdCl7cmV0dXJuIHJlc29sdmUoTF9saXN0KShsYXp5KGZ1bmN0aW9uKExfaCl7cmV0dXJuIGZ1bmN0aW9uKExfdCl7cmV0dXJuIGZ1bmN0aW9uKExfRCl7cmV0dXJuIHJlc29sdmUoTF9wcmVkaWNhdGUpKExfaCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2Ryb3BXaGlsZSkoTF9wcmVkaWNhdGUpKExfdCl9KShMX2xpc3QpfX19KSkoTF9uaWwpfX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKGxhenkoXCJkcm9wTGFzdFwiKSkobGF6eSgyKSkobGF6eShcImRyb3BMYXN0IG4gbGlzdCA9IHJldmVyc2UgKGRyb3AgbiAocmV2ZXJzZSBsaXN0KSlcIikpKGxhenkoZnVuY3Rpb24oTF9uKXtyZXR1cm4gZnVuY3Rpb24oTF9saXN0KXtyZXR1cm4gcmVzb2x2ZShMX3JldmVyc2UpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kcm9wKShMX24pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9yZXZlcnNlKShMX2xpc3QpfSl9KX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShsYXp5KFwiYm94XCIpKShsYXp5KDIpKShsYXp5KFwiYm94IG4gbGlzdCA9IGxpc3QgPT0gbmlsXFxuICBuaWxcXG4gIFsodGFrZSBuIGxpc3QpIHwgYm94IG4gKGRyb3AgbiBsaXN0KV1cIikpKGxhenkoZnVuY3Rpb24oTF9uKXtyZXR1cm4gZnVuY3Rpb24oTF9saXN0KXtyZXR1cm4gcmVzb2x2ZShMXyRwJHApKExfbGlzdCkoTF9uaWwpKExfbmlsKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3Rha2UpKExfbikoTF9saXN0KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9ib3gpKExfbikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2Ryb3ApKExfbikoTF9saXN0KX0pfSl9KX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShsYXp5KFwiYXRcIikpKGxhenkoMikpKGxhenkoXCJhdCBsIHggPSAoeCA9PSAwKSAoaGVhZCBsKSAoYXQgKHRhaWwgbCkgKC0tICh4KSApIClcIikpKGxhenkoZnVuY3Rpb24oTF9sKXtyZXR1cm4gZnVuY3Rpb24oTF94KXtyZXR1cm4gcmVzb2x2ZShMXyRwJHApKExfeCkobGF6eSgwKSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2hlYWQpKExfbCl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYXQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90YWlsKShMX2wpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMXyRfJF8pKExfeCl9KX0pfX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKGxhenkoXCJzZXJpZXNcIikpKGxhenkoMikpKGxhenkoXCJzZXJpZXMgZnVuYyBuID0gbjooc2VyaWVzIGZ1bmMgKGZ1bmMgbikpXCIpKShsYXp5KGZ1bmN0aW9uKExfZnVuYyl7cmV0dXJuIGZ1bmN0aW9uKExfbil7cmV0dXJuIHJlc29sdmUoTF9jb25zKShMX24pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zZXJpZXMpKExfZnVuYykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2Z1bmMpKExfbil9KX0pfX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKGxhenkoXCJmcm9tXCIpKShsYXp5KDEpKShsYXp5KFwiZnJvbSBuID0gc2VyaWVzICsrIG5cIikpKGxhenkoZnVuY3Rpb24oTF9uKXtyZXR1cm4gcmVzb2x2ZShMX3NlcmllcykoTF8kbyRvKShMX24pfSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkobGF6eShcImZyb21CeVwiKSkobGF6eSgyKSkobGF6eShcImZyb21CeSBuIGluYyA9IHNlcmllcyAoKCspIGluYykgblwiKSkobGF6eShmdW5jdGlvbihMX24pe3JldHVybiBmdW5jdGlvbihMX2luYyl7cmV0dXJuIHJlc29sdmUoTF9zZXJpZXMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF8kbykoTF9pbmMpfSkoTF9uKX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShsYXp5KFwiZnJvbVRvXCIpKShsYXp5KDIpKShsYXp5KFwiZnJvbVRvIG4gbSA9IHRha2VXaGlsZSAoKD4pIG0pIChmcm9tIG4pXCIpKShsYXp5KGZ1bmN0aW9uKExfbil7cmV0dXJuIGZ1bmN0aW9uKExfbSl7cmV0dXJuIHJlc29sdmUoTF90YWtlV2hpbGUpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF8keikoTF9tKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9mcm9tKShMX24pfSl9fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkobGF6eShcImZyb21Ub0J5XCIpKShsYXp5KDMpKShsYXp5KFwiZnJvbVRvQnkgbiBtIGluYyA9IHRha2VXaGlsZSAoKD4pIG0pIChmcm9tQnkgbiBpbmMpXCIpKShsYXp5KGZ1bmN0aW9uKExfbil7cmV0dXJuIGZ1bmN0aW9uKExfbSl7cmV0dXJuIGZ1bmN0aW9uKExfaW5jKXtyZXR1cm4gcmVzb2x2ZShMX3Rha2VXaGlsZSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMXyR6KShMX20pfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2Zyb21CeSkoTF9uKShMX2luYyl9KX19fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkobGF6eShcImNvdW50XCIpKShsYXp5KDIpKShsYXp5KFwiY291bnQgeCBsID0gY291bnRJZiAoZXEgeCkgbFwiKSkobGF6eShmdW5jdGlvbihMX3gpe3JldHVybiBmdW5jdGlvbihMX2wpe3JldHVybiByZXNvbHZlKExfY291bnRJZikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2VxKShMX3gpfSkoTF9sKX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShsYXp5KFwiY291bnRJZlwiKSkobGF6eSgyKSkobGF6eShcImNvdW50SWYgZiBsID0gKGVxIGwgbmlsKSAwXFxuICArIChmIChoZWFkIGwpIDEgMCkgKGNvdW50SWYgZiAodGFpbCBsKSlcIikpKGxhenkoZnVuY3Rpb24oTF9mKXtyZXR1cm4gZnVuY3Rpb24oTF9sKXtyZXR1cm4gcmVzb2x2ZShMX2VxKShMX2wpKExfbmlsKShsYXp5KDApKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfJG8pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9mKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaGVhZCkoTF9sKX0pKGxhenkoMSkpKGxhenkoMCkpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvdW50SWYpKExfZikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3RhaWwpKExfbCl9KX0pfSl9fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkobGF6eShcImNvdW50SWZOb3RcIikpKGxhenkoMikpKGxhenkoXCJjb3VudElmTm90IGYgbCA9IGNvdW50SWYgKFxcXFx4LiBub3QgKGYgeCkpIGxcIikpKGxhenkoZnVuY3Rpb24oTF9mKXtyZXR1cm4gZnVuY3Rpb24oTF9sKXtyZXR1cm4gcmVzb2x2ZShMX2NvdW50SWYpKGxhenkoZnVuY3Rpb24oTF94KXtyZXR1cm4gcmVzb2x2ZShMX25vdCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2YpKExfeCl9KX0pKShMX2wpfX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKGxhenkoXCJvZGRzXCIpKShsYXp5KDEpKShsYXp5KFwib2RkcyBsID0gbFxcbiAgXFxcXGggdCBEIC4gW2ggfCBldmVucyB0XVxcbiAgbmlsXCIpKShsYXp5KGZ1bmN0aW9uKExfbCl7cmV0dXJuIHJlc29sdmUoTF9sKShsYXp5KGZ1bmN0aW9uKExfaCl7cmV0dXJuIGZ1bmN0aW9uKExfdCl7cmV0dXJuIGZ1bmN0aW9uKExfRCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShMX2gpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9ldmVucykoTF90KX0pfX19KSkoTF9uaWwpfSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkobGF6eShcImV2ZW5zXCIpKShsYXp5KDEpKShsYXp5KFwiZXZlbnMgbCA9IGxcXG4gIFxcXFxoIHQgRCAuIG9kZHMgdFxcbiAgbmlsXCIpKShsYXp5KGZ1bmN0aW9uKExfbCl7cmV0dXJuIHJlc29sdmUoTF9sKShsYXp5KGZ1bmN0aW9uKExfaCl7cmV0dXJuIGZ1bmN0aW9uKExfdCl7cmV0dXJuIGZ1bmN0aW9uKExfRCl7cmV0dXJuIHJlc29sdmUoTF9vZGRzKShMX3QpfX19KSkoTF9uaWwpfSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkobGF6eShcImNsZWF2ZVwiKSkobGF6eSgxKSkobGF6eShcImNsZWF2ZSBsID0gWyhldmVucyBsKSB8IChvZGRzIGwpXVwiKSkobGF6eShmdW5jdGlvbihMX2wpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2V2ZW5zKShMX2wpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX29kZHMpKExfbCl9KX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKGxhenkoXCJtZXJnZVwiKSkobGF6eSgzKSkobGF6eShcIm1lcmdlIGNtcCBhIGIgPSBhXFxuICBcXFxcYWggYXQgRCAuIGJcXG4gICAgXFxcXGJoIGJ0IEQgLiBjbXAgYWggYmhcXG4gICAgICBbYWggfCAobWVyZ2UgY21wIGF0IGIpXVxcbiAgICAgIFtiaCB8IChtZXJnZSBjbXAgYSBidCldXFxuICAgIGFcXG4gIGJcIikpKGxhenkoZnVuY3Rpb24oTF9jbXApe3JldHVybiBmdW5jdGlvbihMX2Epe3JldHVybiBmdW5jdGlvbihMX2Ipe3JldHVybiByZXNvbHZlKExfYSkobGF6eShmdW5jdGlvbihMX2FoKXtyZXR1cm4gZnVuY3Rpb24oTF9hdCl7cmV0dXJuIGZ1bmN0aW9uKExfRCl7cmV0dXJuIHJlc29sdmUoTF9iKShsYXp5KGZ1bmN0aW9uKExfYmgpe3JldHVybiBmdW5jdGlvbihMX2J0KXtyZXR1cm4gZnVuY3Rpb24oTF9EXzApe3JldHVybiByZXNvbHZlKExfY21wKShMX2FoKShMX2JoKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF9haCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX21lcmdlKShMX2NtcCkoTF9hdCkoTF9iKX0pfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKExfYmgpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9tZXJnZSkoTF9jbXApKExfYSkoTF9idCl9KX0pfX19KSkoTF9hKX19fSkpKExfYil9fX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKGxhenkoXCJtZXJnZVNvcnRcIikpKGxhenkoMikpKGxhenkoXCJtZXJnZVNvcnQgY21wIGwgPSBsXFxuICBcXFxcaCB0IEQgLiBlcSAodGFpbCBsKSBuaWxcXG4gICAgbFxcbiAgICBkb1xcbiAgICAgIGNsID0gY2xlYXZlIGxcXG4gICAgICBlID0gaGVhZCBjbFxcbiAgICAgIG8gPSB0YWlsIGNsXFxuICAgICAgbWVyZ2UgY21wIChtZXJnZVNvcnQgY21wIGUpIChtZXJnZVNvcnQgY21wIG8pXFxuICBuaWxcIikpKGxhenkoZnVuY3Rpb24oTF9jbXApe3JldHVybiBmdW5jdGlvbihMX2wpe3JldHVybiByZXNvbHZlKExfbCkobGF6eShmdW5jdGlvbihMX2gpe3JldHVybiBmdW5jdGlvbihMX3Qpe3JldHVybiBmdW5jdGlvbihMX0Qpe3JldHVybiByZXNvbHZlKExfZXEpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90YWlsKShMX2wpfSkoTF9uaWwpKExfbCkoZnVuY3Rpb24oKXtcbnZhciBMX28sIExfZSwgTF9jbDtcblxuTF9vID0gZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3RhaWwpKExfY2wpfTtcblxuTF9lID0gZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2hlYWQpKExfY2wpfTtcblxuTF9jbCA9IGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jbGVhdmUpKExfbCl9O1xucmV0dXJuIHJlc29sdmUoTF9tZXJnZSkoTF9jbXApKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9tZXJnZVNvcnQpKExfY21wKShMX2UpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX21lcmdlU29ydCkoTF9jbXApKExfbyl9KX0pfX19KSkoTF9uaWwpfX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKGxhenkoXCJzb3J0XCIpKShsYXp5KDEpKShsYXp5KFwic29ydCBsID0gc29ydEJ5ICg8PSkgbFwiKSkobGF6eShmdW5jdGlvbihMX2wpe3JldHVybiByZXNvbHZlKExfc29ydEJ5KShMXyR5JHApKExfbCl9KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmaW5lKShsYXp5KFwic29ydEJ5XCIpKShsYXp5KDIpKShsYXp5KFwic29ydEJ5IGNtcCBsID0gbWVyZ2VTb3J0IGNtcCBsXCIpKShsYXp5KGZ1bmN0aW9uKExfY21wKXtyZXR1cm4gZnVuY3Rpb24oTF9sKXtyZXR1cm4gcmVzb2x2ZShMX21lcmdlU29ydCkoTF9jbXApKExfbCl9fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2FkZFRva2VuKShsYXp5KFwiLT5cIikpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkobGF6eShcIm1rU3RyXCIpKShsYXp5KDEpKShsYXp5KFwibWtTdHIgdG9rID0gY29uY2F0WydcXFwiJyAodG9rZW5TdHJpbmcgdG9rKSAnXFxcIiddXCIpKShsYXp5KGZ1bmN0aW9uKExfdG9rKXtyZXR1cm4gcmVzb2x2ZShMX3N0ckNhdCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGxhenkoXCJcXFwiXCIpKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3Rva2VuU3RyaW5nKShMX3Rvayl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykobGF6eShcIlxcXCJcIikpKExfbmlsKX0pfSl9KX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZNYWNybykobGF6eShcImRlZkNhc2VcIikpKGxhenkoZnVuY3Rpb24oTF9saXN0KXtyZXR1cm4gKGZ1bmN0aW9uKCl7XG5cbnZhciBMX3QzLCBMX2gzLCBMX3QyLCBMX2gyLCBMX3QxLCBMX2gxO1xuXG5MX3QzID0gZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3RhaWwpKExfdDIpfTtcblxuTF9oMyA9IGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9oZWFkKShMX3QyKX07XG5cbkxfdDIgPSBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdGFpbCkoTF90MSl9O1xuXG5MX2gyID0gZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2hlYWQpKExfdDEpfTtcblxuTF90MSA9IGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90YWlsKShMX2xpc3QpfTtcblxuTF9oMSA9IGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9oZWFkKShMX2xpc3QpfTtcbnJldHVybiByZXNvbHZlKExfYW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaXNDb25zKShMX2xpc3QpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2FuZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2lzQ29ucykoTF90MSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaXNDb25zKShMX3QyKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hbmQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pc1Rva2VuU3RyaW5nKShMX2gyKShsYXp5KFwiLlwiKSl9KShMX3RydWUpfSl9KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9tYWtlQ2FzZUFyZ3MpKExfbGlzdCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX21rU3RyKShMX2gxKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9ta1N0cikoTF9oMyl9KShMX3QzKShMX2lkKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9wYXJzZUVycikobGF6eShcIkVycm9yIGluIGNhc2UgZGVmaW5pdGlvbiAtLSBleHBlY3RlZCBmdW5jLm5hbWUgYXJncyB8IGNvbmRpdGlvbiAtPiBhY3Rpb24sIGJ1dCBnb3QgXCIpKShMX2xpc3QpfSl9KSgpfSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkobGF6eShcIm1ha2VDYXNlQXJnc1wiKSkobGF6eSg1KSkobGF6eShcIm1ha2VDYXNlQXJncyBvcmlnIGZ1bmNOYW1lIGFsdE5hbWUgcmVzdCBhcmdzID0gcmVzdFxcbiAgXFxcXGggdCBEIC4gaXNUb2tlblN0cmluZyBoICd8J1xcbiAgICBtYWtlQ2FzZUNvbmRpdGlvbiBvcmlnIGZ1bmNOYW1lIGFsdE5hbWUgKGFyZ3MgbmlsKSB0IGlkXFxuICAgIG1ha2VDYXNlQXJncyBvcmlnIGZ1bmNOYW1lIGFsdE5hbWUgdCAoZGxQdXNoIGFyZ3MgaClcXG4gIHBhcnNlRXJyIFxcXCJFcnJvciBpbiBjYXNlIGRlZmluaXRpb24gLS0gZXhwZWN0ZWQgZnVuYy5uYW1lIGFyZ3MgfCBjb25kaXRpb24gLT4gYWN0aW9uLCBidXQgZ290IFxcXCIgb3JpZ1wiKSkobGF6eShmdW5jdGlvbihMX29yaWcpe3JldHVybiBmdW5jdGlvbihMX2Z1bmNOYW1lKXtyZXR1cm4gZnVuY3Rpb24oTF9hbHROYW1lKXtyZXR1cm4gZnVuY3Rpb24oTF9yZXN0KXtyZXR1cm4gZnVuY3Rpb24oTF9hcmdzKXtyZXR1cm4gcmVzb2x2ZShMX3Jlc3QpKGxhenkoZnVuY3Rpb24oTF9oKXtyZXR1cm4gZnVuY3Rpb24oTF90KXtyZXR1cm4gZnVuY3Rpb24oTF9EKXtyZXR1cm4gcmVzb2x2ZShMX2lzVG9rZW5TdHJpbmcpKExfaCkobGF6eShcInxcIikpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9tYWtlQ2FzZUNvbmRpdGlvbikoTF9vcmlnKShMX2Z1bmNOYW1lKShMX2FsdE5hbWUpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hcmdzKShMX25pbCl9KShMX3QpKExfaWQpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX21ha2VDYXNlQXJncykoTF9vcmlnKShMX2Z1bmNOYW1lKShMX2FsdE5hbWUpKExfdCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RsUHVzaCkoTF9hcmdzKShMX2gpfSl9KX19fSkpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9wYXJzZUVycikobGF6eShcIkVycm9yIGluIGNhc2UgZGVmaW5pdGlvbiAtLSBleHBlY3RlZCBmdW5jLm5hbWUgYXJncyB8IGNvbmRpdGlvbiAtPiBhY3Rpb24sIGJ1dCBnb3QgXCIpKShMX29yaWcpfSl9fX19fSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2RlZmluZSkobGF6eShcIm1ha2VDYXNlQ29uZGl0aW9uXCIpKShsYXp5KDYpKShsYXp5KFwibWFrZUNhc2VDb25kaXRpb24gb3JpZyBmdW5jTmFtZSBhbHROYW1lIGFyZ3MgcmVzdCBjb25kID0gcmVzdFxcbiAgXFxcXGggdCBEIC4gaXNUb2tlblN0cmluZyBoICctPidcXG4gICAgZm9sZHIxIGFwcGVuZCBbWydhbHREZWYnIGZ1bmNOYW1lIGFsdE5hbWUgKGxlbmd0aCBhcmdzKSAnXFxcXFxcXFwnXSBhcmdzIFsnLicgKGNvbmQgbmlsKSBbJ3NvbWUnIHRdICdub25lJ11dXFxuICAgIG1ha2VDYXNlQ29uZGl0aW9uIG9yaWcgZnVuY05hbWUgYWx0TmFtZSBhcmdzIHQgKGRsUHVzaCBjb25kIGgpXFxuIHBhcnNlRXJyIFxcXCJFcnJvciBpbiBjYXNlIGRlZmluaXRpb24gLS0gZXhwZWN0ZWQgZnVuYy5uYW1lIGFyZ3MgfCBjb25kaXRpb24gLT4gYWN0aW9uLCBidXQgZ290IFxcXCIgb3JpZ1wiKSkobGF6eShmdW5jdGlvbihMX29yaWcpe3JldHVybiBmdW5jdGlvbihMX2Z1bmNOYW1lKXtyZXR1cm4gZnVuY3Rpb24oTF9hbHROYW1lKXtyZXR1cm4gZnVuY3Rpb24oTF9hcmdzKXtyZXR1cm4gZnVuY3Rpb24oTF9yZXN0KXtyZXR1cm4gZnVuY3Rpb24oTF9jb25kKXtyZXR1cm4gcmVzb2x2ZShMX3Jlc3QpKGxhenkoZnVuY3Rpb24oTF9oKXtyZXR1cm4gZnVuY3Rpb24oTF90KXtyZXR1cm4gZnVuY3Rpb24oTF9EKXtyZXR1cm4gcmVzb2x2ZShMX2lzVG9rZW5TdHJpbmcpKExfaCkobGF6eShcIi0+XCIpKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZm9sZHIxKShMX2FwcGVuZCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShsYXp5KFwiYWx0RGVmXCIpKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF9mdW5jTmFtZSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKExfYWx0TmFtZSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9sZW5ndGgpKExfYXJncyl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykobGF6eShcIlxcXFxcIikpKExfbmlsKX0pfSl9KX0pfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKExfYXJncykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShsYXp5KFwiLlwiKSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25kKShMX25pbCl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGxhenkoXCJzb21lXCIpKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF90KShMX25pbCl9KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShsYXp5KFwibm9uZVwiKSkoTF9uaWwpfSl9KX0pfSkoTF9uaWwpfSl9KX0pfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX21ha2VDYXNlQ29uZGl0aW9uKShMX29yaWcpKExfZnVuY05hbWUpKExfYWx0TmFtZSkoTF9hcmdzKShMX3QpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kbFB1c2gpKExfY29uZCkoTF9oKX0pfSl9fX0pKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcGFyc2VFcnIpKGxhenkoXCJFcnJvciBpbiBjYXNlIGRlZmluaXRpb24gLS0gZXhwZWN0ZWQgZnVuYy5uYW1lIGFyZ3MgfCBjb25kaXRpb24gLT4gYWN0aW9uLCBidXQgZ290IFwiKSkoTF9vcmlnKX0pfX19fX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYWx0RGVmKShsYXp5KFwic2hvd1wiKSkobGF6eShcInNvbWVcIikpKGxhenkoMSkpKGxhenkoZnVuY3Rpb24oTF9vYmope3JldHVybiByZXNvbHZlKExfaGFzVHlwZSkoTF9vYmopKExfc29tZSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3NvbWUpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zdHJDYXQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShsYXp5KFwiU29tZShcIikpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfb2JqKShMX2lkKShMX2ZhbHNlKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShsYXp5KFwiKVwiKSkoTF9uaWwpfSl9KX0pfSl9KShMX25vbmUpfSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2FsdERlZikobGF6eShcInNob3dcIikpKGxhenkoXCJzb21lMlwiKSkobGF6eSgxKSkobGF6eShmdW5jdGlvbihMX29iail7cmV0dXJuIHJlc29sdmUoTF9oYXNUeXBlKShMX29iaikoTF9zb21lMikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3NvbWUpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zdHJDYXQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShsYXp5KFwiU29tZTIoXCIpKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX29iaikobGF6eShmdW5jdGlvbihMX2Epe3JldHVybiBmdW5jdGlvbihMX2Ipe3JldHVybiByZXNvbHZlKExfY29ucykoTF9hKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykobGF6eShcIiwgXCIpKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF9iKShMX25pbCl9KX0pfX0pKShMX2ZhbHNlKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShsYXp5KFwiKVwiKSkoTF9uaWwpfSl9KX0pfSl9KShMX25vbmUpfSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2FsdERlZikobGF6eShcInNob3dcIikpKGxhenkoXCJub25lXCIpKShsYXp5KDEpKShsYXp5KGZ1bmN0aW9uKExfb2JqKXtyZXR1cm4gcmVzb2x2ZShMX2hhc1R5cGUpKExfb2JqKShMX25vbmUpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zb21lKShsYXp5KFwiTm9uZVwiKSl9KShMX25vbmUpfSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2FsdERlZikobGF6eShcInNob3dcIikpKGxhenkoXCJsZWZ0XCIpKShsYXp5KDEpKShsYXp5KGZ1bmN0aW9uKExfb2JqKXtyZXR1cm4gcmVzb2x2ZShMX2hhc1R5cGUpKExfb2JqKShMX2xlZnQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zb21lKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc3RyQ2F0KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykobGF6eShcIkxlZnQoXCIpKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX29iaikoTF9pZCkoTF9pZCl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykobGF6eShcIilcIikpKExfbmlsKX0pfSl9KX0pfSkoTF9ub25lKX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hbHREZWYpKGxhenkoXCJzaG93XCIpKShsYXp5KFwicmlnaHRcIikpKGxhenkoMSkpKGxhenkoZnVuY3Rpb24oTF9vYmope3JldHVybiByZXNvbHZlKExfaGFzVHlwZSkoTF9vYmopKExfcmlnaHQpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zb21lKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc3RyQ2F0KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykobGF6eShcIlJpZ2h0KFwiKSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9vYmopKExfaWQpKExfaWQpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGxhenkoXCIpXCIpKShMX25pbCl9KX0pfSl9KX0pKExfbm9uZSl9KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYWx0RGVmKShsYXp5KFwic2hvd1wiKSkobGF6eShcIm5pbFwiKSkobGF6eSgxKSkobGF6eShmdW5jdGlvbihMX29iail7cmV0dXJuIHJlc29sdmUoTF9oYXNUeXBlKShMX29iaikoTF9uaWwpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zb21lKShsYXp5KFwibmlsXCIpKX0pKExfbm9uZSl9KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYWx0RGVmKShsYXp5KFwic2hvd1wiKSkobGF6eShcImFzc29jXCIpKShsYXp5KDEpKShsYXp5KGZ1bmN0aW9uKExfb2JqKXtyZXR1cm4gcmVzb2x2ZShMX2lzQWxpc3QpKExfb2JqKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc29tZSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3N0ckNhdCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2ZsYXR0ZW4pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShsYXp5KFwie1wiKSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pbnRlcnNwZXJzZSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX21hcCkobGF6eShmdW5jdGlvbihMX2l0ZW0pe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3Nob3cpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9oZWFkKShMX2l0ZW0pfSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykobGF6eShcIjpcIikpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc2hvdykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3RhaWwpKExfaXRlbSl9KX0pKExfbmlsKX0pfSl9KSkoTF9vYmopfSkobGF6eShcIiBcIikpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGxhenkoXCJ9XCIpKShMX25pbCl9KX0pfSl9KX0pfSkoTF9ub25lKX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hbHREZWYpKGxhenkoXCJzaG93XCIpKShsYXp5KFwiaGFtdFwiKSkobGF6eSgxKSkobGF6eShmdW5jdGlvbihMX29iail7cmV0dXJuIHJlc29sdmUoTF9oYXNUeXBlKShMX29iaikoTF9oYW10KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc29tZSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3N0ckNhdCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2ZsYXR0ZW4pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShsYXp5KFwiaGFtdHtcIikpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaW50ZXJzcGVyc2UpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9tYXApKGxhenkoZnVuY3Rpb24oTF9pdGVtKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zaG93KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaGVhZCkoTF9pdGVtKX0pfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGxhenkoXCI6XCIpKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3Nob3cpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90YWlsKShMX2l0ZW0pfSl9KShMX25pbCl9KX0pfSkpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9oYW10UGFpcnMpKExfb2JqKX0pfSkobGF6eShcIiBcIikpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGxhenkoXCJ9XCIpKShMX25pbCl9KX0pfSl9KX0pfSkoTF9ub25lKX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hbHREZWYpKGxhenkoXCJzaG93XCIpKShsYXp5KFwiY29uc1wiKSkobGF6eSgxKSkobGF6eShmdW5jdGlvbihMX29iail7cmV0dXJuIHJlc29sdmUoTF9oYXNUeXBlKShMX29iaikoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc29tZSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3N0ckNhdCkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2ZsYXR0ZW4pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShsYXp5KFwiW1wiKSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zaG93KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaGVhZCkoTF9vYmopfSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX3Nob3dDb25zRWxlbWVudHMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90YWlsKShMX29iail9KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShsYXp5KFwiXVwiKSkoTF9uaWwpfSl9KX0pfSl9KX0pfSkoTF9ub25lKX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKGxhenkoXCJzaG93Q29uc0VsZW1lbnRzXCIpKShsYXp5KDEpKShsYXp5KFwic2hvd0NvbnNFbGVtZW50cyBsaXN0ID0gaXNDb25zIGxpc3RcXG4gIFsnICcgKHNob3cgKGhlYWQgbGlzdCkpIChzaG93Q29uc0VsZW1lbnRzICh0YWlsIGxpc3QpKV1cXG4gIGlzTmlsIGxpc3RcXG4gICAgJydcXG4gICAgWycgfCAnIChzaG93IGxpc3QpXVwiKSkobGF6eShmdW5jdGlvbihMX2xpc3Qpe3JldHVybiByZXNvbHZlKExfaXNDb25zKShMX2xpc3QpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShsYXp5KFwiIFwiKSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zaG93KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaGVhZCkoTF9saXN0KX0pfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zaG93Q29uc0VsZW1lbnRzKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdGFpbCkoTF9saXN0KX0pfSkoTF9uaWwpfSl9KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9pc05pbCkoTF9saXN0KShsYXp5KFwiXCIpKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykobGF6eShcIiB8IFwiKSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zaG93KShMX2xpc3QpfSkoTF9uaWwpfSl9KX0pfSkpfSxcbiAgZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2FsdERlZikobGF6eShcImJpbmRcIikpKGxhenkoXCJvcHRpb25cIikpKGxhenkoMikpKGxhenkoZnVuY3Rpb24oTF9vcHQpe3JldHVybiBmdW5jdGlvbihMX2NvbnQpe3JldHVybiByZXNvbHZlKExfb3IpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9oYXNUeXBlKShMX29wdCkoTF9zb21lKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9oYXNUeXBlKShMX29wdCkoTF9ub25lKX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zb21lKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfb3B0KShsYXp5KGZ1bmN0aW9uKExfdmFsdWUpe3JldHVybiByZXNvbHZlKExfY29udCkoTF92YWx1ZSl9KSkoTF9ub25lKX0pfSkoTF9ub25lKX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYWx0RGVmKShsYXp5KFwiYmluZFwiKSkobGF6eShcImVpdGhlclwiKSkobGF6eSgyKSkobGF6eShmdW5jdGlvbihMX2VpdGhlcil7cmV0dXJuIGZ1bmN0aW9uKExfY29udCl7cmV0dXJuIHJlc29sdmUoTF9vcikoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2hhc1R5cGUpKExfZWl0aGVyKShMX2xlZnQpfSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2hhc1R5cGUpKExfZWl0aGVyKShMX3JpZ2h0KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9zb21lKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZWl0aGVyKShsYXp5KGZ1bmN0aW9uKExfXyl7cmV0dXJuIHJlc29sdmUoTF9laXRoZXIpfSkpKGxhenkoZnVuY3Rpb24oTF92YWx1ZSl7cmV0dXJuIHJlc29sdmUoTF9jb250KShMX3ZhbHVlKX0pKX0pfSkoTF9ub25lKX19KSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmTWFjcm8pKGxhenkoXCJkZWZXcmFwcGVyXCIpKShsYXp5KGZ1bmN0aW9uKExfbGlzdCl7cmV0dXJuIHJlc29sdmUoTF9ncmFiTGVmdE9mQXJyb3cpKExfbGlzdCkoTF9uaWwpKGxhenkoZnVuY3Rpb24oTF9sZWZ0KXtyZXR1cm4gZnVuY3Rpb24oTF9yaWdodCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShsYXp5KFwib3ZlcnJpZGVcIikpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc3RyQ2F0KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykobGF6eShcIidcIikpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfc3RyVG9rZW5TdHJpbmcpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9oZWFkKShMX2xlZnQpfSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykobGF6eShcIidcIikpKExfbmlsKX0pfSl9KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfYXBwZW5kKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykobGF6eShcIlxcXFxcIikpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90YWlsKShMX2xlZnQpfSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykobGF6eShcIi5cIikpKExfcmlnaHQpfSl9KShMX25pbCl9KX0pfX0pKX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKGxhenkoXCJncmFiTGVmdE9mQXJyb3dcIikpKGxhenkoMykpKGxhenkoXCJncmFiTGVmdE9mQXJyb3cgbGlzdCBsZWZ0IGNvbnQgPSBpc1Rva2VuU3RyaW5nIChoZWFkIGxpc3QpICctPidcXG4gIGNvbnQgKHJldmVyc2UgbGVmdCkgKHRhaWwgbGlzdClcXG4gIGdyYWJMZWZ0T2ZBcnJvdyAodGFpbCBsaXN0KSAoaGVhZCBsaXN0KSA6IGxlZnQgY29udFwiKSkobGF6eShmdW5jdGlvbihMX2xpc3Qpe3JldHVybiBmdW5jdGlvbihMX2xlZnQpe3JldHVybiBmdW5jdGlvbihMX2NvbnQpe3JldHVybiByZXNvbHZlKExfaXNUb2tlblN0cmluZykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2hlYWQpKExfbGlzdCl9KShsYXp5KFwiLT5cIikpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb250KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfcmV2ZXJzZSkoTF9sZWZ0KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF90YWlsKShMX2xpc3QpfSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZ3JhYkxlZnRPZkFycm93KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfdGFpbCkoTF9saXN0KX0pKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfaGVhZCkoTF9saXN0KX0pKExfbGVmdCl9KShMX2NvbnQpfSl9fX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9vdmVycmlkZSkobGF6eShcImhlYWRcIikpKGxhenkoZnVuY3Rpb24oTF9vbGRIZWFkKXtyZXR1cm4gZnVuY3Rpb24oTF9saXN0KXtyZXR1cm4gcmVzb2x2ZShMX2Fzc2VydFR5cGUpKGxhenkoXCJoZWFkIGFyZ3VtZW50XCIpKShMX2NvbnMpKExfbGlzdCkobGF6eShmdW5jdGlvbihMX2gpe3JldHVybiBmdW5jdGlvbihMX3Qpe3JldHVybiByZXNvbHZlKExfaCl9fSkpfX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9vdmVycmlkZSkobGF6eShcInRhaWxcIikpKGxhenkoZnVuY3Rpb24oTF9vbGRUYWlsKXtyZXR1cm4gZnVuY3Rpb24oTF9saXN0KXtyZXR1cm4gcmVzb2x2ZShMX2Fzc2VydFR5cGUpKGxhenkoXCJ0YWlsIGFyZ3VtZW50XCIpKShMX2NvbnMpKExfbGlzdCkobGF6eShmdW5jdGlvbihMX2gpe3JldHVybiBmdW5jdGlvbihMX3Qpe3JldHVybiByZXNvbHZlKExfdCl9fSkpfX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9vdmVycmlkZSkobGF6eShcImhhbXRXaXRoXCIpKShsYXp5KGZ1bmN0aW9uKExfb2xkSGFtdFdpdGgpe3JldHVybiBmdW5jdGlvbihMX2tleSl7cmV0dXJuIGZ1bmN0aW9uKExfdmFsdWUpe3JldHVybiBmdW5jdGlvbihMX2hhbXQpe3JldHVybiByZXNvbHZlKExfb2xkSGFtdFdpdGgpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hc3NlcnRUeXBlKShsYXp5KFwiaGFtdFdpdGgga2V5XCIpKShsYXp5KFwiKnN0cmluZ1wiKSkoTF9rZXkpfSkoTF92YWx1ZSkoTF9oYW10KX19fX0pKX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9kZWZpbmUpKGxhenkoXCJodG1sXCIpKShsYXp5KDEpKShsYXp5KFwiaHRtbCB4ID0gXFxcXGYgLiBmIHhcIikpKGxhenkoc2V0RGF0YVR5cGUoZnVuY3Rpb24oTF94KXtyZXR1cm4gc2V0VHlwZShmdW5jdGlvbihMX2Ype3JldHVybiByZXNvbHZlKExfZikoTF94KX0sICdodG1sJyl9LCAnaHRtbCcpKSl9LFxuICBmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfZGVmVG9rZW5QYWNrKShsYXp5KFwidXRpbFwiKSkoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShsYXp5KFwiLT5cIikpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShsYXp5KFwiLS1cIikpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShsYXp5KFwiKytcIikpKExfbmlsKX0pfSl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x2ZShMX2NvbnMpKGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9jb25zKShsYXp5KFwianNbXCIpKShsYXp5KFwiXVwiKSl9KShMX25pbCl9KShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykoTF9uaWwpKExfbmlsKX0pfSl9KX0sXG4gIGZ1bmN0aW9uKCl7cmV0dXJuIHJlc29sdmUoTF9hZGRTdGRUb2tlblBhY2tzKShmdW5jdGlvbigpe3JldHVybiByZXNvbHZlKExfY29ucykobGF6eShcInV0aWxcIikpKExfbmlsKX0pfV0pO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxucHJvY2Vzcy5uZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhblNldEltbWVkaWF0ZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnNldEltbWVkaWF0ZTtcbiAgICB2YXIgY2FuUG9zdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyXG4gICAgO1xuXG4gICAgaWYgKGNhblNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHdpbmRvdy5zZXRJbW1lZGlhdGUoZikgfTtcbiAgICB9XG5cbiAgICBpZiAoY2FuUG9zdCkge1xuICAgICAgICB2YXIgcXVldWUgPSBbXTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGlmIChldi5zb3VyY2UgPT09IHdpbmRvdyAmJiBldi5kYXRhID09PSAncHJvY2Vzcy10aWNrJykge1xuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZm4pO1xuICAgICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKCdwcm9jZXNzLXRpY2snLCAnKicpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICB9O1xufSkoKTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufVxuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHN0cikge1xuICB2YXIgaGFzaCA9IDUzODEsXG4gICAgICBpICAgID0gc3RyLmxlbmd0aFxuXG4gIHdoaWxlKGkpXG4gICAgaGFzaCA9IChoYXNoICogMzMpIF4gc3RyLmNoYXJDb2RlQXQoLS1pKVxuXG4gIC8qIEphdmFTY3JpcHQgZG9lcyBiaXR3aXNlIG9wZXJhdGlvbnMgKGxpa2UgWE9SLCBhYm92ZSkgb24gMzItYml0IHNpZ25lZFxuICAgKiBpbnRlZ2Vycy4gU2luY2Ugd2Ugd2FudCB0aGUgcmVzdWx0cyB0byBiZSBhbHdheXMgcG9zaXRpdmUsIGlmIHRoZSBoaWdoIGJpdFxuICAgKiBpcyBzZXQsIHVuc2V0IGl0IGFuZCBhZGQgaXQgYmFjayBpbiB0aHJvdWdoICg2NC1iaXQgSUVFRSkgYWRkaXRpb24uICovXG4gIHJldHVybiBoYXNoID49IDAgPyBoYXNoIDogKGhhc2ggJiAweDdGRkZGRkZGKSArIDB4ODAwMDAwMDBcbn1cbiIsIi8vIyBIYXNoaW5nIGZ1bmN0aW9uc1xuXG4vLyBJbnQsIEludCAtPiBJbnRcbi8vIGdldHMgYSA8PSA1IGJpdCBzZWN0aW9uIG9mIGEgaGFzaCwgc2hpZnRlZCBmcm9tIHRoZSBsZWZ0IHBvc2l0aW9uXG4vLyBpbiBwcmFjdGljZSwgYSAzMiBiaXQgc3BsaXRzIGludG8gNyBjaHVua3MgLSA2IG9mIDUgYml0cywgb25lIG9mIDJcbnZhciBtYXNrID0gZnVuY3Rpb24oaGFzaCwgZnJvbSl7IHJldHVybiAoaGFzaCA+Pj4gZnJvbSkgJiAweDAxZiB9XG5cbi8vIFN0cmluZywgSW50LCBGdW5jdGlvbiAtPiBJbnRcbi8vIGdldHMgYSBjaHVuayBvZiBhIGhhc2gsIGdpdmVuIGEgc3RyaW5nIGFuZCBhIGhhc2hpbmcgZnVuY3Rpb25cbi8vIHRoZSBoYXNoaW5nIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSAzMiBiaXQgaGFzaC5cbnZhciBoYXNoTWFzayA9IGZ1bmN0aW9uKHN0ciwgZnJvbSwgaGFzaCl7XG4gICAgcmV0dXJuIG1hc2soaGFzaChzdHIpLCBmcm9tKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0aGFzaDogcmVxdWlyZSgnc3RyaW5nLWhhc2gnKSxcblx0bWFzazogaGFzaE1hc2tcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKVxudmFyIGhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxudmFyIGxpYiA9IG1vZHVsZS5leHBvcnRzXG5cbi8vIyBwZXJzaXN0ZW50IEhhc2ggVHJpZVxuXG4vLyBBIFRyaWUgaXMgYSBzcGVjaWFsaXNlZCB2ZXJzaW9uIG9mIGEgVHJlZSwgaW4gd2hpY2ggbm9kZXMgY2FuIGJlIGZvdW5kIGJ5IG5hdmlnYXRpbmcgYSAncGF0aCcuXG4vLyBGb3IgaW5zdGFuY2UsIGEgZGljdGlvbmFyeSBUcmllIG1heSBzdGFydCB3aXRoIGEgcm9vdCBub2RlLCBoYXZlIEEtWiBhcyB0aGUgY2hpbGQgbm9kZXMuXG4vLyBUaG9zZSBjaGlsZCBub2RlcyBtYXkgYWxzbyBiZSBUcmllcyAoY29tbW9ubHkgcmVmZXJyZWQgdG8gYXMgc3ViLVRyaWVzKS4gIFRoZXJlZm9yZSwgaWZcbi8vIHlvdSB3YW50IHRvIGxvb2sgdXAgJ0FOVCcsIHlvdSBjYW4gc2VlIGlmIGl0J3MgaW4gdGhlIFRyaWUgYnkgbmF2aWdhdGluZyB0byBub2RlIEEsIHRoZW4gdG9cbi8vIG5vZGUgQSdzIGNoaWxkIG5vZGUgTiwgdGhlbiB0byB0aGF0IG5vZGUncyBjaGlsZCBub2RlIFQuICBpLmUuIHRoZSBwYXRoIGZvciBBTlQgaXMgQS0+Ti0+VFxuXG4vLyBBIEhhc2ggVHJpZSBmb3JtcyBpdHMgcGF0aCBieSB0YWtpbmcgYSBoYXNoIG9mIHRoZSBzdHJpbmcgdGhhdCBpcyBiZWluZyBsb29rZWQgdXAsIGFuZFxuLy8gc3BsaXR0aW5nIHRoYXQgaW50byBwYXJ0czpcbi8vIEFOVCA9IDAxMTAxMTAxMTAxMTEwMTExMDEwMTExMDExMDAwMDExID0gMDExMDEtPjEwMTEwLT4xMTEwMS0+MTEwMTAtPjExMTAxLT4xMDAwMC0+MTFcbi8vIEluIHRoaXMgc2NoZW1lLCBhIDMyLWJpdCBoYXNoIGlzIHRha2VuLCBhbmQgc3BsaXQgaW50byBwYXRoIHBhcnRzIHRoYXQgYXJlIG1heGltYWxseVxuLy8gNSBiaXRzIGxvbmcuICBFYWNoIFRyaWUgdGhlcmVmb3JlIGhhcyBjaGlsZHJlbiBmcm9tIDAwMDAwLTExMTExIChvciAwLTMxIGluIGRlY2ltYWwpLlxuXG4vLyBIYXNoIFRyaWVzIGFsbG93IHVzIHRvIHN0b3JlIG5vZGVzIGF0IGEgc2hhbGxvdyBkZXB0aC4gIEZvciBpbnN0YW5jZSwgaWYgdGhlcmUgaXMgb25seVxuLy8gb25lIG1lbWJlciBvZiB0aGUgVHJpZSB3aG9zZSBrZXkncyBmaXJzdCBwYXRoIHBhcnQgaXMgMDExMDEsIHRoZW4gd2UgY2FuIHN0b3JlIHRoZSB2YWx1ZVxuLy8gZGlyZWN0bHkgYXMgdGhlIHJvb3QgVHJpZSdzIDAxMTAxIGNoaWxkIG5vZGUuICBXaHkgZ28gZGVlcGVyPyAgSXQganVzdCBjb3N0cyBtb3JlIHRvIHJldHJpZXZlLlxuXG4vLyBJdCBhbHNvIGFsbG93cyB1cyB0byBrZWVwIHRoZSBUcmllIGZhaXJseSBiYWxhbmNlZDsgc2luY2UgYSBoYXNoIGZ1bmN0aW9uIHNob3VsZCBiZVxuLy8gaGF2ZSBhbiBldmVuIGRpc3RyaWJ1dGlvbiBvZiBoYXNoZXMsIGV2ZW4gaWYgdGhlIGlucHV0cyBzaGFyZSBjb21tb24gcHJlZml4ZXMuXG4vLyBJZiB3ZSB1c2VkIHRoZSBmaXJzdCAyIGxldHRlcnMgb2YgYSB3b3JkLCBmb3IgaW5zdGFuY2UsIHdlJ2QgZW5kIHVwIHdpdGggbG90cyBvZlxuLy8gbm9kZXMgaW4gdGhlICd1bicgYW5kICd0aCcgcGF0aHMsIGFuZCBub3QgbWFueSBpbiB0aGUgJ3R4JyBwYXRoLlxuXG4vLyBBbiBwZXJzaXN0ZW50IEhhc2ggVHJpZSBpcyBhIEhhc2ggVHJpZSBpbiB3aGljaCBhbnkgY29tbW9ubHkgdXBkYXRpbmcgYWN0aW9ucyAtIHJlbW92aW5nLFxuLy8gc2V0dGluZyBvciBhZGRpbmcgdmFsdWVzIC0gcHJvZHVjZSBhbiBlbnRpcmVseSBuZXcgSGFzaCBUcmllLCBhbmQgKmRvbid0KiBhZmZlY3QgdGhlXG4vLyBvcmlnaW5hbCBpbiBhbnkgd2F5LiAgVGhpcyBtZWFucyB0aGF0IHRoZSBIYXNoIFRyaWVzIGNhbiBiZSBzaGFyZWQgc2FmZWx5OyB3aXRob3V0IGZlYXJcbi8vIHRoYXQgdXBkYXRpbmcgdGhlbSB3aWxsIHJlc3VsdCBpbiBhIHZhbHVlIGNoYW5naW5nIGluIG11bHRpcGxlIHBsYWNlcyBpbiBhIHByb2dyYW0uXG5cbi8vIFRvIG1ha2UgdGhpcyBkaXN0aW5jdGlvbiBjbGVhcmVyLCB0aGUgdmVyYnMgJ3NldCcgYW5kICdyZW1vdmUvZGVsZXRlJyBoYXZlIGJlZW4gcmVwbGFjZWRcbi8vIHdpdGggYXNzb2MgKGFzc29jaWF0ZSBhIG5ldyB2YWx1ZSB3aXRoIGFuIHBlcnNpc3RlbnQgSGFzaCBUcmllKSwgYW5kIGRpc3NvYyAoZGlzc29jaWF0ZVxuLy8gYW4gZXhpc3RpbmcgdmFsdWUgd2l0aCBhbiBwZXJzaXN0ZW50IEhhc2ggVHJpZSkuXG5cblxuXG4vLyB0byBhbGxvdyBob29rcyBmb3Igb3RoZXIgaW1wbGVtZW50YXRpb25zL3Rlc3RzIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0XG4vLyBoYXNoIGFuZCBlcXVhbGl0eSBmdW5jdGlvbnMgKHdoaWNoIGFyZSB0aGUgbmVjZXNzYXJ5IG9uZXMgZm9yIGNyZWF0aW5nXG4vLyBoYXNoLXRhYmxlLWxpa2UgYmVoYXZpb3VyLCBhcyB0aGUgaGFzaC10cmllIGhhcyksIHRoZXkgY2FuIGJlIHBhc3NlZCBpblxuLy8gYXMgb3B0cyB0byBhc3NvYy9kaXNzb2MvZ2V0L2hhcy5cblxuLy8gVGhlc2UgZGVmYXVsdHMgY292ZXIgdGhlIH44MCUgdXNlIGNhc2Ugb2YgdW5vcmRlcmVkIHN0cmluZzp2YWwgcGFpcnMuXG52YXIgZGVmYXVsdE9wdHMgPSB7XG4gICAgZXEgICA6IGZ1bmN0aW9uKGEsIGIpeyByZXR1cm4gYSA9PT0gYiB9LFxuICAgIGhhc2ggOiBoYXNoLmhhc2hcbn1cblxuLy8jIE5vZGUgVHlwZXNcblxuLy8gT2JqZWN0IC0+IFRyaWVcbi8vIGEgVHJpZSBpcyBhIHN0b3JlIG9mIGNoaWxkcmVuIHZhbHVlczsgdGhlIG1vc3QgYmFzaWMgdHlwZSBvZiBub24tbGVhZiBub2RlLlxudmFyIFRyaWUgPSBsaWIuVHJpZSA9IGZ1bmN0aW9uKGNoaWxkcmVuKXtcbiAgICByZXR1cm4geyB0eXBlOiAndHJpZScsIGNoaWxkcmVuOiBjaGlsZHJlbiB8fCB7fSB9XG59XG5cbi8vIFN0cmluZywgSlNWYWx1ZSAtPiBWYWx1ZVxuLy8gTm9kZSB0aGF0IHJlcHJlc2VudHMgYSBzcGVjaWZpYyB2YWx1ZVxudmFyIFZhbHVlID0gbGliLlZhbHVlID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSl7XG4gICAgcmV0dXJuIHsgdHlwZTogJ3ZhbHVlJywga2V5OiBrZXksIHZhbHVlOiB2YWx1ZSB9XG59XG5cbi8vIHsgSlNWYWx1ZSB9IC0+IEhhc2htYXBcbi8vIGEgVHJpZSB3aWxsIGhhdmUgYSBtYXggZGVwdGggb2YgNyAoNiwgaWYgMCBpbmRleGVkKS4gIEFmdGVyIHRoYXQsIGFkZGl0aW9uYWxcbi8vIHZhbHVlcyB3aWxsIGp1c3Qgc2x1bmcgaW50byBhIGhhc2htYXAgbm9kZVxudmFyIEhhc2htYXAgPSBsaWIuSGFzaG1hcCA9IGZ1bmN0aW9uKHZhbHVlcyl7XG4gICAgcmV0dXJuIHsgdHlwZTogJ2hhc2htYXAnLCB2YWx1ZXM6IHZhbHVlcyB9XG59XG5cblxuLy8jIEJhc2ljIG1hbmlwdWxhdGlvbiBmdW5jdGlvbnMgLSBoYXMvZ2V0L2Fzc29jL2Rpc3NvY1xuXG4vLyBPYmplY3QsIFN0cmluZywgSlNWYWx1ZSAtPiBPYmplY3RcblxuLy8gY3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYW4gb2JqZWN0LCBhZGRpbmcgb3IgcmVwbGFjaW5nIGEga2V5OnZhbCBwYWlyXG4vLyB3aXRoIHRoZSBvbmUgcHJvdmlkZWRcblxuLy8gbmVjZXNzYXJ5IGZvciB1cGRhdGluZyBub2RlcyBpbiBgYXNzb2NgXG52YXIgY29weUFkZCA9IGZ1bmN0aW9uKG9iaiwga2V5LCB2YWwpe1xuICAgIG9iaiA9IHV0aWwuY2xvbmUob2JqKVxuICAgIG9ialtrZXldID0gdmFsXG4gICAgcmV0dXJuIG9ialxufVxuXG5cbi8vICBOb2RlLCBTdHJpbmcsIEpTVmFsdWUsIChJbnQpIC0+IFRyaWVcblxuLy8gYXNzb2MgJ2Fzc29jaWF0ZXMnIGEgbmV3IHZhbHVlIHdpdGggYSBUcmllLiAgSXQgZG9lcyBzbyBieSBmaW5kaW5nIHRoZVxuLy8gYXBwcm9wcmlhdGUgcGxhY2UgZm9yIHRoZSBuZXcgbm9kZSwgdGhlbiBjcmVhdGluZyBhIGNvcHkgb2YgdGhlIHBhcmVudFxuLy8gbm9kZXMsIGFkZGluZyBpbiBhIHJlZmVyZW5jZSB0byB0aGUgbmV3bHkgY3JlYXRlZCBjaGlsZCBub2RlIGVhY2ggdGltZS5cblxuLy8gVGhpcyBpcyBjYWxsZWQgcGF0aC1jb3B5aW5nLCBzaW5jZSB0aGUgcGF0aCBmcm9tIHRoZSByb290IG5vZGUgdG8gdGhlIG5ld1xuLy8gbm9kZSBpcyBjb3BpZWQgZm9ybSBvbmUgZGF0YXN0cnVjdHVyZSB0byB0aGUgb3RoZXIuICBTaW5jZSB0aGUgdmFzdCBtYWpvcml0eVxuLy8gb2YgZGF0YSB3aWxsIGxpZSBpbiBub2RlcyBiZW5lYXRoZSB0aGVzZSBpbiBzaXphYmxlIGRhdGFzdHJ1Y3R1cmVzLCB0aGlzIHNoYXJpbmdcbi8vIG9mIGRhdGEgYWxsb3dzIGZvciBwZXJzaXN0ZW50IHZhbHVlcyB0byBiZSB1cGRhdGVkIHJlbGF0aXZlbHkgZWZmZWNpZW50bHkgYXQgbGFyZ2Vcbi8vIHNpemUuXG5cbi8vIFRoZSBhbGdvcml0aG0gaXMgYWxzbyBhd2FyZSBvZiAnc3BlY2lmaWNpdHknOyBpLmUuIHRoYXQgYSB2YWx1ZSBuZWVkIG9ubHkgYmUgc3RvcmVkXG4vLyBhdCBhIGRlcHRoIHdoZXJlIGl0IGNhbiBiZSBkaXN0aW5ndWlzaGVkIHVuaXF1ZWx5IGZyb20gb3RoZXIgdmFsdWVzIGJ5IHZpcnR1ZSBvZiBpdHNcbi8vIHBhdGguICBJZiBib3RoICdmb28nIGFuZCAnYmFyJ3MgZmlyc3QgNSBiaXRzIGFyZSAwMTEwMTEsIGFuZCBib3RoIGFyZSBwcmVzZW50IGluIHRoZVxuLy8gVHJpZSwgdGhlbiB0aGV5IG1vc3QgYmUgc3RvcmVkIGluIGEgc3ViLVRyaWUsIGFuZCB1c2UgdGhlIGZvbGxvd2luZyA1IGJpdHMgdG8gZGlmZmVyZW5jaWF0ZVxuLy8gdGhlbXNlbHZlcy4gIElmIHRoZSBUcmllIGdldHMgZGVlcGVyIHRoYW4gdGhlcmUgYXJlIGJpdHMgaW4gdGhlIGhhc2ggKGkuZS4gYSB0b3RhbCBoYXNoIGNvbGxpc2lvbilcbi8vIHRoZW4gaXQgc2ltcGx5IHN0b3JlcyB0aGUgb2JqZWN0cyBpbiBhIEhhc2htYXAgbm9kZS5cbmxpYi5hc3NvYyA9IGZ1bmN0aW9uKG5vZGUsIGtleSwgdmFsLCBvcHRzKXtcbiAgICByZXR1cm4gYXNzb2Mobm9kZSwga2V5LCB2YWwsIG9wdHMgfHwgZGVmYXVsdE9wdHMsIDApXG59XG5cbnZhciBhc3NvYyA9IGZ1bmN0aW9uKG5vZGUsIGtleSwgdmFsLCBvcHRzLCBkZXB0aCl7XG4gICAgcmV0dXJuIGFzc29jRm5zW25vZGUudHlwZV0obm9kZSwga2V5LCB2YWwsIG9wdHMsIGRlcHRoKVxufVxuXG52YXIgYXNzb2NGbnMgPSB7XG4gICAgdHJpZTogZnVuY3Rpb24obm9kZSwga2V5LCB2YWwsIG9wdHMsIGRlcHRoKXtcbiAgICAgICAgdmFyIHBhdGggPSBoYXNoLm1hc2soa2V5LCBkZXB0aCwgb3B0cy5oYXNoKVxuICAgICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW3BhdGhdXG5cbiAgICAgICAgaWYgKCBjaGlsZCA9PT0gdW5kZWZpbmVkICApIHJldHVybiBUcmllKGNvcHlBZGQobm9kZS5jaGlsZHJlbiwgcGF0aCwgVmFsdWUoa2V5LCB2YWwpKSlcbiAgICAgICAgZWxzZSAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBUcmllKGNvcHlBZGQobm9kZS5jaGlsZHJlbiwgcGF0aCwgYXNzb2MoY2hpbGQsIGtleSwgdmFsLCBvcHRzLCBkZXB0aCArIDEpKSlcbiAgICB9LFxuICAgIHZhbHVlOiBmdW5jdGlvbihub2RlLCBrZXksIHZhbCwgb3B0cywgZGVwdGgpe1xuICAgICAgICB2YXIgbm9kZVBhdGggPSBoYXNoLm1hc2sobm9kZS5rZXksIGRlcHRoLCBvcHRzLmhhc2gpXG4gICAgICAgIHZhciBrZXlQYXRoICA9IGhhc2gubWFzayhrZXksIGRlcHRoLCBvcHRzLmhhc2gpXG5cbiAgICAgICAgdmFyIG1ha2VIYXNobWFwID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHt9XG4gICAgICAgICAgICBjaGlsZHJlbltrZXldID0gVmFsdWUoa2V5LCB2YWwpXG4gICAgICAgICAgICBjaGlsZHJlbltub2RlLmtleV0gPSBub2RlXG4gICAgICAgICAgICByZXR1cm4gSGFzaG1hcChjaGlsZHJlbilcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXNvbHZlU2hhbGxvd0NvbmZsaWN0ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHt9XG4gICAgICAgICAgICBjaGlsZHJlbltub2RlUGF0aF0gPSBub2RlXG4gICAgICAgICAgICBjaGlsZHJlbltrZXlQYXRoXSAgPSBWYWx1ZShrZXksIHZhbClcblxuICAgICAgICAgICAgcmV0dXJuIFRyaWUoY2hpbGRyZW4pXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzb2x2ZURlZXBDb25mbGljdCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB7fVxuICAgICAgICAgICAgY2hpbGRyZW5ba2V5UGF0aF0gPSBhc3NvYyhub2RlLCBrZXksIHZhbCwgb3B0cywgZGVwdGggKyAxKVxuICAgICAgICAgICAgcmV0dXJuIFRyaWUoY2hpbGRyZW4pXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWFrZVRyaWUgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgaWYgKCBub2RlUGF0aCAhPT0ga2V5UGF0aCApIHJldHVybiByZXNvbHZlU2hhbGxvd0NvbmZsaWN0KClcbiAgICAgICAgICAgIGVsc2UgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZURlZXBDb25mbGljdCgpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIG9wdHMuZXEobm9kZS5rZXksIGtleSkgKSByZXR1cm4gVmFsdWUoa2V5LCB2YWwpXG4gICAgICAgIGVsc2UgaWYgKCBkZXB0aCA+IDYgKSAgICAgICAgIHJldHVybiBtYWtlSGFzaG1hcCgpXG4gICAgICAgIGVsc2UgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlVHJpZSgpXG4gICAgfSxcbiAgICBoYXNobWFwOiBmdW5jdGlvbihub2RlLCBrZXksIHZhbCwgb3B0cywgZGVwdGgpe1xuICAgICAgICB2YXIgdiA9IGNvcHlBZGQobm9kZS52YWx1ZXMsIGtleSwgVmFsdWUoa2V5LCB2YWwpKVxuICAgICAgICByZXR1cm4gSGFzaG1hcCh2KVxuICAgIH1cbn1cblxuLy8gT2JqZWN0LCBTdHJpbmcgLT4gT2JqZWN0XG5cbi8vIGNyZWF0ZXMgYSBuZXcgb2JqZWN0LCBidXQgd2l0aG91dCBhIGtleS5cbi8vIFVzZWQgaW4gYGRpc3NvY2BcbnZhciBjb3B5RGlzc29jID0gZnVuY3Rpb24ob2JqLCBrZXkpe1xuICAgIG9iaiA9IHV0aWwuY2xvbmUob2JqKVxuICAgIGRlbGV0ZSBvYmpba2V5XVxuICAgIHJldHVybiBvYmpcbn1cblxuXG4vLyBOb2RlLCBTdHJpbmcsIChJbnQpIC0+IFRyaWVcblxuLy8gZGlzc29jIChkaXNhc3NvY2lhdGUpIHJldHVybnMgYSBuZXcgVHJpZSwgYnV0IHdpdGhvdXQgYSBzcGVjaWZpZWQga2V5XG5cbi8vIEFzIHdpdGggYXNzb2MsIGl0IHJlY3Vyc2VzIGRvd24gdGhlIFRyaWUuICBJZiBpdCBmYWlscyB0byBmaW5kIGEga2V5LCB0aGVuXG4vLyBpdCByZXR1cm5zIHRoZSBvcmlnaW5hbCBUcmllLCBzaW5jZSB0aGF0IGlzIGNvbmNlcHR1YWxseSB0aGUgc2FtZSBhcyByZW1vdmluZ1xuLy8gYSBub24tZXhpc3RhbnQga2V5IGZyb20gYW4gb2JqZWN0LlxuXG4vLyBJZiBpdCBmaW5kcyBhIFZhbHVlIGFzc29jaWF0ZWQgd2l0aCBhIGtleSwgaG93ZXZlciwgaXQgd2lsbCBjcmVhdGVcbi8vIGEgcGFyZW50IG5vZGUgdG8gdGhhdCBWYWx1ZSB0aGF0IGNvcGllcyBhbGwgKm90aGVyKiB2YWx1ZXMsIGJ1dCBvbWl0c1xuLy8gdGhlIHZhbHVlIHdpdGggdGhlIGtleSBpbiBxdWVzdGlvbi4gIEFzIHdpdGggYXNzb2MsIGl0IHdpbGwgYWxzbyBwcm9kdWNlIGFcbi8vIGNvcHkgb2YgKml0cyogcGFyZW50LiAgVGhpcyBvY2N1cnMgcmVjdXJzaXZlbHksIGFuZCBpcyBleGFjdGx5IHRoZSBzYW1lIGNvbmNlcHRcbi8vIGFzIHRoZSAncGF0aCBjb3B5aW5nJyB0ZWNobmlxdWUgdXNlZCBpbiBhc3NvYy5cblxuLy8gSWYgcmVtb3ZpbmcgYSB2YWx1ZSByZW1vdmVzIGEgaGFzaCBjb2xsaXNpb24sIHRoZW4gdGhlIFRyaWUgbm9kZSB0aGF0IGNvbnRhaW5lZFxuLy8gdGhvc2UgdmFsdWVzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGp1c3QgYSBWYWx1ZSBub2RlLCB3aGljaCByZXN1bHRzIGluIGEgc2hhbGxvd2VyXG4vLyBUcmllLlxubGliLmRpc3NvYyA9IGZ1bmN0aW9uKG5vZGUsIGtleSwgb3B0cyl7XG4gICAgcmV0dXJuIGRpc3NvYyhub2RlLCBrZXksIG9wdHMgfHwgZGVmYXVsdE9wdHMsIDApXG59XG5cbnZhciBkaXNzb2MgPSBmdW5jdGlvbihub2RlLCBrZXksIG9wdHMsIGRlcHRoKXtcbiAgICByZXR1cm4gZGlzc29jRm5zW25vZGUudHlwZV0obm9kZSwga2V5LCBvcHRzLCBkZXB0aClcbn1cblxudmFyIGRpc3NvY0ZucyA9IHtcbiAgICB0cmllOiBmdW5jdGlvbihub2RlLCBrZXksIG9wdHMsIGRlcHRoKXtcbiAgICAgICAgdmFyIHBhdGggPSBoYXNoLm1hc2soa2V5LCBkZXB0aCwgb3B0cy5oYXNoKVxuICAgICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW3BhdGhdXG5cbiAgICAgICAgLy8gaGFuZGxlIHRoZSAncHJlc2VudCBrZXknIGNhc2VzLiAgSWYgaXQncyBhIFZhbHVlLCByZW1vdmUgaXQuICBJZiBpdCdzIGEgc3ViLVRyaWUgb3IgSGFzaG1hcFxuICAgICAgICAvLyByZWN1cnNlIHRvIHByZXZlbnQgb3RoZXIgdmFsdWVzIGZyb20gYmVpbmcgbG9zdFxuICAgICAgICB2YXIgZGlzc29jS2V5ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGlmICggY2hpbGQudHlwZSA9PT0gJ3ZhbHVlJyAmJiBvcHRzLmVxKGNoaWxkLmtleSwga2V5KSApXG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyaWUoY29weURpc3NvYyhub2RlLmNoaWxkcmVuLCBwYXRoKSlcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJpZShjb3B5RGlzc29jKG5vZGUuY2hpbGRyZW4sIHBhdGgsIGRpc3NvYyhjaGlsZCwga2V5LCBvcHRzLCBkZXB0aCArIDEpKSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZXJlJ3Mgb25seSBhIHNpbmdsZSB2YWx1ZSBpbiBhIFRyaWUgbm9kZSBsZWZ0LCB0aGVuIGl0IGNhbiBiZSByZXBsYWNlZCBieSBpdHMgdmFsdWUsXG4gICAgICAgIC8vIGFsbG93aW5nIHVzIHRvIG1ha2UgdGhlIFRyaWUgbW9yZSBzaGFsbG93LCBhbmQgdGhlcmVmb3JlIG1vcmUgZWZmZWNpZW50LlxuICAgICAgICB2YXIgY29sbGFwc2VUcmllID0gZnVuY3Rpb24odHJpZSl7XG4gICAgICAgICAgICB2YXIgbmFtZXMgPSB1dGlsLmtleXModHJpZS5jaGlsZHJlbilcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHRyaWUuY2hpbGRyZW5bbmFtZXNbMF1dXG5cbiAgICAgICAgICAgIC8vIGRvbid0IGNvbGxhcHNlIGFuIGVtcHR5IHJvb3QgdHJpZVxuICAgICAgICAgICAgaWYgKCBkZXB0aCA9PT0gMCApICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyaWVcbiAgICAgICAgICAgIGVsc2UgaWYgKCBjaGlsZCA9PT0gdW5kZWZpbmVkICkgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmllXG4gICAgICAgICAgICBlbHNlIGlmICggbmFtZXMubGVuZ3RoID09PSAxICYmIGNoaWxkLnR5cGUgPT09ICd2YWx1ZScgKSByZXR1cm4gVmFsdWUoY2hpbGQua2V5LCBjaGlsZC52YWx1ZSlcbiAgICAgICAgICAgIGVsc2UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmllXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGFuZGxlVHJpZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gY29sbGFwc2VUcmllKGRpc3NvY0tleShub2RlKSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZXJlJ3Mgbm8gY2hpbGQsIHJldHVybiB0aGUgbm9kZVxuICAgICAgICBpZiAoIGNoaWxkID09PSB1bmRlZmluZWQgKSAgcmV0dXJuIG5vZGU7XG4gICAgICAgIGVsc2UgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlVHJpZSgpO1xuICAgIH0sXG4gICAgdmFsdWU6IGZ1bmN0aW9uKCl7fSxcbiAgICBoYXNobWFwOiBmdW5jdGlvbihub2RlLCBrZXksIG9wdHMsIGRlcHRoKXtcbiAgICAgICAgdmFyIHJldCA9IGNvcHlEaXNzb2Mobm9kZS52YWx1ZXMsIGtleSlcbiAgICAgICAgdmFyIG5hbWVzID0gdXRpbC5rZXlzKHJldClcbiAgICAgICAgdmFyIGNoaWxkID0gcmV0W25hbWVzWzBdXVxuXG4gICAgICAgIGlmICggbmFtZXMubGVuZ3RoID09PSAxICkgcmV0dXJuIFZhbHVlKGNoaWxkLmtleSwgY2hpbGQudmFsdWUpXG4gICAgICAgIGVsc2UgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEhhc2htYXAocmV0KVxuICAgIH1cbn1cblxuXG4vLyBOb2RlLCBTdHJpbmcsIChJbnQpLCAoT2JqZWN0KS0+IEJvb2xcblxuLy8gVHJpZS1lcXVpdmFsZW50IG9mIHRoZSAnaW4nIG9wZXJhdG9yLlxuXG4vLyBIYXMgcmVjdXJzZXMgZG93biBhIG5vZGUsIHVzaW5nIGhhc2gubWFzayB0byBuYXZpZ2F0ZSBhICdwYXRoJyBkb3duIGJyYW5jaGVzLlxuLy8gSWYgYSB2YWx1ZSBub2RlIGlzIGZvdW5kLCBpZiBpdHMga2V5IGlzIGVxdWFsIHRvIHRoZSBrZXkgcHJvdmlkZWQsIHRoZW4gdGhlXG4vLyBUcmllIGNvbnRhaW5zIHRoZSBrZXksIGFuZCB0cnVlIGlzIHJldHVybmVkLlxuXG4vLyBIYXNobWFwcyBzdG9yZSB2YWx1ZXMgaW4gdGhlIG91dGVybW9zdCBsZWF2ZXMgd2hlbiBuZWNlc3NhcnkuICBJZiB0aGV5IGNvbnRhaW5cbi8vIGEga2V5LCBpdCBhbHNvIG1lYW5zIHRoYXQgdGhlIGtleSBpcyBpbiB0aGUgdHJpZSwuXG5saWIuaGFzID0gZnVuY3Rpb24odHJpZSwga2V5LCBvcHRzKXtcbiAgICByZXR1cm4gaGFzKHRyaWUsIGtleSwgb3B0cyB8fCBkZWZhdWx0T3B0cywgMClcbn1cblxudmFyIGhhcyA9IGZ1bmN0aW9uKHRyaWUsIGtleSwgb3B0cywgZGVwdGgpe1xuICAgIHJldHVybiBoYXNGbnNbdHJpZS50eXBlXSh0cmllLCBrZXksIG9wdHMsIGRlcHRoKVxufVxuXG52YXIgaGFzRm5zID0ge1xuICAgIHRyaWU6IGZ1bmN0aW9uKG5vZGUsIGtleSwgb3B0cywgZGVwdGgpe1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2hhc2gubWFzayhrZXksIGRlcHRoLCBvcHRzLmhhc2gpXVxuICAgICAgICBpZiAoIGNoaWxkID09PSB1bmRlZmluZWQgKSAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgZWxzZSAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhcyhjaGlsZCwga2V5LCBvcHRzLCBkZXB0aCArIDEpXG4gICAgfSxcbiAgICB2YWx1ZTogZnVuY3Rpb24obm9kZSwga2V5LCBvcHRzKXtcbiAgICAgICAgcmV0dXJuIG9wdHMuZXEobm9kZS5rZXksIGtleSlcbiAgICB9LFxuICAgIGhhc2htYXA6IGZ1bmN0aW9uKG5vZGUsIGtleSwgb3B0cyl7XG4gICAgICAgIHJldHVybiBrZXkgaW4gbm9kZS52YWx1ZXNcbiAgICB9XG59XG5cbi8vIE5vZGUsIFN0cmluZywgKEludCksIChPYmplY3QpIC0+IFZhbHVlXG5cbi8vIFRyaWUtZXF1aXZhbGVudCBvZiBkb3Qgb3IgYnJhY2tldCBzeW50YXggLSByZXRyaWV2ZXMgYSB2YWx1ZSBhc3NvY2FpdGVkIHdpdGggYSBrZXlcbi8vIG9yIHVuZGVmaW5lZC5cblxuLy8gZ2V0IHJlY3Vyc2VzIGRvd24gdGhlIFRyaWUsIHNpbWlsYXJseSB0byBoYXMuICBJZiBpdCBmaW5kcyBhIG1hdGNoaW5nIGtleSwgaW5zdGVhZFxuLy8gb2YgcmV0dXJuaW5nIHRydWUgb3IgZmFsc2UsIGhvd2V2ZXIsIGl0IHVucGFja3MgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5XG4vLyBhbmQgcmV0dXJucyB0aGF0IGluc3RlYWQuXG5saWIuZ2V0ID0gZnVuY3Rpb24odHJpZSwga2V5LCBvcHRzKXtcbiAgICByZXR1cm4gZ2V0KHRyaWUsIGtleSwgb3B0cyB8fCBkZWZhdWx0T3B0cywgMClcbn1cblxudmFyIGdldCA9IGZ1bmN0aW9uKHRyaWUsIGtleSwgb3B0cywgZGVwdGgpe1xuICAgIHJldHVybiBnZXRGbnNbdHJpZS50eXBlXSh0cmllLCBrZXksIG9wdHMsIGRlcHRoKVxufVxuXG52YXIgZ2V0Rm5zID0ge1xuICAgIHRyaWU6IGZ1bmN0aW9uKG5vZGUsIGtleSwgb3B0cywgZGVwdGgpe1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2hhc2gubWFzayhrZXksIGRlcHRoLCBvcHRzLmhhc2gpXVxuICAgICAgICBpZiAoIGNoaWxkID09PSB1bmRlZmluZWQgKSAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGVsc2UgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXQoY2hpbGQsIGtleSwgb3B0cywgZGVwdGggKyAxKVxuICAgIH0sXG4gICAgdmFsdWU6IGZ1bmN0aW9uKG5vZGUsIGtleSwgb3B0cywgZGVwdGgpe1xuICAgICAgICBpZiAoIG9wdHMuZXEobm9kZS5rZXksIGtleSkgKSByZXR1cm4gbm9kZS52YWx1ZVxuICAgIH0sXG4gICAgaGFzaG1hcDogZnVuY3Rpb24obm9kZSwga2V5LCBvcHRzLCBkZXB0aCl7XG4gICAgICAgIHZhciB2YWx1ZSA9IG5vZGUudmFsdWVzW2tleV1cbiAgICAgICAgcmV0dXJuICB2YWx1ZSA/IHZhbHVlLnZhbHVlIDogdW5kZWZpbmVkXG5cbiAgICB9XG59XG5cblxuXG4vLyBOb2RlLCAoQW55LCBBbnksIFN0cmluZyksIEFueSAtPiBBbnlcblxuLy8gZ2l2ZW4gYSBub2RlLCBmdW5jdGlvbiBhbmQgc2VlZCwgcmVkdWNlIHRvIHByb2R1Y2UgcmVzdWx0cy5cbmxpYi5yZWR1Y2UgPSBmdW5jdGlvbihub2RlLCBjYWxsYmFjaywgaW5pdGlhbCl7XG4gICAgdmFyIHN0YXRlID0gcmVkdWNlKG5vZGUsIGNhbGxiYWNrLCBpbml0aWFsKVxuICAgIHJldHVybiBzdGF0ZSBpbnN0YW5jZW9mIEJyZWFrID8gc3RhdGUudmFsdWUgOiBzdGF0ZVxufVxuXG52YXIgcmVkdWNlID0gZnVuY3Rpb24obm9kZSwgY2FsbGJhY2ssIGluaXRpYWwpIHtcbiAgICByZXR1cm4gcmVkdWNlRm5zW25vZGUudHlwZV0obm9kZSwgY2FsbGJhY2ssIGluaXRpYWwpXG59XG5cbnZhciByZWR1Y2VGbnMgPSB7XG4gICAgdHJpZTogZnVuY3Rpb24obm9kZSwgY2FsbGJhY2ssIHN0YXRlKSB7XG4gICAgICAgIGZvciAoIHZhciBwYXRoIGluIG5vZGUuY2hpbGRyZW4gKSB7XG4gICAgICAgICAgICBpZiAoIG5vZGUuY2hpbGRyZW4uaGFzT3duUHJvcGVydHkocGF0aCkgKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSByZWR1Y2Uobm9kZS5jaGlsZHJlbltwYXRoXSwgY2FsbGJhY2ssIHN0YXRlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlIGluc3RhbmNlb2YgQnJlYWspIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlXG4gICAgfSxcbiAgICB2YWx1ZTogZnVuY3Rpb24obm9kZSwgY2FsbGJhY2ssIHN0YXRlKXtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHN0YXRlLCBub2RlLnZhbHVlLCBub2RlLmtleSlcbiAgICB9LFxuICAgIGhhc2htYXA6IGZ1bmN0aW9uKG5vZGUsIGNhbGxiYWNrLCBzdGF0ZSl7XG4gICAgICAgIGZvciAoIHZhciBrZXkgaW4gbm9kZS52YWx1ZXMgKSB7XG4gICAgICAgICAgICBpZiAoIG5vZGUudmFsdWVzLmhhc093blByb3BlcnR5KGtleSkgKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSByZWR1Y2Uobm9kZS52YWx1ZXNba2V5XSwgY2FsbGJhY2ssIHN0YXRlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlIGluc3RhbmNlb2YgQnJlYWspIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlXG4gICAgfVxufVxuXG5cbnZhciBCcmVhayA9IGxpYi5yZWR1Y2UuQnJlYWsgPSBmdW5jdGlvbih2KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJyZWFrKSkgcmV0dXJuIG5ldyBCcmVhayh2KVxuICAgIHRoaXMudmFsdWUgPSB2XG59XG5cblxuXG4vLyBOb2RlIC0+IE9iamVjdFxuXG4vLyBtdXRhYmxlIHJldHVybnMgYSBtdXRhYmxlIHZlcnNpb24gb2YgYSBUcmllLlxuXG4vLyBJdCBhY2hpZXZlcyB0aGlzIGJ5IHJlY3Vyc2luZyBkb3duIHRoZSBUcmllLCBmaW5kaW5nIGFsbCB0aGUgVmFsdWUgbm9kZXNcbi8vICh3aGV0aGVyIHN0b3JlZCBpbiBhIFRyaWUgZGlyZWN0bHksIG9yIGluIGEgSGFzaG1hcCBub2RlKSwgYW5kIGFkZGluZ1xuLy8gdGhlIHZhbHVlcyB0byBhIHJldHVybiB2YWx1ZS5cblxuLy8gICh5YXkgYWJ1c2luZyBtdXRhYmlsaXR5IGluIHNtYWxsIHBpZWNlcywgYnV0IGtlZXBpbmcgdGhlIGZ1bmN0aW9uXG4vLyBwdXJlIGZyb20gYW4gQVBJIHBlcnNwZWN0aXZlKVxubGliLm11dGFibGUgPSBmdW5jdGlvbihub2RlKXtcbiAgICByZXR1cm4gbGliLnJlZHVjZShub2RlLCBhZGRLZXlWYWwsIHt9KVxufVxuXG52YXIgYWRkS2V5VmFsID0gZnVuY3Rpb24obywgdmFsLCBrZXkpe1xuICAgIG9ba2V5XSA9IHZhbFxuICAgIHJldHVybiBvXG59XG5cbi8vIE5vZGUgLT4gW1N0cmluZ11cblxuLy8ga2V5cyByZXR1cm5zIHRoZSBrZXlzIHN0b3JlZCBpbiB0aGUgYXJyYXksIGxpa2UgT2JqZWN0LmtleXNcbmxpYi5rZXlzID0gZnVuY3Rpb24obm9kZSl7XG4gICAgcmV0dXJuIGxpYi5yZWR1Y2Uobm9kZSwgYWRkS2V5LCBbXSlcbn1cblxudmFyIGFkZEtleSA9IGZ1bmN0aW9uKGFyciwgdmFsLCBrZXkpe1xuICAgIGFyci5wdXNoKGtleSlcbiAgICByZXR1cm4gYXJyXG59XG4iLCIndXNlIHN0cmljdCdcblxuLy8gSW50ZXJuYWxcbnZhciBleHRlbmQgICA9IGZ1bmN0aW9uKHQsIGYpIHsgZm9yICggdmFyIHAgaW4gZiApIHRbcF0gPSBmW3BdOyByZXR1cm4gdCB9XG52YXIgY2xvbmUgICAgPSBmdW5jdGlvbihvKXsgcmV0dXJuIGV4dGVuZCh7fSwgbykgfVxudmFyIHNsaWNlICAgID0gZnVuY3Rpb24oYSwgZiwgbil7IHJldHVybiBbXS5zbGljZS5jYWxsKGEsIGYsIG4pIH1cblxudmFyIG1hcE9iaiA9IGZ1bmN0aW9uKG8sIGZuKXtcbiAgICB2YXIgciA9IHt9XG4gICAgZm9yICggdmFyIHAgaW4gbyApIHJbcF0gPSBmbihvW3BdLCBwLCBvKVxuICAgIHJldHVybiByXG59XG5cbnZhciBtYXAgPSBmdW5jdGlvbihhcnIsIGZuKXtcbiAgICB2YXIgYSA9IFtdXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gYXJyLmxlbmd0aDsgaSA8IGw7IGkgKz0gMSApIGEucHVzaChmbihhcnJbaV0sIGksIGFycikpXG4gICAgcmV0dXJuIGFcbn1cblxudmFyIHJlZHVjZSA9IGZ1bmN0aW9uKGFyciwgZm4pe1xuICAgIHZhciBzZWVkID0gYXJyWzBdXG4gICAgYXJyID0gYXJyLnNsaWNlKDEpXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gYXJyLmxlbmd0aDsgaSA8IGw7IGkgKz0gMSkgc2VlZCA9IGZuKHNlZWQsIGFycltpXSlcbiAgICByZXR1cm4gc2VlZFxufVxuXG52YXIgcGljayA9IGZ1bmN0aW9uKG8pe1xuICAgIHZhciBuYW1lcyA9IHNsaWNlKGFyZ3VtZW50cywgMSksXG4gICAgICAgIHIgICAgID0ge31cblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IG5hbWVzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMSApXG4gICAgICAgIHJbbmFtZXNbaV1dID0gb1tuYW1lc1tpXV1cbiAgICByZXR1cm4gclxufVxuXG4vLyBPYmplY3QgLT4gW1N0cmluZ11cblxuLy8gZ2V0IHRoZSBrZXlzIG9mIGFuIG9iamVjdFxudmFyIGtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbihvKXtcbiAgICB2YXIgYSA9IFtdXG4gICAgZm9yICggdmFyIGtleSBpbiBvICkgYS5wdXNoKGtleSlcbiAgICByZXR1cm4gYVxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGV4dGVuZCAgICA6IGV4dGVuZCxcbiAgICBjbG9uZSAgICAgOiBjbG9uZSxcbiAgICBzbGljZSAgICAgOiBzbGljZSxcbiAgICBtYXBPYmogICAgOiBtYXBPYmosXG4gICAgcGljayAgICAgIDogcGljayxcbiAgICBtYXAgICAgICAgOiBtYXAsXG4gICAgcmVkdWNlICAgIDogcmVkdWNlLFxuICAgIGtleXMgICAgICA6IGtleXNcbn1cbiJdfQ==
;