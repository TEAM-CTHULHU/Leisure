// Generated by CoffeeScript 1.6.3
(function() {
  var BS, DEL, ENTER, HL_TAGS, Headline, KW_BOILERPLATE, KW_INFO, KW_NAME, Keyword, Meat, Results, Source, TAB, addKeyPress, astButton, atTextEnd, atTextStart, baseEnv, bindContent, borderRE, boundarySpan, bsWillDestroyParent, checkCollapsed, checkEnterReparse, checkExtraNewline, checkSourceMod, checkStart, commentButton, commentHtml, content, contentSpan, createResults, crossesHidden, curPos, currentLine, currentTextPosition, defaultBindings, defaultEnv, defaultMarkup, displaySource, executeDef, executeSource, executeText, fancyOrg, findKeyBinding, followingSpan, getOrgParent, getOrgType, getResultsForSource, handleMutation, headlineRE, invalidateOrgText, isCollapsed, keyFuncs, keywordRE, lastOrgOffset, lazy, lz, makeBoundary, markupGuts, markupNode, markupOrg, markupOrgWithNode, matchLine, matchLineAt, modifiers, modifyingKey, nextOrgId, optionalBoundary, orgAttrs, orgEnv, orgNotebook, parseOrgMode, parseTags, processResults, redrawAllIssues, redrawIssue, reprocessResults, resolve, root, rz, setCurKeyBinding, shouldCancelBS, shouldCancelDEL, srcStartRE, swapMarkup, toggleComment, _, _ref, _ref1, _ref2, _ref3;

  _ref = root = module.exports = require('./base'), resolve = _ref.resolve, lazy = _ref.lazy, defaultEnv = _ref.defaultEnv;

  rz = resolve;

  lz = lazy;

  _ref1 = require('./browserSupport'), TAB = _ref1.TAB, ENTER = _ref1.ENTER, BS = _ref1.BS, DEL = _ref1.DEL;

  _ref2 = require('./org'), keywordRE = _ref2.keywordRE, KW_BOILERPLATE = _ref2.KW_BOILERPLATE, KW_NAME = _ref2.KW_NAME, KW_INFO = _ref2.KW_INFO, srcStartRE = _ref2.srcStartRE, parseOrgMode = _ref2.parseOrgMode, Headline = _ref2.Headline, Meat = _ref2.Meat, Keyword = _ref2.Keyword, Source = _ref2.Source, Results = _ref2.Results, headlineRE = _ref2.headlineRE, HL_TAGS = _ref2.HL_TAGS, parseTags = _ref2.parseTags, matchLine = _ref2.matchLine;

  _ref3 = require('./orgSupport'), orgNotebook = _ref3.orgNotebook, parseOrgMode = _ref3.parseOrgMode, orgAttrs = _ref3.orgAttrs, content = _ref3.content, contentSpan = _ref3.contentSpan, checkStart = _ref3.checkStart, optionalBoundary = _ref3.optionalBoundary, boundarySpan = _ref3.boundarySpan, displaySource = _ref3.displaySource, checkEnterReparse = _ref3.checkEnterReparse, checkCollapsed = _ref3.checkCollapsed, checkExtraNewline = _ref3.checkExtraNewline, followingSpan = _ref3.followingSpan, currentLine = _ref3.currentLine, checkSourceMod = _ref3.checkSourceMod, isCollapsed = _ref3.isCollapsed, nextOrgId = _ref3.nextOrgId, modifyingKey = _ref3.modifyingKey, getOrgParent = _ref3.getOrgParent, getOrgType = _ref3.getOrgType, orgEnv = _ref3.orgEnv, executeText = _ref3.executeText, getResultsForSource = _ref3.getResultsForSource, swapMarkup = _ref3.swapMarkup, modifiers = _ref3.modifiers, keyFuncs = _ref3.keyFuncs, defaultBindings = _ref3.defaultBindings, addKeyPress = _ref3.addKeyPress, findKeyBinding = _ref3.findKeyBinding, invalidateOrgText = _ref3.invalidateOrgText, setCurKeyBinding = _ref3.setCurKeyBinding;

  redrawAllIssues = require('./storage').redrawAllIssues;

  _ = require('./lodash.min');

  lastOrgOffset = -1;

  curPos = -1;

  markupOrg = function(text) {
    var node, result, _ref4;
    _ref4 = markupOrgWithNode(text), node = _ref4[0], result = _ref4[1];
    return result;
  };

  markupOrgWithNode = function(text) {
    var nodes, org;
    nodes = {};
    if (text[text.length - 1] !== '\n') {
      text = text + '\n';
    }
    org = parseOrgMode(text);
    lastOrgOffset = -1;
    return [org, markupNode(org)];
  };

  borderRE = /[\n]+$/;

  makeBoundary = function(node) {
    var nls;
    nls = node.text.match(borderRE);
    if (nls) {
      return "<div class='boundary'>" + nls[0] + "</div>";
    } else {
      return "";
    }
  };

  markupNode = function(org) {
    var html, intertext, name, nameM, pos, res, src, srcContent, srcLead, srcM, srcTrail, text;
    if (org.offset <= lastOrgOffset) {
      return '';
    } else if (org instanceof Results) {
      pos = org.contentPos - org.offset;
      text = org.text.substring(pos);
      return "<span " + (orgAttrs(org)) + "><span data-org-type='text'>" + (org.text.substring(0, pos)) + "</span>" + (contentSpan(text));
    } else if (org instanceof Keyword) {
      if (org.name.match(/name/i)) {
        intertext = '';
        name = org;
        src = org.next;
        while (src instanceof Meat && !(src instanceof Source)) {
          intertext += src.text;
          src = src.next;
        }
        if (src instanceof Source) {
          lastOrgOffset = src.offset;
          nameM = name.text.match(keywordRE);
          srcM = src.text.match(srcStartRE);
          srcContent = src.content;
          srcLead = src.text.substring(0, src.contentPos - src.offset);
          srcTrail = src.text.substring(src.contentPos - src.offset + src.content.length);
          html = "<div class='codeblock' " + (orgAttrs(src)) + " data-org-codeblock='" + (name.info.trim()) + "'><div class='codename'><span class='hidden'>" + nameM[KW_BOILERPLATE] + "</span><div><larger><b>" + name.info + "</b></larger></div>" + intertext + "</div><div class='hidden'>" + srcLead + "</div><div class='codewrapper'><div class='codecontent'>" + srcContent + "<span class='hidden' data-org-type='boundary'>" + srcTrail + "</span></div>";
          res = src.next;
          intertext = '';
          while (res && !(res instanceof Results) && !(res instanceof Keyword)) {
            intertext += res.text;
            res = res.next;
          }
          if (res instanceof Results) {
            lastOrgOffset = res.offset;
            pos = res.contentPos - res.offset;
            html += "" + (intertext ? "<div class='hidden' data-org-type='boundary'>" + intertext + "</div>" : '') + "<div class='results-indicator' data-org-type='boundary'><span></span></div><div class='coderesults' " + (orgAttrs(res)) + "><span class='hidden'>" + (res.text.substring(0, pos)) + "</span><div>" + (reprocessResults(res.text.substring(pos))) + "</div></div>";
          }
          return html + ("</div>" + (commentButton(name.info.trim())) + "</div><div class='comments' data-org-comments='" + (name.info.trim()) + "'><div></div></div>");
        } else {
          return defaultMarkup(org);
        }
      } else {
        return defaultMarkup(org);
      }
    } else if (org instanceof Headline) {
      return "<span " + (orgAttrs(org)) + "><span data-org-type='text'>" + org.text + "</span>" + (markupGuts(org, checkStart(start, org.text))) + "</span>";
    } else if (content(org.text).length) {
      return defaultMarkup(org);
    } else {
      return "<div " + (orgAttrs(org)) + ">" + org.text + "</div>";
    }
  };

  commentButton = function(name) {
    return "<button class='comment-button' onclick='Leisure.toggleComment(\"" + name + "\")' contenteditable='false'><img src='icons/monotone_talk_chat_speech.png'></button>";
  };

  astButton = function(name) {
    return "<button class='ast-button' onclick='Leisure.toggleAst(\"" + (name.info.trim()) + "\")' contenteditable='false'><img src='icons/monotone_groups.png'></button>";
  };

  toggleComment = function(name) {
    var block;
    block = $("[data-org-comments=" + name + "]");
    if (block.hasClass('showcomments')) {
      return block.removeClass('showcomments');
    } else {
      return block.addClass('showcomments');
    }
  };

  defaultMarkup = function(org) {
    return "<span " + (orgAttrs(org)) + ">" + org.text + "</span>";
  };

  createResults = function(srcNode) {
    var created;
    while (srcNode && !srcNode.classList.contains('codeblock')) {
      srcNode = srcNode.parentNode;
    }
    if (created = srcNode && !$(srcNode).find('.coderesults').length) {
      $(srcNode).find('.codewrapper').append("<div class=\"results-indicator\" data-org-type=\"boundary\"><span></span></div><div class=\"coderesults\" data-org-type=\"results\"><span class=\"hidden\">#+RESULTS:\n</span><div>\n</div></div>");
    }
    return created;
  };

  shouldCancelBS = function(parent, r) {
    return atTextStart(r) && crossesHidden(-1);
  };

  atTextStart = function(r) {
    return r.collapsed && (r.startContainer.nodeType === 1 || (r.startContainer.nodeType === 3 && r.startOffset === 0));
  };

  atTextEnd = function(r) {
    return r.collapsed && (r.startContainer.nodeType === 1 || (r.startContainer.nodeType === 3 && ((r.startOffset === r.startContainer.length && 1) || (r.startOffset === r.startContainer.length - 1 && r.startContainer.textContent[r.startOffset] === '\n' && 2))));
  };

  shouldCancelDEL = function(parent, r) {
    var atEnd;
    return (atEnd = atTextEnd(r)) && crossesHidden(atEnd + 1);
  };

  matchLineAt = function(parent, pos) {
    var end, start, text;
    text = parent.textContent;
    start = text.substring(0, pos).lastIndexOf('\n');
    end = text.indexOf('\n', start + 1);
    if (end === -1) {
      end = text.length;
    }
    return matchLine(text.substring(start + 1, end));
  };

  markupGuts = function(org, start) {
    var c, p, prev, s;
    if (!org.children.length) {
      return '';
    } else {
      prev = start ? null : org;
      return ((function() {
        var _i, _len, _ref4, _results;
        _ref4 = org.children;
        _results = [];
        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
          c = _ref4[_i];
          s = start;
          start = false;
          p = prev;
          prev = c;
          _results.push(markupNode(c, s));
        }
        return _results;
      })()).join("");
    }
  };

  currentTextPosition = function(parent, r) {
    if (curPos > -1) {
      return curPos;
    } else {
      return curPos = getTextPosition(parent, r || getSelection().getRangeAt(0));
    }
  };

  crossesHidden = function(delta) {
    var n, r, s, _i, _len, _ref4;
    s = rangy.getSelection();
    r = s.getRangeAt(0);
    if (delta < 0) {
      r.moveStart('character', delta);
    } else {
      r.moveEnd('character', delta);
    }
    if (r.startContainer === r.endContainer) {
      return false;
    } else {
      _ref4 = r.getNodes();
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        n = _ref4[_i];
        if (r.containsNode(n) && isCollapsed(n)) {
          return true;
        }
      }
      return false;
    }
  };

  bindContent = function(div) {
    div.addEventListener('mousedown', function(e) {
      return setCurKeyBinding(null);
    });
    div.addEventListener('keydown', function(e) {
      var bound, br, c, cancelled, checkMod, currentMatch, el, n, needsReparse, par, r, s, _ref4;
      curPos = -1;
      c = e.charCode || e.keyCode || e.which;
      if (!addKeyPress(e, c)) {
        return;
      }
      s = getSelection();
      r = s.getRangeAt(0);
      _ref4 = findKeyBinding(e, div, r), bound = _ref4[0], checkMod = _ref4[1];
      if (bound) {
        cancelled = !checkMod;
      } else {
        checkMod = modifyingKey(c);
        cancelled = false;
      }
      if (!bound) {
        if (modifyingKey(c)) {
          el = r.startContainer;
          par = el.parentNode;
          n = s.focusNode;
          currentMatch = matchLine(currentLine(div));
          if (c === ENTER) {
            e.preventDefault();
            if (!checkCollapsed(n, 1)) {
              if (n.nodeType === 3 && r.collapsed && r.startOffset === n.length && n.parentNode.getAttribute('data-org-type') === 'text') {
                br = document.createTextNode('\n');
                $(br).prependTo(followingSpan(n.parentNode));
                r.setStart(br, br.length);
                r.setEnd(br, br.length);
              } else {
                r.insertNode(br = document.createTextNode(checkExtraNewline(r, n, div)));
                br.parentNode.normalize();
              }
              r.collapse();
              s.removeAllRanges();
              s.addRange(r);
              setTimeout((function() {
                return checkEnterReparse(div, r);
              }), 1);
            } else {
              return;
            }
          } else if (c === BS || c === DEL) {
            if ((c === BS && shouldCancelBS(div, r)) || (c === DEL && shouldCancelDEL(div, r))) {
              e.preventDefault();
              return;
            } else if (c === BS && bsWillDestroyParent(r)) {
              e.preventDefault();
              el.data = el.data.substring(1);
            }
          } else if (el.nodeType === 3 && el.data === '\n') {
            setTimeout((function() {
              var sel;
              if (el.data[el.data.length - 1] !== '\n') {
                el.data += '\n';
                sel = getSelection();
                r = sel.getRangeAt(0);
                r.setStart(el, 1);
                r.setEnd(el, 1);
                sel.removeAllRanges();
                sel.addRange(r);
              }
              return checkSourceMod(div, currentMatch);
            }), 1);
            return;
          }
        }
      }
      if (!cancelled && checkMod) {
        if ((getOrgType(getOrgParent(el))) === 'boundary') {
          needsReparse = true;
        }
        return setTimeout((function() {
          return checkSourceMod(div, currentMatch);
        }), 1);
      }
    });
    div.addEventListener('DOMCharacterDataModified', handleMutation, true);
    div.addEventListener('DOMSubtreeModified', handleMutation, true);
    return displaySource();
  };

  bsWillDestroyParent = function(r) {
    var r2;
    if (r.startContainer.nodeType === 3 && r.startOffset === 1 && r.startContainer.data.match(/^.\n?$/)) {
      r2 = rangy.createRangyRange();
      r2.selectNodeContents(r.startContainer.parentNode);
      return r2.text() === r.startContainer.data;
    } else {
      return false;
    }
  };

  handleMutation = function(evt) {
    invalidateOrgText();
    return displaySource();
  };

  executeSource = function(parent, node) {
    var txt, _ref4;
    while (node && !((_ref4 = node.classList) != null ? _ref4.contains('codecontent') : void 0)) {
      node = node.parentNode;
    }
    if (node) {
      createResults(node);
      txt = node.textContent;
      if (txt.trim().length) {
        return executeText(node.textContent, orgEnv(parent, node));
      } else {
        return orgEnv(parent, node);
      }
    }
  };

  executeDef = function(node) {
    while (node && !node.hasAttribute('data-org-results')) {
      node = node.parentNode;
    }
    if (node) {
      return executeText($(node).find('.codecontent')[0].firstChild.textContent, baseEnv);
    }
  };

  reprocessResults = function(str) {
    return str.replace(/(^|\n): /g, '$1<span class="hidden">: </span>');
  };

  processResults = function(str) {
    if (str) {
      if (str[str.length - 1] === '\n') {
        str = str.substring(0, str.length - 1);
      }
      return "<span class='hidden'>: </span>" + (str.replace(/\n/g, '\n<span class="hidden">: </span>')) + "\n";
    } else {
      return str;
    }
  };

  redrawIssue = function(issue) {
    var c, holder, issueName, name, nameEl;
    issueName = issue.title.trim();
    if ((name = $("[data-org-comments='" + issueName + "']")).length) {
      holder = name[0].firstChild;
      if (!(nameEl = holder.shadowRoot)) {
        nameEl = holder.createShadowRoot();
        root.applyAuthorStyles = true;
      }
      console.log("first gravatar: " + issue.comments[0].gravatar_id);
      return nameEl.innerHTML = "" + (commentHtml(issue, 'main')) + (((function() {
        var _i, _len, _ref4, _results;
        _ref4 = issue.comments;
        _results = [];
        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
          c = _ref4[_i];
          _results.push(commentHtml(c, 'added'));
        }
        return _results;
      })()).join(''));
    }
  };

  commentHtml = function(comment, type) {
    return "<div class='commentbox'><img src='http://gravatar.com/avatar/" + comment.user.gravatar_id + "?s=48'><div class='" + type + "'>" + comment.body + "</div></div>";
  };

  orgEnv = function(parent, node) {
    var r;
    r = getResultsForSource(parent, node);
    if (r) {
      r.innerHTML = '';
      return {
        write: function(str) {
          return r.innerHTML += processResults(str);
        },
        __proto__: defaultEnv
      };
    } else {
      return {
        write: function(str) {
          return console.log(": " + (str.replace(/\n/g, '\n: ')) + "\n");
        },
        __proto__: defaultEnv
      };
    }
  };

  baseEnv = {
    write: function(str) {
      return console.log(processResults(str));
    },
    __proto__: defaultEnv
  };

  fancyOrg = {
    __proto__: orgNotebook,
    markupOrg: markupOrg,
    markupOrgWithNode: markupOrgWithNode,
    bindContent: bindContent,
    installOrgDOM: function(parent, orgNode, orgText) {
      var _this = this;
      orgNotebook.installOrgDOM(parent, orgNode, orgText);
      setTimeout((function() {
        var node, _i, _len, _ref4, _results;
        _ref4 = $('[data-org-results]');
        _results = [];
        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
          node = _ref4[_i];
          switch ($(node).attr('data-org-results').toLowerCase()) {
            case 'dynamic':
              _results.push(_this.executeSource(parent, $(node).find('.codecontent')[0].firstChild));
              break;
            case 'def':
              _results.push(_this.executeDef(node));
              break;
            default:
              _results.push(void 0);
          }
        }
        return _results;
      }), 1);
      return redrawAllIssues();
    },
    executeSource: executeSource,
    executeDef: executeDef,
    createResults: createResults,
    bindings: defaultBindings,
    redrawIssue: function(i) {
      return redrawIssue(i);
    }
  };

  root.fancyOrg = fancyOrg;

  root.toggleComment = toggleComment;

}).call(this);

/*
//@ sourceMappingURL=fancyOrg.map
*/
