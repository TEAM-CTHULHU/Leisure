// Generated by CoffeeScript 1.6.3
(function() {
  var BS, DEL, DOCUMENT_POSITION_CONTAINED_BY, ENTER, HL_TAGS, HTML, Headline, KW_BOILERPLATE, KW_INFO, KW_NAME, Keyword, Link, ListItem, Meat, Results, SimpleMarkup, Source, TAB, addComment, addKeyPress, allowEvents, atTextEnd, atTextStart, baseEnv, bindContent, boundarySpan, bsWillDestroyParent, checkCollapsed, checkEnterReparse, checkExtraNewline, checkSourceMod, checkStart, clearResults, colonify, commentBlock, commentButton, commentHtml, content, contentSpan, createResults, crossesHidden, curPos, currentLine, currentTextPosition, defaultBindings, defaultEnv, defaultMarkup, define, displaySource, documentTop, eatListItem, emptyPresenter, escapeAttr, escapeHtml, escapePresentationHtml, executeDef, executeSource, executeText, fancyCheckSourceMod, fancyOrg, findDomPosition, findKeyBinding, followingSpan, getCodeContainer, getNodeSource, getOrgParent, getOrgType, getResultsForSource, getTextPosition, getType, handleKey, handleMutation, headlineRE, hideSlider, hideSlides, hlStars, htmlForResults, imagePath, invalidateOrgText, isCollapsed, isDef, isMonad, isOrContains, keyFuncs, keywordRE, lastOrgOffset, lazy, lz, makeSyncMonad, markupGuts, markupHeadline, markupHtml, markupLeisure, markupLink, markupListItem, markupNode, markupOrg, markupOrgWithNode, markupSimple, markupSource, matchLine, matchLineAt, modifiers, modifyingKey, nativeRange, needsNewline, newCodeContent, newCommentBox, nextOrgId, nextSlide, nonl, oldRestorePosition, optionalBoundary, orgAttrs, orgEnv, orgNotebook, orgSrcAttrs, parseOrgMode, parseTags, presentValue, presenter, prevSlide, processResults, propsFor, psgn, recreateAstButtons, redrawAllIssues, redrawIssue, replacePresenter, replaceRelatedPresenter, replaceUnrelatedPresenter, reprocessResults, resolve, restorePosition, restoreSlide, root, runMonad, rz, setCurKeyBinding, setCurrentSlide, setMinMax, setShadowHtml, setSlideAt, shouldCancelBS, shouldCancelDEL, show, showAst, showSliderButton, showSlides, slideBindings, slideMode, slideOffset, slideParent, splitLines, srcStartRE, swapMarkup, textNodeAfter, textNodeBefore, toggleComment, toggleSlides, unescapePresentationHtml, unwrap, _, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;

  _ref = root = module.exports = require('./base'), resolve = _ref.resolve, lazy = _ref.lazy, defaultEnv = _ref.defaultEnv;

  rz = resolve;

  lz = lazy;

  _ref1 = require('./browserSupport'), TAB = _ref1.TAB, ENTER = _ref1.ENTER, BS = _ref1.BS, DEL = _ref1.DEL;

  _ref2 = require('./ast'), getType = _ref2.getType, define = _ref2.define, makeSyncMonad = _ref2.makeSyncMonad;

  _ref3 = require('./runtime'), runMonad = _ref3.runMonad, isMonad = _ref3.isMonad, escapePresentationHtml = _ref3.escapePresentationHtml, unescapePresentationHtml = _ref3.unescapePresentationHtml;

  _ref4 = require('./org'), keywordRE = _ref4.keywordRE, KW_BOILERPLATE = _ref4.KW_BOILERPLATE, KW_NAME = _ref4.KW_NAME, KW_INFO = _ref4.KW_INFO, srcStartRE = _ref4.srcStartRE, parseOrgMode = _ref4.parseOrgMode, Headline = _ref4.Headline, Meat = _ref4.Meat, Keyword = _ref4.Keyword, Source = _ref4.Source, HTML = _ref4.HTML, Results = _ref4.Results, ListItem = _ref4.ListItem, SimpleMarkup = _ref4.SimpleMarkup, Link = _ref4.Link, headlineRE = _ref4.headlineRE, HL_TAGS = _ref4.HL_TAGS, parseTags = _ref4.parseTags, matchLine = _ref4.matchLine;

  _ref5 = require('./orgSupport'), orgNotebook = _ref5.orgNotebook, parseOrgMode = _ref5.parseOrgMode, orgAttrs = _ref5.orgAttrs, content = _ref5.content, contentSpan = _ref5.contentSpan, checkStart = _ref5.checkStart, optionalBoundary = _ref5.optionalBoundary, boundarySpan = _ref5.boundarySpan, displaySource = _ref5.displaySource, checkEnterReparse = _ref5.checkEnterReparse, checkCollapsed = _ref5.checkCollapsed, checkExtraNewline = _ref5.checkExtraNewline, followingSpan = _ref5.followingSpan, currentLine = _ref5.currentLine, checkSourceMod = _ref5.checkSourceMod, isCollapsed = _ref5.isCollapsed, nextOrgId = _ref5.nextOrgId, modifyingKey = _ref5.modifyingKey, getOrgParent = _ref5.getOrgParent, getOrgType = _ref5.getOrgType, executeText = _ref5.executeText, executeDef = _ref5.executeDef, getResultsForSource = _ref5.getResultsForSource, swapMarkup = _ref5.swapMarkup, modifiers = _ref5.modifiers, keyFuncs = _ref5.keyFuncs, defaultBindings = _ref5.defaultBindings, addKeyPress = _ref5.addKeyPress, findKeyBinding = _ref5.findKeyBinding, invalidateOrgText = _ref5.invalidateOrgText, setCurKeyBinding = _ref5.setCurKeyBinding, presentValue = _ref5.presentValue, propsFor = _ref5.propsFor, escapeHtml = _ref5.escapeHtml, escapeAttr = _ref5.escapeAttr, restorePosition = _ref5.restorePosition, splitLines = _ref5.splitLines, orgSrcAttrs = _ref5.orgSrcAttrs, baseEnv = _ref5.baseEnv, getNodeSource = _ref5.getNodeSource, isDef = _ref5.isDef, getTextPosition = _ref5.getTextPosition, findDomPosition = _ref5.findDomPosition, nativeRange = _ref5.nativeRange, textNodeAfter = _ref5.textNodeAfter, textNodeBefore = _ref5.textNodeBefore;

  redrawAllIssues = require('./storage').redrawAllIssues;

  _ = require('./lodash.min');

  oldRestorePosition = restorePosition;

  fancyOrg = null;

  slideMode = false;

  lastOrgOffset = -1;

  curPos = -1;

  emptyPresenter = {
    hide: function() {},
    isRelated: function() {
      return false;
    }
  };

  presenter = emptyPresenter;

  DOCUMENT_POSITION_CONTAINED_BY = 16;

  root.restorePosition = restorePosition = function(parent, block) {
    var c, container, end, endContainer, endOffset, newSlide, offset, r, sel, slide, slideIndex, sta, start, _ref6, _ref7;
    sel = getSelection();
    slide = slideParent(sel.focusNode);
    slideIndex = slideOffset(slide);
    if ((sel != null ? sel.rangeCount : void 0) && slideIndex > -1) {
      r = sel.getRangeAt(0);
      start = getTextPosition(slide, r.startContainer, r.startOffset);
      end = getTextPosition(slide, r.endContainer, r.endOffset);
      _ref6 = findDomPosition(slide, start), container = _ref6[0], sta = _ref6[1];
      if ((isCollapsed(container)) && sta === 0) {
        container = textNodeBefore(container);
      }
      offset = documentTop(container) - window.pageYOffset;
      block();
      newSlide = $('[data-org-headline="1"]')[slideIndex];
      if (slideMode) {
        setCurrentSlide(newSlide);
      }
      if (start > -1 && (r = nativeRange(findDomPosition(newSlide, start)))) {
        if (isCollapsed(r.startContainer)) {
          c = r.startContainer;
          while (isCollapsed(c)) {
            c = textNodeBefore(c);
          }
          r.setStart(c, 0);
          r.collapse(true);
        } else {
          _ref7 = findDomPosition(newSlide, end), endContainer = _ref7[0], endOffset = _ref7[1];
          r.setEnd(endContainer, endOffset);
        }
        sel.removeAllRanges();
        sel.addRange(r);
        window.scrollTo(0, documentTop(r.startContainer) - offset);
        return;
      }
    }
    return block();
  };

  replaceUnrelatedPresenter = function(target, newPres) {
    var result;
    if (result = !presenter.isRelated(target)) {
      replacePresenter(newPres);
    }
    return result;
  };

  replaceRelatedPresenter = function(target, newPres) {
    var result;
    if (result = presenter.isRelated(target)) {
      replacePresenter(newPres);
    }
    return result;
  };

  replacePresenter = function(pres) {
    presenter.hide();
    return presenter = pres;
  };

  markupOrg = function(text) {
    var node, result, _ref6;
    _ref6 = markupOrgWithNode(text), node = _ref6[0], result = _ref6[1];
    return result;
  };

  markupOrgWithNode = function(text) {
    var nodes, org;
    nodes = {};
    if (text[text.length - 1] !== '\n') {
      text = text + '\n';
    }
    org = parseOrgMode(text);
    lastOrgOffset = -1;
    return [org, markupNode(org)];
  };

  markupNode = function(org) {
    var intertext, name, pos, src, text;
    if (org.offset <= lastOrgOffset) {
      return '';
    } else if (org instanceof Results) {
      pos = org.contentPos - org.offset;
      text = org.text.substring(pos);
      return "<span " + (orgAttrs(org)) + "><span data-org-type='text'>" + (escapeHtml(org.text.substring(0, pos))) + "</span>" + (contentSpan(text));
    } else if (org instanceof HTML) {
      return markupHtml(org);
    } else if (org instanceof Keyword) {
      if (org.name.match(/^name$/i)) {
        intertext = '';
        name = org;
        src = org.next;
        while (src instanceof Meat && !(src instanceof Source)) {
          intertext += src.text;
          src = src.next;
        }
        if (src instanceof Source) {
          return markupSource(src, name, intertext);
        } else {
          return defaultMarkup(org);
        }
      } else if (org instanceof Source) {
        return markupSource(org);
      } else {
        return defaultMarkup(org);
      }
    } else if (org instanceof Headline) {
      return markupHeadline(org);
    } else if (org instanceof ListItem) {
      return markupListItem(org);
    } else if (org instanceof SimpleMarkup) {
      return markupSimple(org);
    } else if (org instanceof Link) {
      return markupLink(org);
    } else if (content(org.text).length) {
      return defaultMarkup(org);
    } else {
      return "<div " + (orgAttrs(org)) + ">" + (escapeHtml(org.text)) + "</div>";
    }
  };

  imagePath = /\.(png|jpg|gif|svg|tiff|bmp)$/i;

  markupLink = function(org) {
    var c, guts, _i, _len, _ref6;
    if (!org.children.length && org.path.match(imagePath)) {
      return "<span class='hidden'>" + org.text + "</span><img src='" + org.path + "'>";
    } else {
      guts = '';
      _ref6 = org.children;
      for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
        c = _ref6[_i];
        guts += markupNode(c);
      }
      if (!guts) {
        return "<span class='hidden'>[[</span><a href='" + org.path + "'>" + org.path + "</a><span class='hidden'>]]</span>";
      } else {
        return "<span class='hidden'>[[" + org.path + "][</span><a href='" + org.path + "'>" + guts + "</a><span class='hidden'>]]</span>";
      }
    }
  };

  markupSimple = function(org) {
    var c, guts, text, _i, _len, _ref6;
    guts = '';
    _ref6 = org.children;
    for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
      c = _ref6[_i];
      guts += markupNode(c);
    }
    text = (function() {
      switch (org.markupType) {
        case 'bold':
          return "<b>" + guts + "</b>";
        case 'italic':
          return "<i>" + guts + "</i>";
        case 'underline':
          return "<span style='text-decoration: underline'>" + guts + "</span>";
        case 'strikethrough':
          return "<span style='text-decoration: line-through'>" + guts + "</span>";
        case 'code':
          return "<code>" + guts + "</code>";
        case 'verbatim':
          return "<code>" + guts + "</code>";
      }
    })();
    return "<span class='hidden'>" + org.text[0] + "</span>" + text + "<span class='hidden'>" + org.text[0] + "</span>";
  };

  hlStars = /^\*+ */;

  markupHeadline = function(org) {
    var last, match, stars, starsM, start, tags, _ref6;
    match = org.text.match(headlineRE);
    start = ("" + (org.text.substring(0, org.text.length - ((_ref6 = match != null ? match[HL_TAGS] : void 0) != null ? _ref6 : '').length - 1))).trim();
    if (org.text[org.text.length - 1] === '\n') {
      tags = escapeHtml(org.text.substring(start.length, org.text.length - 1));
      last = '\n';
    } else {
      tags = escapeHtml(org.text.substring(start.length));
      last = '';
    }
    if (starsM = start.match(hlStars)) {
      stars = start.substring(0, starsM[0].length);
      start = start.substring(stars.length);
    } else {
      stars = '';
    }
    return "<div " + (orgAttrs(org)) + "><span class='hidden'>" + stars + "</span><span data-org-type='text'><span data-org-type='text-content'>" + (escapeHtml(start)) + "</span><span class='tags'>" + tags + "</span>" + last + "</span>" + (markupGuts(org, checkStart(start, org.text))) + "</div>";
  };

  markupHtml = function(org) {
    return "<div " + (orgAttrs(org)) + "><span data-org-html='true'>" + ($('<div>' + org.content() + '</div>').html()) + "</span><span class='hidden'>" + (escapeHtml(org.text)) + "</span></div>";
  };

  markupSource = function(org, name, intertext) {
    var lead, srcContent, trail;
    srcContent = org.content;
    lead = org.text.substring(0, org.contentPos - org.offset);
    trail = org.text.substring(org.contentPos - org.offset + org.content.length);
    return markupLeisure(org, name, intertext, srcContent, lead, trail);
  };

  markupLeisure = function(org, name, intertext, content, lead, trail) {
    var codeBlock, html, nameM, pos, res, wrapper;
    lastOrgOffset = org.offset;
    if (name) {
      nameM = name.text.match(keywordRE);
      codeBlock = " data-org-codeblock='" + (escapeAttr(name.info.trim())) + "'><div class='codename'><span class='hidden'>" + (escapeHtml(nameM[KW_BOILERPLATE])) + "</span><div><larger><b>" + (escapeHtml(name.info)) + "</b></larger></div>" + (escapeHtml(intertext)) + "</div>";
    } else {
      codeBlock = ">";
    }
    html = "<div class='codeblock' " + (orgAttrs(org)) + codeBlock + "<div class='hidden'>" + (escapeHtml(lead)) + "</div>";
    wrapper = "<table class='codewrapper'><tr><td><div " + (orgSrcAttrs(org)) + ">" + (escapeHtml(content)) + "</div><span class='hidden' data-org-type='boundary'>" + (escapeHtml(trail)) + "</span>";
    res = org.next;
    intertext = '';
    while (res && !(res instanceof Results) && !(res instanceof Keyword)) {
      intertext += res.text;
      res = res.next;
    }
    if (res instanceof Results) {
      lastOrgOffset = res.offset;
      pos = res.contentPos - res.offset;
      wrapper += htmlForResults(res.text.substring(pos));
    } else {
      wrapper += htmlForResults('');
    }
    wrapper += "</td></tr></table>";
    return html + wrapper + (name ? "" + (commentButton(name.info.trim())) + "</div>" + (commentBlock(name.info.trim())) : "</div>") + '\n';
  };

  markupListItem = function(org) {
    var end, next, parent, start;
    if (org.level === 0) {
      start = !org.getPreviousListItem();
      end = !org.getNextListItem();
    } else {
      start = (parent = org.getParent()) && parent === org.getPreviousListItem();
      next = org.getNextListItem();
      end = !next || next.level < org.level;
    }
    return "" + (start ? '<ul>' : '') + "<li " + (orgAttrs(org)) + " data-org-listlevel='" + org.level + "'" + (org.checked != null ? ' data-org-checked="' + org.checked + '"' : '') + "><span class='hidden'>" + (escapeHtml(org.text.substring(0, org.contentOffset))) + "</span><span>" + (escapeHtml(org.text.substring(org.contentOffset))) + "</span></li>" + (eatListItem(org)) + (end ? '</ul>' : '');
  };

  eatListItem = function(org) {
    var item, result;
    if (org.next instanceof Meat && org.next.text[0] === '\n') {
      return '';
    } else {
      item = org;
      result = '';
      while (((org = org.next) instanceof Meat) && !(org instanceof ListItem)) {
        result += markupNode(org);
        lastOrgOffset = org.offset;
      }
      return result;
    }
  };

  unwrap = function(node) {
    var parent;
    parent = node.parentNode;
    if (parent) {
      while (node.firstChild != null) {
        parent.insertBefore(node.firstChild, node);
      }
      return parent.removeChild(node);
    }
  };

  recreateAstButtons = function(parent, node) {
    return restorePosition(parent, function() {
      var button, chunk, cur, curStart, div, mchunk, mid, mnum, num, numStart, numberSpan, rest, t, _i, _j, _len, _len1, _ref6, _ref7, _results;
      _ref6 = $(node).find('.ast-button');
      for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
        button = _ref6[_i];
        button.remove();
      }
      _ref7 = $(node).find('.org-num');
      for (_j = 0, _len1 = _ref7.length; _j < _len1; _j++) {
        num = _ref7[_j];
        unwrap(num);
      }
      t = node.textContent;
      if (t && t[t.length - 1] !== '\n') {
        node.textContent = t += '\n';
      }
      chunk = /^[^ \n].*$/mg;
      num = /(^|[^0-9.]+)([0-9][0-9.]*|\.[0-9.]+)/mg;
      node.normalize();
      rest = t;
      mchunk = chunk.exec(t);
      mnum = num.exec(t);
      cur = node.firstChild;
      curStart = 0;
      _results = [];
      while (cur && (mchunk || mnum)) {
        if (mchunk && (!mnum || mchunk.index <= mnum.index + mnum[1].length)) {
          cur = (mchunk.index > curStart ? cur.splitText(mchunk.index - curStart) : cur);
          curStart = mchunk.index;
          div = document.createElement('div');
          div.setAttribute('class', 'ast-button');
          div.setAttribute('contenteditable', 'false');
          (function(d, offset) {
            return div.onmousedown = function(e) {
              return showAst(e, d, offset);
            };
          })(div, mchunk.index);
          if (curStart === 0) {
            div.setAttribute('style', 'top: 0');
          }
          node.insertBefore(div, cur);
          mchunk = chunk.exec(t);
          continue;
        }
        if (mnum && (!mchunk || mnum.index + mnum[1].length <= mchunk.index)) {
          numStart = mnum.index + mnum[1].length;
          mid = (numStart > curStart ? cur.splitText(numStart - curStart) : cur);
          cur = mid.splitText(mnum[2].length);
          curStart = mnum.index + mnum[0].length;
          numberSpan = document.createElement('span');
          numberSpan.appendChild(mid);
          numberSpan.classList.add('org-num');
          node.insertBefore(numberSpan, cur);
          node.normalize();
          (function(n) {
            return n.onmousedown = function(e) {
              e.stopPropagation();
              e.preventDefault();
              return showSliderButton(node, n);
            };
          })(numberSpan);
          _results.push(mnum = num.exec(t));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    });
  };

  newCodeContent = function(name, content) {
    var node, parent;
    parent = $("[data-org-codeblock='" + name + "']");
    if (node = parent.find('[data-org-src]')[0]) {
      node.innerHTML = escapeHtml(content);
      return recreateAstButtons(parent, node);
    }
  };

  define('newCodeContent', lz(function(name) {
    return $F(arguments, function(content) {
      return makeSyncMonad(function(env, cont) {
        newCodeContent(rz(name), rz(content));
        return cont(rz(L_true));
      });
    });
  }));

  isOrContains = function(parent, node) {
    var n;
    return (n = parent.compareDocumentPosition(node) & DOCUMENT_POSITION_CONTAINED_BY) || n === 0;
  };

  showAst = function(evt, astButton, offset) {
    var nl, result, text;
    evt.preventDefault();
    evt.stopPropagation();
    if (!replaceRelatedPresenter(presenter.button, emptyPresenter)) {
      if (!astButton.firstChild) {
        astButton.innerHTML = "<div></div>";
      }
      text = astButton.parentNode.textContent;
      nl = text.indexOf('\n', offset + 1);
      text = text.substring(offset, (nl < 0 ? text.length : nl));
      result = rz(L_newParseLine)(lz(0))(L_nil)(lz(text));
      return runMonad(result, baseEnv, function(ast) {
        var err;
        if (getType(ast) !== 'parseErr') {
          console.log("SIMPLIFIED: " + (show(lz(runMonad(rz(L_simplify)(lz(text)))))));
          try {
            setShadowHtml(astButton.firstChild, "<div class='ast'>" + (rz(L_wrappedTreeFor)(lz(ast))(L_id)) + "</div>");
            return replacePresenter({
              hide: function() {
                return astButton.firstChild.remove();
              },
              isRelated: function(node) {
                return isOrContains(astButton, node);
              },
              button: astButton
            });
          } catch (_error) {
            err = _error;
            return console.log("Error showing AST: " + err.stack);
          }
        }
      });
    }
  };

  show = function(obj) {
    return rz(L_show)(lz(obj));
  };

  commentButton = function(name) {
    return "<button class='comment-button' onclick='Leisure.toggleComment(\"" + (escapeAttr(name)) + "\")' contenteditable='false' data-org-commentcount='0'><img src='icons/monotone_talk_chat_speech.png'><span></span></button>";
  };

  commentBlock = function(name) {
    return "<div class='comments' data-org-comments='" + (escapeAttr(name)) + "'><div></div></div>";
  };

  toggleComment = function(name) {
    var block;
    block = $("[data-org-comments=" + name + "]");
    if (block.hasClass('showcomments')) {
      return block.removeClass('showcomments');
    } else {
      block.addClass('showcomments');
      return $("[data-org-codeblock='" + (escapeAttr(name)) + "'] button.comment-button").removeClass('new-comments');
    }
  };

  addComment = function(name) {
    return alert('Add comment not implemented, yet');
  };

  defaultMarkup = function(org) {
    return "<span " + (orgAttrs(org)) + ">" + (escapeHtml(org.text)) + "</span>";
  };

  htmlForResults = function(text) {
    return "</td><td><div class='results-indicator' data-org-type='boundary'><span></span></div></td><td><div class='coderesults' data-org-type='results'><span class='hidden'>#+RESULTS:</span><div class='resultscontent'><span></span><span class='hidden'>" + (nonl(escapeHtml('\n' + text))) + "</span></div></div>";
  };

  nonl = function(txt) {
    if (txt[txt.length - 1] === '\n') {
      return txt.substring(0, txt.length - 1);
    } else {
      return txt;
    }
  };

  createResults = function(srcNode) {
    var created, _ref6;
    while (srcNode && !((_ref6 = srcNode.classList) != null ? _ref6.contains('codeblock') : void 0)) {
      srcNode = srcNode.parentNode;
    }
    if (created = srcNode && !$(srcNode).find('.coderesults').length) {
      $(srcNode).find('.codewrapper').append(htmlForResults(''));
    }
    return created;
  };

  shouldCancelBS = function(parent, r) {
    return atTextStart(r) && crossesHidden(-1);
  };

  atTextStart = function(r) {
    return r.collapsed && (r.startContainer.nodeType === 1 || (r.startContainer.nodeType === 3 && r.startOffset === 0));
  };

  atTextEnd = function(r) {
    return r.collapsed && (r.startContainer.nodeType === 1 || (r.startContainer.nodeType === 3 && ((r.startOffset === r.startContainer.length && 1) || (r.startOffset === r.startContainer.length - 1 && r.startContainer.textContent[r.startOffset] === '\n' && 2))));
  };

  shouldCancelDEL = function(parent, r) {
    var atEnd;
    return (atEnd = atTextEnd(r)) && crossesHidden(atEnd + 1);
  };

  matchLineAt = function(parent, pos) {
    var end, start, text;
    text = parent.textContent;
    start = text.substring(0, pos).lastIndexOf('\n');
    end = text.indexOf('\n', start + 1);
    if (end === -1) {
      end = text.length;
    }
    return matchLine(text.substring(start + 1, end));
  };

  markupGuts = function(org, start) {
    var c, p, prev, s;
    if (!org.children.length) {
      return '';
    } else {
      prev = start ? null : org;
      return ((function() {
        var _i, _len, _ref6, _results;
        _ref6 = org.children;
        _results = [];
        for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
          c = _ref6[_i];
          s = start;
          start = false;
          p = prev;
          prev = c;
          _results.push(markupNode(c, s));
        }
        return _results;
      })()).join("");
    }
  };

  currentTextPosition = function(parent, r) {
    if (curPos > -1) {
      return curPos;
    } else {
      return curPos = getTextPosition(parent, r || getSelection().getRangeAt(0));
    }
  };

  crossesHidden = function(delta) {
    var r, _ref6;
    r = getSelection().getRangeAt(0);
    return !((0 <= (_ref6 = r.startOffset) && _ref6 < r.startContainer.length)) && isCollapsed((delta < 0 ? textNodeBefore : textNodeAfter)(r.startContainer));
  };

  bindContent = function(div) {
    div.addEventListener('mousedown', function(e) {
      if (replaceUnrelatedPresenter(e.target, emptyPresenter)) {
        return setCurKeyBinding(null);
      }
    });
    div.addEventListener('keydown', handleKey(div));
    div.addEventListener('DOMCharacterDataModified', handleMutation, true);
    div.addEventListener('DOMSubtreeModified', handleMutation, true);
    return displaySource();
  };

  handleKey = function(div) {
    return function(e) {
      var bound, br, c, cancelled, checkMod, currentMatch, el, n, needsReparse, par, r, s, _ref6;
      curPos = -1;
      c = e.charCode || e.keyCode || e.which;
      if (!addKeyPress(e, c)) {
        return;
      }
      s = getSelection();
      r = s.getRangeAt(0);
      _ref6 = findKeyBinding(e, div, r), bound = _ref6[0], checkMod = _ref6[1];
      if (bound) {
        cancelled = !checkMod;
      } else {
        checkMod = modifyingKey(c);
        cancelled = false;
      }
      if (String.fromCharCode(c) === 'C' && e.altKey) {
        root.orgApi.executeSource(div, getSelection().focusNode);
      } else if (!bound) {
        if (modifyingKey(c)) {
          n = s.focusNode;
          el = r.startContainer;
          par = el.parentNode;
          currentMatch = matchLine(currentLine(div));
          if (c === ENTER) {
            e.preventDefault();
            if (n.nodeType === 3 && r.collapsed && r.startOffset === n.length && n.parentNode.getAttribute('data-org-type') === 'text') {
              br = document.createTextNode('\n');
              $(br).prependTo(followingSpan(n.parentNode));
              r.setStart(br, br.length);
              r.setEnd(br, br.length);
            } else {
              r.insertNode(br = document.createTextNode(checkExtraNewline(r, n, div)));
              br.parentNode.normalize();
            }
            r.collapse();
            s.removeAllRanges();
            s.addRange(r);
            setTimeout((function() {
              return checkEnterReparse(div, r);
            }), 1);
          } else if (c === BS || c === DEL) {
            if ((c === BS && shouldCancelBS(div, r)) || (c === DEL && shouldCancelDEL(div, r))) {
              e.preventDefault();
              return;
            } else if (c === BS && bsWillDestroyParent(r)) {
              e.preventDefault();
              el.data = el.data.substring(1);
            }
          } else if (el.nodeType === 3) {
            setTimeout((function() {
              return fancyCheckSourceMod(n, div, currentMatch, el);
            }), 1);
            return;
          }
        }
      }
      if (!cancelled && checkMod) {
        if ((getOrgType(getOrgParent(el))) === 'boundary') {
          needsReparse = true;
        }
        return setTimeout((function() {
          return fancyCheckSourceMod(n, div, currentMatch);
        }), 1);
      }
    };
  };

  getCodeContainer = function(node) {
    return node && (((typeof node.getAttribute === "function" ? node.getAttribute('data-org-src') : void 0) && node) || (!(typeof node.getAttribute === "function" ? node.getAttribute('data-org-type') : void 0) && getCodeContainer(node.parentNode)));
  };

  fancyCheckSourceMod = function(focus, div, currentMatch, el) {
    var code;
    if (code = getCodeContainer(focus)) {
      recreateAstButtons(div, code);
    } else if (needsNewline(el)) {
      restorePosition(el.parentNode, function() {
        el.data += '\n';
        return el.parentNode.normalize();
      });
    }
    return checkSourceMod(div, currentMatch);
  };

  needsNewline = function(el) {
    var ance, next, r;
    if (el && !el.nextSibling && el.data[el.data.length - 1] !== '\n') {
      next = textNodeAfter(el);
      if (next && el.parentNode !== next.parentNode) {
        r = document.createRange();
        r.setStart(el, 0);
        r.setEnd(next, next.data.length);
        ance = r.commonAncestorContainer;
        while (el && (el = el.parentNode) !== ance) {
          if (getComputedStyle(el).display === 'block') {
            return true;
          }
        }
      }
    }
    return false;
  };

  bsWillDestroyParent = function(r) {
    if (r.startContainer.nodeType === 3 && r.startOffset === 1 && r.startContainer.data.match(/^.\n?$/)) {
      return r.startContainer.parentNode.textContent === r.startContainer.data;
    } else {
      return false;
    }
  };

  allowEvents = true;

  handleMutation = function(evt) {
    if (allowEvents) {
      invalidateOrgText();
      return displaySource();
    }
  };

  executeSource = function(parent, node, cont) {
    var srcNode, text, _ref6;
    _ref6 = getNodeSource(node), srcNode = _ref6[0], text = _ref6[1];
    if (srcNode) {
      createResults(srcNode);
      if (text.trim().length) {
        return executeText(text.trim(), propsFor(srcNode), orgEnv(parent, srcNode), cont);
      }
    }
  };

  reprocessResults = function(node) {
    if (node.firstChild.shadowRoot) {
      node.firstChild.shadowRoot.innerHTML = '';
      node.firstChild.shadowRoot.applyAuthorStyles = true;
    }
    return processResults(node.firstChild.nextElementSibling.textContent, node, true);
  };

  processResults = function(str, node, skipText) {
    var line, shadow, _i, _len, _ref6, _results;
    if (!node.firstChild.shadowRoot) {
      node.firstChild.createShadowRoot();
      node.firstChild.shadowRoot.applyAuthorStyles = true;
    }
    shadow = node.firstChild.shadowRoot;
    if (!skipText) {
      node.firstChild.nextElementSibling.textContent += escapePresentationHtml(str.substring(0, str.length - 1)) + str[str.length - 1];
    }
    _ref6 = splitLines(str);
    _results = [];
    for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
      line = _ref6[_i];
      if (line.match(/^: /)) {
        _results.push(shadow.innerHTML += "<div class='resultsline'>" + (line.substring(2)) + "</div>");
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  setShadowHtml = function(holder, html) {
    var el;
    if (!(el = holder.shadowRoot)) {
      el = holder.createShadowRoot();
      el.applyAuthorStyles = true;
    }
    return el.innerHTML = html;
  };

  redrawIssue = function(issue) {
    var button, c, count, issueName, name;
    issueName = issue.leisureName;
    if ((name = $("[data-org-comments='" + issueName + "']")).length) {
      count = issue.comments.length + 1;
      button = $("[data-org-codeblock='" + issueName + "'] button.comment-button");
      if (button.attr('data-org-commentcount') !== count) {
        button.attr('data-org-commentcount', count);
        button.addClass('new-comments');
      }
      setShadowHtml(button.find('span')[0], count);
      return setShadowHtml(name[0].firstChild, "" + (commentHtml(issue, 'main')) + (((function() {
        var _i, _len, _ref6, _results;
        _ref6 = issue.comments;
        _results = [];
        for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
          c = _ref6[_i];
          _results.push(commentHtml(c, 'added'));
        }
        return _results;
      })()).join('')) + (newCommentBox(issueName)));
    }
  };

  commentHtml = function(comment, type) {
    return "<div class='commentbox'><img src='http://gravatar.com/avatar/" + comment.user.gravatar_id + "?s=48'><div class='" + type + "'>" + comment.body + "</div></div>";
  };

  newCommentBox = function(name) {
    return "<textarea pseudo='x-new-comment'></textarea><br><button onclick='Leisure.addComment(\"" + name + "\")'>Add Comment</button>";
  };

  colonify = function(str) {
    return ': ' + (str.replace(/[\n\\]/g, function(c) {
      if (c === '\n') {
        return '\\n';
      } else {
        return '\\\\';
      }
    })) + '\n';
  };

  clearResults = function(node) {
    var r;
    if ((r = node.firstChild.shadowRoot)) {
      r.innerHTML = '';
    }
    return node.firstChild.nextElementSibling.innerHTML = '';
  };

  orgEnv = function(parent, node) {
    var r;
    r = node;
    if (!$(r).is('.resultscontent')) {
      r = $(r).find('.resultscontent')[0];
    }
    if (r) {
      clearResults(r);
      return {
        __proto__: defaultEnv,
        readFile: function(filename, cont) {
          return window.setTimeout((function() {
            return $.get(filename, function(data) {
              return cont(false, data);
            });
          }), 1);
        },
        write: function(str) {
          return processResults(colonify(String(str)), r);
        },
        presentValue: presentValue,
        newCodeContent: function(name, con) {
          return console.log("NEW CODE CONTENT: " + name + ", " + con);
        }
      };
    } else {
      return {
        __proto__: defaultEnv,
        readFile: function(filename, cont) {
          return window.setTimeout((function() {
            return $.get(filename, function(data) {
              return cont(false, data);
            });
          }), 1);
        },
        write: function(str) {
          return console.log(colonify(str));
        },
        newCodeContent: function(name, con) {
          return console.log("NEW CODE CONTENT: " + name + ", " + con);
        }
      };
    }
  };

  hideSlider = function(numberSpan) {
    return replaceRelatedPresenter(numberSpan, emptyPresenter);
  };

  showSliderButton = function(parent, numberSpan) {
    var computing, d, inside, max, min, orgParent, orgType, sl, sliding, value;
    if (hideSlider(numberSpan)) {
      return;
    }
    inside = false;
    sliding = false;
    d = $("<div style='z-index: 1; position: absolute; width: 200px; background: white; border: solid green 1px' slider contentEditable='false'></div>")[0];
    d.style.top = "" + (numberSpan.offsetTop + numberSpan.offsetHeight + 5) + "px";
    d.style.minTop = '0px';
    d.style.left = "" + (Math.max(0, numberSpan.offsetLeft + numberSpan.offsetWidth / 2 - 100)) + "px";
    d.addEventListener('mouseover', function(e) {
      if (!inside) {
        return inside = true;
      }
    });
    d.addEventListener('mouseout', function(e) {
      if (e.toElement !== d && !d.contains(e.toElement)) {
        inside = false;
        if (!sliding) {
          return hideSlider(numberSpan);
        }
      }
    });
    value = Number(numberSpan.textContent);
    min = value < 0 ? value * 2 : value / 2;
    max = value === 0 ? 10 : value * 2;
    orgParent = getOrgParent(numberSpan);
    orgType = orgParent.getAttribute('data-org-results');
    computing = false;
    sl = $(d).slider({
      animate: 'fast',
      start: function() {
        sliding = true;
        allowEvents = false;
        return true;
      },
      stop: function(event, ui) {
        setMinMax(sl);
        allowEvents = true;
        sliding = false;
        if (!inside) {
          return hideSlider(numberSpan);
        }
      },
      slide: function(event, ui) {
        var done;
        numberSpan.innerHTML = String(ui.value);
        if (!computing && (orgType === 'dynamic' || orgType === 'def')) {
          computing = true;
          done = function() {
            return computing = false;
          };
          return setTimeout((function() {
            if (orgType === 'dynamic') {
              return root.orgApi.executeSource(parent, numberSpan.parentNode, done);
            } else if (orgType === 'def') {
              return root.orgApi.executeDef(orgParent, done);
            }
          }), 1);
        }
      },
      value: value
    });
    parent.insertBefore(d, numberSpan);
    setMinMax(sl, value);
    replacePresenter({
      numberSpan: numberSpan,
      hide: function() {
        return d.remove();
      },
      isRelated: function(node) {
        return (isOrContains(d, node)) || (isOrContains(numberSpan, node));
      }
    });
    return d.focus();
  };

  psgn = function(x) {
    if (x < 0) {
      return -1;
    } else {
      return 1;
    }
  };

  setMinMax = function(sl, value) {
    var max, min, step, _ref6;
    value = value || sl.slider("value");
    min = 0;
    max = (1 <= (_ref6 = Math.abs(value)) && _ref6 < 50) || value === 0 ? 100 * psgn(value) : value * 2;
    step = (max - min) / 100;
    if (Math.round(value) === value) {
      step = Math.round(step);
      step = Math.max(1, step - step % (max - min));
    }
    sl.slider("option", "min", min);
    sl.slider("option", "max", max);
    return sl.slider("option", "step", step);
  };

  setCurrentSlide = function(element) {
    $('.currentSlide').removeClass('currentSlide');
    return $(element).addClass('currentSlide');
  };

  nextSlide = function() {
    var ns, slide;
    ns = null;
    if (slide = $('.currentSlide')[0]) {
      if ($(slide.nextElementSibling).has('[data-org-headline="1"]')) {
        ns = slide.nextElementSibling;
      }
    }
    if (!ns) {
      ns = $('[data-org-headline="1"]')[0];
    }
    return setCurrentSlide(ns);
  };

  prevSlide = function() {
    var ps, s, slide;
    ps = null;
    if (slide = $('.currentSlide')[0]) {
      if ($(slide.previousElementSibling).has('[data-org-headline="1"]')) {
        ps = slide.previousElementSibling;
      }
    }
    if (!$(ps).is('[data-org-headline="1"]')) {
      s = $('[data-org-headline="1"]');
      ps = s[s.length - 1];
    }
    if (ps) {
      return setCurrentSlide(ps);
    }
  };

  showSlides = function() {
    setCurrentSlide($('[data-org-headline="1"]')[0]);
    return document.body.classList.add('slides');
  };

  slideParent = function(node) {
    while (node && !$(node).is('[data-org-headline="1"]')) {
      node = node.parentNode;
    }
    return node;
  };

  documentTop = function(node) {
    var top;
    top = 0;
    while (node) {
      if (node.tagName) {
        top = top + node.offsetTop;
        node = node.offsetParent;
      } else {
        node = node.parentNode;
      }
    }
    return top;
  };

  hideSlides = function() {
    return document.body.classList.remove('slides');
  };

  slideBindings = {
    'LEFT': function(e, parent, r) {
      e.preventDefault();
      prevSlide();
      return false;
    },
    'RIGHT': function(e, parent, r) {
      e.preventDefault();
      nextSlide();
      return false;
    }
  };

  toggleSlides = function() {
    slideMode = !slideMode;
    fancyOrg.bindings = (slideMode ? slideBindings : defaultBindings);
    if (slideMode) {
      return restorePosition(null, function() {
        $('[data-org-html]').addClass('slideHtml');
        $('body').addClass('slides');
        return nextSlide();
      });
    } else {
      $('body').removeClass('slides');
      return $('[data-org-html]').addClass('slideHtml');
    }
  };

  define('toggleSlides', lz(makeSyncMonad(function(env, cont) {
    toggleSlides();
    return cont(rz(L_true));
  })));

  slideOffset = function(slide) {
    var a;
    if (slide) {
      a = [];
      a.push.apply(a, $("[data-org-headline='1']"));
      return a.indexOf(slide != null ? slide : $('.currentSlide')[0]);
    } else {
      return -1;
    }
  };

  setSlideAt = function(index) {
    return setCurrentSlide($("[data-org-headline='1']")[index]);
  };

  restoreSlide = function(block) {
    var offset;
    if (!slideMode) {
      return block();
    } else {
      offset = slideOffset();
      block();
      return setSlideAt(offset);
    }
  };

  fancyOrg = {
    __proto__: orgNotebook,
    markupOrg: markupOrg,
    markupOrgWithNode: markupOrgWithNode,
    bindContent: bindContent,
    installOrgDOM: function(parent, orgNode, orgText) {
      this.parent = parent;
      return restorePosition(parent, function() {
        var node, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref6, _ref7, _ref8, _ref9,
          _this = this;
        parent.setAttribute('class', 'org-fancy');
        orgNotebook.installOrgDOM(parent, orgNode, orgText);
        _ref6 = $('[data-org-html]');
        for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
          node = _ref6[_i];
          setShadowHtml(node, node.innerHTML);
          node.innerHTML = '';
        }
        _ref7 = $('[data-org-src]');
        for (_j = 0, _len1 = _ref7.length; _j < _len1; _j++) {
          node = _ref7[_j];
          recreateAstButtons(parent, node);
        }
        _ref8 = $('.resultscontent');
        for (_k = 0, _len2 = _ref8.length; _k < _len2; _k++) {
          node = _ref8[_k];
          reprocessResults(node);
        }
        _ref9 = $('[data-org-headline="1"]');
        for (_l = 0, _len3 = _ref9.length; _l < _len3; _l++) {
          node = _ref9[_l];
          setShadowHtml(node, "<div class='page'><div class='border'></div><div class='pagecontent'><content></content></div></div>");
        }
        return setTimeout((function() {
          var _len4, _m, _ref10;
          _ref10 = $('[data-org-comments]');
          for (_m = 0, _len4 = _ref10.length; _m < _len4; _m++) {
            node = _ref10[_m];
            setShadowHtml(node.firstElementChild, newCommentBox(node.getAttribute('data-org-comments')));
          }
          return redrawAllIssues();
        }), 1);
      });
    },
    executeSource: executeSource,
    executeDef: executeDef,
    createResults: createResults,
    bindings: defaultBindings,
    redrawIssue: function(i) {
      return redrawIssue(i);
    },
    leisureButton: function() {
      return restorePosition(this.parent, function() {
        toggleSlides();
        if (slideMode) {
          return setTimeout((function() {
            return $('[maindoc]').focus();
          }), 1);
        } else {
          return swapMarkup();
        }
      });
    }
  };

  root.fancyOrg = fancyOrg;

  root.toggleComment = toggleComment;

  root.addComment = addComment;

  root.recreateAstButtons = recreateAstButtons;

}).call(this);

/*
//@ sourceMappingURL=fancyOrg.map
*/
