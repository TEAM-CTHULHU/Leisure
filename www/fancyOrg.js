// Generated by CoffeeScript 1.6.3
(function() {
  var BS, DEL, ENTER, HL_TAGS, Headline, KW_BOILERPLATE, KW_INFO, KW_NAME, Keyword, Meat, Results, Source, TAB, atTextEnd, atTextStart, bindContent, borderRE, boundarySpan, bsWillDestroyParent, checkCollapsed, checkEnterReparse, checkExtraNewline, checkSourceMod, checkStart, content, contentSpan, createResults, crossesHidden, curPos, currentLine, currentTextPosition, decorateResultsIndicators, defaultEnv, defaultMarkup, displaySource, executeSource, executeText, fancyOrg, followingSpan, getOrgParent, getOrgType, getResultsForSource, handleMutation, headlineRE, isCollapsed, keywordRE, lastOrgOffset, lazy, lz, makeBoundary, markupGuts, markupNode, markupOrg, markupOrgWithNode, matchLine, matchLineAt, modifyingKey, nextOrgId, optionalBoundary, orgAttrs, orgEnv, orgNotebook, parseOrgMode, parseTags, processResults, reprocessResults, resolve, root, rz, shouldCancelBS, shouldCancelDEL, srcStartRE, _ref, _ref1, _ref2, _ref3;

  _ref = root = module.exports = require('./base'), resolve = _ref.resolve, lazy = _ref.lazy, defaultEnv = _ref.defaultEnv;

  rz = resolve;

  lz = lazy;

  _ref1 = require('./browserSupport'), TAB = _ref1.TAB, ENTER = _ref1.ENTER, BS = _ref1.BS, DEL = _ref1.DEL;

  _ref2 = require('./org'), keywordRE = _ref2.keywordRE, KW_BOILERPLATE = _ref2.KW_BOILERPLATE, KW_NAME = _ref2.KW_NAME, KW_INFO = _ref2.KW_INFO, srcStartRE = _ref2.srcStartRE, parseOrgMode = _ref2.parseOrgMode, Headline = _ref2.Headline, Meat = _ref2.Meat, Keyword = _ref2.Keyword, Source = _ref2.Source, Results = _ref2.Results, headlineRE = _ref2.headlineRE, HL_TAGS = _ref2.HL_TAGS, parseTags = _ref2.parseTags, matchLine = _ref2.matchLine;

  _ref3 = require('./orgSupport'), orgNotebook = _ref3.orgNotebook, parseOrgMode = _ref3.parseOrgMode, orgAttrs = _ref3.orgAttrs, content = _ref3.content, contentSpan = _ref3.contentSpan, checkStart = _ref3.checkStart, optionalBoundary = _ref3.optionalBoundary, boundarySpan = _ref3.boundarySpan, displaySource = _ref3.displaySource, checkEnterReparse = _ref3.checkEnterReparse, checkCollapsed = _ref3.checkCollapsed, checkExtraNewline = _ref3.checkExtraNewline, followingSpan = _ref3.followingSpan, currentLine = _ref3.currentLine, checkSourceMod = _ref3.checkSourceMod, isCollapsed = _ref3.isCollapsed, nextOrgId = _ref3.nextOrgId, modifyingKey = _ref3.modifyingKey, getOrgParent = _ref3.getOrgParent, getOrgType = _ref3.getOrgType, orgEnv = _ref3.orgEnv, executeText = _ref3.executeText, getResultsForSource = _ref3.getResultsForSource;

  lastOrgOffset = -1;

  curPos = -1;

  markupOrg = function(text) {
    var node, result, _ref4;
    _ref4 = markupOrgWithNode(text), node = _ref4[0], result = _ref4[1];
    return result;
  };

  markupOrgWithNode = function(text) {
    var nodes, org;
    nodes = {};
    if (text[text.length - 1] !== '\n') {
      text = text + '\n';
    }
    org = parseOrgMode(text);
    lastOrgOffset = -1;
    return [org, markupNode(org)];
  };

  borderRE = /[\n]+$/;

  makeBoundary = function(node) {
    var nls;
    nls = node.text.match(borderRE);
    if (nls) {
      return "<div class='boundary'>" + nls[0] + "</div>";
    } else {
      return "";
    }
  };

  markupNode = function(org) {
    var html, intertext, name, nameM, pos, res, src, srcContent, srcLead, srcM, srcTrail, text;
    if (org.offset <= lastOrgOffset) {
      return '';
    } else if (org instanceof Results) {
      pos = org.contentPos - org.offset;
      text = org.text.substring(pos);
      return "<span " + (orgAttrs(org)) + "><span data-org-type='text'>" + (org.text.substring(0, pos)) + "</span>" + (contentSpan(text));
    } else if (org instanceof Keyword) {
      if (org.name.match(/name/i)) {
        intertext = '\n';
        name = org;
        src = org.next;
        while (src instanceof Meat && !(src instanceof Source)) {
          intertext += src.text;
          src = src.next;
        }
        if (src instanceof Source) {
          lastOrgOffset = src.offset;
          nameM = name.text.match(keywordRE);
          srcM = src.text.match(srcStartRE);
          srcContent = src.content;
          srcLead = src.text.substring(0, src.contentPos - src.offset);
          srcTrail = src.text.substring(src.contentPos - src.offset + src.content.length);
          html = "<div class='codeblock' " + (orgAttrs(src)) + "><div class='codename'><span class='hidden'>" + nameM[KW_BOILERPLATE] + "</span>" + name.info + intertext + "</div><div class='hidden'>" + srcLead + "</div><div class='codewrapper'><div class='codecontent'>" + srcContent + "</div><span class='hidden' data-org-type='boundary'>" + srcTrail + "</span>";
          res = src.next;
          intertext = '';
          while (res && !(res instanceof Results) && !(res instanceof Keyword)) {
            intertext += res.text;
            res = res.next;
          }
          if (res instanceof Results) {
            lastOrgOffset = res.offset;
            pos = res.contentPos - res.offset;
            html += "" + (intertext ? "<div class='hidden' data-org-type='boundary'>" + intertext + "</div>" : '') + "<div class='results-indicator' data-org-type='boundary'></div><div class='coderesults' " + (orgAttrs(res)) + "><span class='hidden'>" + (res.text.substring(0, pos)) + "</span><div>" + (reprocessResults(res.text.substring(pos))) + "</div></div>";
          }
          return html + "</div></div>";
        } else {
          return defaultMarkup(org);
        }
      } else {
        return defaultMarkup(org);
      }
    } else if (org instanceof Headline) {
      return "<span " + (orgAttrs(org)) + "><span data-org-type='text'>" + org.text + "</span>" + (markupGuts(org, checkStart(start, org.text))) + "</span>";
    } else if (content(org.text).length) {
      return defaultMarkup(org);
    } else {
      return "<div " + (orgAttrs(org)) + ">" + org.text + "</div>";
    }
  };

  defaultMarkup = function(org) {
    return "<span " + (orgAttrs(org)) + ">" + org.text + "</span>";
  };

  decorateResultsIndicators = function(indicator) {
    var node, _i, _len, _ref4, _results;
    _ref4 = $(indicator);
    _results = [];
    for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
      node = _ref4[_i];
      root = node.createShadowRoot();
      _results.push(root.innerHTML = "-->");
    }
    return _results;
  };

  createResults = function(srcNode) {
    var created;
    while (srcNode && !srcNode.classList.contains('codeblock')) {
      srcNode = srcNode.parentNode;
    }
    if (created = srcNode && !$(srcNode).find('.coderesults').length) {
      $(srcNode).find('.codewrapper').append("<div class=\"results-indicator\" data-org-type=\"boundary\"></div><div class=\"coderesults\" data-org-type=\"results\"><span class=\"hidden\">#+RESULTS:\n</span><div>\n</div></div>");
      decorateResultsIndicators($(srcNode).find('.results-indicator'));
    }
    return created;
  };

  shouldCancelBS = function(parent, r) {
    return atTextStart(r) && crossesHidden(-1);
  };

  atTextStart = function(r) {
    return r.collapsed && (r.startContainer.nodeType === 1 || (r.startContainer.nodeType === 3 && r.startOffset === 0));
  };

  atTextEnd = function(r) {
    return r.collapsed && (r.startContainer.nodeType === 1 || (r.startContainer.nodeType === 3 && ((r.startOffset === r.startContainer.length && 1) || (r.startOffset === r.startContainer.length - 1 && r.startContainer.textContent[r.startOffset] === '\n' && 2))));
  };

  shouldCancelDEL = function(parent, r) {
    var atEnd;
    return (atEnd = atTextEnd(r)) && crossesHidden(atEnd + 1);
  };

  matchLineAt = function(parent, pos) {
    var end, start, text;
    text = parent.textContent;
    start = text.substring(0, pos).lastIndexOf('\n');
    end = text.indexOf('\n', start + 1);
    if (end === -1) {
      end = text.length;
    }
    return matchLine(text.substring(start + 1, end));
  };

  markupGuts = function(org, start) {
    var c, p, prev, s;
    if (!org.children.length) {
      return '';
    } else {
      prev = start ? null : org;
      return ((function() {
        var _i, _len, _ref4, _results;
        _ref4 = org.children;
        _results = [];
        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
          c = _ref4[_i];
          s = start;
          start = false;
          p = prev;
          prev = c;
          _results.push(markupNode(c, s));
        }
        return _results;
      })()).join("");
    }
  };

  currentTextPosition = function(parent, r) {
    if (curPos > -1) {
      return curPos;
    } else {
      return curPos = getTextPosition(parent, r || getSelection().getRangeAt(0));
    }
  };

  crossesHidden = function(delta) {
    var n, r, s, _i, _len, _ref4;
    s = rangy.getSelection();
    r = s.getRangeAt(0);
    if (delta < 0) {
      r.moveStart('character', delta);
    } else {
      r.moveEnd('character', delta);
    }
    if (r.startContainer === r.endContainer) {
      return false;
    } else {
      _ref4 = r.getNodes();
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        n = _ref4[_i];
        if (r.containsNode(n) && isCollapsed(n)) {
          return true;
        }
      }
      return false;
    }
  };

  bindContent = function(div) {
    div.addEventListener('keydown', function(e) {
      var br, c, currentMatch, el, n, needsReparse, par, r, s;
      curPos = -1;
      c = e.charCode || e.keyCode || e.which;
      if (modifyingKey(c)) {
        s = getSelection();
        r = s.getRangeAt(0);
        el = r.startContainer;
        par = el.parentNode;
        n = s.focusNode;
        currentMatch = matchLine(currentLine(div));
        if (c === ENTER) {
          e.preventDefault();
          if (!checkCollapsed(n, 1)) {
            if (n.nodeType === 3 && r.collapsed && r.startOffset === n.length && n.parentNode.getAttribute('data-org-type') === 'text') {
              br = document.createTextNode('\n');
              $(br).prependTo(followingSpan(n.parentNode));
              r.setStart(br, br.length);
              r.setEnd(br, br.length);
            } else {
              r.insertNode(br = document.createTextNode(checkExtraNewline(r, n, div)));
              br.parentNode.normalize();
            }
            r.collapse();
            s.removeAllRanges();
            s.addRange(r);
            setTimeout((function() {
              return checkEnterReparse(div, r);
            }), 1);
          } else {
            return;
          }
        } else if (c === BS || c === DEL) {
          if ((c === BS && shouldCancelBS(div, r)) || (c === DEL && shouldCancelDEL(div, r))) {
            e.preventDefault();
            return;
          } else if (c === BS && bsWillDestroyParent(r)) {
            e.preventDefault();
            el.data = el.data.substring(1);
          }
        } else if (el.nodeType === 3 && el.data === '\n') {
          setTimeout((function() {
            var sel;
            if (el.data[el.data.length - 1] !== '\n') {
              el.data += '\n';
              sel = getSelection();
              r = sel.getRangeAt(0);
              r.setStart(el, 1);
              r.setEnd(el, 1);
              sel.removeAllRanges();
              sel.addRange(r);
            }
            return checkSourceMod(div, currentMatch);
          }), 1);
          return;
        }
        if ((getOrgType(getOrgParent(el))) === 'boundary') {
          needsReparse = true;
        }
        return setTimeout((function() {
          return checkSourceMod(div, currentMatch);
        }), 1);
      }
    });
    div.addEventListener('DOMCharacterDataModified', handleMutation, true);
    return div.addEventListener('DOMSubtreeModified', handleMutation, true);
  };

  bsWillDestroyParent = function(r) {
    var r2;
    if (r.startContainer.nodeType === 3 && r.startOffset === 1 && r.startContainer.data.match(/^.\n?$/)) {
      r2 = rangy.createRangyRange();
      r2.selectNodeContents(r.startContainer.parentNode);
      return r2.text() === r.startContainer.data;
    } else {
      return false;
    }
  };

  handleMutation = function(evt) {
    return displaySource();
  };

  executeSource = function(parent, node) {
    var txt, _ref4;
    while (node && !((_ref4 = node.classList) != null ? _ref4.contains('codecontent') : void 0)) {
      node = node.parentNode;
    }
    if (node) {
      createResults(node);
      txt = node.textContent;
      if (txt.trim().length) {
        return executeText(node.textContent, orgEnv(parent, node));
      } else {
        return orgEnv(parent, node);
      }
    }
  };

  reprocessResults = function(str) {
    return str.replace(/(^|\n): /g, '$1<span class="hidden">: </span>');
  };

  processResults = function(str) {
    if (str) {
      if (str[str.length - 1] === '\n') {
        str = str.substring(0, str.length - 1);
      }
      return "<span class='hidden'>: </span>" + (str.replace(/\n/g, '\n<span class="hidden">: </span>')) + "\n";
    } else {
      return str;
    }
  };

  orgEnv = function(parent, node) {
    var r;
    r = getResultsForSource(parent, node);
    if (r) {
      r.innerHTML = '';
      return {
        write: function(str) {
          return r.innerHTML += processResults(str);
        },
        __proto__: defaultEnv
      };
    } else {
      return {
        write: function(str) {
          return console.log(": " + (str.replace(/\n/g, '\n: ')) + "\n");
        },
        __proto__: defaultEnv
      };
    }
  };

  fancyOrg = {
    __proto__: orgNotebook,
    markupOrg: markupOrg,
    markupOrgWithNode: markupOrgWithNode,
    bindContent: bindContent,
    installOrgDOM: function(parent, orgNode, orgText) {
      var node, _i, _len, _ref4,
        _this = this;
      orgNotebook.installOrgDOM(parent, orgNode, orgText);
      _ref4 = $('[data-org-dynamic="true"]');
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        node = _ref4[_i];
        setTimeout((function() {
          return _this.executeSource(parent, $(node).find('.codecontent')[0].firstChild);
        }), 1);
      }
      return decorateResultsIndicators($('.results-indicator'));
    },
    executeSource: executeSource,
    createResults: createResults
  };

  root.fancyOrg = fancyOrg;

}).call(this);

/*
//@ sourceMappingURL=fancyOrg.map
*/
