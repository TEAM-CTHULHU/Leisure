// Generated by CoffeeScript 1.6.3
(function() {
  var BS, DEL, ENTER, HL_TAGS, Headline, KW_BOILERPLATE, KW_INFO, KW_NAME, Keyword, Meat, Results, Source, TAB, addComment, addKeyPress, astButton, atTextEnd, atTextStart, baseEnv, bindContent, boundarySpan, bsWillDestroyParent, checkCollapsed, checkEnterReparse, checkExtraNewline, checkSourceMod, checkStart, commentBlock, commentButton, commentHtml, content, contentSpan, createResults, crossesHidden, curPos, currentLine, currentTextPosition, defaultBindings, defaultEnv, defaultMarkup, displaySource, escapeAttr, escapeHtml, executeDef, executeSource, executeText, fancyCheckSourceMod, fancyOrg, findKeyBinding, followingSpan, getOrgParent, getOrgType, getResultsForSource, getType, handleMutation, headlineRE, invalidateOrgText, isCodeContainer, isCollapsed, isHtml, isMonad, keyFuncs, keywordRE, lastOrgOffset, lazy, lz, markupGuts, markupHeadline, markupHtml, markupLeisure, markupNode, markupOrg, markupOrgWithNode, markupSource, matchLine, matchLineAt, modifiers, modifyingKey, newCommentBox, nextOrgId, optionalBoundary, orgAttrs, orgEnv, orgNotebook, parseOrgMode, parseTags, presentValue, processResults, propsFor, recreateAstButtons, redrawAllIssues, redrawIssue, reprocessResults, resolve, restorePosition, root, runMonad, rz, setCurKeyBinding, setShadowHtml, shouldCancelBS, shouldCancelDEL, show, showAst, srcStartRE, swapMarkup, toggleComment, _, _ref, _ref1, _ref2, _ref3, _ref4;

  _ref = root = module.exports = require('./base'), resolve = _ref.resolve, lazy = _ref.lazy, defaultEnv = _ref.defaultEnv;

  rz = resolve;

  lz = lazy;

  _ref1 = require('./browserSupport'), TAB = _ref1.TAB, ENTER = _ref1.ENTER, BS = _ref1.BS, DEL = _ref1.DEL;

  getType = require('./ast').getType;

  _ref2 = require('./runtime'), runMonad = _ref2.runMonad, isMonad = _ref2.isMonad;

  _ref3 = require('./org'), keywordRE = _ref3.keywordRE, KW_BOILERPLATE = _ref3.KW_BOILERPLATE, KW_NAME = _ref3.KW_NAME, KW_INFO = _ref3.KW_INFO, srcStartRE = _ref3.srcStartRE, parseOrgMode = _ref3.parseOrgMode, Headline = _ref3.Headline, Meat = _ref3.Meat, Keyword = _ref3.Keyword, Source = _ref3.Source, Results = _ref3.Results, headlineRE = _ref3.headlineRE, HL_TAGS = _ref3.HL_TAGS, parseTags = _ref3.parseTags, matchLine = _ref3.matchLine;

  _ref4 = require('./orgSupport'), orgNotebook = _ref4.orgNotebook, parseOrgMode = _ref4.parseOrgMode, orgAttrs = _ref4.orgAttrs, content = _ref4.content, contentSpan = _ref4.contentSpan, checkStart = _ref4.checkStart, optionalBoundary = _ref4.optionalBoundary, boundarySpan = _ref4.boundarySpan, displaySource = _ref4.displaySource, checkEnterReparse = _ref4.checkEnterReparse, checkCollapsed = _ref4.checkCollapsed, checkExtraNewline = _ref4.checkExtraNewline, followingSpan = _ref4.followingSpan, currentLine = _ref4.currentLine, checkSourceMod = _ref4.checkSourceMod, isCollapsed = _ref4.isCollapsed, nextOrgId = _ref4.nextOrgId, modifyingKey = _ref4.modifyingKey, getOrgParent = _ref4.getOrgParent, getOrgType = _ref4.getOrgType, orgEnv = _ref4.orgEnv, executeText = _ref4.executeText, getResultsForSource = _ref4.getResultsForSource, swapMarkup = _ref4.swapMarkup, modifiers = _ref4.modifiers, keyFuncs = _ref4.keyFuncs, defaultBindings = _ref4.defaultBindings, addKeyPress = _ref4.addKeyPress, findKeyBinding = _ref4.findKeyBinding, invalidateOrgText = _ref4.invalidateOrgText, setCurKeyBinding = _ref4.setCurKeyBinding, presentValue = _ref4.presentValue, propsFor = _ref4.propsFor, escapeHtml = _ref4.escapeHtml, escapeAttr = _ref4.escapeAttr, restorePosition = _ref4.restorePosition;

  redrawAllIssues = require('./storage').redrawAllIssues;

  _ = require('./lodash.min');

  lastOrgOffset = -1;

  curPos = -1;

  markupOrg = function(text) {
    var node, result, _ref5;
    _ref5 = markupOrgWithNode(text), node = _ref5[0], result = _ref5[1];
    return result;
  };

  markupOrgWithNode = function(text) {
    var nodes, org;
    nodes = {};
    if (text[text.length - 1] !== '\n') {
      text = text + '\n';
    }
    org = parseOrgMode(text);
    lastOrgOffset = -1;
    return [org, markupNode(org)];
  };

  markupNode = function(org) {
    var intertext, name, pos, src, text;
    if (org.offset <= lastOrgOffset) {
      return '';
    } else if (org instanceof Results) {
      pos = org.contentPos - org.offset;
      text = org.text.substring(pos);
      return "<span " + (orgAttrs(org)) + "><span data-org-type='text'>" + (escapeHtml(org.text.substring(0, pos))) + "</span>" + (contentSpan(text));
    } else if (org instanceof Keyword) {
      if (org.name.match(/^name$/i)) {
        intertext = '';
        name = org;
        src = org.next;
        while (src instanceof Meat && !(src instanceof Source)) {
          intertext += src.text;
          src = src.next;
        }
        if (src instanceof Source) {
          return markupSource(src, name, intertext);
        } else {
          return defaultMarkup(org);
        }
      } else if (org instanceof Source) {
        return markupSource(org);
      } else {
        return defaultMarkup(org);
      }
    } else if (org instanceof Headline) {
      return markupHeadline(org);
    } else if (content(org.text).length) {
      return defaultMarkup(org);
    } else {
      return "<div " + (orgAttrs(org)) + ">" + (escapeHtml(org.text)) + "</div>";
    }
  };

  markupHeadline = function(org) {
    return "<div " + (orgAttrs(org)) + " data-org-headline='" + (escapeAttr(org.level)) + "'><span data-org-type='text'>" + (escapeHtml(org.text)) + "</span>" + (markupGuts(org, checkStart(start, org.text))) + "</div>";
  };

  markupSource = function(org, name, intertext) {
    var lead, srcContent, trail;
    srcContent = org.content;
    lead = org.text.substring(0, org.contentPos - org.offset);
    trail = org.text.substring(org.contentPos - org.offset + org.content.length);
    return (isHtml(org) ? markupHtml : markupLeisure)(org, name, intertext, srcContent, lead, trail);
  };

  isHtml = function(org) {
    return org.info.match(/^ *html($| )/);
  };

  markupHtml = function(org, name, intertext, content, lead, trail) {
    var _ref5;
    return "<span class='hidden'>" + (escapeHtml(((_ref5 = name != null ? name.text : void 0) != null ? _ref5 : '') + (intertext != null ? intertext : '') + org.text)) + "</span><span data-org-html='true'>" + content + "</span>";
  };

  markupLeisure = function(org, name, intertext, content, lead, trail) {
    var codeBlock, html, nameM, pos, res;
    lastOrgOffset = org.offset;
    if (name) {
      nameM = name.text.match(keywordRE);
      codeBlock = " data-org-codeblock='" + (escapeAttr(name.info.trim())) + "'><div class='codename'><span class='hidden'>" + (escapeHtml(nameM[KW_BOILERPLATE])) + "</span><div><larger><b>" + (escapeHtml(name.info)) + "</b></larger></div>" + (escapeHtml(intertext)) + "</div>";
    } else {
      codeBlock = ">";
    }
    html = "<div class='codeblock' " + (orgAttrs(org)) + codeBlock + "<div class='hidden'>" + (escapeHtml(lead)) + "</div><div class='codewrapper'><div class='codecontent'>" + (escapeHtml(content)) + "</div><span class='hidden' data-org-type='boundary'>" + (escapeHtml(trail)) + "</span>";
    res = org.next;
    intertext = '';
    while (res && !(res instanceof Results) && !(res instanceof Keyword)) {
      intertext += res.text;
      res = res.next;
    }
    if (res instanceof Results) {
      lastOrgOffset = res.offset;
      pos = res.contentPos - res.offset;
      html += "" + (intertext ? "<div class='hidden' data-org-type='boundary'>" + escapeHtml(intertext) + "</div>" : '') + "<div class='results-indicator' data-org-type='boundary'><span></span></div><div class='coderesults' " + (orgAttrs(res)) + "><span class='hidden'>" + (escapeHtml(res.text.substring(0, pos))) + "</span><div>" + (reprocessResults(res.text.substring(pos))) + "</div></div>";
    }
    return html + (name ? "</div>" + (commentButton(name.info.trim())) + "</div>" + (commentBlock(name.info.trim())) : "</div></div>");
  };

  recreateAstButtons = function(node) {
    return restorePosition(node, function() {
      var button, cur, div, m, prev, r, t, _i, _len, _ref5, _results;
      _ref5 = $(node).find('.ast-button');
      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
        button = _ref5[_i];
        button.remove();
      }
      t = node.textContent;
      r = /^[^\n ]/gm;
      node.normalize();
      cur = node.firstChild;
      prev = 0;
      _results = [];
      while (m = r.exec(t)) {
        cur = cur.splitText(m.index - prev);
        prev = m.index;
        div = document.createElement('div');
        div.setAttribute('class', 'ast-button');
        div.setAttribute('contenteditable', 'false');
        (function(d, offset) {
          return div.onclick = function(e) {
            return showAst(d, offset);
          };
        })(div, m.index);
        if (prev === 0) {
          div.setAttribute('style', 'top: 0');
        }
        _results.push(node.insertBefore(div, cur));
      }
      return _results;
    });
  };

  showAst = function(astButton, offset) {
    var nl, result, text;
    if (!astButton.firstChild) {
      astButton.innerHTML = "<div></div>";
    }
    console.log("Clicked ast button at offset " + offset);
    text = astButton.parentNode.textContent;
    nl = text.indexOf('\n', offset + 1);
    text = text.substring(offset, (nl < 0 ? text.length : nl));
    result = rz(L_newParseLine)(lz(0))(L_nil)(lz(text));
    return runMonad(result, baseEnv, function(ast) {
      var err;
      if (getType(ast) !== 'parseErr') {
        console.log("SIMPLIFIED: " + (show(lz(runMonad(rz(L_simplify)(lz(text)))))));
        try {
          return setShadowHtml(astButton.firstChild, rz(L_wrappedTreeFor)(lz(ast))(L_id));
        } catch (_error) {
          err = _error;
        }
      }
    });
  };

  show = function(obj) {
    return rz(L_show)(lz(obj));
  };

  commentButton = function(name) {
    return "<button class='comment-button' onclick='Leisure.toggleComment(\"" + (escapeAttr(name)) + "\")' contenteditable='false' data-org-commentcount='0'><img src='icons/monotone_talk_chat_speech.png'><span></span></button>";
  };

  commentBlock = function(name) {
    return "<div class='comments' data-org-comments='" + (escapeAttr(name)) + "'><div></div></div>";
  };

  astButton = function(name) {
    return "<button class='ast-button' onclick='Leisure.toggleAst(\"" + (escapeAttr(name.info.trim())) + "\")' contenteditable='false'><img src='icons/monotone_groups.png'></button>";
  };

  toggleComment = function(name) {
    var block;
    block = $("[data-org-comments=" + name + "]");
    if (block.hasClass('showcomments')) {
      return block.removeClass('showcomments');
    } else {
      block.addClass('showcomments');
      return $("[data-org-codeblock='" + (escapeAttr(name)) + "'] button.comment-button").removeClass('new-comments');
    }
  };

  addComment = function(name) {
    return console.log("ADD A COMMENT FOR " + name);
  };

  defaultMarkup = function(org) {
    return "<span " + (orgAttrs(org)) + ">" + (escapeHtml(org.text)) + "</span>";
  };

  createResults = function(srcNode) {
    var created;
    while (srcNode && !srcNode.classList.contains('codeblock')) {
      srcNode = srcNode.parentNode;
    }
    if (created = srcNode && !$(srcNode).find('.coderesults').length) {
      $(srcNode).find('.codewrapper').append("<div class=\"results-indicator\" data-org-type=\"boundary\"><span></span></div><div class=\"coderesults\" data-org-type=\"results\"><span class=\"hidden\">#+RESULTS:\n</span><div>\n</div></div>");
    }
    return created;
  };

  shouldCancelBS = function(parent, r) {
    return atTextStart(r) && crossesHidden(-1);
  };

  atTextStart = function(r) {
    return r.collapsed && (r.startContainer.nodeType === 1 || (r.startContainer.nodeType === 3 && r.startOffset === 0));
  };

  atTextEnd = function(r) {
    return r.collapsed && (r.startContainer.nodeType === 1 || (r.startContainer.nodeType === 3 && ((r.startOffset === r.startContainer.length && 1) || (r.startOffset === r.startContainer.length - 1 && r.startContainer.textContent[r.startOffset] === '\n' && 2))));
  };

  shouldCancelDEL = function(parent, r) {
    var atEnd;
    return (atEnd = atTextEnd(r)) && crossesHidden(atEnd + 1);
  };

  matchLineAt = function(parent, pos) {
    var end, start, text;
    text = parent.textContent;
    start = text.substring(0, pos).lastIndexOf('\n');
    end = text.indexOf('\n', start + 1);
    if (end === -1) {
      end = text.length;
    }
    return matchLine(text.substring(start + 1, end));
  };

  markupGuts = function(org, start) {
    var c, p, prev, s;
    if (!org.children.length) {
      return '';
    } else {
      prev = start ? null : org;
      return ((function() {
        var _i, _len, _ref5, _results;
        _ref5 = org.children;
        _results = [];
        for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
          c = _ref5[_i];
          s = start;
          start = false;
          p = prev;
          prev = c;
          _results.push(markupNode(c, s));
        }
        return _results;
      })()).join("");
    }
  };

  currentTextPosition = function(parent, r) {
    if (curPos > -1) {
      return curPos;
    } else {
      return curPos = getTextPosition(parent, r || getSelection().getRangeAt(0));
    }
  };

  crossesHidden = function(delta) {
    var r, _ref5;
    r = getSelection().getRangeAt(0);
    return !((0 <= (_ref5 = r.startOffset) && _ref5 < r.startContainer.length)) && isCollapsed((delta < 0 ? textNodeBefore : textNodeAfter)(r.startContainer));
  };

  bindContent = function(div) {
    div.addEventListener('mousedown', function(e) {
      return setCurKeyBinding(null);
    });
    div.addEventListener('keydown', function(e) {
      var bound, br, c, cancelled, checkMod, currentMatch, el, n, needsReparse, par, r, s, _ref5;
      curPos = -1;
      c = e.charCode || e.keyCode || e.which;
      if (!addKeyPress(e, c)) {
        return;
      }
      s = getSelection();
      r = s.getRangeAt(0);
      _ref5 = findKeyBinding(e, div, r), bound = _ref5[0], checkMod = _ref5[1];
      if (bound) {
        cancelled = !checkMod;
      } else {
        checkMod = modifyingKey(c);
        cancelled = false;
      }
      if (!bound) {
        if (modifyingKey(c)) {
          n = s.focusNode;
          el = r.startContainer;
          par = el.parentNode;
          currentMatch = matchLine(currentLine(div));
          if (String.fromCharCode(c) === 'C' && e.altKey) {
            root.orgApi.executeSource(div, getSelection().focusNode);
          } else if (c === ENTER) {
            e.preventDefault();
            if (n.nodeType === 3 && r.collapsed && r.startOffset === n.length && n.parentNode.getAttribute('data-org-type') === 'text') {
              br = document.createTextNode('\n');
              $(br).prependTo(followingSpan(n.parentNode));
              r.setStart(br, br.length);
              r.setEnd(br, br.length);
            } else {
              r.insertNode(br = document.createTextNode(checkExtraNewline(r, n, div)));
              br.parentNode.normalize();
            }
            r.collapse();
            s.removeAllRanges();
            s.addRange(r);
            setTimeout((function() {
              return checkEnterReparse(div, r);
            }), 1);
          } else if (c === BS || c === DEL) {
            if ((c === BS && shouldCancelBS(div, r)) || (c === DEL && shouldCancelDEL(div, r))) {
              e.preventDefault();
              return;
            } else if (c === BS && bsWillDestroyParent(r)) {
              e.preventDefault();
              el.data = el.data.substring(1);
            }
          } else if (el.nodeType === 3) {
            setTimeout((function() {
              if (el.data[el.data.length - 1] !== '\n') {
                restorePosition(el.parentNode, function() {
                  return el.data += '\n';
                });
              }
              return fancyCheckSourceMod(n, div, currentMatch);
            }), 1);
            return;
          }
        }
      }
      if (!cancelled && checkMod) {
        if ((getOrgType(getOrgParent(el))) === 'boundary') {
          needsReparse = true;
        }
        return setTimeout((function() {
          return fancyCheckSourceMod(n, div, currentMatch);
        }), 1);
      }
    });
    div.addEventListener('DOMCharacterDataModified', handleMutation, true);
    div.addEventListener('DOMSubtreeModified', handleMutation, true);
    return displaySource();
  };

  isCodeContainer = function(node) {
    return node.classList.contains('codecontent');
  };

  fancyCheckSourceMod = function(focus, div, currentMatch) {
    if (isCodeContainer(focus.parentNode)) {
      return recreateAstButtons(focus.parentNode);
    }
  };

  bsWillDestroyParent = function(r) {
    if (r.startContainer.nodeType === 3 && r.startOffset === 1 && r.startContainer.data.match(/^.\n?$/)) {
      return r.startContainer.parentNode.textContent === r.startContainer.data;
    } else {
      return false;
    }
  };

  handleMutation = function(evt) {
    invalidateOrgText();
    return displaySource();
  };

  executeSource = function(parent, node) {
    var txt, _ref5;
    while (node && !((_ref5 = node.classList) != null ? _ref5.contains('codecontent') : void 0)) {
      node = node.parentNode;
    }
    if (node) {
      createResults(node);
      txt = node.textContent;
      if (txt.trim().length) {
        return executeText(node.textContent, propsFor(node), orgEnv(parent, node));
      }
    }
  };

  executeDef = function(node) {
    while (node && !node.hasAttribute('data-org-results')) {
      node = node.parentNode;
    }
    if (node) {
      return executeText($(node).find('.codecontent')[0].firstChild.textContent, propsFor(node), baseEnv);
    }
  };

  reprocessResults = function(str) {
    return escapeHtml(str).replace(/(^|\n): /g, '$1<span class="hidden">: </span>');
  };

  processResults = function(str) {
    if (str) {
      str = String(str);
      if (str[str.length - 1] === '\n') {
        str = str.substring(0, str.length - 1);
      }
      return "<span class='hidden'>: </span>" + (str.replace(/\n/g, '\n<span class="hidden">: </span>')) + "\n";
    } else {
      return str;
    }
  };

  setShadowHtml = function(holder, html) {
    var el;
    if (!(el = holder.shadowRoot)) {
      el = holder.createShadowRoot();
      el.applyAuthorStyles = true;
    }
    return el.innerHTML = html;
  };

  redrawIssue = function(issue) {
    var button, c, count, issueName, name;
    issueName = issue.leisureName;
    if ((name = $("[data-org-comments='" + issueName + "']")).length) {
      console.log("Showing comment button for " + issueName);
      count = issue.comments.length + 1;
      button = $("[data-org-codeblock='" + issueName + "'] button.comment-button");
      if (button.attr('data-org-commentcount') !== count) {
        button.attr('data-org-commentcount', count);
        button.addClass('new-comments');
      }
      setShadowHtml(button.find('span')[0], count);
      console.log("first gravatar: " + issue.comments[0].gravatar_id);
      return setShadowHtml(name[0].firstChild, "" + (commentHtml(issue, 'main')) + (((function() {
        var _i, _len, _ref5, _results;
        _ref5 = issue.comments;
        _results = [];
        for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
          c = _ref5[_i];
          _results.push(commentHtml(c, 'added'));
        }
        return _results;
      })()).join('')) + (newCommentBox(issueName)));
    }
  };

  commentHtml = function(comment, type) {
    return "<div class='commentbox'><img src='http://gravatar.com/avatar/" + comment.user.gravatar_id + "?s=48'><div class='" + type + "'>" + comment.body + "</div></div>";
  };

  newCommentBox = function(name) {
    return "<textarea pseudo='x-new-comment'></textarea><br><button onclick='Leisure.addComment(\"" + name + "\")'>Add Comment</button>";
  };

  orgEnv = function(parent, node) {
    var r;
    r = getResultsForSource(parent, node);
    if (r) {
      r.innerHTML = '';
      return {
        __proto__: defaultEnv,
        readFile: function(filename, cont) {
          return window.setTimeout((function() {
            return $.get(filename, function(data) {
              return cont(false, data);
            });
          }), 1);
        },
        write: function(str) {
          return r.innerHTML += processResults(str);
        },
        presentValue: presentValue
      };
    } else {
      return {
        __proto__: defaultEnv,
        readFile: function(filename, cont) {
          return window.setTimeout((function() {
            return $.get(filename, function(data) {
              return cont(false, data);
            });
          }), 1);
        },
        write: function(str) {
          return console.log(": " + (str.replace(/\n/g, '\n: ')) + "\n");
        }
      };
    }
  };

  baseEnv = {
    __proto__: defaultEnv,
    readFile: function(filename, cont) {
      return window.setTimeout((function() {
        return $.get(filename, function(data) {
          return cont(false, data);
        });
      }), 1);
    },
    write: function(str) {
      return console.log(processResults(str));
    }
  };

  fancyOrg = {
    __proto__: orgNotebook,
    markupOrg: markupOrg,
    markupOrgWithNode: markupOrgWithNode,
    bindContent: bindContent,
    installOrgDOM: function(parent, orgNode, orgText) {
      var node, _i, _j, _len, _len1, _ref5, _ref6,
        _this = this;
      orgNotebook.installOrgDOM(parent, orgNode, orgText);
      _ref5 = $('[data-org-html]');
      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
        node = _ref5[_i];
        console.log("HTML SRC: ", node, "TEXT: " + (node.getAttribute('data-org-html')));
        setShadowHtml(node, node.innerHTML);
        node.innerHTML = '';
      }
      _ref6 = $('.codecontent');
      for (_j = 0, _len1 = _ref6.length; _j < _len1; _j++) {
        node = _ref6[_j];
        recreateAstButtons(node);
      }
      return setTimeout((function() {
        var _k, _l, _len2, _len3, _ref7, _ref8;
        _ref7 = $('[data-org-results]');
        for (_k = 0, _len2 = _ref7.length; _k < _len2; _k++) {
          node = _ref7[_k];
          switch ($(node).attr('data-org-results').toLowerCase()) {
            case 'dynamic':
              _this.executeSource(parent, $(node).find('.codecontent')[0].firstChild);
              break;
            case 'def':
              _this.executeDef(node);
          }
        }
        _ref8 = $('[data-org-comments]');
        for (_l = 0, _len3 = _ref8.length; _l < _len3; _l++) {
          node = _ref8[_l];
          setShadowHtml(node.firstElementChild, newCommentBox(node.getAttribute('data-org-comments')));
        }
        return redrawAllIssues();
      }), 1);
    },
    executeSource: executeSource,
    executeDef: executeDef,
    createResults: createResults,
    bindings: defaultBindings,
    redrawIssue: function(i) {
      return redrawIssue(i);
    }
  };

  root.fancyOrg = fancyOrg;

  root.toggleComment = toggleComment;

  root.addComment = addComment;

  root.recreateAstButtons = recreateAstButtons;

}).call(this);

/*
//@ sourceMappingURL=fancyOrg.map
*/
