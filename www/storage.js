// Generated by CoffeeScript 1.6.3
(function() {
  var Github, Headline, Keyword, Meat, Results, Source, addComment, addIssue, checkEvents, commentHtml, commentIssueURLs, commentIssues, connectStorage, connection, defaultEnv, getAllIssuesAndCommentsThen, getContent, handleGithubEvent, initStorage, isIssueEvent, lastUpdate, lazy, redrawIssue, redrawIssues, refreshIssueData, reparse, repo, resolve, root, storageListener, _ref, _ref1,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ref = root = module.exports = require('./base'), resolve = _ref.resolve, lazy = _ref.lazy, defaultEnv = _ref.defaultEnv;

  _ref1 = require('./org'), Headline = _ref1.Headline, Meat = _ref1.Meat, Keyword = _ref1.Keyword, Source = _ref1.Source, Results = _ref1.Results;

  reparse = require('./orgSupport').reparse;

  Github = require('./github');

  connection = null;

  repo = null;

  commentIssues = {};

  commentIssueURLs = {};

  initStorage = function() {
    $('#name').val(localStorage.getItem('githubName'));
    $('#password').val(localStorage.getItem('githubPassword'));
    $('#user').val(localStorage.getItem('githubUser'));
    $('#repository').val(localStorage.getItem('githubRepository'));
    return $('#file').val(localStorage.getItem('githubFile'));
  };

  lastUpdate = 0;

  getContent = function(data) {
    return atob(data.content);
  };

  connectStorage = function() {
    var file, name, password, repository, user;
    localStorage.setItem('githubName', name = $('#name').val());
    localStorage.setItem('githubPassword', password = $('#password').val());
    localStorage.setItem('githubUser', user = $('#user').val());
    localStorage.setItem('githubRepository', repository = $('#repository').val());
    localStorage.setItem('githubFile', file = $('#file').val());
    connection = root.githubConnect({
      username: name,
      password: password
    });
    repo = connection.getRepo(user, repository);
    return repo.getEvents(null, function(err, data) {
      if (err) {
        console.log("ERROR: " + (JSON.stringify(err, null, ' ')));
        return;
      }
      lastUpdate = new Date(data[0].created_at).getTime();
      return getAllIssuesAndCommentsThen(connection, user, repository, function(issueList) {
        var contents;
        if (!(__indexOf.call(root.reparseListeners, storageListener) >= 0)) {
          root.reparseListeners.push(storageListener);
        }
        return contents = repo.contents('master', file, function(err, data) {
          if (!err) {
            reparse($('[maindoc]')[0], data);
          } else {
            alert("ERROR: " + err);
          }
          document.body.classList.remove('not-logged-in');
          return checkEvents(lastUpdate, 1, []);
        });
      });
    });
  };

  isIssueEvent = function(event) {
    var _ref2;
    return (_ref2 = event.type) === 'IssueCommentEvent' || _ref2 === 'IssuesEvent';
  };

  window.EVENTS = [];

  checkEvents = function(lastUp, page, events) {
    return repo.getEvents({
      page: page
    }, function(err, data) {
      var event, issues, time, url, _i, _len;
      if (err) {
        console.log("ERROR: " + (JSON.stringify(err, null, ' ')));
        return;
      }
      if (data.length > 0 && data && (time = new Date(data[0].created_at).getTime()) > lastUp) {
        window.EVENTS.push(data);
        while (data.length > 0 && isIssueEvent(data[0]) && (time = new Date(data[0].created_at).getTime()) > lastUp) {
          data[0].time = time;
          if (time > lastUpdate) {
            lastUpdate = time;
          }
          if (data[0].type === 'IssueCommentEvent') {
            addComment(data[0].payload.comment);
          }
          events.push(data.shift());
        }
        return checkEvents(lastUp, page + 1, events);
      } else {
        events.sort(function(a, b) {
          return a.time - b.time;
        });
        issues = {};
        for (_i = 0, _len = events.length; _i < _len; _i++) {
          event = events[_i];
          issues[event.payload.issue.url] = true;
        }
        refreshIssueData(0, (function() {
          var _results;
          _results = [];
          for (url in issues) {
            _results.push(url);
          }
          return _results;
        })(), function(i) {
          return redrawIssues(i);
        });
        return setTimeout((function() {
          return checkEvents(lastUpdate, 1, []);
        }), 1000);
      }
    });
  };

  redrawIssues = function(issues) {
    var issue, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = issues.length; _i < _len; _i++) {
      issue = issues[_i];
      _results.push(redrawIssue(issue));
    }
    return _results;
  };

  redrawIssue = function(issue) {
    var c, issueName, name, nameEl, _ref2;
    issueName = issue.title.trim();
    if (!(name = $("[data-org-comments='" + issueName + "']")).length) {
      nameEl = $("[data-org-name='" + issueName + "']");
      if (!nameEl.length) {
        return;
      }
      name = $(nameEl).after("<span data-org-comments='" + issueName + "'></span>").next();
      root = name[0].createShadowRoot();
      root.applyAuthorStyles = true;
    }
    console.log("first gravatar: " + issue.comments[0].gravatar_id);
    return (_ref2 = name[0]) != null ? _ref2.shadowRoot.innerHTML = "" + (commentHtml(issue, 'main')) + (((function() {
      var _i, _len, _ref3, _results;
      _ref3 = issue.comments;
      _results = [];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        c = _ref3[_i];
        _results.push(commentHtml(c, 'added'));
      }
      return _results;
    })()).join('')) : void 0;
  };

  commentHtml = function(comment, type) {
    return "<div class='commentbox'><img src='http://gravatar.com/avatar/" + comment.user.gravatar_id + "?s=48'><div class='" + type + "'>" + comment.body + "</div></div>";
  };

  addComment = function(comment) {
    var i, issue, _i, _ref2;
    if (issue = commentIssueURLs[comment.issue_url]) {
      for (i = _i = 0, _ref2 = issue.comments.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
        if (issue.comments[i].url === comment.url) {
          issue.comments[i] = comment;
          return;
        }
      }
      return issue.comments.push(comment);
    }
  };

  addIssue = function(issue) {
    var label, _i, _len, _ref2;
    _ref2 = issue.labels;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      label = _ref2[_i];
      if (label.name === 'comment') {
        commentIssues[issue.title.trim()] = issue;
        commentIssueURLs[issue.url] = issue;
        return;
      }
    }
    delete commentIssues[issue.title.trim()];
    return delete commentIssueURLs[issue.url];
  };

  refreshIssueData = function(index, urls, cont) {
    var issue;
    if (index < urls.length) {
      return Github._request("GET", urls[index], null, function(err, data) {
        var _ref2, _ref3;
        if (err) {
          console.log("ERROR: " + (JSON.stringify(err, null, ' ')));
          return;
        }
        if (data.comments_url != null) {
          data.comments = (_ref2 = (_ref3 = commentIssueURLs[data.url]) != null ? _ref3.comments : void 0) != null ? _ref2 : [];
          addIssue(data);
        }
        return refreshIssueData(index + 1, urls, cont);
      });
    } else {
      return cont((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = urls.length; _i < _len; _i++) {
          issue = urls[_i];
          _results.push(commentIssueURLs[issue]);
        }
        return _results;
      })());
    }
  };

  handleGithubEvent = function(event) {
    var name;
    if (event.type === 'IssueCommentEvent') {
      event.payload.comment.body;
    }
    return name = event.payload.issue.title;
  };

  getAllIssuesAndCommentsThen = function(con, userName, repoName, block) {
    var issues;
    issues = con.getIssues(userName, repoName);
    return issues.list({}, function(err, issueList) {
      var num, processComments;
      if (!err) {
        num = 0;
        processComments = function() {
          var found, getComments, l, _i, _len, _ref2, _ref3;
          if (num < issueList.length) {
            found = false;
            _ref3 = (_ref2 = issueList[num].labels) != null ? _ref2 : [];
            for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
              l = _ref3[_i];
              if (l.name === 'comment') {
                found = true;
                addIssue(issueList[num]);
                issueList[num].comments = [];
                getComments = function(page) {
                  return issues.getComments(issueList[num].number, {
                    page: page
                  }, function(err, comments) {
                    var _ref4;
                    if (err) {
                      return console.log("ERROR FETCHING COMMENTS FOR ISSUE " + num + ": " + err);
                    } else if (comments.length === 0) {
                      num++;
                      return processComments();
                    } else {
                      (_ref4 = issueList[num].comments).push.apply(_ref4, comments);
                      return getComments(page + 1);
                    }
                  });
                };
                getComments(1);
              }
            }
            if (!found) {
              num++;
              return processComments();
            }
          } else {
            return block(issueList);
          }
        };
        return processComments();
      } else {
        return block([]);
      }
    });
  };

  storageListener = function(parent, orgNode, orgText) {
    return orgNode.scan(function(node) {
      var issue, name;
      if (node instanceof Source) {
        name = node.prev;
        while (name instanceof Meat && name.text.match(/^[ \n]*$/)) {
          name = name.prev;
        }
        if (name instanceof Keyword && name.name.match(/name/i)) {
          if ((issue = commentIssues[name.name.trim()])) {
            return redrawIssue(issue);
          }
        }
      }
    });
  };

  root.initStorage = initStorage;

  root.connectStorage = connectStorage;

}).call(this);

/*
//@ sourceMappingURL=storage.map
*/
