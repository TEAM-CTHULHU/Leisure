// Generated by CoffeeScript 1.6.3
(function() {
  var Github, Headline, Keyword, Meat, Results, Source, addComment, addIssue, checkEvents, commentHtml, commentIssueURLs, commentIssues, connectStorage, connection, currentFile, defaultEnv, getAllIssuesAndCommentsThen, getContent, getRelevantIssueName, initStorage, isIssueEvent, lastUpdate, lazy, loadOrg, redrawAllIssues, redrawIssue, redrawIssues, refreshIssueData, repo, resolve, root, storageListener, useFile, _ref, _ref1,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ref = root = module.exports = require('./base'), resolve = _ref.resolve, lazy = _ref.lazy, defaultEnv = _ref.defaultEnv;

  _ref1 = require('./org'), Headline = _ref1.Headline, Meat = _ref1.Meat, Keyword = _ref1.Keyword, Source = _ref1.Source, Results = _ref1.Results;

  loadOrg = require('./orgSupport').loadOrg;

  Github = require('./github');

  connection = null;

  repo = null;

  commentIssues = {};

  commentIssueURLs = {};

  initStorage = function() {
    $('#name').val(localStorage.getItem('githubName'));
    $('#password').val(localStorage.getItem('githubPassword'));
    $('#user').val(localStorage.getItem('githubUser'));
    $('#repository').val(localStorage.getItem('githubRepository'));
    return $('#file').val(localStorage.getItem('githubFile'));
  };

  currentFile = null;

  lastUpdate = 0;

  getContent = function(data) {
    return atob(data.content);
  };

  useFile = function(file) {
    var reader;
    reader = new FileReader();
    reader.onload = function(e) {
      return loadOrg($('[maindoc]')[0], e.target.result);
    };
    reader.readAsText(file);
    document.body.classList.remove('not-logged-in');
    return checkEvents(lastUpdate, 1, []);
  };

  connectStorage = function() {
    var name, password, repository, user;
    localStorage.setItem('githubName', name = $('#name').val());
    localStorage.setItem('githubPassword', password = $('#password').val());
    localStorage.setItem('githubUser', user = $('#user').val());
    localStorage.setItem('githubRepository', repository = $('#repository').val());
    localStorage.setItem('githubFile', currentFile = $('#file').val());
    connection = root.githubConnect({
      username: name,
      password: password
    });
    repo = connection.getRepo(user, repository);
    return repo.getEvents(null, function(err, data) {
      if (err) {
        console.log("ERROR: " + (JSON.stringify(err, null, ' ')));
        return;
      }
      lastUpdate = new Date(data[0].created_at).getTime();
      return getAllIssuesAndCommentsThen(connection, user, repository, function(issueList) {
        var contents;
        if (!(__indexOf.call(root.reparseListeners, storageListener) >= 0)) {
          root.reparseListeners.push(storageListener);
        }
        return contents = repo.contents('master', currentFile, function(err, data) {
          if (!err) {
            loadOrg($('[maindoc]')[0], data);
          } else {
            alert("ERROR: " + err);
          }
          document.body.classList.remove('not-logged-in');
          return checkEvents(lastUpdate, 1, []);
        });
      });
    });
  };

  isIssueEvent = function(event) {
    var _ref2;
    return (_ref2 = event.type) === 'IssueCommentEvent' || _ref2 === 'IssuesEvent';
  };

  window.EVENTS = [];

  checkEvents = function(lastUp, page, events) {
    if (repo != null) {
      return repo.getEvents({
        page: page
      }, function(err, data) {
        var event, issues, time, url, _i, _len;
        if (err) {
          console.log("ERROR: " + (JSON.stringify(err, null, ' ')));
          return;
        }
        if (data.length > 0 && data && (time = new Date(data[0].created_at).getTime()) > lastUp) {
          window.EVENTS.push(data);
          while (data.length > 0 && isIssueEvent(data[0]) && (time = new Date(data[0].created_at).getTime()) > lastUp) {
            data[0].time = time;
            if (time > lastUpdate) {
              lastUpdate = time;
            }
            if (data[0].type === 'IssueCommentEvent') {
              addComment(data[0].payload.comment);
            }
            events.push(data.shift());
          }
          return checkEvents(lastUp, page + 1, events);
        } else {
          events.sort(function(a, b) {
            return a.time - b.time;
          });
          issues = {};
          for (_i = 0, _len = events.length; _i < _len; _i++) {
            event = events[_i];
            issues[event.payload.issue.url] = true;
          }
          refreshIssueData(0, (function() {
            var _results;
            _results = [];
            for (url in issues) {
              _results.push(url);
            }
            return _results;
          })(), function(i) {
            return redrawIssues(i);
          });
          return setTimeout((function() {
            return checkEvents(lastUpdate, 1, []);
          }), 1000);
        }
      });
    }
  };

  redrawAllIssues = function() {
    var issue, name, _results;
    _results = [];
    for (name in commentIssues) {
      issue = commentIssues[name];
      _results.push(root.currentMode.redrawIssue(issue));
    }
    return _results;
  };

  redrawIssues = function(issues) {
    var issue, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = issues.length; _i < _len; _i++) {
      issue = issues[_i];
      _results.push(root.currentMode.redrawIssue(issue));
    }
    return _results;
  };

  getRelevantIssueName = function(issue) {
    var match;
    if (match = issue.title.trim().match(new RegExp("^" + currentFile + ":(.*)$"))) {
      return issue.leisureName = match[1];
    } else {
      return null;
    }
  };

  redrawIssue = function(issue) {
    var c, issueName, name, nameEl, _ref2;
    if (issueName = getRelevantIssueName(issue)) {
      if (!(name = $("[data-org-comments='" + issueName + "']")).length) {
        nameEl = $("[data-org-name='" + issueName + "']");
        if (!nameEl.length) {
          return;
        }
        name = $(nameEl).after("<span data-org-comments='" + issueName + "'></span>").next();
        root = name[0].createShadowRoot();
        root.applyAuthorStyles = true;
      }
      console.log("first gravatar: " + issue.comments[0].gravatar_id);
      return (_ref2 = name[0]) != null ? _ref2.shadowRoot.innerHTML = "" + (commentHtml(issue, 'main')) + (((function() {
        var _i, _len, _ref3, _results;
        _ref3 = issue.comments;
        _results = [];
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          c = _ref3[_i];
          _results.push(commentHtml(c, 'added'));
        }
        return _results;
      })()).join('')) : void 0;
    }
  };

  commentHtml = function(comment, type) {
    return "<div class='commentbox'><img src='http://gravatar.com/avatar/" + comment.user.gravatar_id + "?s=48'><div class='" + type + "'>" + comment.body + "</div></div>";
  };

  addComment = function(comment) {
    var i, issue, _i, _ref2;
    if (issue = commentIssueURLs[comment.issue_url]) {
      for (i = _i = 0, _ref2 = issue.comments.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
        if (issue.comments[i].url === comment.url) {
          issue.comments[i] = comment;
          return;
        }
      }
      return issue.comments.push(comment);
    }
  };

  addIssue = function(issue) {
    var label, name, _i, _len, _ref2;
    if (name = getRelevantIssueName(issue)) {
      _ref2 = issue.labels;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        label = _ref2[_i];
        if (label.name === 'comment') {
          commentIssues[name] = issue;
          commentIssueURLs[issue.url] = issue;
          return;
        }
      }
      if (commentIssueURLs[issue.url]) {
        delete commentIssues[name];
        return delete commentIssueURLs[issue.url];
      }
    }
  };

  refreshIssueData = function(index, urls, cont) {
    var issue;
    if (index < urls.length) {
      return Github._request("GET", urls[index], null, function(err, data) {
        var _ref2, _ref3;
        if (err) {
          console.log("ERROR: " + (JSON.stringify(err, null, ' ')));
          return;
        }
        if (data.comments_url != null) {
          data.comments = (_ref2 = (_ref3 = commentIssueURLs[data.url]) != null ? _ref3.comments : void 0) != null ? _ref2 : [];
          addIssue(data);
        }
        return refreshIssueData(index + 1, urls, cont);
      });
    } else {
      return cont((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = urls.length; _i < _len; _i++) {
          issue = urls[_i];
          _results.push(commentIssueURLs[issue]);
        }
        return _results;
      })());
    }
  };

  getAllIssuesAndCommentsThen = function(con, userName, repoName, block) {
    var issues;
    issues = con.getIssues(userName, repoName);
    return issues.list({}, function(err, issueList) {
      var num, processComments;
      if (!err) {
        num = 0;
        processComments = function() {
          var found, getComments, l, _i, _len, _ref2, _ref3;
          if (num < issueList.length) {
            found = false;
            _ref3 = (_ref2 = issueList[num].labels) != null ? _ref2 : [];
            for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
              l = _ref3[_i];
              if (l.name === 'comment') {
                found = true;
                addIssue(issueList[num]);
                issueList[num].comments = [];
                getComments = function(page) {
                  return issues.getComments(issueList[num].number, {
                    page: page
                  }, function(err, comments) {
                    var _ref4;
                    if (err) {
                      return console.log("ERROR FETCHING COMMENTS FOR ISSUE " + num + ": " + err);
                    } else if (comments.length === 0) {
                      num++;
                      return processComments();
                    } else {
                      (_ref4 = issueList[num].comments).push.apply(_ref4, comments);
                      return getComments(page + 1);
                    }
                  });
                };
                getComments(1);
              }
            }
            if (!found) {
              num++;
              return processComments();
            }
          } else {
            return block(issueList);
          }
        };
        return processComments();
      } else {
        return block([]);
      }
    });
  };

  storageListener = function(parent, orgNode, orgText) {
    return orgNode.scan(function(node) {
      var issue, name;
      if (node instanceof Source) {
        name = node.prev;
        while (name && !(name instanceof Keyword && name.name.match(/name/i)) && !(name instanceof Source) && !(name instanceof Headline)) {
          name = name.prev;
        }
        if (name instanceof Keyword && name.name.match(/name/i)) {
          if ((issue = commentIssues[name.info.trim()])) {
            return root.currentMode.redrawIssue(issue);
          }
        }
      }
    });
  };

  root.initStorage = initStorage;

  root.connectStorage = connectStorage;

  root.redrawAllIssues = redrawAllIssues;

  root.useFile = useFile;

}).call(this);

/*
//@ sourceMappingURL=storage.map
*/
