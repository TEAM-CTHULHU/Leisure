// Generated by CoffeeScript 1.6.3
(function() {
  var Github, Headline, Keyword, Meat, Results, Source, addComment, addIssue, checkEvents, commentHtml, commentIssueURLs, commentIssues, connectStorage, connection, createComment, currentFile, defaultEnv, getAllIssuesAndCommentsThen, getContent, getRelevantIssueName, githubParams, initStorage, isIssueEvent, lastUpdate, lazy, loadOrg, redrawAllIssues, redrawIssue, redrawIssues, refreshIssueData, repo, resolve, root, storageListener, storeInGit, useFile, useUrl, _ref, _ref1,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ref = root = module.exports = require('./base'), resolve = _ref.resolve, lazy = _ref.lazy, defaultEnv = _ref.defaultEnv;

  _ref1 = require('./org'), Headline = _ref1.Headline, Meat = _ref1.Meat, Keyword = _ref1.Keyword, Source = _ref1.Source, Results = _ref1.Results;

  loadOrg = require('./orgSupport').loadOrg;

  Github = require('./github');

  connection = null;

  repo = null;

  commentIssues = {};

  commentIssueURLs = {};

  initStorage = function() {
    var load, uri;
    uri = new URI(document.location.toString());
    if (load = uri.getFragParams().load) {
      return useUrl(decodeURIComponent(load));
    } else {
      $('#name').val(localStorage.getItem('githubName'));
      $('#password').val(localStorage.getItem('githubPassword'));
      $('#user').val(localStorage.getItem('githubUser'));
      $('#repository').val(localStorage.getItem('githubRepository'));
      return $('#file').val(localStorage.getItem('githubFile'));
    }
  };

  currentFile = null;

  lastUpdate = 0;

  getContent = function(data) {
    return atob(data.content);
  };

  useUrl = function(url) {
    return ($.get(url, function(data) {
      loadOrg($('[maindoc]')[0], data, (url.match(/^\w+:/) ? new URI(url).path : url));
      document.body.classList.remove('not-logged-in');
      return checkEvents(lastUpdate, 1, []);
    })).fail(function(err) {
      return alert("Couldn't load url: " + url);
    });
  };

  useFile = function(file) {
    var reader;
    reader = new FileReader();
    reader.onload = function(e) {
      var _ref2;
      return loadOrg($('[maindoc]')[0], e.target.result, (_ref2 = file.path) != null ? _ref2 : file.name);
    };
    reader.readAsText(file);
    document.body.classList.remove('not-logged-in');
    return checkEvents(lastUpdate, 1, []);
  };

  githubParams = null;

  connectStorage = function() {
    var name, password, repository, user;
    localStorage.setItem('githubName', name = decodeURIComponent($('#name').val()));
    localStorage.setItem('githubPassword', password = decodeURIComponent($('#password').val()));
    localStorage.setItem('githubUser', user = decodeURIComponent($('#user').val()));
    localStorage.setItem('githubRepository', repository = decodeURIComponent($('#repository').val()));
    localStorage.setItem('githubFile', currentFile = decodeURIComponent($('#file').val()));
    root.githubParams = githubParams = {
      user: user,
      name: repository,
      repo: repository,
      repository: repository,
      file: currentFile,
      username: user,
      password: password
    };
    connection = root.githubConnect({
      username: name,
      password: password
    });
    root.repo = repo = root.getRepo(githubParams);
    return repo.getEvents(null, function(err, data) {
      if (err) {
        console.log("ERROR: " + (JSON.stringify(err, null, ' ')));
        return;
      }
      lastUpdate = new Date(data[0].created_at).getTime();
      return getAllIssuesAndCommentsThen(connection, user, repository, function(issueList) {
        var contents;
        if (!(__indexOf.call(root.reparseListeners, storageListener) >= 0)) {
          root.reparseListeners.push(storageListener);
        }
        return contents = repo.contents('master', currentFile, function(err, data) {
          if (!err) {
            loadOrg($('[maindoc]')[0], data, currentFile);
          } else {
            alert("ERROR: " + err);
          }
          document.body.classList.remove('not-logged-in');
          return checkEvents(lastUpdate, 1, []);
        });
      });
    });
  };

  storeInGit = function(contents, path, branch, cb) {
    return repo.setContents(branch != null ? branch : 'master', path != null ? path : githubParams.file, contents, cb);
  };

  isIssueEvent = function(event) {
    var _ref2;
    return (_ref2 = event.type) === 'IssueCommentEvent' || _ref2 === 'IssuesEvent';
  };

  window.EVENTS = [];

  checkEvents = function(lastUp, page, events) {
    if (repo != null) {
      return repo.getEvents({
        page: page
      }, function(err, data) {
        var event, issues, time, url, _i, _len;
        if (err) {
          console.log("ERROR: " + (JSON.stringify(err, null, ' ')));
          return;
        }
        if (data.length > 0 && data && (time = new Date(data[0].created_at).getTime()) > lastUp) {
          window.EVENTS.push(data);
          while (data.length > 0 && isIssueEvent(data[0]) && (time = new Date(data[0].created_at).getTime()) > lastUp) {
            data[0].time = time;
            if (time > lastUpdate) {
              lastUpdate = time;
            }
            if (data[0].type === 'IssueCommentEvent') {
              addComment(data[0].payload.comment);
            }
            events.push(data.shift());
          }
          return checkEvents(lastUp, page + 1, events);
        } else {
          events.sort(function(a, b) {
            return a.time - b.time;
          });
          issues = {};
          for (_i = 0, _len = events.length; _i < _len; _i++) {
            event = events[_i];
            issues[event.payload.issue.url] = true;
          }
          refreshIssueData(0, (function() {
            var _results;
            _results = [];
            for (url in issues) {
              _results.push(url);
            }
            return _results;
          })(), function(i) {
            return redrawIssues(i);
          });
          return setTimeout((function() {
            return checkEvents(lastUpdate, 1, []);
          }), 1000);
        }
      });
    }
  };

  redrawAllIssues = function() {
    var issue, name, _results;
    _results = [];
    for (name in commentIssues) {
      issue = commentIssues[name];
      _results.push(root.currentMode.redrawIssue(issue));
    }
    return _results;
  };

  redrawIssues = function(issues) {
    var issue, l, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = issues.length; _i < _len; _i++) {
      issue = issues[_i];
      if (issue) {
        _results.push((function() {
          var _j, _len1, _ref2, _results1;
          _ref2 = issue.labels;
          _results1 = [];
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            l = _ref2[_j];
            if (l.name === 'comment') {
              root.currentMode.redrawIssue(issue);
            }
            break;
          }
          return _results1;
        })());
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  getRelevantIssueName = function(issue) {
    var match;
    if (match = issue.title.trim().match(new RegExp("^" + currentFile + ":(.*)$"))) {
      return issue.leisureName = match[1];
    } else {
      return null;
    }
  };

  redrawIssue = function(issue) {
    var c, issueName, name, nameEl, _ref2;
    if (issueName = getRelevantIssueName(issue)) {
      if (!(name = $("[data-org-comments='" + issueName + "']")).length) {
        nameEl = $("[data-org-name='" + issueName + "']");
        if (!nameEl.length) {
          return;
        }
        name = $(nameEl).after("<span data-org-comments='" + issueName + "'></span>").next();
        root = name[0].createShadowRoot();
        root.applyAuthorStyles = true;
      }
      console.log("first gravatar: " + issue.comments[0].gravatar_id);
      return (_ref2 = name[0]) != null ? _ref2.shadowRoot.innerHTML = "" + (commentHtml(issue, 'main')) + (((function() {
        var _i, _len, _ref3, _results;
        _ref3 = issue.comments;
        _results = [];
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          c = _ref3[_i];
          _results.push(commentHtml(c, 'added'));
        }
        return _results;
      })()).join('')) : void 0;
    }
  };

  commentHtml = function(comment, type) {
    return "<div class='commentbox'><img src='http://gravatar.com/avatar/" + comment.user.gravatar_id + "?s=48'><div class='" + type + "'>" + comment.body + "</div></div>";
  };

  addComment = function(comment) {
    var i, issue, _i, _ref2;
    if (issue = commentIssueURLs[comment.issue_url]) {
      for (i = _i = 0, _ref2 = issue.comments.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
        if (issue.comments[i].url === comment.url) {
          issue.comments[i] = comment;
          return;
        }
      }
      return issue.comments.push(comment);
    }
  };

  addIssue = function(issue) {
    var label, name, _i, _len, _ref2;
    if (name = getRelevantIssueName(issue)) {
      _ref2 = issue.labels;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        label = _ref2[_i];
        if (label.name === 'comment') {
          commentIssues[name] = issue;
          commentIssueURLs[issue.url] = issue;
          return;
        }
      }
      if (commentIssueURLs[issue.url]) {
        delete commentIssues[name];
        return delete commentIssueURLs[issue.url];
      }
    }
  };

  refreshIssueData = function(index, urls, cont) {
    var issue;
    if (index < urls.length) {
      return Github._request("GET", urls[index], null, function(err, data) {
        var l, _i, _len, _ref2, _ref3, _ref4;
        if (err) {
          console.log("ERROR: " + (JSON.stringify(err, null, ' ')));
          return;
        }
        if (data.comments_url != null) {
          _ref2 = data.labels;
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            l = _ref2[_i];
            if (l.name === 'comment') {
              data.comments = (_ref3 = (_ref4 = commentIssueURLs[data.url]) != null ? _ref4.comments : void 0) != null ? _ref3 : [];
              addIssue(data);
              break;
            }
          }
        }
        return refreshIssueData(index + 1, urls, cont);
      });
    } else {
      return cont((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = urls.length; _i < _len; _i++) {
          issue = urls[_i];
          _results.push(commentIssueURLs[issue]);
        }
        return _results;
      })());
    }
  };

  createComment = function(funcName, comment, user, repository, file) {
    var data, issue;
    if (issue = commentIssues[funcName]) {
      return Github._request("POST", "/repos/" + (user != null ? user : githubParams.user) + "/" + (repository != null ? repository : githubParams.repository) + "/issues/" + issue.number + "/comments", {
        body: comment
      }, function(err, data) {
        return console.log("GITHUB " + (err ? 'ERROR' : 'SUCCESS') + ": " + (JSON.stringify(err != null ? err : data)));
      });
    } else {
      data = {
        title: "" + (file != null ? file : githubParams.file) + ":" + funcName,
        body: comment,
        labels: ['comment']
      };
      return Github._request("POST", "/repos/" + (user != null ? user : githubParams.user) + "/" + (repository != null ? repository : githubParams.repository) + "/issues", data, function(err, data) {
        return console.log("GITHUB " + (err ? 'ERROR' : 'SUCCESS') + ": " + (JSON.stringify(err != null ? err : data)));
      });
    }
  };

  getAllIssuesAndCommentsThen = function(con, userName, repoName, block) {
    var issues;
    issues = con.getIssues(userName, repoName);
    return issues.list({}, function(err, issueList) {
      var num, processComments;
      if (!err) {
        num = 0;
        processComments = function() {
          var found, getComments, l, _i, _len, _ref2, _ref3;
          if (num < issueList.length) {
            found = false;
            _ref3 = (_ref2 = issueList[num].labels) != null ? _ref2 : [];
            for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
              l = _ref3[_i];
              if (l.name === 'comment') {
                found = true;
                addIssue(issueList[num]);
                issueList[num].comments = [];
                getComments = function(page) {
                  return issues.getComments(issueList[num].number, {
                    page: page
                  }, function(err, comments) {
                    var _ref4;
                    if (err) {
                      return console.log("ERROR FETCHING COMMENTS FOR ISSUE " + num + ": " + err);
                    } else if (comments.length === 0) {
                      num++;
                      return processComments();
                    } else {
                      (_ref4 = issueList[num].comments).push.apply(_ref4, comments);
                      return getComments(page + 1);
                    }
                  });
                };
                getComments(1);
              }
            }
            if (!found) {
              num++;
              return processComments();
            }
          } else {
            return block(issueList);
          }
        };
        return processComments();
      } else {
        return block([]);
      }
    });
  };

  storageListener = function(parent, orgNode, orgText) {
    return orgNode.scan(function(node) {
      var issue, name;
      if (node instanceof Source) {
        name = node.prev;
        while (name && !(name instanceof Keyword && name.name.match(/name/i)) && !(name instanceof Source) && !(name instanceof Headline)) {
          name = name.prev;
        }
        if (name instanceof Keyword && name.name.match(/name/i)) {
          if ((issue = commentIssues[name.info.trim()])) {
            return root.currentMode.redrawIssue(issue);
          }
        }
      }
    });
  };

  root.initStorage = initStorage;

  root.connectStorage = connectStorage;

  root.redrawAllIssues = redrawAllIssues;

  root.useFile = useFile;

  root.createComment = createComment;

  root.storeInGit = storeInGit;

  root.repo = repo;

}).call(this);

/*
//@ sourceMappingURL=storage.map
*/
