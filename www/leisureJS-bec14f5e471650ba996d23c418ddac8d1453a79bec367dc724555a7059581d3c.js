;(function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require=="function"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error("Cannot find module '"+n+"'")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require=="function"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({1:[function(require,module,exports){
(function(global){// Generated by CoffeeScript 1.6.2
/*
Copyright (C) 2012, Bill Burdick, Tiny Concepts: https://github.com/zot/Leisure

(licensed with ZLIB license)

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software
in a product, an acknowledgment in the product documentation would be
appreciated but is not required.

2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.

3. This notice may not be removed or altered from any source distribution.
*/


(function() {
  var L_anno, L_apply, L_lambda, L_let, L_lit, L_ref, LeisureObject, Leisure_BaseCons, Leisure_cons, Leisure_nil, Nil, anno, apply, ast2Json, ast2JsonEncodings, astString, charCodes, checkType, cons, consEq, consFrom, define, ensureLeisureClass, evalFunc, foldLeft, functionInfo, getAnnoBody, getAnnoData, getAnnoName, getApplyArg, getApplyFunc, getDataType, getLambdaBody, getLambdaVar, getLetBody, getLetName, getLetValue, getLitVal, getRefName, getType, head, jsType, json2Ast, json2AstEncodings, lambda, leisureAddFunc, letStr, lit, llet, makeSuper, mkProto, nameFunc, nameSub, primCons, primFoldLeft, ref, root, save, setDataType, setType, supertypes, tail, throwError, _, _ref, _ref1, _ref2,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  root = module.exports = require('./base');

  _ = require('./lodash.min');

  charCodes = {
    "'": '$a',
    ',': '$b',
    '$': '$$',
    '@': '$d',
    '?': '$e',
    '/': '$f',
    '*': '$g',
    '&': '$h',
    '^': '$i',
    '!': '$k',
    '`': '$l',
    '~': '$m',
    '-': '$_',
    '+': '$o',
    '=': '$p',
    '|': '$q',
    '[': '$r',
    ']': '$s',
    '{': '$t',
    '}': '$u',
    '"': '$v',
    ':': '$w',
    ';': '$x',
    '<': '$y',
    '>': '$z',
    '%': '$A',
    '.': '$B'
  };

  nameSub = function(name) {
    var code, i, s, _i, _ref;

    s = '';
    for (i = _i = 0, _ref = name.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      code = charCodes[name[i]];
      s += code != null ? code : name[i];
    }
    return s;
  };

  setDataType = function(func, dataType) {
    if (dataType) {
      func.dataType = dataType;
    }
    return func;
  };

  setType = function(func, type) {
    if (type) {
      func.type = type;
    }
    func.__proto__ = (ensureLeisureClass(type)).prototype;
    return func;
  };

  LeisureObject = (function() {
    function LeisureObject() {}

    return LeisureObject;

  })();

  LeisureObject.prototype.className = 'LeisureObject';

  global.Leisure_Object = LeisureObject;

  supertypes = {};

  root.leisureClassChange = 0;

  ensureLeisureClass = function(leisureClass) {
    var cl;

    cl = "Leisure_" + (nameSub(leisureClass));
    if (global[cl] == null) {
      global[cl] = eval("(function " + cl + "(){})");
      supertypes[cl] = 'Leisure_Object';
      root.leisureClassChange++;
    }
    return global[cl];
  };

  makeSuper = function(type, supertype) {
    supertypes["Leisure_" + (nameSub(type))] = "Leisure_" + (nameSub(supertype));
    return root.leisureClassChange++;
  };

  ensureLeisureClass('cons');

  ensureLeisureClass('nil');

  supertypes.Leisure_cons = 'Leisure_Object';

  supertypes.Leisure_nil = 'Leisure_Object';

  ensureLeisureClass('ast');

  ensureLeisureClass('lit');

  Leisure_lit.prototype.toString = function() {
    return "lit(" + (getLitVal(this)) + ")";
  };

  ensureLeisureClass('ref');

  Leisure_ref.prototype.toString = function() {
    return "ref(" + (getRefName(this)) + ")";
  };

  ensureLeisureClass('lambda');

  Leisure_lambda.prototype.toString = function() {
    return "lambda(" + (astString(this)) + ")";
  };

  ensureLeisureClass('apply');

  Leisure_apply.prototype.toString = function() {
    return "apply(" + (astString(this)) + ")";
  };

  ensureLeisureClass('let');

  Leisure_let.prototype.toString = function() {
    return "let(" + (astString(this)) + ")";
  };

  ensureLeisureClass('anno');

  Leisure_anno.prototype.toString = function() {
    return "anno(" + (astString(this)) + ")";
  };

  ensureLeisureClass('doc');

  ensureLeisureClass('srcLocation');

  ensureLeisureClass('pattern');

  makeSuper('lit', 'ast');

  makeSuper('ref', 'ast');

  makeSuper('lambda', 'ast');

  makeSuper('apply', 'ast');

  makeSuper('let', 'ast');

  makeSuper('anno', 'ast');

  astString = function(ast) {
    var argStr, funcStr, _ref;

    switch (getType(ast)) {
      case 'lit':
        return getLitVal(ast);
      case 'ref':
        return getRefName(ast);
      case 'apply':
        funcStr = astString(getApplyFunc(ast));
        if ((_ref = getType(getApplyFunc(ast))) === 'lambda' || _ref === 'let') {
          funcStr = "(" + funcStr + ")";
        }
        argStr = astString(getApplyArg(ast));
        if (getType(getApplyArg(ast)) === 'apply') {
          argStr = "(" + argStr + ")";
        }
        return "" + funcStr + " " + argStr;
      case 'lambda':
        return "\\" + (getLambdaVar(ast)) + " . " + (astString(getLambdaBody(ast)));
      case 'let':
        return "\\\\" + (letStr(ast));
      case 'anno':
        return "\\@" + (getAnnoName(ast)) + " " + (getAnnoData(ast)) + " . " + (astString(getAnnoBody(ast)));
    }
  };

  letStr = function(ast) {
    var binding, body;

    body = getLetBody(ast);
    binding = "(" + (getLetName(ast)) + " = " + (astString(getLetValue(ast))) + ")";
    if (body instanceof Leisure_let) {
      return "" + binding + " " + (letStr(body));
    } else {
      return "" + binding + " . " + (astString(body));
    }
  };

  Leisure_BaseCons = (function(_super) {
    __extends(Leisure_BaseCons, _super);

    function Leisure_BaseCons() {
      _ref = Leisure_BaseCons.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    Leisure_BaseCons.prototype.head = function() {
      throw new Error("Not Implemented");
    };

    Leisure_BaseCons.prototype.tail = function() {
      throw new Error("Not Implemented");
    };

    Leisure_BaseCons.prototype.isNil = function() {
      return false;
    };

    Leisure_BaseCons.prototype.find = function(func) {
      if (func(this.head())) {
        return this.head();
      } else {
        return this.tail().find(func);
      }
    };

    Leisure_BaseCons.prototype.removeAll = function(func) {
      var t;

      t = this.tail().removeAll(func);
      if (func(this.head())) {
        return t;
      } else if (t === this.tail()) {
        return this;
      } else {
        return cons(this.head(), t);
      }
    };

    Leisure_BaseCons.prototype.map = function(func) {
      return cons(func(this.head()), this.tail().map(func));
    };

    Leisure_BaseCons.prototype.foldl = function(func, arg) {
      return this.tail().foldl(func, func(arg, this.head()));
    };

    Leisure_BaseCons.prototype.foldl1 = function(func) {
      return this.tail().foldl(func, this.head());
    };

    Leisure_BaseCons.prototype.foldr = function(func, arg) {
      return func(this.head(), this.tail().foldr(func, arg));
    };

    Leisure_BaseCons.prototype.foldr1 = function(func) {
      if (this.tail() === Nil) {
        return this.head();
      } else {
        return func(this.head(), this.tail().foldr1(func));
      }
    };

    Leisure_BaseCons.prototype.toArray = function() {
      return this.foldl((function(i, el) {
        i.push(el);
        return i;
      }), []);
    };

    Leisure_BaseCons.prototype.join = function(str) {
      return this.toArray().join(str);
    };

    Leisure_BaseCons.prototype.reverse = function() {
      return this.rev(Nil);
    };

    Leisure_BaseCons.prototype.rev = function(result) {
      return this.tail().rev(cons(this.head(), result));
    };

    Leisure_BaseCons.prototype.elementString = function() {
      var _ref1;

      return "" + (((_ref1 = this.head()) != null ? _ref1.constructor : void 0) === this.constructor || this.head() instanceof Leisure_nil ? '[' + this.head().elementString() + ']' : this.head()) + (this.tail() instanceof Leisure_nil ? '' : this.tail() instanceof Leisure_BaseCons ? " " + (this.tail().elementString()) : " | " + (this.tail()));
    };

    Leisure_BaseCons.prototype.equals = function(other) {
      return this === other || (other instanceof Leisure_BaseCons && consEq(this.head(), other.head()) && consEq(this.tail(), other.tail()));
    };

    Leisure_BaseCons.prototype.each = function(block) {
      block(this.head());
      return this.tail().each(block);
    };

    Leisure_BaseCons.prototype.length = function() {
      return this.foldl((function(i, el) {
        return i + 1;
      }), 0);
    };

    Leisure_BaseCons.prototype.last = function() {
      var t;

      t = this.tail();
      if (t === Nil) {
        return this.head();
      } else {
        return t.last();
      }
    };

    Leisure_BaseCons.prototype.append = function(l) {
      return cons(this.head(), this.tail().append(l));
    };

    Leisure_BaseCons.prototype.toString = function() {
      return "" + (this.stringName()) + "[" + (this.elementString()) + "]";
    };

    Leisure_BaseCons.prototype.stringName = function() {
      return "BaseCons";
    };

    return Leisure_BaseCons;

  })(LeisureObject);

  consEq = function(a, b) {
    return a === b || (a instanceof Leisure_BaseCons && a.equals(b));
  };

  Leisure_cons = (function(_super) {
    __extends(Leisure_cons, _super);

    function Leisure_cons() {
      _ref1 = Leisure_cons.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    Leisure_cons.prototype.head = function() {
      return this(function() {
        return function(a) {
          return function(b) {
            return a();
          };
        };
      });
    };

    Leisure_cons.prototype.tail = function() {
      return this(function() {
        return function(a) {
          return function(b) {
            return b();
          };
        };
      });
    };

    Leisure_cons.prototype.stringName = function() {
      return "Cons";
    };

    return Leisure_cons;

  })(Leisure_BaseCons);

  global.Leisure_cons = Leisure_cons;

  Leisure_nil = (function(_super) {
    __extends(Leisure_nil, _super);

    function Leisure_nil() {
      _ref2 = Leisure_nil.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    Leisure_nil.prototype.isNil = function() {
      return true;
    };

    Leisure_nil.prototype.find = function() {
      return this;
    };

    Leisure_nil.prototype.removeAll = function() {
      return this;
    };

    Leisure_nil.prototype.map = function(func) {
      return Nil;
    };

    Leisure_nil.prototype.foldl = function(func, arg) {
      return arg;
    };

    Leisure_nil.prototype.foldr = function(func, arg) {
      return arg;
    };

    Leisure_nil.prototype.reverse = function() {
      return this;
    };

    Leisure_nil.prototype.rev = function(result) {
      return result;
    };

    Leisure_nil.prototype.equals = function(other) {
      return other instanceof Leisure_nil;
    };

    Leisure_nil.prototype.each = function() {};

    Leisure_nil.prototype.toArray = function() {
      return [];
    };

    Leisure_nil.prototype.join = function() {
      return '';
    };

    Leisure_nil.prototype.append = function(l) {
      return l;
    };

    Leisure_nil.prototype.toString = function() {
      return "Cons[]";
    };

    Leisure_nil.prototype.elementString = function() {
      return '';
    };

    return Leisure_nil;

  })(LeisureObject);

  global.Leisure_nil = Leisure_nil;

  jsType = function(v) {
    var t;

    t = typeof v;
    if (t === 'object') {
      return v.constructor || t;
    } else {
      return t;
    }
  };

  mkProto = function(protoFunc, value) {
    value.__proto__ = protoFunc.prototype;
    return value;
  };

  throwError = function(msg) {
    throw (msg instanceof Error ? msg : new Error(String(msg)));
  };

  checkType = function(value, type) {
    if (!(value instanceof type)) {
      return throwError("Type error: expected type: " + type + ", but got: " + (jsType(value)));
    }
  };

  primCons = setDataType((function(a) {
    return function(b) {
      return mkProto(Leisure_cons, setType((function(f) {
        return f()(a)(b);
      }), 'cons'));
    };
  }), 'cons');

  Nil = mkProto(Leisure_nil, setDataType(setType((function(a) {
    return function(b) {
      return b();
    };
  }), 'nil'), 'nil'));

  cons = function(a, b) {
    return primCons(function() {
      return a;
    })(function() {
      return b;
    });
  };

  foldLeft = function(func, val, thing) {
    if (thing instanceof Leisure_cons) {
      return thing.foldl(func, val);
    } else {
      return primFoldLeft(func, val, thing, 0);
    }
  };

  primFoldLeft = function(func, val, array, index) {
    if (index < array.length) {
      return primFoldLeft(func, func(val, array[index]), array, index + 1);
    } else {
      return val;
    }
  };

  global.leisureFuncs = {};

  global.leisureFuncNames = Nil;

  leisureAddFunc = global.leisureAddFunc = function(nm) {
    return global.leisureFuncNames = cons(nm, global.leisureFuncNames);
  };

  root.evalFunc = evalFunc = eval;

  root.functionCount = 0;

  functionInfo = {};

  nameFunc = function(func, name) {
    var f;

    f = null;
    return function() {
      if (f === null) {
        f = func();
        if (typeof f === 'function') {
          f.leisureName = name;
        }
        return f;
      } else {
        return f;
      }
    };
  };

  define = function(name, func, arity, src, method) {
    var nm;

    functionInfo[name] = {
      src: src,
      arity: arity,
      leisureName: name
    };
    nm = 'L_' + nameSub(name);
    if (!method && global.noredefs && (global[nm] != null)) {
      throwError("[DEF] Attempt to redefine definition: " + name);
    }
    global[nm] = global.leisureFuncs[nm] = nameFunc(func, name);
    leisureAddFunc(name);
    root.functionCount++;
    return func;
  };

  L_lit = setDataType((function(_x) {
    return setType((function(_f) {
      return _f()(_x);
    }), 'lit');
  }), 'lit');

  L_ref = setDataType((function(_x) {
    return setType((function(_f) {
      return _f()(_x);
    }), 'ref');
  }), 'ref');

  L_lambda = setDataType((function(_v) {
    return function(_f) {
      return setType((function(_g) {
        return _g()(_v)(_f);
      }), 'lambda');
    };
  }), 'lambda');

  L_apply = setDataType((function(_func) {
    return function(_arg) {
      return setType((function(_f) {
        return _f()(_func)(_arg);
      }), 'apply');
    };
  }), 'apply');

  L_let = setDataType((function(_n) {
    return function(_v) {
      return function(_b) {
        return setType((function(_f) {
          return _f()(_n)(_v)(_b);
        }), 'let');
      };
    };
  }), 'let');

  L_anno = setDataType((function(_name) {
    return function(_data) {
      return function(_body) {
        return setType((function(_f) {
          return _f()(_name)(_data)(_body);
        }), 'anno');
      };
    };
  }), 'anno');

  getType = function(f) {
    var t;

    t = typeof f;
    return (t === 'function' && (f != null ? f.type : void 0)) || ("*" + t);
  };

  define('getType', (function() {
    return function(value) {
      return getType(value());
    };
  }), 1);

  getDataType = function(f) {
    return (typeof f === 'function' && f.dataType) || '';
  };

  define('getDataType', (function() {
    return function(value) {
      return getDataType(value());
    };
  }), 1);

  save = {};

  save.lit = lit = function(l) {
    return L_lit(function() {
      return l;
    });
  };

  save.ref = ref = function(r) {
    return L_ref(function() {
      return r;
    });
  };

  save.lambda = lambda = function(v, body) {
    return L_lambda(function() {
      return v;
    })(function() {
      return body;
    });
  };

  save.apply = apply = function(f, a) {
    return L_apply(function() {
      return f;
    })(function() {
      return a;
    });
  };

  save.llet = llet = function(n, v, b) {
    return L_let(function() {
      return n;
    })(function() {
      return v;
    })(function() {
      return b;
    });
  };

  save.anno = anno = function(name, data, body) {
    return L_anno(function() {
      return name;
    })(function() {
      return data;
    })(function() {
      return body;
    });
  };

  save.cons = cons;

  getLitVal = function(lt) {
    return lt(function() {
      return function(v) {
        return v();
      };
    });
  };

  getRefName = function(rf) {
    return rf(function() {
      return function(v) {
        return v();
      };
    });
  };

  getLambdaVar = function(lam) {
    return lam(function() {
      return function(v) {
        return function(b) {
          return v();
        };
      };
    });
  };

  getLambdaBody = function(lam) {
    return lam(function() {
      return function(v) {
        return function(b) {
          return b();
        };
      };
    });
  };

  getApplyFunc = function(apl) {
    return apl(function() {
      return function(a) {
        return function(b) {
          return a();
        };
      };
    });
  };

  getApplyArg = function(apl) {
    return apl(function() {
      return function(a) {
        return function(b) {
          return b();
        };
      };
    });
  };

  getLetName = function(lt) {
    return lt(function() {
      return function(n) {
        return function(v) {
          return function(b) {
            return n();
          };
        };
      };
    });
  };

  getLetValue = function(lt) {
    return lt(function() {
      return function(n) {
        return function(v) {
          return function(b) {
            return v();
          };
        };
      };
    });
  };

  getLetBody = function(lt) {
    return lt(function() {
      return function(n) {
        return function(v) {
          return function(b) {
            return b();
          };
        };
      };
    });
  };

  getAnnoName = function(anno) {
    return anno(function() {
      return function(name) {
        return function(data) {
          return function(body) {
            return name();
          };
        };
      };
    });
  };

  getAnnoData = function(anno) {
    return anno(function() {
      return function(name) {
        return function(data) {
          return function(body) {
            return data();
          };
        };
      };
    });
  };

  getAnnoBody = function(anno) {
    return anno(function() {
      return function(name) {
        return function(data) {
          return function(body) {
            return body();
          };
        };
      };
    });
  };

  json2AstEncodings = {
    lit: function(json) {
      return L_lit(function() {
        return json.value;
      });
    },
    ref: function(json) {
      return L_ref(function() {
        return json.varName;
      });
    },
    lambda: function(json) {
      return L_lambda(function() {
        return json.varName;
      })(function() {
        return json2Ast(json.body);
      });
    },
    apply: function(json) {
      return L_apply(function() {
        return json2Ast(json.func);
      })(function() {
        return json2Ast(json.arg);
      });
    },
    "let": function(json) {
      return L_let(function() {
        return json.varName;
      })(function() {
        return json2Ast(json.value);
      })(function() {
        return json2Ast(json.body);
      });
    },
    anno: function(json) {
      return L_anno(function() {
        return json.name;
      })(function() {
        return json2Ast(json.data);
      })(function() {
        return json2Ast(json.body);
      });
    },
    cons: function(json) {
      return save.cons(json2Ast(json.head), json2Ast(json.tail));
    },
    nil: function(json) {
      return Nil;
    }
  };

  lit = save.lit;

  ref = save.ref;

  lambda = save.lambda;

  apply = save.apply;

  llet = save.llet;

  anno = save.anno;

  cons = save.cons;

  json2Ast = function(json) {
    if (typeof json === 'object') {
      return json2AstEncodings[json._type](json);
    } else {
      return json;
    }
  };

  ast2JsonEncodings = {
    Leisure_lit: function(ast) {
      return {
        _type: 'lit',
        value: getLitVal(ast)
      };
    },
    Leisure_ref: function(ast) {
      return {
        _type: 'ref',
        varName: getRefName(ast)
      };
    },
    Leisure_lambda: function(ast) {
      return {
        _type: 'lambda',
        varName: getLambdaVar(ast),
        body: ast2Json(getLambdaBody(ast))
      };
    },
    Leisure_apply: function(ast) {
      return {
        _type: 'apply',
        func: ast2Json(getApplyFunc(ast)),
        arg: ast2Json(getApplyArg(ast))
      };
    },
    Leisure_let: function(ast) {
      return {
        _type: 'let',
        varName: getLetName(ast),
        value: ast2Json(getLetValue(ast)),
        body: ast2Json(getLetBody(ast))
      };
    },
    Leisure_anno: function(ast) {
      return {
        _type: 'anno',
        name: getAnnoName(ast),
        data: ast2Json(getAnnoData(ast)),
        body: ast2Json(getAnnoBody(ast))
      };
    },
    Leisure_cons: function(ast) {
      return {
        _type: 'cons',
        head: ast2Json(ast.head()),
        tail: ast2Json(ast.tail())
      };
    },
    Leisure_nil: function(ast) {
      return {
        _type: 'nil'
      };
    }
  };

  ast2Json = function(ast) {
    var _ref3;

    if (ast2JsonEncodings[(_ref3 = ast.constructor) != null ? _ref3.name : void 0]) {
      return ast2JsonEncodings[ast.constructor.name](ast);
    } else {
      return ast;
    }
  };

  define('json2Ast', (function() {
    return function(json) {
      return json2Ast(JSON.parse(json()));
    };
  }));

  define('ast2Json', (function() {
    return function(ast) {
      return JSON.stringify(ast2Json(ast()));
    };
  }));

  consFrom = function(array, i) {
    i = i || 0;
    if (i < array.length) {
      return cons(array[i], consFrom(array, i + 1));
    } else {
      return Nil;
    }
  };

  head = function(l) {
    return l.head();
  };

  tail = function(l) {
    return l.tail();
  };

  root.head = head;

  root.tail = tail;

  root.consFrom = consFrom;

  root.nameSub = nameSub;

  root.setDataType = setDataType;

  root.setType = setType;

  root.mkProto = mkProto;

  root.Nil = Nil;

  root.cons = cons;

  root.primCons = primCons;

  root.define = define;

  root.getType = getType;

  root.getDataType = getDataType;

  root.lit = lit;

  root.ref = ref;

  root.lambda = lambda;

  root.apply = apply;

  root.anno = anno;

  root.llet = llet;

  root.getRefName = getRefName;

  root.getLitVal = getLitVal;

  root.getLambdaBody = getLambdaBody;

  root.getLambdaVar = getLambdaVar;

  root.getApplyFunc = getApplyFunc;

  root.getApplyArg = getApplyArg;

  root.getLetName = getLetName;

  root.getLetValue = getLetValue;

  root.getLetBody = getLetBody;

  root.getAnnoName = getAnnoName;

  root.getAnnoData = getAnnoData;

  root.getAnnoBody = getAnnoBody;

  root.throwError = throwError;

  root.foldLeft = foldLeft;

  root.LeisureObject = LeisureObject;

  root.evalFunc = evalFunc;

  root.json2Ast = json2Ast;

  root.ast2Json = ast2Json;

  root.Leisure_lit = Leisure_lit;

  root.Leisure_ref = Leisure_ref;

  root.Leisure_lambda = Leisure_lambda;

  root.Leisure_apply = Leisure_apply;

  root.Leisure_let = Leisure_let;

  root.Leisure_anno = Leisure_anno;

  root.ensureLeisureClass = ensureLeisureClass;

  root.makeSuper = makeSuper;

  root.supertypes = supertypes;

  root.functionInfo = functionInfo;

}).call(this);

/*
*/

})(self)
},{"./base":2,"./lodash.min":6}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
/*
Copyright (C) 2013, Bill Burdick, Tiny Concepts: https://github.com/zot/Leisure

(licensed with ZLIB license)

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software
in a product, an acknowledgment in the product documentation would be
appreciated but is not required.

2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.

3. This notice may not be removed or altered from any source distribution.
*/


(function() {
  var fs, readFile, root, writeFile;

  root = module.exports;

  fs = require('fs');

  readFile = function(fileName, cont) {
    return fs.readFile(fileName, {
      encoding: 'utf8'
    }, cont);
  };

  writeFile = function(fileName, data, cont) {
    return fs.writeFile(fileName, data, {
      encoding: 'utf8'
    }, cont);
  };

  root.readFile = readFile;

  root.writeFile = writeFile;

}).call(this);

/*
*/

},{"fs":12}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var Leisure, exports, k, nb, v, _ref;

  window.marked = require('./marked');

  Leisure = exports = module.exports = require('./base');

  require('./ast');

  require('./gen');

  require('./runtime');

  require('./generatedPrelude');

  require('./std');

  require('./md');

  window.Notebook = nb = require('./notebook');

  _ref = window.Leisure;
  for (k in _ref) {
    v = _ref[k];
    Leisure[k] = v;
  }

  window.Leisure = Leisure;

}).call(this);

/*
*/

},{"./ast":1,"./base":2,"./gen":4,"./generatedPrelude":5,"./marked":7,"./md":8,"./notebook":9,"./runtime":10,"./std":11}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
/*
Copyright (C) 2013, Bill Burdick, Tiny Concepts: https://github.com/zot/Leisure

(licensed with ZLIB license)

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software
in a product, an acknowledgment in the product documentation would be
appreciated but is not required.

2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.

3. This notice may not be removed or altered from any source distribution.
*/


(function() {
  var Leisure_anno, Leisure_apply, Leisure_lambda, Leisure_let, Leisure_lit, Leisure_ref, Nil, addUniq, cons, consFrom, define, dumpAnno, gen, genApplyArg, genLets, genUniq, getAnnoBody, getAnnoData, getAnnoName, getApplyArg, getApplyFunc, getLambdaBody, getLambdaVar, getLastLetBody, getLetBody, getLetName, getLetValue, getLitVal, getRefName, left, letList, makeSyncMonad, memoize, nameSub, right, root, runMonad, setDataType, setType, uniqName, varNameSub, _, _false, _ref, _ref1;

  _ref = root = module.exports = require('./ast'), nameSub = _ref.nameSub, getLitVal = _ref.getLitVal, getRefName = _ref.getRefName, getLambdaVar = _ref.getLambdaVar, getLambdaBody = _ref.getLambdaBody, getApplyFunc = _ref.getApplyFunc, getApplyArg = _ref.getApplyArg, getAnnoName = _ref.getAnnoName, getAnnoData = _ref.getAnnoData, getAnnoBody = _ref.getAnnoBody, getLetName = _ref.getLetName, getLetValue = _ref.getLetValue, getLetBody = _ref.getLetBody, Leisure_lit = _ref.Leisure_lit, Leisure_ref = _ref.Leisure_ref, Leisure_lambda = _ref.Leisure_lambda, Leisure_apply = _ref.Leisure_apply, Leisure_let = _ref.Leisure_let, Leisure_anno = _ref.Leisure_anno, setType = _ref.setType, setDataType = _ref.setDataType, cons = _ref.cons, Nil = _ref.Nil, consFrom = _ref.consFrom, define = _ref.define;

  _ref1 = require('./runtime'), makeSyncMonad = _ref1.makeSyncMonad, runMonad = _ref1.runMonad, _false = _ref1._false, left = _ref1.left, right = _ref1.right;

  _ = require('./lodash.min');

  varNameSub = function(n) {
    return "L_" + (nameSub(n));
  };

  gen = function(ast) {
    return genUniq(ast, Nil, [Nil, 0]);
  };

  genUniq = function(ast, names, uniq) {
    var arity, data, funcName, genned, n, name, src, u, _ref2;

    switch (ast.constructor) {
      case Leisure_lit:
        return JSON.stringify(getLitVal(ast));
      case Leisure_ref:
        return "" + (uniqName(getRefName(ast), uniq)) + "()";
      case Leisure_lambda:
        name = getLambdaVar(ast);
        u = addUniq(name, names, uniq);
        n = cons(name, names);
        return "function(" + (uniqName(name, u)) + "){return " + (genUniq(getLambdaBody(ast), n, u)) + "}";
      case Leisure_apply:
        return "" + (genUniq(getApplyFunc(ast), names, uniq)) + "(" + (genApplyArg(getApplyArg(ast), names, uniq)) + ")";
      case Leisure_let:
        return "(function(){\n" + (genLets(ast, names, uniq)) + "})()";
      case Leisure_anno:
        name = getAnnoName(ast);
        data = getAnnoData(ast);
        genned = genUniq(getAnnoBody(ast), names, uniq);
        switch (name) {
          case 'type':
            return "setType(" + genned + ", '" + data + "')";
          case 'dataType':
            return "setDataType(" + genned + ", '" + data + "')";
          case 'define':
            _ref2 = data.toArray(), funcName = _ref2[0], arity = _ref2[1], src = _ref2[2];
            return "define('" + funcName + "', (function(){return " + genned + "}), " + arity + ", " + (JSON.stringify(src)) + ")";
          default:
            return genned;
        }
        break;
      default:
        return "DUR? " + ast + ", " + ast.constructor + " " + Leisure_lambda;
    }
  };

  memoize = function(func) {
    return "(function(){var $m; return function(){return $m || ($m = " + func + ")}})()";
  };

  dumpAnno = function(ast) {
    if (ast instanceof Leisure_anno) {
      return dumpAnno(getAnnoBody(ast));
    } else {
      return ast;
    }
  };

  genApplyArg = function(arg, names, uniq) {
    if (dumpAnno(arg) instanceof Leisure_apply) {
      return memoize(genUniq(arg, names, uniq));
    } else if (arg instanceof Leisure_ref) {
      return uniqName(getRefName(arg), uniq);
    } else if (arg instanceof Leisure_let) {
      return "function(){" + (genLets(arg, names, uniq)) + "}";
    } else if (dumpAnno(arg) instanceof Leisure_lambda) {
      return memoize(genUniq(arg, names, uniq));
    } else {
      return "function(){return " + (genUniq(arg, names, uniq)) + "}";
    }
  };

  genLets = function(ast, names, uniq) {
    var assigns, decs, _ref2;

    _ref2 = _.foldl(letList(ast, []), (function(result, l) {
      var code, letName, letNames, n, newU, u;

      n = result[0], u = result[1], letNames = result[2], code = result[3];
      newU = addUniq(getLetName(l), n, u);
      letName = uniqName(getLetName(l), newU);
      return [cons(getLetName(l), n), newU, cons(letName, letNames), cons('\n' + letName + ' = ' + genApplyArg(getLetValue(l), n, u), code)];
    }), [names, uniq, Nil, Nil]), names = _ref2[0], uniq = _ref2[1], decs = _ref2[2], assigns = _ref2[3];
    return "\nvar " + (decs.join(', ')) + ";\n" + (assigns.join(';\n')) + ";\nreturn " + (genUniq(getLastLetBody(ast), names, uniq));
  };

  addUniq = function(name, names, uniq) {
    var num, overrides;

    if ((names.find(function(el) {
      return el === name;
    })) !== Nil) {
      overrides = uniq[0], num = uniq[1];
      return [cons(cons(name, "" + name + "_" + num), overrides), num + 1];
    } else {
      return uniq;
    }
  };

  uniqName = function(name, uniq) {
    var kv;

    uniq = uniq[0];
    kv = uniq.find((function(el) {
      return el.head() === name;
    }), uniq);
    return varNameSub((kv !== Nil ? kv.tail() : name));
  };

  letList = function(ast, buf) {
    if (ast instanceof Leisure_let) {
      buf.push(ast);
      return letList(getLetBody(ast), buf);
    } else {
      return buf;
    }
  };

  getLastLetBody = function(ast) {
    if (ast instanceof Leisure_let) {
      return getLastLetBody(getLetBody(ast));
    } else {
      return ast;
    }
  };

  define('runAst', function() {
    return function(ast) {
      var err;

      try {
        return eval("(" + (gen(ast())) + ")");
      } catch (_error) {
        err = _error;
        return L_parseErr()(function() {
          return "\n\nParse error: " + err.toString() + "\nAST: ";
        })(ast);
      }
    };
  });

  root.gen = gen;

}).call(this);

/*
*/

},{"./ast":1,"./lodash.min":6,"./runtime":10}],5:[function(require,module,exports){
L_runMonads([
  function(){return L_define()(function(){return "true"})(function(){return 0})(function(){return "true = \\a b . a"})((function(){var $m; return function(){return $m || ($m = setDataType(setType(function(L_a){return function(L_b){return L_a()}}, 'true'), 'true'))}})())},
  function(){return L_define()(function(){return "false"})(function(){return 0})(function(){return "false = \\a b . b"})((function(){var $m; return function(){return $m || ($m = setDataType(setType(function(L_a){return function(L_b){return L_b()}}, 'false'), 'false'))}})())},
  function(){return L_define()(function(){return "not"})(function(){return 1})(function(){return "not b = b false true"})((function(){var $m; return function(){return $m || ($m = function(L_b){return L_b()(L_false)(L_true)})}})())},
  function(){return L_define()(function(){return "and"})(function(){return 2})(function(){return "and a b = a b false"})((function(){var $m; return function(){return $m || ($m = function(L_a){return function(L_b){return L_a()(L_b)(L_false)}})}})())},
  function(){return L_define()(function(){return "or"})(function(){return 2})(function(){return "or a b = a true b"})((function(){var $m; return function(){return $m || ($m = function(L_a){return function(L_b){return L_a()(L_true)(L_b)}})}})())},
  function(){return L_define()(function(){return "some"})(function(){return 1})(function(){return "some x = \\someCase noneCase . someCase x"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_x){return setType(function(L_someCase){return function(L_noneCase){return L_someCase()(L_x)}}, 'some')}, 'some'))}})())},
  function(){return L_define()(function(){return "some2"})(function(){return 2})(function(){return "some2 a b = \\someCase noneCase . someCase a b"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_a){return function(L_b){return setType(function(L_someCase){return function(L_noneCase){return L_someCase()(L_a)(L_b)}}, 'some2')}}, 'some2'))}})())},
  function(){return L_define()(function(){return "none"})(function(){return 0})(function(){return "none = \\someCase noneCase . noneCase"})((function(){var $m; return function(){return $m || ($m = setDataType(setType(function(L_someCase){return function(L_noneCase){return L_noneCase()}}, 'none'), 'none'))}})())},
  function(){return L_define()(function(){return "neq"})(function(){return 2})(function(){return "neq a b = not (eq a b)"})((function(){var $m; return function(){return $m || ($m = function(L_a){return function(L_b){return L_not()((function(){var $m; return function(){return $m || ($m = L_eq()(L_a)(L_b))}})())}})}})())},
  function(){return L_define()(function(){return "left"})(function(){return 1})(function(){return "left x = \\lCase rCase . lCase x"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_x){return setType(function(L_lCase){return function(L_rCase){return L_lCase()(L_x)}}, 'left')}, 'left'))}})())},
  function(){return L_define()(function(){return "right"})(function(){return 1})(function(){return "right x = \\lCase rCase . rCase x"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_x){return setType(function(L_lCase){return function(L_rCase){return L_rCase()(L_x)}}, 'right')}, 'right'))}})())},
  function(){return L_define()(function(){return "id"})(function(){return 1})(function(){return "id x = x"})((function(){var $m; return function(){return $m || ($m = function(L_x){return L_x()})}})())},
  function(){return L_define()(function(){return "compose"})(function(){return 2})(function(){return "compose f g = \\x . f (g x)"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_f){return function(L_g){return setType(function(L_x){return L_f()((function(){var $m; return function(){return $m || ($m = L_g()(L_x))}})())}, 'compose')}}, 'compose'))}})())},
  function(){return L_define()(function(){return "flip"})(function(){return 1})(function(){return "flip func = \\x y . func y x"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_func){return setType(function(L_x){return function(L_y){return L_func()(L_y)(L_x)}}, 'flip')}, 'flip'))}})())},
  function(){return L_define()(function(){return "cons"})(function(){return 2})(function(){return "cons a b = \\f . f a b"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_a){return function(L_b){return setType(function(L_f){return L_f()(L_a)(L_b)}, 'cons')}}, 'cons'))}})())},
  function(){return L_define()(function(){return "isCons"})(function(){return 1})(function(){return "isCons c = hasType c cons"})((function(){var $m; return function(){return $m || ($m = function(L_c){return L_hasType()(L_c)(L_cons)})}})())},
  function(){return L_define()(function(){return "nil"})(function(){return 0})(function(){return "nil = \\a b . b"})((function(){var $m; return function(){return $m || ($m = setDataType(setType(function(L_a){return function(L_b){return L_b()}}, 'nil'), 'nil'))}})())},
  function(){return L_define()(function(){return "isNil"})(function(){return 1})(function(){return "isNil n = hasType n nil"})((function(){var $m; return function(){return $m || ($m = function(L_n){return L_hasType()(L_n)(L_nil)})}})())},
  function(){return L_define()(function(){return "head"})(function(){return 1})(function(){return "head l = l \\h t . h"})((function(){var $m; return function(){return $m || ($m = function(L_l){return L_l()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_h()}})}})())})}})())},
  function(){return L_define()(function(){return "tail"})(function(){return 1})(function(){return "tail l = l \\h t . t"})((function(){var $m; return function(){return $m || ($m = function(L_l){return L_l()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_t()}})}})())})}})())},
  function(){return L_define()(function(){return "last"})(function(){return 1})(function(){return "last l = isCons l\n  l \\h t . isCons t (last t) h\n  nil"})((function(){var $m; return function(){return $m || ($m = function(L_l){return L_isCons()(L_l)((function(){var $m; return function(){return $m || ($m = L_l()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_isCons()(L_t)((function(){var $m; return function(){return $m || ($m = L_last()(L_t))}})())(L_h)}})}})()))}})())(L_nil)})}})())},
  function(){return L_define()(function(){return "removeLast"})(function(){return 1})(function(){return "removeLast l = isCons l\n  l \\h t . isCons t (cons h (removeLast t)) nil\n  nil"})((function(){var $m; return function(){return $m || ($m = function(L_l){return L_isCons()(L_l)((function(){var $m; return function(){return $m || ($m = L_l()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_isCons()(L_t)((function(){var $m; return function(){return $m || ($m = L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_removeLast()(L_t))}})()))}})())(L_nil)}})}})()))}})())(L_nil)})}})())},
  function(){return L_define()(function(){return "length"})(function(){return 1})(function(){return "length list = list\n  \\h t D . + 1 (length t)\n  0"})((function(){var $m; return function(){return $m || ($m = function(L_list){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_$o()(function(){return 1})((function(){var $m; return function(){return $m || ($m = L_length()(L_t))}})())}}})}})())(function(){return 0})})}})())},
  function(){return L_define()(function(){return "append"})(function(){return 2})(function(){return "append a b = a (\\h t D . cons h (append t b)) b"})((function(){var $m; return function(){return $m || ($m = function(L_a){return function(L_b){return L_a()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_append()(L_t)(L_b))}})())}}})}})())(L_b)}})}})())},
  function(){return L_define()(function(){return "flatten"})(function(){return 1})(function(){return "flatten list = isCons list\n  subflatten list nil\n  list"})((function(){var $m; return function(){return $m || ($m = function(L_list){return L_isCons()(L_list)((function(){var $m; return function(){return $m || ($m = L_subflatten()(L_list)(L_nil))}})())(L_list)})}})())},
  function(){return L_define()(function(){return "subflatten"})(function(){return 2})(function(){return "subflatten list result = isNil list\n  result\n  isCons list\n    list \\h t . subflatten h (subflatten t result)\n    cons list result"})((function(){var $m; return function(){return $m || ($m = function(L_list){return function(L_result){return L_isNil()(L_list)(L_result)((function(){var $m; return function(){return $m || ($m = L_isCons()(L_list)((function(){var $m; return function(){return $m || ($m = L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_subflatten()(L_h)((function(){var $m; return function(){return $m || ($m = L_subflatten()(L_t)(L_result))}})())}})}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cons()(L_list)(L_result))}})()))}})())}})}})())},
  function(){return L_define()(function(){return "reverse"})(function(){return 1})(function(){return "reverse l = rev l nil"})((function(){var $m; return function(){return $m || ($m = function(L_l){return L_rev()(L_l)(L_nil)})}})())},
  function(){return L_define()(function(){return "rev"})(function(){return 2})(function(){return "rev l result = l (\\h t D . rev t (cons h result)) result"})((function(){var $m; return function(){return $m || ($m = function(L_l){return function(L_result){return L_l()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_rev()(L_t)((function(){var $m; return function(){return $m || ($m = L_cons()(L_h)(L_result))}})())}}})}})())(L_result)}})}})())},
  function(){return L_define()(function(){return "filter"})(function(){return 2})(function(){return "filter func list = list (\\h t D . func h (cons h) id (filter func t)) nil"})((function(){var $m; return function(){return $m || ($m = function(L_func){return function(L_list){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_func()(L_h)((function(){var $m; return function(){return $m || ($m = L_cons()(L_h))}})())(L_id)((function(){var $m; return function(){return $m || ($m = L_filter()(L_func)(L_t))}})())}}})}})())(L_nil)}})}})())},
  function(){return L_define()(function(){return "find"})(function(){return 2})(function(){return "find predicate list = list (\\h t D . predicate h (some h) (find predicate t)) none"})((function(){var $m; return function(){return $m || ($m = function(L_predicate){return function(L_list){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_predicate()(L_h)((function(){var $m; return function(){return $m || ($m = L_some()(L_h))}})())((function(){var $m; return function(){return $m || ($m = L_find()(L_predicate)(L_t))}})())}}})}})())(L_none)}})}})())},
  function(){return L_define()(function(){return "contains"})(function(){return 2})(function(){return "contains list item = find (\\el . eq el item) list (\\x . true) false"})((function(){var $m; return function(){return $m || ($m = function(L_list){return function(L_item){return L_find()((function(){var $m; return function(){return $m || ($m = function(L_el){return L_eq()(L_el)(L_item)})}})())(L_list)((function(){var $m; return function(){return $m || ($m = function(L_x){return L_true()})}})())(L_false)}})}})())},
  function(){return L_define()(function(){return "map"})(function(){return 2})(function(){return "map func l = l (\\h t D . cons (func h) (map func t)) nil"})((function(){var $m; return function(){return $m || ($m = function(L_func){return function(L_l){return L_l()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_cons()((function(){var $m; return function(){return $m || ($m = L_func()(L_h))}})())((function(){var $m; return function(){return $m || ($m = L_map()(L_func)(L_t))}})())}}})}})())(L_nil)}})}})())},
  function(){return L_define()(function(){return "mapSave"})(function(){return 2})(function(){return "mapSave func l = l\n  \\h t D . \\\\\n    newH = func h\n    newT = mapSave func t\n    .\n    and (eq newH h) (eq newT t)\n      l\n      cons newH newT\n  nil"})((function(){var $m; return function(){return $m || ($m = function(L_func){return function(L_l){return L_l()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return (function(){

var L_newT, L_newH;

L_newT = (function(){var $m; return function(){return $m || ($m = L_mapSave()(L_func)(L_t))}})();

L_newH = (function(){var $m; return function(){return $m || ($m = L_func()(L_h))}})();
return L_and()((function(){var $m; return function(){return $m || ($m = L_eq()(L_newH)(L_h))}})())((function(){var $m; return function(){return $m || ($m = L_eq()(L_newT)(L_t))}})())(L_l)((function(){var $m; return function(){return $m || ($m = L_cons()(L_newH)(L_newT))}})())})()}}})}})())(L_nil)}})}})())},
  function(){return L_define()(function(){return "foldl"})(function(){return 3})(function(){return "foldl func initialValue l = l (\\h t D . foldl func (func initialValue h) t) initialValue"})((function(){var $m; return function(){return $m || ($m = function(L_func){return function(L_initialValue){return function(L_l){return L_l()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_foldl()(L_func)((function(){var $m; return function(){return $m || ($m = L_func()(L_initialValue)(L_h))}})())(L_t)}}})}})())(L_initialValue)}}})}})())},
  function(){return L_define()(function(){return "foldl1"})(function(){return 2})(function(){return "foldl1 func l = l \\h t . foldl func h t"})((function(){var $m; return function(){return $m || ($m = function(L_func){return function(L_l){return L_l()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_foldl()(L_func)(L_h)(L_t)}})}})())}})}})())},
  function(){return L_define()(function(){return "foldr"})(function(){return 3})(function(){return "foldr func initialValue list = list\n  \\h t D . func h (foldr func initialValue t)\n  initialValue"})((function(){var $m; return function(){return $m || ($m = function(L_func){return function(L_initialValue){return function(L_list){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_func()(L_h)((function(){var $m; return function(){return $m || ($m = L_foldr()(L_func)(L_initialValue)(L_t))}})())}}})}})())(L_initialValue)}}})}})())},
  function(){return L_define()(function(){return "foldr1"})(function(){return 2})(function(){return "foldr1 func list = list \\h t . isNil t\n  h\n  func h (foldr1 func t)"})((function(){var $m; return function(){return $m || ($m = function(L_func){return function(L_list){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_isNil()(L_t)(L_h)((function(){var $m; return function(){return $m || ($m = L_func()(L_h)((function(){var $m; return function(){return $m || ($m = L_foldr1()(L_func)(L_t))}})()))}})())}})}})())}})}})())},
  function(){return L_define()(function(){return "intersperse"})(function(){return 2})(function(){return "intersperse list element = list (\\h t D .\n  isNil t\n    list\n    cons h (cons element (intersperse t element))) nil"})((function(){var $m; return function(){return $m || ($m = function(L_list){return function(L_element){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_isNil()(L_t)(L_list)((function(){var $m; return function(){return $m || ($m = L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_cons()(L_element)((function(){var $m; return function(){return $m || ($m = L_intersperse()(L_t)(L_element))}})()))}})()))}})())}}})}})())(L_nil)}})}})())},
  function(){return L_define()(function(){return "join"})(function(){return 2})(function(){return "join list el = strCat (intersperse list el)"})((function(){var $m; return function(){return $m || ($m = function(L_list){return function(L_el){return L_strCat()((function(){var $m; return function(){return $m || ($m = L_intersperse()(L_list)(L_el))}})())}})}})())},
  function(){return L_define()(function(){return "findIndex"})(function(){return 2})(function(){return "findIndex func list = idx list func 0"})((function(){var $m; return function(){return $m || ($m = function(L_func){return function(L_list){return L_idx()(L_list)(L_func)(function(){return 0})}})}})())},
  function(){return L_define()(function(){return "idx"})(function(){return 3})(function(){return "idx list func pos = list\n  \\h t D . func h\n    pos\n    idx t func (+ 1 pos)\n  -1"})((function(){var $m; return function(){return $m || ($m = function(L_list){return function(L_func){return function(L_pos){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_func()(L_h)(L_pos)((function(){var $m; return function(){return $m || ($m = L_idx()(L_t)(L_func)((function(){var $m; return function(){return $m || ($m = L_$o()(function(){return 1})(L_pos))}})()))}})())}}})}})())(function(){return -1})}}})}})())},
  function(){return L_define()(function(){return "index"})(function(){return 2})(function(){return "index list el = find (\\item . == el item) list"})((function(){var $m; return function(){return $m || ($m = function(L_list){return function(L_el){return L_find()((function(){var $m; return function(){return $m || ($m = function(L_item){return L_$p$p()(L_el)(L_item)})}})())(L_list)}})}})())},
  function(){return L_define()(function(){return "acons"})(function(){return 3})(function(){return "acons k v alist = cons (cons k v) alist"})((function(){var $m; return function(){return $m || ($m = function(L_k){return function(L_v){return function(L_alist){return L_cons()((function(){var $m; return function(){return $m || ($m = L_cons()(L_k)(L_v))}})())(L_alist)}}})}})())},
  function(){return L_define()(function(){return "assoc"})(function(){return 2})(function(){return "assoc k alist  = find (\\el . eq k (head el)) alist (\\cell . cell \\head tail . some tail) none"})((function(){var $m; return function(){return $m || ($m = function(L_k){return function(L_alist){return L_find()((function(){var $m; return function(){return $m || ($m = function(L_el){return L_eq()(L_k)((function(){var $m; return function(){return $m || ($m = L_head()(L_el))}})())})}})())(L_alist)((function(){var $m; return function(){return $m || ($m = function(L_cell){return L_cell()((function(){var $m; return function(){return $m || ($m = function(L_head){return function(L_tail){return L_some()(L_tail)}})}})())})}})())(L_none)}})}})())},
  function(){return L_define()(function(){return "rassoc"})(function(){return 2})(function(){return "rassoc v alist = find (\\el . eq v (tail el)) alist (\\cell . cell \\head tail . some head) none"})((function(){var $m; return function(){return $m || ($m = function(L_v){return function(L_alist){return L_find()((function(){var $m; return function(){return $m || ($m = function(L_el){return L_eq()(L_v)((function(){var $m; return function(){return $m || ($m = L_tail()(L_el))}})())})}})())(L_alist)((function(){var $m; return function(){return $m || ($m = function(L_cell){return L_cell()((function(){var $m; return function(){return $m || ($m = function(L_head){return function(L_tail){return L_some()(L_head)}})}})())})}})())(L_none)}})}})())},
  function(){return L_define()(function(){return "quicksort"})(function(){return 2})(function(){return "quicksort less list = (qs less list) nil"})((function(){var $m; return function(){return $m || ($m = function(L_less){return function(L_list){return L_qs()(L_less)(L_list)(L_nil)}})}})())},
  function(){return L_define()(function(){return "qs"})(function(){return 2})(function(){return "qs sortedFunc list = list\n  \\h t D . \\\\\n    greater = filter (sortedFunc h) t\n    lesser = filter (compose not (sortedFunc h)) t\n    .\n    \\rest . (qs sortedFunc lesser) (cons h ((qs sortedFunc greater) rest))\n  id"})((function(){var $m; return function(){return $m || ($m = function(L_sortedFunc){return function(L_list){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return (function(){

var L_lesser, L_greater;

L_lesser = (function(){var $m; return function(){return $m || ($m = L_filter()((function(){var $m; return function(){return $m || ($m = L_compose()(L_not)((function(){var $m; return function(){return $m || ($m = L_sortedFunc()(L_h))}})()))}})())(L_t))}})();

L_greater = (function(){var $m; return function(){return $m || ($m = L_filter()((function(){var $m; return function(){return $m || ($m = L_sortedFunc()(L_h))}})())(L_t))}})();
return function(L_rest){return L_qs()(L_sortedFunc)(L_lesser)((function(){var $m; return function(){return $m || ($m = L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_qs()(L_sortedFunc)(L_greater)(L_rest))}})()))}})())}})()}}})}})())(L_id)}})}})())},
  function(){return L_define()(function(){return "insertSorted"})(function(){return 3})(function(){return "insertSorted sortFunc item list = list\n  \\h t D . sortFunc item h (cons item list) (cons h (insertSorted sortFunc item t))\n  cons item nil"})((function(){var $m; return function(){return $m || ($m = function(L_sortFunc){return function(L_item){return function(L_list){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_sortFunc()(L_item)(L_h)((function(){var $m; return function(){return $m || ($m = L_cons()(L_item)(L_list))}})())((function(){var $m; return function(){return $m || ($m = L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_insertSorted()(L_sortFunc)(L_item)(L_t))}})()))}})())}}})}})())((function(){var $m; return function(){return $m || ($m = L_cons()(L_item)(L_nil))}})())}}})}})())},
  function(){return L_define()(function(){return "token"})(function(){return 2})(function(){return "token txt pos = \\f . f txt pos"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_txt){return function(L_pos){return setType(function(L_f){return L_f()(L_txt)(L_pos)}, 'token')}}, 'token'))}})())},
  function(){return L_define()(function(){return "tokenString"})(function(){return 1})(function(){return "tokenString tok = tok \\t p . t"})((function(){var $m; return function(){return $m || ($m = function(L_tok){return L_tok()((function(){var $m; return function(){return $m || ($m = function(L_t){return function(L_p){return L_t()}})}})())})}})())},
  function(){return L_define()(function(){return "tokenPos"})(function(){return 1})(function(){return "tokenPos tok = tok \\t p . p"})((function(){var $m; return function(){return $m || ($m = function(L_tok){return L_tok()((function(){var $m; return function(){return $m || ($m = function(L_t){return function(L_p){return L_p()}})}})())})}})())},
  function(){return L_define()(function(){return "isToken"})(function(){return 1})(function(){return "isToken t = hasType t token"})((function(){var $m; return function(){return $m || ($m = function(L_t){return L_hasType()(L_t)(L_token)})}})())},
  function(){return L_define()(function(){return "parens"})(function(){return 3})(function(){return "parens start end content = \\f . f start end content"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_start){return function(L_end){return function(L_content){return setType(function(L_f){return L_f()(L_start)(L_end)(L_content)}, 'parens')}}}, 'parens'))}})())},
  function(){return L_define()(function(){return "parensStart"})(function(){return 1})(function(){return "parensStart p = p \\s e c . s"})((function(){var $m; return function(){return $m || ($m = function(L_p){return L_p()((function(){var $m; return function(){return $m || ($m = function(L_s){return function(L_e){return function(L_c){return L_s()}}})}})())})}})())},
  function(){return L_define()(function(){return "parensEnd"})(function(){return 1})(function(){return "parensEnd p = p \\s e c . e"})((function(){var $m; return function(){return $m || ($m = function(L_p){return L_p()((function(){var $m; return function(){return $m || ($m = function(L_s){return function(L_e){return function(L_c){return L_e()}}})}})())})}})())},
  function(){return L_define()(function(){return "parensContent"})(function(){return 1})(function(){return "parensContent p = p \\s e c . c"})((function(){var $m; return function(){return $m || ($m = function(L_p){return L_p()((function(){var $m; return function(){return $m || ($m = function(L_s){return function(L_e){return function(L_c){return L_c()}}})}})())})}})())},
  function(){return L_define()(function(){return "isParens"})(function(){return 1})(function(){return "isParens p = hasType p parens"})((function(){var $m; return function(){return $m || ($m = function(L_p){return L_hasType()(L_p)(L_parens)})}})())},
  function(){return L_define()(function(){return "makeParens"})(function(){return 3})(function(){return "makeParens start end content =\n  and (isCons content) (isNil (tail content))\n    makeParens start end (head content)\n    or (isToken content) (isParens content)\n      content\n      parens start end content"})((function(){var $m; return function(){return $m || ($m = function(L_start){return function(L_end){return function(L_content){return L_and()((function(){var $m; return function(){return $m || ($m = L_isCons()(L_content))}})())((function(){var $m; return function(){return $m || ($m = L_isNil()((function(){var $m; return function(){return $m || ($m = L_tail()(L_content))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_makeParens()(L_start)(L_end)((function(){var $m; return function(){return $m || ($m = L_head()(L_content))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_or()((function(){var $m; return function(){return $m || ($m = L_isToken()(L_content))}})())((function(){var $m; return function(){return $m || ($m = L_isParens()(L_content))}})())(L_content)((function(){var $m; return function(){return $m || ($m = L_parens()(L_start)(L_end)(L_content))}})()))}})())}}})}})())},
  function(){return L_define()(function(){return "parensFromToks"})(function(){return 3})(function(){return "parensFromToks left right content = \\\\\n  start = tokenPos left\n  end = + (tokenPos right) (strLen (tokenString right))\n  .\n  parens start end content"})((function(){var $m; return function(){return $m || ($m = function(L_left){return function(L_right){return function(L_content){return (function(){

var L_end, L_start;

L_end = (function(){var $m; return function(){return $m || ($m = L_$o()((function(){var $m; return function(){return $m || ($m = L_tokenPos()(L_right))}})())((function(){var $m; return function(){return $m || ($m = L_strLen()((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_right))}})()))}})()))}})();

L_start = (function(){var $m; return function(){return $m || ($m = L_tokenPos()(L_left))}})();
return L_parens()(L_start)(L_end)(L_content)})()}}})}})())},
  function(){return L_define()(function(){return "stripParens"})(function(){return 1})(function(){return "stripParens p = isParens p (parensContent p) p"})((function(){var $m; return function(){return $m || ($m = function(L_p){return L_isParens()(L_p)((function(){var $m; return function(){return $m || ($m = L_parensContent()(L_p))}})())(L_p)})}})())},
  function(){return L_define()(function(){return "parseErr"})(function(){return 2})(function(){return "parseErr msg1 msg2 = \\f . f (strCat (cons msg1 (cons msg2 nil)))"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_msg1){return function(L_msg2){return setType(function(L_f){return L_f()((function(){var $m; return function(){return $m || ($m = L_strCat()((function(){var $m; return function(){return $m || ($m = L_cons()(L_msg1)((function(){var $m; return function(){return $m || ($m = L_cons()(L_msg2)(L_nil))}})()))}})()))}})())}, 'parseErr')}}, 'parseErr'))}})())},
  function(){return L_define()(function(){return "parseErrMsg"})(function(){return 1})(function(){return "parseErrMsg err = err \\m . m"})((function(){var $m; return function(){return $m || ($m = function(L_err){return L_err()((function(){var $m; return function(){return $m || ($m = function(L_m){return L_m()})}})())})}})())},
  function(){return L_define()(function(){return "isParseErr"})(function(){return 1})(function(){return "isParseErr thing = hasType thing parseErr"})((function(){var $m; return function(){return $m || ($m = function(L_thing){return L_hasType()(L_thing)(L_parseErr)})}})())},
  function(){return L_define()(function(){return "emptyToken"})(function(){return 0})(function(){return "emptyToken = regexp '^\\\\n[ \\\\i]*(#|$)'"})((function(){var $m; return function(){return $m || ($m = L_regexp()(function(){return "^\\n[ \\i]*(#|$)"}))}})())},
  function(){return L_define()(function(){return "makeTokens"})(function(){return 2})(function(){return "makeTokens strings start = strings (\\h t D . makeMoreTokens h t start) nil"})((function(){var $m; return function(){return $m || ($m = function(L_strings){return function(L_start){return L_strings()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_makeMoreTokens()(L_h)(L_t)(L_start)}}})}})())(L_nil)}})}})())},
  function(){return L_define()(function(){return "makeMoreTokens"})(function(){return 3})(function(){return "makeMoreTokens h t start = \\\\\n  next = makeTokens t (+ start (strLen h))\n  .\n  and (strMatches h emptyToken) (or (isNil t) (strStartsWith (head t) '\\n'))\n    makeTokens t (+ start (strLen h))\n    or (strStartsWith h ' ') (strStartsWith h '#')\n      next\n      and (strStartsWith h '\\n') (strStartsWith (head t) '#')\n        makeTokens (tail t) (+ start (+ (strLen h) (strLen (head t))))\n        cons (token h start) next"})((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_start){return (function(){

var L_next;

L_next = (function(){var $m; return function(){return $m || ($m = L_makeTokens()(L_t)((function(){var $m; return function(){return $m || ($m = L_$o()(L_start)((function(){var $m; return function(){return $m || ($m = L_strLen()(L_h))}})()))}})()))}})();
return L_and()((function(){var $m; return function(){return $m || ($m = L_strMatches()(L_h)(L_emptyToken))}})())((function(){var $m; return function(){return $m || ($m = L_or()((function(){var $m; return function(){return $m || ($m = L_isNil()(L_t))}})())((function(){var $m; return function(){return $m || ($m = L_strStartsWith()((function(){var $m; return function(){return $m || ($m = L_head()(L_t))}})())(function(){return "\n"}))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_makeTokens()(L_t)((function(){var $m; return function(){return $m || ($m = L_$o()(L_start)((function(){var $m; return function(){return $m || ($m = L_strLen()(L_h))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_or()((function(){var $m; return function(){return $m || ($m = L_strStartsWith()(L_h)(function(){return " "}))}})())((function(){var $m; return function(){return $m || ($m = L_strStartsWith()(L_h)(function(){return "#"}))}})())(L_next)((function(){var $m; return function(){return $m || ($m = L_and()((function(){var $m; return function(){return $m || ($m = L_strStartsWith()(L_h)(function(){return "\n"}))}})())((function(){var $m; return function(){return $m || ($m = L_strStartsWith()((function(){var $m; return function(){return $m || ($m = L_head()(L_t))}})())(function(){return "#"}))}})())((function(){var $m; return function(){return $m || ($m = L_makeTokens()((function(){var $m; return function(){return $m || ($m = L_tail()(L_t))}})())((function(){var $m; return function(){return $m || ($m = L_$o()(L_start)((function(){var $m; return function(){return $m || ($m = L_$o()((function(){var $m; return function(){return $m || ($m = L_strLen()(L_h))}})())((function(){var $m; return function(){return $m || ($m = L_strLen()((function(){var $m; return function(){return $m || ($m = L_head()(L_t))}})()))}})()))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_token()(L_h)(L_start))}})())(L_next))}})()))}})()))}})())})()}}})}})())},
  function(){return L_define()(function(){return "splitTokens"})(function(){return 2})(function(){return "splitTokens str pat = filter (\\s . not (eq s '')) (basicSplitTokens str pat true)"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pat){return L_filter()((function(){var $m; return function(){return $m || ($m = function(L_s){return L_not()((function(){var $m; return function(){return $m || ($m = L_eq()(L_s)(function(){return ""}))}})())})}})())((function(){var $m; return function(){return $m || ($m = L_basicSplitTokens()(L_str)(L_pat)(L_true))}})())}})}})())},
  function(){return L_define()(function(){return "numberPat"})(function(){return 0})(function(){return "numberPat = regexp '-?([0-9]+(\\\\.[0-9]+)?|\\\\.[0-9]+)'"})((function(){var $m; return function(){return $m || ($m = L_regexp()(function(){return "-?([0-9]+(\\.[0-9]+)?|\\.[0-9]+)"}))}})())},
  function(){return L_define()(function(){return "matchOffset"})(function(){return 2})(function(){return "matchOffset str match = isNil match\n  strLen str\n  head (tail (tail match))"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_match){return L_isNil()(L_match)((function(){var $m; return function(){return $m || ($m = L_strLen()(L_str))}})())((function(){var $m; return function(){return $m || ($m = L_head()((function(){var $m; return function(){return $m || ($m = L_tail()((function(){var $m; return function(){return $m || ($m = L_tail()(L_match))}})()))}})()))}})())}})}})())},
  function(){return L_define()(function(){return "basicSplitTokens"})(function(){return 3})(function(){return "basicSplitTokens str pat prevIsDel = == str ''\n  nil\n  \\\\\n    num = strMatch str numberPat\n    del = strMatch str pat\n    numOffset = matchOffset str num\n    delOffset = matchOffset str del\n    select = and (== numOffset 0) prevIsDel\n      \\del num first . num\n      == delOffset 0\n        \\del num first . del\n        \\del num first . first\n    first = select (head del) (head num) (strSubstring str 0 delOffset)\n    .\n    cons\n      first\n      basicSplitTokens\n        strSubstring str (strLen first) 0\n        pat\n        select true false false"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pat){return function(L_prevIsDel){return L_$p$p()(L_str)(function(){return ""})(L_nil)(function(){
var L_first, L_select, L_delOffset, L_numOffset, L_del, L_num;

L_first = (function(){var $m; return function(){return $m || ($m = L_select()((function(){var $m; return function(){return $m || ($m = L_head()(L_del))}})())((function(){var $m; return function(){return $m || ($m = L_head()(L_num))}})())((function(){var $m; return function(){return $m || ($m = L_strSubstring()(L_str)(function(){return 0})(L_delOffset))}})()))}})();

L_select = (function(){var $m; return function(){return $m || ($m = L_and()((function(){var $m; return function(){return $m || ($m = L_$p$p()(L_numOffset)(function(){return 0}))}})())(L_prevIsDel)((function(){var $m; return function(){return $m || ($m = function(L_del_0){return function(L_num_1){return function(L_first){return L_num_1()}}})}})())((function(){var $m; return function(){return $m || ($m = L_$p$p()(L_delOffset)(function(){return 0})((function(){var $m; return function(){return $m || ($m = function(L_del_0){return function(L_num_1){return function(L_first){return L_del_0()}}})}})())((function(){var $m; return function(){return $m || ($m = function(L_del_0){return function(L_num_1){return function(L_first){return L_first()}}})}})()))}})()))}})();

L_delOffset = (function(){var $m; return function(){return $m || ($m = L_matchOffset()(L_str)(L_del))}})();

L_numOffset = (function(){var $m; return function(){return $m || ($m = L_matchOffset()(L_str)(L_num))}})();

L_del = (function(){var $m; return function(){return $m || ($m = L_strMatch()(L_str)(L_pat))}})();

L_num = (function(){var $m; return function(){return $m || ($m = L_strMatch()(L_str)(L_numberPat))}})();
return L_cons()(L_first)((function(){var $m; return function(){return $m || ($m = L_basicSplitTokens()((function(){var $m; return function(){return $m || ($m = L_strSubstring()(L_str)((function(){var $m; return function(){return $m || ($m = L_strLen()(L_first))}})())(function(){return 0}))}})())(L_pat)((function(){var $m; return function(){return $m || ($m = L_select()(L_true)(L_false)(L_false))}})()))}})())})}}})}})())},
  function(){return L_define()(function(){return "tokens"})(function(){return 2})(function(){return "tokens str pat = makeTokens (splitTokens str pat) 0"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pat){return L_makeTokens()((function(){var $m; return function(){return $m || ($m = L_splitTokens()(L_str)(L_pat))}})())(function(){return 0})}})}})())},
  function(){return L_define()(function(){return "isString"})(function(){return 1})(function(){return "isString s = == (getType s) '*string'"})((function(){var $m; return function(){return $m || ($m = function(L_s){return L_$p$p()((function(){var $m; return function(){return $m || ($m = L_getType()(L_s))}})())(function(){return "*string"})})}})())},
  function(){return L_define()(function(){return "isTokenString"})(function(){return 2})(function(){return "isTokenString tok str = or\n  and (isToken tok) (eq (tokenString tok) str)\n  and (isString tok) (eq tok str)"})((function(){var $m; return function(){return $m || ($m = function(L_tok){return function(L_str){return L_or()((function(){var $m; return function(){return $m || ($m = L_and()((function(){var $m; return function(){return $m || ($m = L_isToken()(L_tok))}})())((function(){var $m; return function(){return $m || ($m = L_eq()((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_tok))}})())(L_str))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_and()((function(){var $m; return function(){return $m || ($m = L_isString()(L_tok))}})())((function(){var $m; return function(){return $m || ($m = L_eq()(L_tok)(L_str))}})()))}})())}})}})())},
  function(){return L_define()(function(){return "isTokenStart"})(function(){return 2})(function(){return "isTokenStart tok str = or\n  and (isToken tok) (strStartsWith (tokenString tok) str)\n  and (isString tok) (strStartsWith tok str)"})((function(){var $m; return function(){return $m || ($m = function(L_tok){return function(L_str){return L_or()((function(){var $m; return function(){return $m || ($m = L_and()((function(){var $m; return function(){return $m || ($m = L_isToken()(L_tok))}})())((function(){var $m; return function(){return $m || ($m = L_strStartsWith()((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_tok))}})())(L_str))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_and()((function(){var $m; return function(){return $m || ($m = L_isString()(L_tok))}})())((function(){var $m; return function(){return $m || ($m = L_strStartsWith()(L_tok)(L_str))}})()))}})())}})}})())},
  function(){return L_define()(function(){return "strTokenString"})(function(){return 1})(function(){return "strTokenString tok = withToken tok nil \\str pos . str"})((function(){var $m; return function(){return $m || ($m = function(L_tok){return L_withToken()(L_tok)(L_nil)((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pos){return L_str()}})}})())})}})())},
  function(){return L_define()(function(){return "withToken"})(function(){return 3})(function(){return "withToken tok nonTokCase tokCase = isToken tok\n  tok tokCase\n  isString tok\n    tokCase tok -1\n    nonTokCase"})((function(){var $m; return function(){return $m || ($m = function(L_tok){return function(L_nonTokCase){return function(L_tokCase){return L_isToken()(L_tok)((function(){var $m; return function(){return $m || ($m = L_tok()(L_tokCase))}})())((function(){var $m; return function(){return $m || ($m = L_isString()(L_tok)((function(){var $m; return function(){return $m || ($m = L_tokCase()(L_tok)(function(){return -1}))}})())(L_nonTokCase))}})())}}})}})())},
  function(){return L_define()(function(){return "withCons"})(function(){return 3})(function(){return "withCons l nilCase cont = isCons l (l (\\h t D . cont h t) nilCase) nilCase"})((function(){var $m; return function(){return $m || ($m = function(L_l){return function(L_nilCase){return function(L_cont){return L_isCons()(L_l)((function(){var $m; return function(){return $m || ($m = L_l()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_cont()(L_h)(L_t)}}})}})())(L_nilCase))}})())(L_nilCase)}}})}})())},
  function(){return L_define()(function(){return "ifNotErr"})(function(){return 2})(function(){return "ifNotErr thing cont = hasType thing parseErr thing (cont thing)"})((function(){var $m; return function(){return $m || ($m = function(L_thing){return function(L_cont){return L_hasType()(L_thing)(L_parseErr)(L_thing)((function(){var $m; return function(){return $m || ($m = L_cont()(L_thing))}})())}})}})())},
  function(){return L_define()(function(){return "parseToks"})(function(){return 2})(function(){return "parseToks toks groups =\n  isNil toks nil\n    ifNotErr (parseTok toks groups) \\list . list \\h t .\n      ifNotErr (parseToks t groups) \\res .\n        cons h\n          and (isCons res) (isBlockStart (head res))\n            cons res nil\n            res"})((function(){var $m; return function(){return $m || ($m = function(L_toks){return function(L_groups){return L_isNil()(L_toks)(L_nil)((function(){var $m; return function(){return $m || ($m = L_ifNotErr()((function(){var $m; return function(){return $m || ($m = L_parseTok()(L_toks)(L_groups))}})())((function(){var $m; return function(){return $m || ($m = function(L_list){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_ifNotErr()((function(){var $m; return function(){return $m || ($m = L_parseToks()(L_t)(L_groups))}})())((function(){var $m; return function(){return $m || ($m = function(L_res){return L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_and()((function(){var $m; return function(){return $m || ($m = L_isCons()(L_res))}})())((function(){var $m; return function(){return $m || ($m = L_isBlockStart()((function(){var $m; return function(){return $m || ($m = L_head()(L_res))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cons()(L_res)(L_nil))}})())(L_res))}})())})}})())}})}})())})}})()))}})())}})}})())},
  function(){return L_define()(function(){return "parseTok"})(function(){return 2})(function(){return "parseTok toks groups = withCons toks nil \\h t .\n  withToken h toks \\txt pos .\n    assoc txt groups\n      \\close . parseGroup h t nil close groups\n      isTokenStart h '\\n' (parseIndent h t nil groups)\n        toks"})((function(){var $m; return function(){return $m || ($m = function(L_toks){return function(L_groups){return L_withCons()(L_toks)(L_nil)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_withToken()(L_h)(L_toks)((function(){var $m; return function(){return $m || ($m = function(L_txt){return function(L_pos){return L_assoc()(L_txt)(L_groups)((function(){var $m; return function(){return $m || ($m = function(L_close){return L_parseGroup()(L_h)(L_t)(L_nil)(L_close)(L_groups)})}})())((function(){var $m; return function(){return $m || ($m = L_isTokenStart()(L_h)(function(){return "\n"})((function(){var $m; return function(){return $m || ($m = L_parseIndent()(L_h)(L_t)(L_nil)(L_groups))}})())(L_toks))}})())}})}})())}})}})())}})}})())},
  function(){return L_define()(function(){return "parseGroup"})(function(){return 5})(function(){return "parseGroup left toks gr close groups = withCons toks (parseErr 'Unterminated group starting ' (loc left))\n  \\h t . isTokenString h close\n    eq close ')'\n      cons (parensFromToks left h (reverse gr)) t\n      cons (cons left (cons (reverse gr) (cons h nil))) t\n    withToken h\n      ifNotErr (parseTok toks groups) \\list . list \\restH restT .\n        parseGroup left restT (cons restH gr) close groups\n      \\txt pos .\n        rassoc txt groups\n          \\open . parseErr (strCat (cons 'Mismatched group: ' (cons (tokenString left) (cons txt (cons ' ' nil))))) (loc left)\n          ifNotErr (parseTok toks groups) \\list . list \\restH restT . parseGroup left restT (cons restH gr) close groups"})((function(){var $m; return function(){return $m || ($m = function(L_left){return function(L_toks){return function(L_gr){return function(L_close){return function(L_groups){return L_withCons()(L_toks)((function(){var $m; return function(){return $m || ($m = L_parseErr()(function(){return "Unterminated group starting "})((function(){var $m; return function(){return $m || ($m = L_loc()(L_left))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_isTokenString()(L_h)(L_close)((function(){var $m; return function(){return $m || ($m = L_eq()(L_close)(function(){return ")"})((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_parensFromToks()(L_left)(L_h)((function(){var $m; return function(){return $m || ($m = L_reverse()(L_gr))}})()))}})())(L_t))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_cons()(L_left)((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_reverse()(L_gr))}})())((function(){var $m; return function(){return $m || ($m = L_cons()(L_h)(L_nil))}})()))}})()))}})())(L_t))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_withToken()(L_h)((function(){var $m; return function(){return $m || ($m = L_ifNotErr()((function(){var $m; return function(){return $m || ($m = L_parseTok()(L_toks)(L_groups))}})())((function(){var $m; return function(){return $m || ($m = function(L_list){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_restH){return function(L_restT){return L_parseGroup()(L_left)(L_restT)((function(){var $m; return function(){return $m || ($m = L_cons()(L_restH)(L_gr))}})())(L_close)(L_groups)}})}})())})}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_txt){return function(L_pos){return L_rassoc()(L_txt)(L_groups)((function(){var $m; return function(){return $m || ($m = function(L_open){return L_parseErr()((function(){var $m; return function(){return $m || ($m = L_strCat()((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "Mismatched group: "})((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_left))}})())((function(){var $m; return function(){return $m || ($m = L_cons()(L_txt)((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return " "})(L_nil))}})()))}})()))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_loc()(L_left))}})())})}})())((function(){var $m; return function(){return $m || ($m = L_ifNotErr()((function(){var $m; return function(){return $m || ($m = L_parseTok()(L_toks)(L_groups))}})())((function(){var $m; return function(){return $m || ($m = function(L_list){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_restH){return function(L_restT){return L_parseGroup()(L_left)(L_restT)((function(){var $m; return function(){return $m || ($m = L_cons()(L_restH)(L_gr))}})())(L_close)(L_groups)}})}})())})}})()))}})())}})}})()))}})())}})}})())}}}}})}})())},
  function(){return L_define()(function(){return "parseIndent"})(function(){return 4})(function(){return "parseIndent indent toks gr groups =\n  withCons toks (cons (makeParens (tokenPos indent) (lexEnd (head gr)) (reverse gr)) nil)\n    \\h t . or (withToken h false (\\txt pos . rassoc txt groups (\\open . true) false))\n      and (isTokenStart h '\\n') (<= (strLen (tokenString h)) (strLen (tokenString indent)))\n      cons (makeParens (tokenPos indent) (tokenPos h) (reverse gr)) toks\n      ifNotErr (parseTok toks groups) \\list . list \\restH restT . parseIndent indent restT (cons restH gr) groups"})((function(){var $m; return function(){return $m || ($m = function(L_indent){return function(L_toks){return function(L_gr){return function(L_groups){return L_withCons()(L_toks)((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_makeParens()((function(){var $m; return function(){return $m || ($m = L_tokenPos()(L_indent))}})())((function(){var $m; return function(){return $m || ($m = L_lexEnd()((function(){var $m; return function(){return $m || ($m = L_head()(L_gr))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_reverse()(L_gr))}})()))}})())(L_nil))}})())((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_or()((function(){var $m; return function(){return $m || ($m = L_withToken()(L_h)(L_false)((function(){var $m; return function(){return $m || ($m = function(L_txt){return function(L_pos){return L_rassoc()(L_txt)(L_groups)((function(){var $m; return function(){return $m || ($m = function(L_open){return L_true()})}})())(L_false)}})}})()))}})())((function(){var $m; return function(){return $m || ($m = L_and()((function(){var $m; return function(){return $m || ($m = L_isTokenStart()(L_h)(function(){return "\n"}))}})())((function(){var $m; return function(){return $m || ($m = L_$y$p()((function(){var $m; return function(){return $m || ($m = L_strLen()((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_h))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_strLen()((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_indent))}})()))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_makeParens()((function(){var $m; return function(){return $m || ($m = L_tokenPos()(L_indent))}})())((function(){var $m; return function(){return $m || ($m = L_tokenPos()(L_h))}})())((function(){var $m; return function(){return $m || ($m = L_reverse()(L_gr))}})()))}})())(L_toks))}})())((function(){var $m; return function(){return $m || ($m = L_ifNotErr()((function(){var $m; return function(){return $m || ($m = L_parseTok()(L_toks)(L_groups))}})())((function(){var $m; return function(){return $m || ($m = function(L_list){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_restH){return function(L_restT){return L_parseIndent()(L_indent)(L_restT)((function(){var $m; return function(){return $m || ($m = L_cons()(L_restH)(L_gr))}})())(L_groups)}})}})())})}})()))}})())}})}})())}}}})}})())},
  function(){return L_define()(function(){return "lit"})(function(){return 1})(function(){return "lit value = \\f . f value"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_value){return setType(function(L_f){return L_f()(L_value)}, 'lit')}, 'lit'))}})())},
  function(){return L_define()(function(){return "ref"})(function(){return 1})(function(){return "ref name = \\f . f name"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_name){return setType(function(L_f){return L_f()(L_name)}, 'ref')}, 'ref'))}})())},
  function(){return L_define()(function(){return "lambda"})(function(){return 2})(function(){return "lambda name body = \\f . f name body"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_name){return function(L_body){return setType(function(L_f){return L_f()(L_name)(L_body)}, 'lambda')}}, 'lambda'))}})())},
  function(){return L_define()(function(){return "apply"})(function(){return 2})(function(){return "apply func arg = \\f . f func arg"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_func){return function(L_arg){return setType(function(L_f){return L_f()(L_func)(L_arg)}, 'apply')}}, 'apply'))}})())},
  function(){return L_define()(function(){return "let"})(function(){return 3})(function(){return "let name value body = \\f . f name value body"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_name){return function(L_value){return function(L_body){return setType(function(L_f){return L_f()(L_name)(L_value)(L_body)}, 'let')}}}, 'let'))}})())},
  function(){return L_define()(function(){return "anno"})(function(){return 3})(function(){return "anno name data body = \\f . f name data body"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_name){return function(L_data){return function(L_body){return setType(function(L_f){return L_f()(L_name)(L_data)(L_body)}, 'anno')}}}, 'anno'))}})())},
  function(){return L_define()(function(){return "withParens"})(function(){return 3})(function(){return "withParens p err cont = isParens p (p cont) err"})((function(){var $m; return function(){return $m || ($m = function(L_p){return function(L_err){return function(L_cont){return L_isParens()(L_p)((function(){var $m; return function(){return $m || ($m = L_p()(L_cont))}})())(L_err)}}})}})())},
  function(){return L_define()(function(){return "setParens"})(function(){return 2})(function(){return "setParens p func = isParens p\n  p \\start end content . parens start end (func content)\n  func p"})((function(){var $m; return function(){return $m || ($m = function(L_p){return function(L_func){return L_isParens()(L_p)((function(){var $m; return function(){return $m || ($m = L_p()((function(){var $m; return function(){return $m || ($m = function(L_start){return function(L_end){return function(L_content){return L_parens()(L_start)(L_end)((function(){var $m; return function(){return $m || ($m = L_func()(L_content))}})())}}})}})()))}})())((function(){var $m; return function(){return $m || ($m = L_func()(L_p))}})())}})}})())},
  function(){return L_define()(function(){return "withStripped"})(function(){return 2})(function(){return "withStripped list cont = withParens list (cont list) \\start end content . withStripped content cont"})((function(){var $m; return function(){return $m || ($m = function(L_list){return function(L_cont){return L_withParens()(L_list)((function(){var $m; return function(){return $m || ($m = L_cont()(L_list))}})())((function(){var $m; return function(){return $m || ($m = function(L_start){return function(L_end){return function(L_content){return L_withStripped()(L_content)(L_cont)}}})}})())}})}})())},
  function(){return L_define()(function(){return "position"})(function(){return 1})(function(){return "position thing = isToken thing (tokenPos thing)\n  isParens thing (parensStart thing)\n    isCons thing (position (head thing))\n      -1"})((function(){var $m; return function(){return $m || ($m = function(L_thing){return L_isToken()(L_thing)((function(){var $m; return function(){return $m || ($m = L_tokenPos()(L_thing))}})())((function(){var $m; return function(){return $m || ($m = L_isParens()(L_thing)((function(){var $m; return function(){return $m || ($m = L_parensStart()(L_thing))}})())((function(){var $m; return function(){return $m || ($m = L_isCons()(L_thing)((function(){var $m; return function(){return $m || ($m = L_position()((function(){var $m; return function(){return $m || ($m = L_head()(L_thing))}})()))}})())(function(){return -1}))}})()))}})())})}})())},
  function(){return L_define()(function(){return "lexEnd"})(function(){return 1})(function(){return "lexEnd thing = isToken thing (+ (tokenPos thing) (strLen (tokenString thing)))\n  isParens thing (parensEnd thing)\n    isCons thing (lexEnd (last thing))\n      -1"})((function(){var $m; return function(){return $m || ($m = function(L_thing){return L_isToken()(L_thing)((function(){var $m; return function(){return $m || ($m = L_$o()((function(){var $m; return function(){return $m || ($m = L_tokenPos()(L_thing))}})())((function(){var $m; return function(){return $m || ($m = L_strLen()((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_thing))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_isParens()(L_thing)((function(){var $m; return function(){return $m || ($m = L_parensEnd()(L_thing))}})())((function(){var $m; return function(){return $m || ($m = L_isCons()(L_thing)((function(){var $m; return function(){return $m || ($m = L_lexEnd()((function(){var $m; return function(){return $m || ($m = L_last()(L_thing))}})()))}})())(function(){return -1}))}})()))}})())})}})())},
  function(){return L_define()(function(){return "loc"})(function(){return 1})(function(){return "loc thing = \\\\\n  p = position thing\n  l = eq p -1 'an unknown location' p\n  .\n  strCat (cons 'at ' (cons l nil))"})((function(){var $m; return function(){return $m || ($m = function(L_thing){return (function(){

var L_l, L_p;

L_l = (function(){var $m; return function(){return $m || ($m = L_eq()(L_p)(function(){return -1})(function(){return "an unknown location"})(L_p))}})();

L_p = (function(){var $m; return function(){return $m || ($m = L_position()(L_thing))}})();
return L_strCat()((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "at "})((function(){var $m; return function(){return $m || ($m = L_cons()(L_l)(L_nil))}})()))}})())})()})}})())},
  function(){return L_define()(function(){return "scrub"})(function(){return 1})(function(){return "scrub str = strFromList (scrubList (strToList str))"})((function(){var $m; return function(){return $m || ($m = function(L_str){return L_strFromList()((function(){var $m; return function(){return $m || ($m = L_scrubList()((function(){var $m; return function(){return $m || ($m = L_strToList()(L_str))}})()))}})())})}})())},
  function(){return L_define()(function(){return "scrubList"})(function(){return 1})(function(){return "scrubList list = list\n  \\h t D . \\\\\n    next = scrubList t\n    .\n    eq h '\\\\' (cons h (cons (head t) (scrubList (tail t))))\n      eq h '\\\"' (cons '\\\\' (cons '\\\"' next))\n        cons h next\n  nil"})((function(){var $m; return function(){return $m || ($m = function(L_list){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return (function(){

var L_next;

L_next = (function(){var $m; return function(){return $m || ($m = L_scrubList()(L_t))}})();
return L_eq()(L_h)(function(){return "\\"})((function(){var $m; return function(){return $m || ($m = L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_head()(L_t))}})())((function(){var $m; return function(){return $m || ($m = L_scrubList()((function(){var $m; return function(){return $m || ($m = L_tail()(L_t))}})()))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_eq()(L_h)(function(){return "\""})((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "\\"})((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "\""})(L_next))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cons()(L_h)(L_next))}})()))}})())})()}}})}})())(L_nil)})}})())},
  function(){return L_define()(function(){return "createAst"})(function(){return 3})(function(){return "createAst inList names cont = withStripped inList \\list .\n  isToken list (createLitOrRef (tokenString list) names cont)\n    list\n      \\h t D .\n        isTokenString h '\\\\\\\\' (createLet h t names cont)\n          isTokenString h '\\\\@' (createAnno h t names cont)\n            isTokenString h '\\\\' (createLambda h t names cont)\n              createApply list names cont\n      cont nil"})((function(){var $m; return function(){return $m || ($m = function(L_inList){return function(L_names){return function(L_cont){return L_withStripped()(L_inList)((function(){var $m; return function(){return $m || ($m = function(L_list){return L_isToken()(L_list)((function(){var $m; return function(){return $m || ($m = L_createLitOrRef()((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_list))}})())(L_names)(L_cont))}})())((function(){var $m; return function(){return $m || ($m = L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_isTokenString()(L_h)(function(){return "\\\\"})((function(){var $m; return function(){return $m || ($m = L_createLet()(L_h)(L_t)(L_names)(L_cont))}})())((function(){var $m; return function(){return $m || ($m = L_isTokenString()(L_h)(function(){return "\\@"})((function(){var $m; return function(){return $m || ($m = L_createAnno()(L_h)(L_t)(L_names)(L_cont))}})())((function(){var $m; return function(){return $m || ($m = L_isTokenString()(L_h)(function(){return "\\"})((function(){var $m; return function(){return $m || ($m = L_createLambda()(L_h)(L_t)(L_names)(L_cont))}})())((function(){var $m; return function(){return $m || ($m = L_createApply()(L_list)(L_names)(L_cont))}})()))}})()))}})())}}})}})())((function(){var $m; return function(){return $m || ($m = L_cont()(L_nil))}})()))}})())})}})())}}})}})())},
  function(){return L_define()(function(){return "strMatches"})(function(){return 2})(function(){return "strMatches str pat = isCons (strMatch str pat)"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pat){return L_isCons()((function(){var $m; return function(){return $m || ($m = L_strMatch()(L_str)(L_pat))}})())}})}})())},
  function(){return L_define()(function(){return "digit"})(function(){return 0})(function(){return "digit = regexp '^[0-9]+$'"})((function(){var $m; return function(){return $m || ($m = L_regexp()(function(){return "^[0-9]+$"}))}})())},
  function(){return L_define()(function(){return "backslashCodes"})(function(){return 0})(function(){return "backslashCodes = 'bfnrt'"})(function(){return "bfnrt"})},
  function(){return L_define()(function(){return "backslashValues"})(function(){return 0})(function(){return "backslashValues = '\\b\\f\\n\\r\\t'"})(function(){return "\b\f\n\r\t"})},
  function(){return L_define()(function(){return "convertStringEscape"})(function(){return 3})(function(){return "convertStringEscape char codes values =\n  eq codes ''\n    char\n    eq char (strAt codes 0)\n      strAt values 0\n      convertStringEscape char (strSubstring codes 1 0) (strSubstring values 1 0)"})((function(){var $m; return function(){return $m || ($m = function(L_char){return function(L_codes){return function(L_values){return L_eq()(L_codes)(function(){return ""})(L_char)((function(){var $m; return function(){return $m || ($m = L_eq()(L_char)((function(){var $m; return function(){return $m || ($m = L_strAt()(L_codes)(function(){return 0}))}})())((function(){var $m; return function(){return $m || ($m = L_strAt()(L_values)(function(){return 0}))}})())((function(){var $m; return function(){return $m || ($m = L_convertStringEscape()(L_char)((function(){var $m; return function(){return $m || ($m = L_strSubstring()(L_codes)(function(){return 1})(function(){return 0}))}})())((function(){var $m; return function(){return $m || ($m = L_strSubstring()(L_values)(function(){return 1})(function(){return 0}))}})()))}})()))}})())}}})}})())},
  function(){return L_define()(function(){return "convertStringEscapes"})(function(){return 3})(function(){return "convertStringEscapes orig str cont =\n  eq str ''\n    cont str\n    eq (strAt str 0) '\\\\'\n      eq (strLen str) 1 (parseErr \"Error, backslash without character in string: \" orig)\n        convertStringEscapes orig (strSubstring str 2 0) \\rest . cont\n          strAdd\n            convertStringEscape (strAt str 1) backslashCodes backslashValues\n            rest\n      convertStringEscapes orig (strSubstring str 1 0) \\rest . cont\n        strAdd\n          strAt str 0\n          rest"})((function(){var $m; return function(){return $m || ($m = function(L_orig){return function(L_str){return function(L_cont){return L_eq()(L_str)(function(){return ""})((function(){var $m; return function(){return $m || ($m = L_cont()(L_str))}})())((function(){var $m; return function(){return $m || ($m = L_eq()((function(){var $m; return function(){return $m || ($m = L_strAt()(L_str)(function(){return 0}))}})())(function(){return "\\"})((function(){var $m; return function(){return $m || ($m = L_eq()((function(){var $m; return function(){return $m || ($m = L_strLen()(L_str))}})())(function(){return 1})((function(){var $m; return function(){return $m || ($m = L_parseErr()(function(){return "Error, backslash without character in string: "})(L_orig))}})())((function(){var $m; return function(){return $m || ($m = L_convertStringEscapes()(L_orig)((function(){var $m; return function(){return $m || ($m = L_strSubstring()(L_str)(function(){return 2})(function(){return 0}))}})())((function(){var $m; return function(){return $m || ($m = function(L_rest){return L_cont()((function(){var $m; return function(){return $m || ($m = L_strAdd()((function(){var $m; return function(){return $m || ($m = L_convertStringEscape()((function(){var $m; return function(){return $m || ($m = L_strAt()(L_str)(function(){return 1}))}})())(L_backslashCodes)(L_backslashValues))}})())(L_rest))}})())})}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_convertStringEscapes()(L_orig)((function(){var $m; return function(){return $m || ($m = L_strSubstring()(L_str)(function(){return 1})(function(){return 0}))}})())((function(){var $m; return function(){return $m || ($m = function(L_rest){return L_cont()((function(){var $m; return function(){return $m || ($m = L_strAdd()((function(){var $m; return function(){return $m || ($m = L_strAt()(L_str)(function(){return 0}))}})())(L_rest))}})())})}})()))}})()))}})())}}})}})())},
  function(){return L_define()(function(){return "parseString"})(function(){return 2})(function(){return "parseString str cont =\n  neq (strAt str 0) (strAt str -1) (parseErr \"Badly terminated string: \" str)\n    convertStringEscapes str (strSubstring str 1 -1) cont"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_cont){return L_neq()((function(){var $m; return function(){return $m || ($m = L_strAt()(L_str)(function(){return 0}))}})())((function(){var $m; return function(){return $m || ($m = L_strAt()(L_str)(function(){return -1}))}})())((function(){var $m; return function(){return $m || ($m = L_parseErr()(function(){return "Badly terminated string: "})(L_str))}})())((function(){var $m; return function(){return $m || ($m = L_convertStringEscapes()(L_str)((function(){var $m; return function(){return $m || ($m = L_strSubstring()(L_str)(function(){return 1})(function(){return -1}))}})())(L_cont))}})())}})}})())},
  function(){return L_define()(function(){return "createLitOrRef"})(function(){return 3})(function(){return "createLitOrRef tok names cont =\n  contains names tok\n    cont (ref tok)\n    or (strStartsWith tok '\\\"') (strStartsWith tok \"'\")\n      parseString tok \\str . cont (lit str)\n      strStartsWith tok '.'\n        jsonParse (strCat (cons '0' (cons tok nil))) (\\err . cont (ref tok)) (\\item . cont (lit item))\n        or (and (>= (strAt tok 0) '0') (<= (strAt tok 0) '9')) (strStartsWith tok '-')\n          jsonParse tok (\\err . cont (ref tok)) (\\item . cont (lit item))\n          cont (ref tok)"})((function(){var $m; return function(){return $m || ($m = function(L_tok){return function(L_names){return function(L_cont){return L_contains()(L_names)(L_tok)((function(){var $m; return function(){return $m || ($m = L_cont()((function(){var $m; return function(){return $m || ($m = L_ref()(L_tok))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_or()((function(){var $m; return function(){return $m || ($m = L_strStartsWith()(L_tok)(function(){return "\""}))}})())((function(){var $m; return function(){return $m || ($m = L_strStartsWith()(L_tok)(function(){return "'"}))}})())((function(){var $m; return function(){return $m || ($m = L_parseString()(L_tok)((function(){var $m; return function(){return $m || ($m = function(L_str){return L_cont()((function(){var $m; return function(){return $m || ($m = L_lit()(L_str))}})())})}})()))}})())((function(){var $m; return function(){return $m || ($m = L_strStartsWith()(L_tok)(function(){return "."})((function(){var $m; return function(){return $m || ($m = L_jsonParse()((function(){var $m; return function(){return $m || ($m = L_strCat()((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "0"})((function(){var $m; return function(){return $m || ($m = L_cons()(L_tok)(L_nil))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_err){return L_cont()((function(){var $m; return function(){return $m || ($m = L_ref()(L_tok))}})())})}})())((function(){var $m; return function(){return $m || ($m = function(L_item){return L_cont()((function(){var $m; return function(){return $m || ($m = L_lit()(L_item))}})())})}})()))}})())((function(){var $m; return function(){return $m || ($m = L_or()((function(){var $m; return function(){return $m || ($m = L_and()((function(){var $m; return function(){return $m || ($m = L_$z$p()((function(){var $m; return function(){return $m || ($m = L_strAt()(L_tok)(function(){return 0}))}})())(function(){return "0"}))}})())((function(){var $m; return function(){return $m || ($m = L_$y$p()((function(){var $m; return function(){return $m || ($m = L_strAt()(L_tok)(function(){return 0}))}})())(function(){return "9"}))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_strStartsWith()(L_tok)(function(){return "-"}))}})())((function(){var $m; return function(){return $m || ($m = L_jsonParse()(L_tok)((function(){var $m; return function(){return $m || ($m = function(L_err){return L_cont()((function(){var $m; return function(){return $m || ($m = L_ref()(L_tok))}})())})}})())((function(){var $m; return function(){return $m || ($m = function(L_item){return L_cont()((function(){var $m; return function(){return $m || ($m = L_lit()(L_item))}})())})}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cont()((function(){var $m; return function(){return $m || ($m = L_ref()(L_tok))}})()))}})()))}})()))}})()))}})())}}})}})())},
  function(){return L_define()(function(){return "createLambda"})(function(){return 4})(function(){return "createLambda start list names cont = \\\\\n  err = parseErr \"Lambda needs a variable name, a dot, and a body \" (loc start)\n  .\n  withCons list err \\name rest .\n    withToken name err \\n p .\n      withCons rest err \\dot body .\n        # are these partial applications too hard to read?\n        isTokenString dot '.' (createAst body) (createLambda start rest)\n          cons n names\n          \\bodyAst . cont (lambda n bodyAst)"})((function(){var $m; return function(){return $m || ($m = function(L_start){return function(L_list){return function(L_names){return function(L_cont){return (function(){

var L_err;

L_err = (function(){var $m; return function(){return $m || ($m = L_parseErr()(function(){return "Lambda needs a variable name, a dot, and a body "})((function(){var $m; return function(){return $m || ($m = L_loc()(L_start))}})()))}})();
return L_withCons()(L_list)(L_err)((function(){var $m; return function(){return $m || ($m = function(L_name){return function(L_rest){return L_withToken()(L_name)(L_err)((function(){var $m; return function(){return $m || ($m = function(L_n){return function(L_p){return L_withCons()(L_rest)(L_err)((function(){var $m; return function(){return $m || ($m = function(L_dot){return function(L_body){return L_isTokenString()(L_dot)(function(){return "."})((function(){var $m; return function(){return $m || ($m = L_createAst()(L_body))}})())((function(){var $m; return function(){return $m || ($m = L_createLambda()(L_start)(L_rest))}})())((function(){var $m; return function(){return $m || ($m = L_cons()(L_n)(L_names))}})())((function(){var $m; return function(){return $m || ($m = function(L_bodyAst){return L_cont()((function(){var $m; return function(){return $m || ($m = L_lambda()(L_n)(L_bodyAst))}})())})}})())}})}})())}})}})())}})}})())})()}}}})}})())},
  function(){return L_define()(function(){return "createAnno"})(function(){return 4})(function(){return "createAnno start list names cont =\n  withCons list (parseErr \"No annotation name or data in annotation \" (loc start)) \\name rest .\n    withCons rest (parseErr \"No data for annotation \" (loc start)) \\data rest . \\\\\n      finish data body = createAst body names \\bodyAst .\n        cleanTokens start name \\name .\n          cleanTokens start data \\data .\n            cont (anno name data bodyAst)\n      .\n      isTokenString data '.'\n        finish nil rest\n        withStripped data \\data .\n          withCons rest (parseErr \"No body for annotation \" (loc start)) \\dot body .\n            isTokenString dot '.'\n              finish data body\n              parseErr \"Annotation expects dot after name and data \" (loc start)"})((function(){var $m; return function(){return $m || ($m = function(L_start){return function(L_list){return function(L_names){return function(L_cont){return L_withCons()(L_list)((function(){var $m; return function(){return $m || ($m = L_parseErr()(function(){return "No annotation name or data in annotation "})((function(){var $m; return function(){return $m || ($m = L_loc()(L_start))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_name){return function(L_rest){return L_withCons()(L_rest)((function(){var $m; return function(){return $m || ($m = L_parseErr()(function(){return "No data for annotation "})((function(){var $m; return function(){return $m || ($m = L_loc()(L_start))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_data){return function(L_rest_0){return (function(){

var L_finish;

L_finish = (function(){var $m; return function(){return $m || ($m = function(L_data_1){return function(L_body){return L_createAst()(L_body)(L_names)((function(){var $m; return function(){return $m || ($m = function(L_bodyAst){return L_cleanTokens()(L_start)(L_name)((function(){var $m; return function(){return $m || ($m = function(L_name_2){return L_cleanTokens()(L_start)(L_data_1)((function(){var $m; return function(){return $m || ($m = function(L_data_3){return L_cont()((function(){var $m; return function(){return $m || ($m = L_anno()(L_name_2)(L_data_3)(L_bodyAst))}})())})}})())})}})())})}})())}})}})();
return L_isTokenString()(L_data)(function(){return "."})((function(){var $m; return function(){return $m || ($m = L_finish()(L_nil)(L_rest_0))}})())((function(){var $m; return function(){return $m || ($m = L_withStripped()(L_data)((function(){var $m; return function(){return $m || ($m = function(L_data_1){return L_withCons()(L_rest_0)((function(){var $m; return function(){return $m || ($m = L_parseErr()(function(){return "No body for annotation "})((function(){var $m; return function(){return $m || ($m = L_loc()(L_start))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_dot){return function(L_body){return L_isTokenString()(L_dot)(function(){return "."})((function(){var $m; return function(){return $m || ($m = L_finish()(L_data_1)(L_body))}})())((function(){var $m; return function(){return $m || ($m = L_parseErr()(function(){return "Annotation expects dot after name and data "})((function(){var $m; return function(){return $m || ($m = L_loc()(L_start))}})()))}})())}})}})())})}})()))}})())})()}})}})())}})}})())}}}})}})())},
  function(){return L_define()(function(){return "bodyStructPat"})(function(){return 0})(function(){return "bodyStructPat = regexp '\\\\|\\\\\\\\|\\\\@'"})((function(){var $m; return function(){return $m || ($m = L_regexp()(function(){return "\\|\\\\|\\@"}))}})())},
  function(){return L_define()(function(){return "createApply"})(function(){return 3})(function(){return "createApply inList names cont = withStripped inList \\list .\n  withCons list (parseErr \"Funcion apply expecting a non-empty list \" (loc inList)) \\h t .\n    createAst h names \\func . chainApply func t names cont"})((function(){var $m; return function(){return $m || ($m = function(L_inList){return function(L_names){return function(L_cont){return L_withStripped()(L_inList)((function(){var $m; return function(){return $m || ($m = function(L_list){return L_withCons()(L_list)((function(){var $m; return function(){return $m || ($m = L_parseErr()(function(){return "Funcion apply expecting a non-empty list "})((function(){var $m; return function(){return $m || ($m = L_loc()(L_inList))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_createAst()(L_h)(L_names)((function(){var $m; return function(){return $m || ($m = function(L_func){return L_chainApply()(L_func)(L_t)(L_names)(L_cont)})}})())}})}})())})}})())}}})}})())},
  function(){return L_define()(function(){return "blockStarts"})(function(){return 0})(function(){return "blockStarts = cons '\\\\' (cons '\\\\\\\\' (cons '\\\\@' nil))"})((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "\\"})((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "\\\\"})((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "\\@"})(L_nil))}})()))}})()))}})())},
  function(){return L_define()(function(){return "chainApply"})(function(){return 4})(function(){return "chainApply func list names cont = withCons list (cont func) \\argItem rest .\n  and (isToken argItem) (contains blockStarts (tokenString argItem))\n    createAst list names \\arg . cont (apply func arg)\n    createAst argItem names \\arg . chainApply (apply func arg) rest names cont"})((function(){var $m; return function(){return $m || ($m = function(L_func){return function(L_list){return function(L_names){return function(L_cont){return L_withCons()(L_list)((function(){var $m; return function(){return $m || ($m = L_cont()(L_func))}})())((function(){var $m; return function(){return $m || ($m = function(L_argItem){return function(L_rest){return L_and()((function(){var $m; return function(){return $m || ($m = L_isToken()(L_argItem))}})())((function(){var $m; return function(){return $m || ($m = L_contains()(L_blockStarts)((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_argItem))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_createAst()(L_list)(L_names)((function(){var $m; return function(){return $m || ($m = function(L_arg){return L_cont()((function(){var $m; return function(){return $m || ($m = L_apply()(L_func)(L_arg))}})())})}})()))}})())((function(){var $m; return function(){return $m || ($m = L_createAst()(L_argItem)(L_names)((function(){var $m; return function(){return $m || ($m = function(L_arg){return L_chainApply()((function(){var $m; return function(){return $m || ($m = L_apply()(L_func)(L_arg))}})())(L_rest)(L_names)(L_cont)})}})()))}})())}})}})())}}}})}})())},
  function(){return L_define()(function(){return "cleanTokens"})(function(){return 3})(function(){return "cleanTokens start toks cont = isToken toks\n  cont (tokenString toks)\n  withCons toks (cont toks) \\head tail .\n    cleanTokens start head \\head .\n      cleanTokens start tail \\tail .\n        cont (cons head tail)"})((function(){var $m; return function(){return $m || ($m = function(L_start){return function(L_toks){return function(L_cont){return L_isToken()(L_toks)((function(){var $m; return function(){return $m || ($m = L_cont()((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_toks))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_withCons()(L_toks)((function(){var $m; return function(){return $m || ($m = L_cont()(L_toks))}})())((function(){var $m; return function(){return $m || ($m = function(L_head){return function(L_tail){return L_cleanTokens()(L_start)(L_head)((function(){var $m; return function(){return $m || ($m = function(L_head_0){return L_cleanTokens()(L_start)(L_tail)((function(){var $m; return function(){return $m || ($m = function(L_tail_1){return L_cont()((function(){var $m; return function(){return $m || ($m = L_cons()(L_head_0)(L_tail_1))}})())})}})())})}})())}})}})()))}})())}}})}})())},
  function(){return L_define()(function(){return "createLet"})(function(){return 4})(function(){return "createLet start list names cont = withCons list\n  parseErr \"No variable or body for let \" (loc start)\n  \\binding body . eq body nil (createAst binding name cont)\n    getLetNames start list names \\newNames .\n      createSublets start binding body newNames cont"})((function(){var $m; return function(){return $m || ($m = function(L_start){return function(L_list){return function(L_names){return function(L_cont){return L_withCons()(L_list)((function(){var $m; return function(){return $m || ($m = L_parseErr()(function(){return "No variable or body for let "})((function(){var $m; return function(){return $m || ($m = L_loc()(L_start))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_binding){return function(L_body){return L_eq()(L_body)(L_nil)((function(){var $m; return function(){return $m || ($m = L_createAst()(L_binding)(L_name)(L_cont))}})())((function(){var $m; return function(){return $m || ($m = L_getLetNames()(L_start)(L_list)(L_names)((function(){var $m; return function(){return $m || ($m = function(L_newNames){return L_createSublets()(L_start)(L_binding)(L_body)(L_newNames)(L_cont)})}})()))}})())}})}})())}}}})}})())},
  function(){return L_define()(function(){return "getLetNames"})(function(){return 4})(function(){return "getLetNames start list names cont = \\\\\n  err = parseErr \"Let expected binding \" (loc start)\n  .\n  withCons list (cont names) \\binding body .\n    isTokenString binding '.' (cont names)\n      withParens binding err \\start end def .\n        withCons def err \\name rest .\n          withToken name err \\str pos .\n            getLetNames start body (cons str names) cont"})((function(){var $m; return function(){return $m || ($m = function(L_start){return function(L_list){return function(L_names){return function(L_cont){return (function(){

var L_err;

L_err = (function(){var $m; return function(){return $m || ($m = L_parseErr()(function(){return "Let expected binding "})((function(){var $m; return function(){return $m || ($m = L_loc()(L_start))}})()))}})();
return L_withCons()(L_list)((function(){var $m; return function(){return $m || ($m = L_cont()(L_names))}})())((function(){var $m; return function(){return $m || ($m = function(L_binding){return function(L_body){return L_isTokenString()(L_binding)(function(){return "."})((function(){var $m; return function(){return $m || ($m = L_cont()(L_names))}})())((function(){var $m; return function(){return $m || ($m = L_withParens()(L_binding)(L_err)((function(){var $m; return function(){return $m || ($m = function(L_start_0){return function(L_end){return function(L_def){return L_withCons()(L_def)(L_err)((function(){var $m; return function(){return $m || ($m = function(L_name){return function(L_rest){return L_withToken()(L_name)(L_err)((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pos){return L_getLetNames()(L_start_0)(L_body)((function(){var $m; return function(){return $m || ($m = L_cons()(L_str)(L_names))}})())(L_cont)}})}})())}})}})())}}})}})()))}})())}})}})())})()}}}})}})())},
  function(){return L_define()(function(){return "createSublets"})(function(){return 5})(function(){return "createSublets start binding body names cont =\n  isTokenString binding '.' (createAst body names cont)\n    withCons body (parseErr \"Let expected a body \" (loc start)) \\bodyH bodyT .\n      getNameAndDef (parensStart binding) (parensContent binding) names \\name def .\n        createSublets start bodyH bodyT names \\bodyAst .\n          cont (let (tokenString name) def bodyAst)"})((function(){var $m; return function(){return $m || ($m = function(L_start){return function(L_binding){return function(L_body){return function(L_names){return function(L_cont){return L_isTokenString()(L_binding)(function(){return "."})((function(){var $m; return function(){return $m || ($m = L_createAst()(L_body)(L_names)(L_cont))}})())((function(){var $m; return function(){return $m || ($m = L_withCons()(L_body)((function(){var $m; return function(){return $m || ($m = L_parseErr()(function(){return "Let expected a body "})((function(){var $m; return function(){return $m || ($m = L_loc()(L_start))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_bodyH){return function(L_bodyT){return L_getNameAndDef()((function(){var $m; return function(){return $m || ($m = L_parensStart()(L_binding))}})())((function(){var $m; return function(){return $m || ($m = L_parensContent()(L_binding))}})())(L_names)((function(){var $m; return function(){return $m || ($m = function(L_name){return function(L_def){return L_createSublets()(L_start)(L_bodyH)(L_bodyT)(L_names)((function(){var $m; return function(){return $m || ($m = function(L_bodyAst){return L_cont()((function(){var $m; return function(){return $m || ($m = L_let()((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_name))}})())(L_def)(L_bodyAst))}})())})}})())}})}})())}})}})()))}})())}}}}})}})())},
  function(){return L_define()(function(){return "getNameAndDef"})(function(){return 4})(function(){return "getNameAndDef pos binding names cont =\n  withCons (tail binding) (parseErr \"Let expected binding at \" pos) \\snd sndT .\n    isTokenString snd '=' (createAst sndT names \\def . cont (head binding) def)\n      getLetLambda pos (tail binding) nil names \\lamb . cont (head binding) lamb"})((function(){var $m; return function(){return $m || ($m = function(L_pos){return function(L_binding){return function(L_names){return function(L_cont){return L_withCons()((function(){var $m; return function(){return $m || ($m = L_tail()(L_binding))}})())((function(){var $m; return function(){return $m || ($m = L_parseErr()(function(){return "Let expected binding at "})(L_pos))}})())((function(){var $m; return function(){return $m || ($m = function(L_snd){return function(L_sndT){return L_isTokenString()(L_snd)(function(){return "="})((function(){var $m; return function(){return $m || ($m = L_createAst()(L_sndT)(L_names)((function(){var $m; return function(){return $m || ($m = function(L_def){return L_cont()((function(){var $m; return function(){return $m || ($m = L_head()(L_binding))}})())(L_def)})}})()))}})())((function(){var $m; return function(){return $m || ($m = L_getLetLambda()(L_pos)((function(){var $m; return function(){return $m || ($m = L_tail()(L_binding))}})())(L_nil)(L_names)((function(){var $m; return function(){return $m || ($m = function(L_lamb){return L_cont()((function(){var $m; return function(){return $m || ($m = L_head()(L_binding))}})())(L_lamb)})}})()))}})())}})}})())}}}})}})())},
  function(){return L_define()(function(){return "getLetLambda"})(function(){return 5})(function(){return "getLetLambda pos def args names cont =\n  withCons def (parseErr \"Let expected binding at \" pos) \\arg rest .\n    not (isToken arg) (parseErr \"Let expected binding at \" pos)\n      isTokenString arg '='\n        createAst (cons (token '\\\\' pos) (append (reverse args) (cons (token '.' (position arg)) rest))) names cont\n        getLetLambda pos rest (cons arg args) names cont"})((function(){var $m; return function(){return $m || ($m = function(L_pos){return function(L_def){return function(L_args){return function(L_names){return function(L_cont){return L_withCons()(L_def)((function(){var $m; return function(){return $m || ($m = L_parseErr()(function(){return "Let expected binding at "})(L_pos))}})())((function(){var $m; return function(){return $m || ($m = function(L_arg){return function(L_rest){return L_not()((function(){var $m; return function(){return $m || ($m = L_isToken()(L_arg))}})())((function(){var $m; return function(){return $m || ($m = L_parseErr()(function(){return "Let expected binding at "})(L_pos))}})())((function(){var $m; return function(){return $m || ($m = L_isTokenString()(L_arg)(function(){return "="})((function(){var $m; return function(){return $m || ($m = L_createAst()((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_token()(function(){return "\\"})(L_pos))}})())((function(){var $m; return function(){return $m || ($m = L_append()((function(){var $m; return function(){return $m || ($m = L_reverse()(L_args))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_token()(function(){return "."})((function(){var $m; return function(){return $m || ($m = L_position()(L_arg))}})()))}})())(L_rest))}})()))}})()))}})())(L_names)(L_cont))}})())((function(){var $m; return function(){return $m || ($m = L_getLetLambda()(L_pos)(L_rest)((function(){var $m; return function(){return $m || ($m = L_cons()(L_arg)(L_args))}})())(L_names)(L_cont))}})()))}})())}})}})())}}}}})}})())},
  function(){return L_define()(function(){return "parenGroups"})(function(){return 0})(function(){return "parenGroups = cons (cons '(' ')') nil"})((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "("})(function(){return ")"}))}})())(L_nil))}})())},
  function(){return L_define()(function(){return "scanLineG"})(function(){return 5})(function(){return "scanLineG str pat groups onDef onExpr = \\\\\n  toks = tokens str pat\n  groupToks = foldr (\\el value . el \\h t . cons h (cons t value)) (cons '=' blockStarts) groups\n  .\n  # check if it's a definition\n  find (\\tok . or (contains groupToks (tokenString tok)) (isCons (strMatch (tokenString tok) '^\\n'))) toks (\\item . isTokenString item '=') false\n    toks \\name rest . \\\\\n      parseIt func = \\\\\n        parsed = parseToks (checkSetDataType func rest name) groups\n        .\n        onDef (ifNotErr parsed \\list . createDef list name (arity rest 0) str)\n      .\n      isTokenString (head rest) '='\n        isTokenString (head (tail rest)) '\\\\'\n          parseIt (setTypeAnno (tail rest) (tokenString name))\n          parseIt (tail rest)\n        transformDef name rest \\def .\n          parseIt (cons (token '\\\\' (- (position (head rest)) 1)) def)\n    ifNotErr (parseToks toks groups) \\list . onExpr list"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pat){return function(L_groups){return function(L_onDef){return function(L_onExpr){return (function(){

var L_groupToks, L_toks;

L_groupToks = (function(){var $m; return function(){return $m || ($m = L_foldr()((function(){var $m; return function(){return $m || ($m = function(L_el){return function(L_value){return L_el()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_cons()(L_t)(L_value))}})())}})}})())}})}})())((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "="})(L_blockStarts))}})())(L_groups))}})();

L_toks = (function(){var $m; return function(){return $m || ($m = L_tokens()(L_str)(L_pat))}})();
return L_find()((function(){var $m; return function(){return $m || ($m = function(L_tok){return L_or()((function(){var $m; return function(){return $m || ($m = L_contains()(L_groupToks)((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_tok))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_isCons()((function(){var $m; return function(){return $m || ($m = L_strMatch()((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_tok))}})())(function(){return "^\n"}))}})()))}})())})}})())(L_toks)((function(){var $m; return function(){return $m || ($m = function(L_item){return L_isTokenString()(L_item)(function(){return "="})})}})())(L_false)((function(){var $m; return function(){return $m || ($m = L_toks()((function(){var $m; return function(){return $m || ($m = function(L_name){return function(L_rest){return (function(){

var L_parseIt;

L_parseIt = (function(){var $m; return function(){return $m || ($m = function(L_func){return (function(){

var L_parsed;

L_parsed = (function(){var $m; return function(){return $m || ($m = L_parseToks()((function(){var $m; return function(){return $m || ($m = L_checkSetDataType()(L_func)(L_rest)(L_name))}})())(L_groups))}})();
return L_onDef()((function(){var $m; return function(){return $m || ($m = L_ifNotErr()(L_parsed)((function(){var $m; return function(){return $m || ($m = function(L_list){return L_createDef()(L_list)(L_name)((function(){var $m; return function(){return $m || ($m = L_arity()(L_rest)(function(){return 0}))}})())(L_str)})}})()))}})())})()})}})();
return L_isTokenString()((function(){var $m; return function(){return $m || ($m = L_head()(L_rest))}})())(function(){return "="})((function(){var $m; return function(){return $m || ($m = L_isTokenString()((function(){var $m; return function(){return $m || ($m = L_head()((function(){var $m; return function(){return $m || ($m = L_tail()(L_rest))}})()))}})())(function(){return "\\"})((function(){var $m; return function(){return $m || ($m = L_parseIt()((function(){var $m; return function(){return $m || ($m = L_setTypeAnno()((function(){var $m; return function(){return $m || ($m = L_tail()(L_rest))}})())((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_name))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_parseIt()((function(){var $m; return function(){return $m || ($m = L_tail()(L_rest))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_transformDef()(L_name)(L_rest)((function(){var $m; return function(){return $m || ($m = function(L_def){return L_parseIt()((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_token()(function(){return "\\"})((function(){var $m; return function(){return $m || ($m = L_$_()((function(){var $m; return function(){return $m || ($m = L_position()((function(){var $m; return function(){return $m || ($m = L_head()(L_rest))}})()))}})())(function(){return 1}))}})()))}})())(L_def))}})())})}})()))}})())})()}})}})()))}})())((function(){var $m; return function(){return $m || ($m = L_ifNotErr()((function(){var $m; return function(){return $m || ($m = L_parseToks()(L_toks)(L_groups))}})())((function(){var $m; return function(){return $m || ($m = function(L_list){return L_onExpr()(L_list)})}})()))}})())})()}}}}})}})())},
  function(){return L_define()(function(){return "parseLineG"})(function(){return 6})(function(){return "parseLineG str pat names groups onDef onExpr = \\\\\n  astCallback cb = \\list . createAst list names \\ast . cb ast\n  .\n  scanLineG str pat groups (astCallback onDef) (astCallback onExpr)"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pat){return function(L_names){return function(L_groups){return function(L_onDef){return function(L_onExpr){return (function(){

var L_astCallback;

L_astCallback = (function(){var $m; return function(){return $m || ($m = function(L_cb){return function(L_list){return L_createAst()(L_list)(L_names)((function(){var $m; return function(){return $m || ($m = function(L_ast){return L_cb()(L_ast)})}})())}})}})();
return L_scanLineG()(L_str)(L_pat)(L_groups)((function(){var $m; return function(){return $m || ($m = L_astCallback()(L_onDef))}})())((function(){var $m; return function(){return $m || ($m = L_astCallback()(L_onExpr))}})())})()}}}}}})}})())},
  function(){return L_define()(function(){return "transformDef"})(function(){return 3})(function(){return "transformDef name toks cont = withCons toks (parseErr \"Bad definition, expecting tokens\" (loc name)) \\h t .\n  isTokenString h '='\n    isTokenString (head t) '\\\\'\n      cont (cons (token '.' (position h)) (setTypeAnno t (tokenString name)))\n      cont (cons (token '.' (position h)) t)\n    transformDef name t \\list . cont (cons h list)"})((function(){var $m; return function(){return $m || ($m = function(L_name){return function(L_toks){return function(L_cont){return L_withCons()(L_toks)((function(){var $m; return function(){return $m || ($m = L_parseErr()(function(){return "Bad definition, expecting tokens"})((function(){var $m; return function(){return $m || ($m = L_loc()(L_name))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_isTokenString()(L_h)(function(){return "="})((function(){var $m; return function(){return $m || ($m = L_isTokenString()((function(){var $m; return function(){return $m || ($m = L_head()(L_t))}})())(function(){return "\\"})((function(){var $m; return function(){return $m || ($m = L_cont()((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_token()(function(){return "."})((function(){var $m; return function(){return $m || ($m = L_position()(L_h))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_setTypeAnno()(L_t)((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_name))}})()))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cont()((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_token()(function(){return "."})((function(){var $m; return function(){return $m || ($m = L_position()(L_h))}})()))}})())(L_t))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_transformDef()(L_name)(L_t)((function(){var $m; return function(){return $m || ($m = function(L_list){return L_cont()((function(){var $m; return function(){return $m || ($m = L_cons()(L_h)(L_list))}})())})}})()))}})())}})}})())}}})}})())},
  function(){return L_define()(function(){return "setTypeAnno"})(function(){return 2})(function(){return "setTypeAnno toks name = \\\\\n  tok = \\str . token str (position toks)\n  .\n  cons (tok '\\\\@') (cons (tok 'type') (cons (tok name) (cons (tok '.') toks)))"})((function(){var $m; return function(){return $m || ($m = function(L_toks){return function(L_name){return (function(){

var L_tok;

L_tok = (function(){var $m; return function(){return $m || ($m = function(L_str){return L_token()(L_str)((function(){var $m; return function(){return $m || ($m = L_position()(L_toks))}})())})}})();
return L_cons()((function(){var $m; return function(){return $m || ($m = L_tok()(function(){return "\\@"}))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_tok()(function(){return "type"}))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_tok()(L_name))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_tok()(function(){return "."}))}})())(L_toks))}})()))}})()))}})())})()}})}})())},
  function(){return L_define()(function(){return "setDataTypeAnno"})(function(){return 2})(function(){return "setDataTypeAnno toks name = \\\\\n  tok = \\str . token str (position toks)\n  .\n  cons (tok '\\\\@') (cons (tok 'dataType') (cons (tok (tokenString name)) (cons (tok '.') toks)))"})((function(){var $m; return function(){return $m || ($m = function(L_toks){return function(L_name){return (function(){

var L_tok;

L_tok = (function(){var $m; return function(){return $m || ($m = function(L_str){return L_token()(L_str)((function(){var $m; return function(){return $m || ($m = L_position()(L_toks))}})())})}})();
return L_cons()((function(){var $m; return function(){return $m || ($m = L_tok()(function(){return "\\@"}))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_tok()(function(){return "dataType"}))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_tok()((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_name))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_tok()(function(){return "."}))}})())(L_toks))}})()))}})()))}})())})()}})}})())},
  function(){return L_define()(function(){return "createDef"})(function(){return 4})(function(){return "createDef def name arity src = \\\\\n  tok str = token str (position def)\n  .\n  jsonStringify (tokenString name) (\\err . parseErr (strCat (cons \"Bad function name \" (cons (loc name) nil))) err) \\nameStr .\n    jsonStringify src (\\err . parseErr (strCat (cons \"Bad source \" (cons (loc name) nil))) err) \\srcStr .\n      #cons (tok 'define') (cons (tok nameStr) (cons (tok (strString arity)) (cons (tok srcStr) (cons def nil))))\n      cons (tok '\\\\@') (cons (cons (tok 'definition') (cons (tok name) nil)) (cons (tok '.') (cons (tok 'define') (cons (tok nameStr) (cons (tok (strString arity)) (cons (tok srcStr) (cons def nil)))))))"})((function(){var $m; return function(){return $m || ($m = function(L_def){return function(L_name){return function(L_arity){return function(L_src){return (function(){

var L_tok;

L_tok = (function(){var $m; return function(){return $m || ($m = function(L_str){return L_token()(L_str)((function(){var $m; return function(){return $m || ($m = L_position()(L_def))}})())})}})();
return L_jsonStringify()((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_name))}})())((function(){var $m; return function(){return $m || ($m = function(L_err){return L_parseErr()((function(){var $m; return function(){return $m || ($m = L_strCat()((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "Bad function name "})((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_loc()(L_name))}})())(L_nil))}})()))}})()))}})())(L_err)})}})())((function(){var $m; return function(){return $m || ($m = function(L_nameStr){return L_jsonStringify()(L_src)((function(){var $m; return function(){return $m || ($m = function(L_err){return L_parseErr()((function(){var $m; return function(){return $m || ($m = L_strCat()((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "Bad source "})((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_loc()(L_name))}})())(L_nil))}})()))}})()))}})())(L_err)})}})())((function(){var $m; return function(){return $m || ($m = function(L_srcStr){return L_cons()((function(){var $m; return function(){return $m || ($m = L_tok()(function(){return "\\@"}))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_tok()(function(){return "definition"}))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_tok()(L_name))}})())(L_nil))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_tok()(function(){return "."}))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_tok()(function(){return "define"}))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_tok()(L_nameStr))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_tok()((function(){var $m; return function(){return $m || ($m = L_strString()(L_arity))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_tok()(L_srcStr))}})())((function(){var $m; return function(){return $m || ($m = L_cons()(L_def)(L_nil))}})()))}})()))}})()))}})()))}})()))}})()))}})())})}})())})}})())})()}}}})}})())},
  function(){return L_define()(function(){return "checkSetDataType"})(function(){return 3})(function(){return "checkSetDataType toks curToks name = withCons curToks toks \\h t .\n  isTokenString h '='\n    isTokenString (head t) '\\\\'\n      setDataTypeAnno toks name\n      toks\n    checkSetDataType toks t name"})((function(){var $m; return function(){return $m || ($m = function(L_toks){return function(L_curToks){return function(L_name){return L_withCons()(L_curToks)(L_toks)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_isTokenString()(L_h)(function(){return "="})((function(){var $m; return function(){return $m || ($m = L_isTokenString()((function(){var $m; return function(){return $m || ($m = L_head()(L_t))}})())(function(){return "\\"})((function(){var $m; return function(){return $m || ($m = L_setDataTypeAnno()(L_toks)(L_name))}})())(L_toks))}})())((function(){var $m; return function(){return $m || ($m = L_checkSetDataType()(L_toks)(L_t)(L_name))}})())}})}})())}}})}})())},
  function(){return L_define()(function(){return "arity"})(function(){return 2})(function(){return "arity toks n = isTokenString (head toks) '=' n (arity (tail toks) (+ n 1))"})((function(){var $m; return function(){return $m || ($m = function(L_toks){return function(L_n){return L_isTokenString()((function(){var $m; return function(){return $m || ($m = L_head()(L_toks))}})())(function(){return "="})(L_n)((function(){var $m; return function(){return $m || ($m = L_arity()((function(){var $m; return function(){return $m || ($m = L_tail()(L_toks))}})())((function(){var $m; return function(){return $m || ($m = L_$o()(L_n)(function(){return 1}))}})()))}})())}})}})())},
  function(){return L_define()(function(){return "tokListStr"})(function(){return 1})(function(){return "tokListStr toks = jsonStringify (join (map (\\t . tokenString t) toks) ' ')"})((function(){var $m; return function(){return $m || ($m = function(L_toks){return L_jsonStringify()((function(){var $m; return function(){return $m || ($m = L_join()((function(){var $m; return function(){return $m || ($m = L_map()((function(){var $m; return function(){return $m || ($m = function(L_t){return L_tokenString()(L_t)})}})())(L_toks))}})())(function(){return " "}))}})())})}})())},
  function(){return L_define()(function(){return "linePat"})(function(){return 0})(function(){return "linePat = regexp '\\\\r?\\\\n(?=[^ ]|$)'"})((function(){var $m; return function(){return $m || ($m = L_regexp()(function(){return "\\r?\\n(?=[^ ]|$)"}))}})())},
  function(){return L_define()(function(){return "emptyLinePat"})(function(){return 0})(function(){return "emptyLinePat = regexp '(^[ \\\\i]*\\\\#.*|^[ \\\\i]*$|^\\\\r?\\\\n[ \\\\i]*$)'"})((function(){var $m; return function(){return $m || ($m = L_regexp()(function(){return "(^[ \\i]*\\#.*|^[ \\i]*$|^\\r?\\n[ \\i]*$)"}))}})())},
  function(){return L_define()(function(){return "lineScrub"})(function(){return 0})(function(){return "lineScrub = regexpFlags '\\\\r\\\\n' 'g'"})((function(){var $m; return function(){return $m || ($m = L_regexpFlags()(function(){return "\\r\\n"})(function(){return "g"}))}})())},
  function(){return L_define()(function(){return "linesForFile"})(function(){return 1})(function(){return "linesForFile text = filter\n  \\line . isNil (strMatch line emptyLinePat)\n  strSplit (strReplace text lineScrub '\\n') linePat"})((function(){var $m; return function(){return $m || ($m = function(L_text){return L_filter()((function(){var $m; return function(){return $m || ($m = function(L_line){return L_isNil()((function(){var $m; return function(){return $m || ($m = L_strMatch()(L_line)(L_emptyLinePat))}})())})}})())((function(){var $m; return function(){return $m || ($m = L_strSplit()((function(){var $m; return function(){return $m || ($m = L_strReplace()(L_text)(L_lineScrub)(function(){return "\n"}))}})())(L_linePat))}})())})}})())},
  function(){return L_define()(function(){return "defPat"})(function(){return 0})(function(){return "defPat = regexp '^[^ =]+.* =( |$)'"})((function(){var $m; return function(){return $m || ($m = L_regexp()(function(){return "^[^ =]+.* =( |$)"}))}})())},
  function(){return L_define()(function(){return "unanchoredDefPat"})(function(){return 0})(function(){return "unanchoredDefPat = regexp '^((?:\\\\s*\\\\n|#[^\\\\n]*\\\\n)*)([^=\\\\n]*)(=\\\\([^=]+=|=)?'"})((function(){var $m; return function(){return $m || ($m = L_regexp()(function(){return "^((?:\\s*\\n|#[^\\n]*\\n)*)([^=\\n]*)(=\\([^=]+=|=)?"}))}})())},
  function(){return L_define()(function(){return "namesForLines"})(function(){return 1})(function(){return "namesForLines lines = foldl\n  \\result line . \\\\\n    m = strMatch line defPat\n    .\n    isNil m result (cons (head (tail m)) result)\n  nil\n  lines"})((function(){var $m; return function(){return $m || ($m = function(L_lines){return L_foldl()((function(){var $m; return function(){return $m || ($m = function(L_result){return function(L_line){return (function(){

var L_m;

L_m = (function(){var $m; return function(){return $m || ($m = L_strMatch()(L_line)(L_defPat))}})();
return L_isNil()(L_m)(L_result)((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_head()((function(){var $m; return function(){return $m || ($m = L_tail()(L_m))}})()))}})())(L_result))}})())})()}})}})())(L_nil)(L_lines)})}})())},
  function(){return L_define()(function(){return "runParseFilters"})(function(){return 2})(function(){return "runParseFilters filters line = filters\n  \\h t D . bind (h line) \\filtered . runParseFilters t filtered\n  line"})((function(){var $m; return function(){return $m || ($m = function(L_filters){return function(L_line){return L_filters()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_bind()((function(){var $m; return function(){return $m || ($m = L_h()(L_line))}})())((function(){var $m; return function(){return $m || ($m = function(L_filtered){return L_runParseFilters()(L_t)(L_filtered)})}})())}}})}})())(L_line)}})}})())},
  function(){return L_define()(function(){return "isBlockStart"})(function(){return 1})(function(){return "isBlockStart tok = and\n  isToken tok\n  contains blockStarts (tokenString tok)"})((function(){var $m; return function(){return $m || ($m = function(L_tok){return L_and()((function(){var $m; return function(){return $m || ($m = L_isToken()(L_tok))}})())((function(){var $m; return function(){return $m || ($m = L_contains()(L_blockStarts)((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_tok))}})()))}})())})}})())},
  function(){return L_define()(function(){return "macroSub"})(function(){return 2})(function(){return "macroSub macs expr = postProcessMacro -1 -1 (baseMacroSub macs expr)"})((function(){var $m; return function(){return $m || ($m = function(L_macs){return function(L_expr){return L_postProcessMacro()(function(){return -1})(function(){return -1})((function(){var $m; return function(){return $m || ($m = L_baseMacroSub()(L_macs)(L_expr))}})())}})}})())},
  function(){return L_define()(function(){return "consifyMacroValue"})(function(){return 1})(function(){return "consifyMacroValue value = isCons value value (cons value nil)"})((function(){var $m; return function(){return $m || ($m = function(L_value){return L_isCons()(L_value)(L_value)((function(){var $m; return function(){return $m || ($m = L_cons()(L_value)(L_nil))}})())})}})())},
  function(){return L_define()(function(){return "baseMacroSub"})(function(){return 2})(function(){return "baseMacroSub macs expr = isToken expr\n  expr\n  isParens expr\n    expr \\start end content . \\\\\n      result = baseMacroSub macs content\n      .\n      isToken result result (parens start end result)\n    withCons expr expr \\h t .\n      isBlockStart h\n        cons h\n          isTokenString h '\\\\\\\\'\n            macroSubLet macs t\n            macroSubBody '.' macs t\n        withToken h\n          \\\\\n            subH = baseMacroSub macs h\n            .\n            withToken subH\n              cons subH (map (baseMacroSub macs) t)\n              \\tok pos . baseMacroSub macs (cons subH t)\n          \\tok pos . assoc tok macs\n            \\def . baseMacroSub macs (def t)\n            cons h (map (baseMacroSub macs) t)"})((function(){var $m; return function(){return $m || ($m = function(L_macs){return function(L_expr){return L_isToken()(L_expr)(L_expr)((function(){var $m; return function(){return $m || ($m = L_isParens()(L_expr)((function(){var $m; return function(){return $m || ($m = L_expr()((function(){var $m; return function(){return $m || ($m = function(L_start){return function(L_end){return function(L_content){return (function(){

var L_result;

L_result = (function(){var $m; return function(){return $m || ($m = L_baseMacroSub()(L_macs)(L_content))}})();
return L_isToken()(L_result)(L_result)((function(){var $m; return function(){return $m || ($m = L_parens()(L_start)(L_end)(L_result))}})())})()}}})}})()))}})())((function(){var $m; return function(){return $m || ($m = L_withCons()(L_expr)(L_expr)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_isBlockStart()(L_h)((function(){var $m; return function(){return $m || ($m = L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_isTokenString()(L_h)(function(){return "\\\\"})((function(){var $m; return function(){return $m || ($m = L_macroSubLet()(L_macs)(L_t))}})())((function(){var $m; return function(){return $m || ($m = L_macroSubBody()(function(){return "."})(L_macs)(L_t))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_withToken()(L_h)(function(){
var L_subH;

L_subH = (function(){var $m; return function(){return $m || ($m = L_baseMacroSub()(L_macs)(L_h))}})();
return L_withToken()(L_subH)((function(){var $m; return function(){return $m || ($m = L_cons()(L_subH)((function(){var $m; return function(){return $m || ($m = L_map()((function(){var $m; return function(){return $m || ($m = L_baseMacroSub()(L_macs))}})())(L_t))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_tok){return function(L_pos){return L_baseMacroSub()(L_macs)((function(){var $m; return function(){return $m || ($m = L_cons()(L_subH)(L_t))}})())}})}})())})((function(){var $m; return function(){return $m || ($m = function(L_tok){return function(L_pos){return L_assoc()(L_tok)(L_macs)((function(){var $m; return function(){return $m || ($m = function(L_def){return L_baseMacroSub()(L_macs)((function(){var $m; return function(){return $m || ($m = L_def()(L_t))}})())})}})())((function(){var $m; return function(){return $m || ($m = L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_map()((function(){var $m; return function(){return $m || ($m = L_baseMacroSub()(L_macs))}})())(L_t))}})()))}})())}})}})()))}})())}})}})()))}})()))}})())}})}})())},
  function(){return L_define()(function(){return "macroSubLet"})(function(){return 2})(function(){return "macroSubLet macs list = list\n  \\h t D . isTokenString h '.'\n    cons h (baseMacroSub macs t)\n    cons (setParens h \\content . macroSubBody '=' macs content) (macroSubLet macs t)\n  # Don't bother with parse errors at this point -- ast generator will detect them\n  nil"})((function(){var $m; return function(){return $m || ($m = function(L_macs){return function(L_list){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_isTokenString()(L_h)(function(){return "."})((function(){var $m; return function(){return $m || ($m = L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_baseMacroSub()(L_macs)(L_t))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_setParens()(L_h)((function(){var $m; return function(){return $m || ($m = function(L_content){return L_macroSubBody()(function(){return "="})(L_macs)(L_content)})}})()))}})())((function(){var $m; return function(){return $m || ($m = L_macroSubLet()(L_macs)(L_t))}})()))}})())}}})}})())(L_nil)}})}})())},
  function(){return L_define()(function(){return "macroSubBody"})(function(){return 3})(function(){return "macroSubBody char macs list = list\n  \\h t D . cons h\n    isTokenString h char baseMacroSub (macroSubBody char)\n      macs\n      t\n  nil"})((function(){var $m; return function(){return $m || ($m = function(L_char){return function(L_macs){return function(L_list){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_isTokenString()(L_h)(L_char)(L_baseMacroSub)((function(){var $m; return function(){return $m || ($m = L_macroSubBody()(L_char))}})())(L_macs)(L_t))}})())}}})}})())(L_nil)}}})}})())},
  function(){return L_define()(function(){return "postProcessMacro"})(function(){return 3})(function(){return "postProcessMacro before after expr = isString expr\n  token expr (eq after -1 before after)\n  isParens expr\n    expr \\start end contents . parens start end (postProcessMacro start end contents)\n    isCons expr\n      expr \\h t .\n        isToken h\n          cons h (postProcessMacro (+ 1 (+ (tokenPos h) (strLen (tokenString h)))) -1 t)\n          \\\\\n            posStart = position h\n            posEnd = position t\n            t2 = postProcessMacro -1 after t\n            h2 = postProcessMacro before -1 h\n            .\n            eq posStart -1\n              cons (postProcessMacro before (position t2) h) t2\n              cons h2 (postProcessMacro (+ 1 (lexEnd h2)) after t)\n      expr"})((function(){var $m; return function(){return $m || ($m = function(L_before){return function(L_after){return function(L_expr){return L_isString()(L_expr)((function(){var $m; return function(){return $m || ($m = L_token()(L_expr)((function(){var $m; return function(){return $m || ($m = L_eq()(L_after)(function(){return -1})(L_before)(L_after))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_isParens()(L_expr)((function(){var $m; return function(){return $m || ($m = L_expr()((function(){var $m; return function(){return $m || ($m = function(L_start){return function(L_end){return function(L_contents){return L_parens()(L_start)(L_end)((function(){var $m; return function(){return $m || ($m = L_postProcessMacro()(L_start)(L_end)(L_contents))}})())}}})}})()))}})())((function(){var $m; return function(){return $m || ($m = L_isCons()(L_expr)((function(){var $m; return function(){return $m || ($m = L_expr()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_isToken()(L_h)((function(){var $m; return function(){return $m || ($m = L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_postProcessMacro()((function(){var $m; return function(){return $m || ($m = L_$o()(function(){return 1})((function(){var $m; return function(){return $m || ($m = L_$o()((function(){var $m; return function(){return $m || ($m = L_tokenPos()(L_h))}})())((function(){var $m; return function(){return $m || ($m = L_strLen()((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_h))}})()))}})()))}})()))}})())(function(){return -1})(L_t))}})()))}})())(function(){
var L_h2, L_t2, L_posEnd, L_posStart;

L_h2 = (function(){var $m; return function(){return $m || ($m = L_postProcessMacro()(L_before)(function(){return -1})(L_h))}})();

L_t2 = (function(){var $m; return function(){return $m || ($m = L_postProcessMacro()(function(){return -1})(L_after)(L_t))}})();

L_posEnd = (function(){var $m; return function(){return $m || ($m = L_position()(L_t))}})();

L_posStart = (function(){var $m; return function(){return $m || ($m = L_position()(L_h))}})();
return L_eq()(L_posStart)(function(){return -1})((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_postProcessMacro()(L_before)((function(){var $m; return function(){return $m || ($m = L_position()(L_t2))}})())(L_h))}})())(L_t2))}})())((function(){var $m; return function(){return $m || ($m = L_cons()(L_h2)((function(){var $m; return function(){return $m || ($m = L_postProcessMacro()((function(){var $m; return function(){return $m || ($m = L_$o()(function(){return 1})((function(){var $m; return function(){return $m || ($m = L_lexEnd()(L_h2))}})()))}})())(L_after)(L_t))}})()))}})())})}})}})()))}})())(L_expr))}})()))}})())}}})}})())},
  function(){return L_define()(function(){return "defMacro"})(function(){return 2})(function(){return "defMacro name def = bind (getValue 'macroDefs') \\macs . setValue 'macroDefs' (acons name def macs)"})((function(){var $m; return function(){return $m || ($m = function(L_name){return function(L_def){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "macroDefs"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_macs){return L_setValue()(function(){return "macroDefs"})((function(){var $m; return function(){return $m || ($m = L_acons()(L_name)(L_def)(L_macs))}})())})}})())}})}})())},
  function(){return L_define()(function(){return "delimiterListPrefix"})(function(){return 0})(function(){return "delimiterListPrefix = \"\\\"(?:\\\\\\\\.|[^\\\"])*\\\"|'(?:\\\\\\\\.|[^'])*'|\\\\n *|#.*| +\""})(function(){return "\"(?:\\\\.|[^\"])*\"|'(?:\\\\.|[^'])*'|\\n *|#.*| +"})},
  function(){return L_define()(function(){return "regexpEscapePat"})(function(){return 0})(function(){return "regexpEscapePat = regexpFlags '[\\\\-\\\\[\\\\]/\\\\{\\\\}\\\\(\\\\)\\\\*\\\\+\\\\?\\\\.\\\\\\\\\\\\^\\\\$\\\\|]' 'g'"})((function(){var $m; return function(){return $m || ($m = L_regexpFlags()(function(){return "[\\-\\[\\]/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]"})(function(){return "g"}))}})())},
  function(){return L_define()(function(){return "addToken"})(function(){return 1})(function(){return "addToken del = bind (getValue 'tokenList')\n  \\dels . contains dels del\n    false\n    \\\\\n      newDels = insertSorted (\\a b . > (strLen a) (strLen b)) del dels\n      .\n      bind (setValue 'tokenList' newDels)\n        \\_ . computeTokenPat newDels"})((function(){var $m; return function(){return $m || ($m = function(L_del){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "tokenList"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_dels){return L_contains()(L_dels)(L_del)(L_false)(function(){
var L_newDels;

L_newDels = (function(){var $m; return function(){return $m || ($m = L_insertSorted()((function(){var $m; return function(){return $m || ($m = function(L_a){return function(L_b){return L_$z()((function(){var $m; return function(){return $m || ($m = L_strLen()(L_a))}})())((function(){var $m; return function(){return $m || ($m = L_strLen()(L_b))}})())}})}})())(L_del)(L_dels))}})();
return L_bind()((function(){var $m; return function(){return $m || ($m = L_setValue()(function(){return "tokenList"})(L_newDels))}})())((function(){var $m; return function(){return $m || ($m = function(L__){return L_computeTokenPat()(L_newDels)})}})())})})}})())})}})())},
  function(){return L_define()(function(){return "computeTokenPat"})(function(){return 1})(function(){return "computeTokenPat dels = \\\\\n  delPats = map (\\item . strReplace item regexpEscapePat \"\\\\$&\") dels\n  newPat = strCat (cons '(' (cons (join (cons delimiterListPrefix delPats) '|') (cons ')' nil)))\n  .\n  setValue 'tokenPat' newPat"})((function(){var $m; return function(){return $m || ($m = function(L_dels){return (function(){

var L_newPat, L_delPats;

L_newPat = (function(){var $m; return function(){return $m || ($m = L_strCat()((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "("})((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_join()((function(){var $m; return function(){return $m || ($m = L_cons()(L_delimiterListPrefix)(L_delPats))}})())(function(){return "|"}))}})())((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return ")"})(L_nil))}})()))}})()))}})()))}})();

L_delPats = (function(){var $m; return function(){return $m || ($m = L_map()((function(){var $m; return function(){return $m || ($m = function(L_item){return L_strReplace()(L_item)(L_regexpEscapePat)(function(){return "\\$&"})})}})())(L_dels))}})();
return L_setValue()(function(){return "tokenPat"})(L_newPat)})()})}})())},
  function(){return L_define()(function(){return "addTokenGroup"})(function(){return 2})(function(){return "addTokenGroup open close = bind (addToken open)\n  \\_ . bind (addToken close)\n    \\_ . bind (getValue 'tokenGroups')\n      \\gr . setValue 'tokenGroups' (acons open close gr)"})((function(){var $m; return function(){return $m || ($m = function(L_open){return function(L_close){return L_bind()((function(){var $m; return function(){return $m || ($m = L_addToken()(L_open))}})())((function(){var $m; return function(){return $m || ($m = function(L__){return L_bind()((function(){var $m; return function(){return $m || ($m = L_addToken()(L_close))}})())((function(){var $m; return function(){return $m || ($m = function(L___0){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "tokenGroups"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_gr){return L_setValue()(function(){return "tokenGroups"})((function(){var $m; return function(){return $m || ($m = L_acons()(L_open)(L_close)(L_gr))}})())})}})())})}})())})}})())}})}})())},
  function(){return L_define()(function(){return "parse"})(function(){return 2})(function(){return "parse str pat = ifNotErr (parseIndent (token '\\n' 0) (tokens str pat) nil parenGroups) \\list . list \\h t . stripParens h"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pat){return L_ifNotErr()((function(){var $m; return function(){return $m || ($m = L_parseIndent()((function(){var $m; return function(){return $m || ($m = L_token()(function(){return "\n"})(function(){return 0}))}})())((function(){var $m; return function(){return $m || ($m = L_tokens()(L_str)(L_pat))}})())(L_nil)(L_parenGroups))}})())((function(){var $m; return function(){return $m || ($m = function(L_list){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_stripParens()(L_h)}})}})())})}})())}})}})())},
  function(){return L_define()(function(){return "parseG"})(function(){return 3})(function(){return "parseG str pat groups = ifNotErr (parseIndent (token '\\n' 0) (tokens str pat) nil groups) \\list . list \\h t . stripParens h"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pat){return function(L_groups){return L_ifNotErr()((function(){var $m; return function(){return $m || ($m = L_parseIndent()((function(){var $m; return function(){return $m || ($m = L_token()(function(){return "\n"})(function(){return 0}))}})())((function(){var $m; return function(){return $m || ($m = L_tokens()(L_str)(L_pat))}})())(L_nil)(L_groups))}})())((function(){var $m; return function(){return $m || ($m = function(L_list){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_stripParens()(L_h)}})}})())})}})())}}})}})())},
  function(){return L_define()(function(){return "parseToAst"})(function(){return 2})(function(){return "parseToAst str pat = createAst (parse str pat) nil id"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pat){return L_createAst()((function(){var $m; return function(){return $m || ($m = L_parse()(L_str)(L_pat))}})())(L_nil)(L_id)}})}})())},
  function(){return L_define()(function(){return "parseM"})(function(){return 1})(function(){return "parseM str =\n  bind (getValue 'tokenPat')\n    \\tokPat . bind (getValue 'tokenGroups')\n      \\groups . parseG str tokPat groups"})((function(){var $m; return function(){return $m || ($m = function(L_str){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "tokenPat"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_tokPat){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "tokenGroups"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_groups){return L_parseG()(L_str)(L_tokPat)(L_groups)})}})())})}})())})}})())},
  function(){return L_define()(function(){return "scanLine"})(function(){return 4})(function(){return "scanLine str pat onDef onExpr = scanLineG str pat parenGroups onDef onExpr"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pat){return function(L_onDef){return function(L_onExpr){return L_scanLineG()(L_str)(L_pat)(L_parenGroups)(L_onDef)(L_onExpr)}}}})}})())},
  function(){return L_define()(function(){return "parseLine"})(function(){return 5})(function(){return "parseLine str pat names onDef onExpr = parseLineG str pat names parenGroups onDef onExpr"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pat){return function(L_names){return function(L_onDef){return function(L_onExpr){return L_parseLineG()(L_str)(L_pat)(L_names)(L_parenGroups)(L_onDef)(L_onExpr)}}}}})}})())},
  function(){return L_define()(function(){return "parseLineM"})(function(){return 1})(function(){return "parseLineM str = bind (getValue 'tokenPat')\n  \\tokPat . bind (getValue 'tokenGroups')\n    \\groups . parseLineG str tokPat nil groups id id"})((function(){var $m; return function(){return $m || ($m = function(L_str){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "tokenPat"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_tokPat){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "tokenGroups"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_groups){return L_parseLineG()(L_str)(L_tokPat)(L_nil)(L_groups)(L_id)(L_id)})}})())})}})())})}})())},
  function(){return L_define()(function(){return "macroSubM"})(function(){return 1})(function(){return "macroSubM expr =\n  bind (getValue 'macroDefs')\n    \\macs . macroSub macs expr"})((function(){var $m; return function(){return $m || ($m = function(L_expr){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "macroDefs"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_macs){return L_macroSub()(L_macs)(L_expr)})}})())})}})())},
  function(){return L_define()(function(){return "macroParse"})(function(){return 1})(function(){return "macroParse str =\n  bind (parseM str)\n    \\ex . macroSubM ex"})((function(){var $m; return function(){return $m || ($m = function(L_str){return L_bind()((function(){var $m; return function(){return $m || ($m = L_parseM()(L_str))}})())((function(){var $m; return function(){return $m || ($m = function(L_ex){return L_macroSubM()(L_ex)})}})())})}})())},
  function(){return L_define()(function(){return "tokensM"})(function(){return 1})(function(){return "tokensM str =\n  bind (getValue 'tokenPat')\n    \\delimiterPat . tokens str delimiterPat"})((function(){var $m; return function(){return $m || ($m = function(L_str){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "tokenPat"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_delimiterPat){return L_tokens()(L_str)(L_delimiterPat)})}})())})}})())},
  function(){return L_define()(function(){return "parseLines"})(function(){return 2})(function(){return "parseLines lines result = lines\n  \\h t D . bind (parseLineM h)\n    \\ast . parseLines t (cons ast result)\n  reverse result"})((function(){var $m; return function(){return $m || ($m = function(L_lines){return function(L_result){return L_lines()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_bind()((function(){var $m; return function(){return $m || ($m = L_parseLineM()(L_h))}})())((function(){var $m; return function(){return $m || ($m = function(L_ast){return L_parseLines()(L_t)((function(){var $m; return function(){return $m || ($m = L_cons()(L_ast)(L_result))}})())})}})())}}})}})())((function(){var $m; return function(){return $m || ($m = L_reverse()(L_result))}})())}})}})())},
  function(){return L_define()(function(){return "parseFile"})(function(){return 1})(function(){return "parseFile text = parseLines (linesForFile text) nil"})((function(){var $m; return function(){return $m || ($m = function(L_text){return L_parseLines()((function(){var $m; return function(){return $m || ($m = L_linesForFile()(L_text))}})())(L_nil)})}})())},
  function(){return L_define()(function(){return "simpleScanLine"})(function(){return 1})(function(){return "simpleScanLine line = bind (getValue 'tokenPat')\n  \\tokenPat . bind (getValue 'tokenGroups')\n    \\groups . scanLineG line tokenPat groups id id"})((function(){var $m; return function(){return $m || ($m = function(L_line){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "tokenPat"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_tokenPat){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "tokenGroups"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_groups){return L_scanLineG()(L_line)(L_tokenPat)(L_groups)(L_id)(L_id)})}})())})}})())})}})())},
  function(){return L_define()(function(){return "scanLineM"})(function(){return 1})(function(){return "scanLineM line = bind (getValue 'tokenPat')\n  \\tokenPat . bind (getValue 'tokenGroups')\n    \\groups . bind (getValue 'parseFilters')\n      \\filters . bind (getValue 'macroDefs')\n        \\macros . bind (runParseFilters filters (scanLineG line tokenPat groups id id))\n          \\scanned . macroSub macros scanned"})((function(){var $m; return function(){return $m || ($m = function(L_line){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "tokenPat"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_tokenPat){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "tokenGroups"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_groups){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "parseFilters"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_filters){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "macroDefs"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_macros){return L_bind()((function(){var $m; return function(){return $m || ($m = L_runParseFilters()(L_filters)((function(){var $m; return function(){return $m || ($m = L_scanLineG()(L_line)(L_tokenPat)(L_groups)(L_id)(L_id))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_scanned){return L_macroSub()(L_macros)(L_scanned)})}})())})}})())})}})())})}})())})}})())})}})())},
  function(){return L_define()(function(){return "newParseLine"})(function(){return 2})(function(){return "newParseLine names line = bind (scanLineM line)\n  \\scanned . createAst scanned names \\ast . ast"})((function(){var $m; return function(){return $m || ($m = function(L_names){return function(L_line){return L_bind()((function(){var $m; return function(){return $m || ($m = L_scanLineM()(L_line))}})())((function(){var $m; return function(){return $m || ($m = function(L_scanned){return L_createAst()(L_scanned)(L_names)((function(){var $m; return function(){return $m || ($m = function(L_ast){return L_ast()})}})())})}})())}})}})())},
  function(){return L_define()(function(){return "runLine"})(function(){return 2})(function(){return "runLine names line = bind (newParseLine names line)\n  \\ast . bind (runAst ast)\n    \\result . cons\n      ast\n      isParseErr result\n        left (parseErrMsg result)\n        right result"})((function(){var $m; return function(){return $m || ($m = function(L_names){return function(L_line){return L_bind()((function(){var $m; return function(){return $m || ($m = L_newParseLine()(L_names)(L_line))}})())((function(){var $m; return function(){return $m || ($m = function(L_ast){return L_bind()((function(){var $m; return function(){return $m || ($m = L_runAst()(L_ast))}})())((function(){var $m; return function(){return $m || ($m = function(L_result){return L_cons()(L_ast)((function(){var $m; return function(){return $m || ($m = L_isParseErr()(L_result)((function(){var $m; return function(){return $m || ($m = L_left()((function(){var $m; return function(){return $m || ($m = L_parseErrMsg()(L_result))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_right()(L_result))}})()))}})())})}})())})}})())}})}})())},
  function(){return L_define()(function(){return "runLines"})(function(){return 2})(function(){return "runLines names lines = lines\n  \\h t D . bind (runLine names h)\n    \\line . bind (runLines names t)\n      \\rest . cons line rest\n  nil"})((function(){var $m; return function(){return $m || ($m = function(L_names){return function(L_lines){return L_lines()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_bind()((function(){var $m; return function(){return $m || ($m = L_runLine()(L_names)(L_h))}})())((function(){var $m; return function(){return $m || ($m = function(L_line){return L_bind()((function(){var $m; return function(){return $m || ($m = L_runLines()(L_names)(L_t))}})())((function(){var $m; return function(){return $m || ($m = function(L_rest){return L_cons()(L_line)(L_rest)})}})())})}})())}}})}})())(L_nil)}})}})())},
  function(){return L_define()(function(){return "runFile"})(function(){return 1})(function(){return "runFile text = \\\\\n  lines = linesForFile text\n  names = namesForLines lines\n  .\n  runLines names lines"})((function(){var $m; return function(){return $m || ($m = function(L_text){return (function(){

var L_names, L_lines;

L_names = (function(){var $m; return function(){return $m || ($m = L_namesForLines()(L_lines))}})();

L_lines = (function(){var $m; return function(){return $m || ($m = L_linesForFile()(L_text))}})();
return L_runLines()(L_names)(L_lines)})()})}})())},
  function(){return L_define()(function(){return "baseLoad"})(function(){return 1})(function(){return "baseLoad file = bind (readFile file)\n  \\result . result\n    \\err . err\n    \\contents . bind (getValue 'activeTokenPacks')\n      \\activePacks . bind resetStdTokenPacks\n        \\_ . bind (runFile contents)\n          \\result . isNil activePacks\n            bind resetStdTokenPacks\n              \\_ . result\n            bind (resetTokenPacks activePacks)\n                \\_ . result"})((function(){var $m; return function(){return $m || ($m = function(L_file){return L_bind()((function(){var $m; return function(){return $m || ($m = L_readFile()(L_file))}})())((function(){var $m; return function(){return $m || ($m = function(L_result){return L_result()((function(){var $m; return function(){return $m || ($m = function(L_err){return L_err()})}})())((function(){var $m; return function(){return $m || ($m = function(L_contents){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "activeTokenPacks"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_activePacks){return L_bind()(L_resetStdTokenPacks)((function(){var $m; return function(){return $m || ($m = function(L__){return L_bind()((function(){var $m; return function(){return $m || ($m = L_runFile()(L_contents))}})())((function(){var $m; return function(){return $m || ($m = function(L_result_0){return L_isNil()(L_activePacks)((function(){var $m; return function(){return $m || ($m = L_bind()(L_resetStdTokenPacks)((function(){var $m; return function(){return $m || ($m = function(L___1){return L_result_0()})}})()))}})())((function(){var $m; return function(){return $m || ($m = L_bind()((function(){var $m; return function(){return $m || ($m = L_resetTokenPacks()(L_activePacks))}})())((function(){var $m; return function(){return $m || ($m = function(L___1){return L_result_0()})}})()))}})())})}})())})}})())})}})())})}})())})}})())})}})())},
  function(){return L_define()(function(){return "load"})(function(){return 1})(function(){return "load file = bind (baseLoad file)\n  \\result . \\\\\n    errs = foldr (\\line results . tail line (\\er . cons er results) (\\x . results)) nil result\n    .\n    isNil errs\n      right true\n      left errs"})((function(){var $m; return function(){return $m || ($m = function(L_file){return L_bind()((function(){var $m; return function(){return $m || ($m = L_baseLoad()(L_file))}})())((function(){var $m; return function(){return $m || ($m = function(L_result){return (function(){

var L_errs;

L_errs = (function(){var $m; return function(){return $m || ($m = L_foldr()((function(){var $m; return function(){return $m || ($m = function(L_line){return function(L_results){return L_tail()(L_line)((function(){var $m; return function(){return $m || ($m = function(L_er){return L_cons()(L_er)(L_results)})}})())((function(){var $m; return function(){return $m || ($m = function(L_x){return L_results()})}})())}})}})())(L_nil)(L_result))}})();
return L_isNil()(L_errs)((function(){var $m; return function(){return $m || ($m = L_right()(L_true))}})())((function(){var $m; return function(){return $m || ($m = L_left()(L_errs))}})())})()})}})())})}})())},
  function(){return L_define()(function(){return "require"})(function(){return 1})(function(){return "require file = bind (getValue 'requiredFiles')\n  \\files . contains files file\n    false\n    bind (load file)\n      \\result . result\n        \\x . left x\n        \\_ . bind (setValue 'requiredFiles' (cons file files))\n          \\_ . right true"})((function(){var $m; return function(){return $m || ($m = function(L_file){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "requiredFiles"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_files){return L_contains()(L_files)(L_file)(L_false)((function(){var $m; return function(){return $m || ($m = L_bind()((function(){var $m; return function(){return $m || ($m = L_load()(L_file))}})())((function(){var $m; return function(){return $m || ($m = function(L_result){return L_result()((function(){var $m; return function(){return $m || ($m = function(L_x){return L_left()(L_x)})}})())((function(){var $m; return function(){return $m || ($m = function(L__){return L_bind()((function(){var $m; return function(){return $m || ($m = L_setValue()(function(){return "requiredFiles"})((function(){var $m; return function(){return $m || ($m = L_cons()(L_file)(L_files))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L___0){return L_right()(L_true)})}})())})}})())})}})()))}})())})}})())})}})())},
  function(){return L_define()(function(){return "defTokenPack"})(function(){return 2})(function(){return "defTokenPack name pack = bind (getValue 'tokenPacks')\n  \\packs . setValue 'tokenPacks' (acons name pack packs)"})((function(){var $m; return function(){return $m || ($m = function(L_name){return function(L_pack){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "tokenPacks"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_packs){return L_setValue()(function(){return "tokenPacks"})((function(){var $m; return function(){return $m || ($m = L_acons()(L_name)(L_pack)(L_packs))}})())})}})())}})}})())},
  function(){return L_define()(function(){return "useTokenPack"})(function(){return 1})(function(){return "useTokenPack name = bind (getValue 'tokenPacks')\n  \\packs . bind (getValue 'tokenGroups')\n    \\groups . bind (getValue 'tokenList')\n      \\tokens . bind (getValue 'activeTokenPacks')\n        \\activePacks . bind (getValue 'parseFilters')\n          \\filters . assoc name packs\n            \\pack . \\\\\n              groupToks = foldl (\\value el . el \\h t . cons h (cons t value)) nil (head (tail pack))\n              newToks = quicksort (\\a b . > (strLen a) (strLen b)) (append (head pack) (append groupToks tokens))\n              .\n              bind (setValue 'tokenList' newToks)\n                \\_ . bind (setValue 'tokenGroups' (append (head (tail pack)) groups))\n                  \\_ . bind (setValue 'parseFilters' (append filters (head (tail (tail pack)))))\n                    \\_ . bind (computeTokenPat newToks)\n                      \\_ . setValue 'activeTokenPacks' (cons name activePacks)\n            nil"})((function(){var $m; return function(){return $m || ($m = function(L_name){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "tokenPacks"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_packs){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "tokenGroups"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_groups){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "tokenList"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_tokens){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "activeTokenPacks"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_activePacks){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "parseFilters"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_filters){return L_assoc()(L_name)(L_packs)((function(){var $m; return function(){return $m || ($m = function(L_pack){return (function(){

var L_newToks, L_groupToks;

L_newToks = (function(){var $m; return function(){return $m || ($m = L_quicksort()((function(){var $m; return function(){return $m || ($m = function(L_a){return function(L_b){return L_$z()((function(){var $m; return function(){return $m || ($m = L_strLen()(L_a))}})())((function(){var $m; return function(){return $m || ($m = L_strLen()(L_b))}})())}})}})())((function(){var $m; return function(){return $m || ($m = L_append()((function(){var $m; return function(){return $m || ($m = L_head()(L_pack))}})())((function(){var $m; return function(){return $m || ($m = L_append()(L_groupToks)(L_tokens))}})()))}})()))}})();

L_groupToks = (function(){var $m; return function(){return $m || ($m = L_foldl()((function(){var $m; return function(){return $m || ($m = function(L_value){return function(L_el){return L_el()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_cons()(L_t)(L_value))}})())}})}})())}})}})())(L_nil)((function(){var $m; return function(){return $m || ($m = L_head()((function(){var $m; return function(){return $m || ($m = L_tail()(L_pack))}})()))}})()))}})();
return L_bind()((function(){var $m; return function(){return $m || ($m = L_setValue()(function(){return "tokenList"})(L_newToks))}})())((function(){var $m; return function(){return $m || ($m = function(L__){return L_bind()((function(){var $m; return function(){return $m || ($m = L_setValue()(function(){return "tokenGroups"})((function(){var $m; return function(){return $m || ($m = L_append()((function(){var $m; return function(){return $m || ($m = L_head()((function(){var $m; return function(){return $m || ($m = L_tail()(L_pack))}})()))}})())(L_groups))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L___0){return L_bind()((function(){var $m; return function(){return $m || ($m = L_setValue()(function(){return "parseFilters"})((function(){var $m; return function(){return $m || ($m = L_append()(L_filters)((function(){var $m; return function(){return $m || ($m = L_head()((function(){var $m; return function(){return $m || ($m = L_tail()((function(){var $m; return function(){return $m || ($m = L_tail()(L_pack))}})()))}})()))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L___1){return L_bind()((function(){var $m; return function(){return $m || ($m = L_computeTokenPat()(L_newToks))}})())((function(){var $m; return function(){return $m || ($m = function(L___2){return L_setValue()(function(){return "activeTokenPacks"})((function(){var $m; return function(){return $m || ($m = L_cons()(L_name)(L_activePacks))}})())})}})())})}})())})}})())})}})())})()})}})())(L_nil)})}})())})}})())})}})())})}})())})}})())})}})())},
  function(){return L_define()(function(){return "resetTokenPacks"})(function(){return 1})(function(){return "resetTokenPacks packs = bind (setValue 'tokenGroups' nil)\n  \\_ . bind (setValue 'tokenList' nil)\n    \\_ . bind (setValue 'activeTokenPacks' nil)\n      \\_ . bind (setValue 'parseFilters' nil)\n        \\_ . foldr1\n          \\packCmd result . bind packCmd \\_ . result\n          map useTokenPack packs"})((function(){var $m; return function(){return $m || ($m = function(L_packs){return L_bind()((function(){var $m; return function(){return $m || ($m = L_setValue()(function(){return "tokenGroups"})(L_nil))}})())((function(){var $m; return function(){return $m || ($m = function(L__){return L_bind()((function(){var $m; return function(){return $m || ($m = L_setValue()(function(){return "tokenList"})(L_nil))}})())((function(){var $m; return function(){return $m || ($m = function(L___0){return L_bind()((function(){var $m; return function(){return $m || ($m = L_setValue()(function(){return "activeTokenPacks"})(L_nil))}})())((function(){var $m; return function(){return $m || ($m = function(L___1){return L_bind()((function(){var $m; return function(){return $m || ($m = L_setValue()(function(){return "parseFilters"})(L_nil))}})())((function(){var $m; return function(){return $m || ($m = function(L___2){return L_foldr1()((function(){var $m; return function(){return $m || ($m = function(L_packCmd){return function(L_result){return L_bind()(L_packCmd)((function(){var $m; return function(){return $m || ($m = function(L___3){return L_result()})}})())}})}})())((function(){var $m; return function(){return $m || ($m = L_map()(L_useTokenPack)(L_packs))}})())})}})())})}})())})}})())})}})())})}})())},
  function(){return L_define()(function(){return "resetStdTokenPacks"})(function(){return 0})(function(){return "resetStdTokenPacks = bind (getValue 'stdTokenPacks')\n  \\stds . bind (resetTokenPacks stds)\n    \\_ . setValue 'activeTokenPacks' nil"})((function(){var $m; return function(){return $m || ($m = L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "stdTokenPacks"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_stds){return L_bind()((function(){var $m; return function(){return $m || ($m = L_resetTokenPacks()(L_stds))}})())((function(){var $m; return function(){return $m || ($m = function(L__){return L_setValue()(function(){return "activeTokenPacks"})(L_nil)})}})())})}})()))}})())},
  function(){return L_define()(function(){return "addStdTokenPacks"})(function(){return 1})(function(){return "addStdTokenPacks morePacks = bind (getValue 'stdTokenPacks')\n  \\stds . setValue 'stdTokenPacks' (append stds morePacks)"})((function(){var $m; return function(){return $m || ($m = function(L_morePacks){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "stdTokenPacks"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_stds){return L_setValue()(function(){return "stdTokenPacks"})((function(){var $m; return function(){return $m || ($m = L_append()(L_stds)(L_morePacks))}})())})}})())})}})())},
  function(){return L_define()(function(){return "addParseFilter"})(function(){return 1})(function(){return "addParseFilter filt = bind (getValue 'parseFilters')\n  \\filters . setValue 'parseFilters' (append filters (cons filt nil))"})((function(){var $m; return function(){return $m || ($m = function(L_filt){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "parseFilters"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_filters){return L_setValue()(function(){return "parseFilters"})((function(){var $m; return function(){return $m || ($m = L_append()(L_filters)((function(){var $m; return function(){return $m || ($m = L_cons()(L_filt)(L_nil))}})()))}})())})}})())})}})())},
  function(){return L_define()(function(){return "d"})(function(){return 3})(function(){return "d label value expr = log (strCat (cons label (cons value nil))) expr"})((function(){var $m; return function(){return $m || ($m = function(L_label){return function(L_value){return function(L_expr){return L_log()((function(){var $m; return function(){return $m || ($m = L_strCat()((function(){var $m; return function(){return $m || ($m = L_cons()(L_label)((function(){var $m; return function(){return $m || ($m = L_cons()(L_value)(L_nil))}})()))}})()))}})())(L_expr)}}})}})())},
  function(){return L_define()(function(){return "dd"})(function(){return 2})(function(){return "dd label arg = d label arg arg"})((function(){var $m; return function(){return $m || ($m = function(L_label){return function(L_arg){return L_d()(L_label)(L_arg)(L_arg)}})}})())},
  function(){return L_setValue()(function(){return "macroDefs"})(L_nil)},
  function(){return L_setValue()(function(){return "requiredFiles"})(L_nil)},
  function(){return L_setValue()(function(){return "tokenPacks"})(L_nil)},
  function(){return L_setValue()(function(){return "activeTokenPacks"})(L_nil)},
  function(){return L_setValue()(function(){return "stdTokenPacks"})((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "std"})(L_nil))}})())},
  function(){return L_defTokenPack()(function(){return "std"})((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "."})((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "\\"})((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "\\\\"})((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "\\@"})(L_nil))}})()))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_acons()(function(){return "("})(function(){return ")"})(L_nil))}})())((function(){var $m; return function(){return $m || ($m = L_cons()(L_nil)(L_nil))}})()))}})()))}})())},
  function(){return L_resetStdTokenPacks()},
  function(){return L_addTokenGroup()(function(){return "["})(function(){return "]"})},
  function(){return L_addToken()(function(){return "|"})},
  function(){return L_define()(function(){return "listify"})(function(){return 1})(function(){return "listify list = list\n  \\h t D . isTokenString h '|'\n    cons t nil\n    cons (cons 'cons' (cons h (listify t))) nil\n  cons 'nil' nil"})((function(){var $m; return function(){return $m || ($m = function(L_list){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_isTokenString()(L_h)(function(){return "|"})((function(){var $m; return function(){return $m || ($m = L_cons()(L_t)(L_nil))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "cons"})((function(){var $m; return function(){return $m || ($m = L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_listify()(L_t))}})()))}})()))}})())(L_nil))}})())}}})}})())((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "nil"})(L_nil))}})())})}})())},
  function(){return L_defMacro()(function(){return "["})((function(){var $m; return function(){return $m || ($m = function(L_list){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_listify()(L_h)}})}})())})}})())},
  function(){return L_define()(function(){return "listFilter"})(function(){return 1})(function(){return "listFilter code = bind (getValue 'listMacros')\n  \\listMacros . filterApplies code \\list . list \\h t .\n    and (isToken h) (contains listMacros (tokenString h))\n      listFilterTail list\n      list"})((function(){var $m; return function(){return $m || ($m = function(L_code){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "listMacros"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_listMacros){return L_filterApplies()(L_code)((function(){var $m; return function(){return $m || ($m = function(L_list){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_and()((function(){var $m; return function(){return $m || ($m = L_isToken()(L_h))}})())((function(){var $m; return function(){return $m || ($m = L_contains()(L_listMacros)((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_h))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_listFilterTail()(L_list))}})())(L_list)}})}})())})}})())})}})())})}})())},
  function(){return L_define()(function(){return "listFilterTail"})(function(){return 1})(function(){return "listFilterTail list = list\n  \\h t D . isTokenString h '|'\n    > (length t) 2\n      cons h (cons (removeLast t) (cons (last t) nil))\n      list\n    cons h (listFilterTail t)\n  nil"})((function(){var $m; return function(){return $m || ($m = function(L_list){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_isTokenString()(L_h)(function(){return "|"})((function(){var $m; return function(){return $m || ($m = L_$z()((function(){var $m; return function(){return $m || ($m = L_length()(L_t))}})())(function(){return 2})((function(){var $m; return function(){return $m || ($m = L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_removeLast()(L_t))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_last()(L_t))}})())(L_nil))}})()))}})()))}})())(L_list))}})())((function(){var $m; return function(){return $m || ($m = L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_listFilterTail()(L_t))}})()))}})())}}})}})())(L_nil)})}})())},
  function(){return L_define()(function(){return "filterApplies"})(function(){return 2})(function(){return "filterApplies code func = isParens code\n  code \\start end contents . parens start end (filterApplies contents func)\n  isCons code\n    \\\\\n      filtered = filterApplyElements code func\n      .\n      and (isCons filtered) (isBlockStart (head filtered))\n        filtered\n        func filtered\n    code"})((function(){var $m; return function(){return $m || ($m = function(L_code){return function(L_func){return L_isParens()(L_code)((function(){var $m; return function(){return $m || ($m = L_code()((function(){var $m; return function(){return $m || ($m = function(L_start){return function(L_end){return function(L_contents){return L_parens()(L_start)(L_end)((function(){var $m; return function(){return $m || ($m = L_filterApplies()(L_contents)(L_func))}})())}}})}})()))}})())((function(){var $m; return function(){return $m || ($m = L_isCons()(L_code)(function(){
var L_filtered;

L_filtered = (function(){var $m; return function(){return $m || ($m = L_filterApplyElements()(L_code)(L_func))}})();
return L_and()((function(){var $m; return function(){return $m || ($m = L_isCons()(L_filtered))}})())((function(){var $m; return function(){return $m || ($m = L_isBlockStart()((function(){var $m; return function(){return $m || ($m = L_head()(L_filtered))}})()))}})())(L_filtered)((function(){var $m; return function(){return $m || ($m = L_func()(L_filtered))}})())})(L_code))}})())}})}})())},
  function(){return L_define()(function(){return "filterApplyElements"})(function(){return 2})(function(){return "filterApplyElements code func = code\n  \\h t D . isBlockStart h\n    cons h (filterBody t func)\n    cons (filterApplies h func)\n      and (isCons t) (isBlockStart (head t))\n        cons (filterApplyElements t func) nil\n        filterApplyElements t func\n  nil"})((function(){var $m; return function(){return $m || ($m = function(L_code){return function(L_func){return L_code()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_isBlockStart()(L_h)((function(){var $m; return function(){return $m || ($m = L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_filterBody()(L_t)(L_func))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_filterApplies()(L_h)(L_func))}})())((function(){var $m; return function(){return $m || ($m = L_and()((function(){var $m; return function(){return $m || ($m = L_isCons()(L_t))}})())((function(){var $m; return function(){return $m || ($m = L_isBlockStart()((function(){var $m; return function(){return $m || ($m = L_head()(L_t))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_filterApplyElements()(L_t)(L_func))}})())(L_nil))}})())((function(){var $m; return function(){return $m || ($m = L_filterApplyElements()(L_t)(L_func))}})()))}})()))}})())}}})}})())(L_nil)}})}})())},
  function(){return L_define()(function(){return "filterBody"})(function(){return 2})(function(){return "filterBody code func = code \\h t . cons h\n  isTokenString h '.'\n    filterApplies t func\n    filterBody t func"})((function(){var $m; return function(){return $m || ($m = function(L_code){return function(L_func){return L_code()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_isTokenString()(L_h)(function(){return "."})((function(){var $m; return function(){return $m || ($m = L_filterApplies()(L_t)(L_func))}})())((function(){var $m; return function(){return $m || ($m = L_filterBody()(L_t)(L_func))}})()))}})())}})}})())}})}})())},
  function(){return L_setValue()(function(){return "listMacros"})((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "["})(L_nil))}})())},
  function(){return L_addParseFilter()(L_listFilter)},
  function(){return L_defTokenPack()(function(){return "list"})((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "|"})((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "="})(L_nil))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "["})(function(){return "]"}))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "or["})(function(){return "]"}))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "and["})(function(){return "]"}))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "concat["})(function(){return "]"}))}})())(L_nil))}})()))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_cons()(L_listFilter)(L_nil))}})())(L_nil))}})()))}})()))}})())},
  function(){return L_addTokenGroup()(function(){return "or["})(function(){return "]"})},
  function(){return L_addTokenGroup()(function(){return "and["})(function(){return "]"})},
  function(){return L_addTokenGroup()(function(){return "concat["})(function(){return "]"})},
  function(){return L_define()(function(){return "listMacroFoldOp"})(function(){return 3})(function(){return "listMacroFoldOp op emptyCase list = list \\h t . foldr\n    \\case result . [op case result]\n    emptyCase\n    h"})((function(){var $m; return function(){return $m || ($m = function(L_op){return function(L_emptyCase){return function(L_list){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_foldr()((function(){var $m; return function(){return $m || ($m = function(L_case){return function(L_result){return L_cons()(L_op)((function(){var $m; return function(){return $m || ($m = L_cons()(L_case)((function(){var $m; return function(){return $m || ($m = L_cons()(L_result)(L_nil))}})()))}})())}})}})())(L_emptyCase)(L_h)}})}})())}}})}})())},
  function(){return L_defMacro()(function(){return "or["})((function(){var $m; return function(){return $m || ($m = function(L_list){return L_listMacroFoldOp()(function(){return "or"})(function(){return "false"})(L_list)})}})())},
  function(){return L_defMacro()(function(){return "and["})((function(){var $m; return function(){return $m || ($m = function(L_list){return L_listMacroFoldOp()(function(){return "and"})(function(){return "true"})(L_list)})}})())},
  function(){return L_defMacro()(function(){return "concat["})((function(){var $m; return function(){return $m || ($m = function(L_list){return L_cons()(function(){return "strCat"})((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "flatten"})((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_listify()((function(){var $m; return function(){return $m || ($m = L_head()(L_list))}})()))}})())(L_nil))}})())(L_nil))}})()))}})())(L_nil))}})())})}})())},
  function(){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "listMacros"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_lm){return L_cons()(function(){return "concat["})(L_lm)})}})())},
  function(){return L_define()(function(){return "infix"})(function(){return 1})(function(){return "infix code = bind (getValue 'infixPrecedence')\n  \\prec . bind (getValue 'infixRightAssociative')\n    \\right . bind (getValue 'tokenGroups')\n      \\groups . filterApplies\n        code\n        \\expr . infixRearrange prec right (map (\\cell . tail cell) groups) expr"})((function(){var $m; return function(){return $m || ($m = function(L_code){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "infixPrecedence"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_prec){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "infixRightAssociative"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_right){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "tokenGroups"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_groups){return L_filterApplies()(L_code)((function(){var $m; return function(){return $m || ($m = function(L_expr){return L_infixRearrange()(L_prec)(L_right)((function(){var $m; return function(){return $m || ($m = L_map()((function(){var $m; return function(){return $m || ($m = function(L_cell){return L_tail()(L_cell)})}})())(L_groups))}})())(L_expr)})}})())})}})())})}})())})}})())})}})())},
  function(){return L_define()(function(){return "infixRearrange"})(function(){return 4})(function(){return "infixRearrange prec right closes list = \\\\\n  len = length list\n  head1 = head list\n  tail1 = tail list\n  head2 = head tail1\n  tail2 = tail tail1\n  head3 = head tail2\n  opPrec = getPrec prec head2\n  .\n  < len 2\n    list\n    isInfix opPrec head1 head2 len\n      or (== len 2) (not (isInfixArg closes head3))\n        [[head2 head1] | tail2]\n        infixRearrange prec right closes (absorbArgument opPrec prec right closes head1 head2 tail2 head3 (- len 2))\n      [head1 | infixRearrange prec right closes tail1]"})((function(){var $m; return function(){return $m || ($m = function(L_prec){return function(L_right){return function(L_closes){return function(L_list){return (function(){

var L_opPrec, L_head3, L_tail2, L_head2, L_tail1, L_head1, L_len;

L_opPrec = (function(){var $m; return function(){return $m || ($m = L_getPrec()(L_prec)(L_head2))}})();

L_head3 = (function(){var $m; return function(){return $m || ($m = L_head()(L_tail2))}})();

L_tail2 = (function(){var $m; return function(){return $m || ($m = L_tail()(L_tail1))}})();

L_head2 = (function(){var $m; return function(){return $m || ($m = L_head()(L_tail1))}})();

L_tail1 = (function(){var $m; return function(){return $m || ($m = L_tail()(L_list))}})();

L_head1 = (function(){var $m; return function(){return $m || ($m = L_head()(L_list))}})();

L_len = (function(){var $m; return function(){return $m || ($m = L_length()(L_list))}})();
return L_$y()(L_len)(function(){return 2})(L_list)((function(){var $m; return function(){return $m || ($m = L_isInfix()(L_opPrec)(L_head1)(L_head2)(L_len)((function(){var $m; return function(){return $m || ($m = L_or()((function(){var $m; return function(){return $m || ($m = L_$p$p()(L_len)(function(){return 2}))}})())((function(){var $m; return function(){return $m || ($m = L_not()((function(){var $m; return function(){return $m || ($m = L_isInfixArg()(L_closes)(L_head3))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_cons()(L_head2)((function(){var $m; return function(){return $m || ($m = L_cons()(L_head1)(L_nil))}})()))}})())(L_tail2))}})())((function(){var $m; return function(){return $m || ($m = L_infixRearrange()(L_prec)(L_right)(L_closes)((function(){var $m; return function(){return $m || ($m = L_absorbArgument()(L_opPrec)(L_prec)(L_right)(L_closes)(L_head1)(L_head2)(L_tail2)(L_head3)((function(){var $m; return function(){return $m || ($m = L_$_()(L_len)(function(){return 2}))}})()))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cons()(L_head1)((function(){var $m; return function(){return $m || ($m = L_infixRearrange()(L_prec)(L_right)(L_closes)(L_tail1))}})()))}})()))}})())})()}}}})}})())},
  function(){return L_define()(function(){return "absorbArgument"})(function(){return 9})(function(){return "absorbArgument opPrec prec right closes head1 head2 tail2 head3 len = \\\\\n  tail3 = tail tail2\n  head4 = head tail3\n  tail4 = tail tail3\n  head5 = head tail4\n  .\n  infixShouldEatNext opPrec prec (contains right (strTokenString head2)) head3 head4 head5 closes len\n    [head1 head2 | absorbArgument (getPrec prec head4) prec right closes head3 head4 tail4 head5 (- len 2)]\n    [[head2 head1 head3] | tail3]"})((function(){var $m; return function(){return $m || ($m = function(L_opPrec){return function(L_prec){return function(L_right){return function(L_closes){return function(L_head1){return function(L_head2){return function(L_tail2){return function(L_head3){return function(L_len){return (function(){

var L_head5, L_tail4, L_head4, L_tail3;

L_head5 = (function(){var $m; return function(){return $m || ($m = L_head()(L_tail4))}})();

L_tail4 = (function(){var $m; return function(){return $m || ($m = L_tail()(L_tail3))}})();

L_head4 = (function(){var $m; return function(){return $m || ($m = L_head()(L_tail3))}})();

L_tail3 = (function(){var $m; return function(){return $m || ($m = L_tail()(L_tail2))}})();
return L_infixShouldEatNext()(L_opPrec)(L_prec)((function(){var $m; return function(){return $m || ($m = L_contains()(L_right)((function(){var $m; return function(){return $m || ($m = L_strTokenString()(L_head2))}})()))}})())(L_head3)(L_head4)(L_head5)(L_closes)(L_len)((function(){var $m; return function(){return $m || ($m = L_cons()(L_head1)((function(){var $m; return function(){return $m || ($m = L_cons()(L_head2)((function(){var $m; return function(){return $m || ($m = L_absorbArgument()((function(){var $m; return function(){return $m || ($m = L_getPrec()(L_prec)(L_head4))}})())(L_prec)(L_right)(L_closes)(L_head3)(L_head4)(L_tail4)(L_head5)((function(){var $m; return function(){return $m || ($m = L_$_()(L_len)(function(){return 2}))}})()))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_cons()(L_head2)((function(){var $m; return function(){return $m || ($m = L_cons()(L_head1)((function(){var $m; return function(){return $m || ($m = L_cons()(L_head3)(L_nil))}})()))}})()))}})())(L_tail3))}})())})()}}}}}}}}})}})())},
  function(){return L_define()(function(){return "isInfixArg"})(function(){return 2})(function(){return "isInfixArg closes item = or[\n  isParens item\n  isCons item\n  and[\n    isToken item\n    not (contains closes (tokenString item))\n    not (isBlockStart item)]]"})((function(){var $m; return function(){return $m || ($m = function(L_closes){return function(L_item){return L_or()((function(){var $m; return function(){return $m || ($m = L_isParens()(L_item))}})())((function(){var $m; return function(){return $m || ($m = L_or()((function(){var $m; return function(){return $m || ($m = L_isCons()(L_item))}})())((function(){var $m; return function(){return $m || ($m = L_or()((function(){var $m; return function(){return $m || ($m = L_and()((function(){var $m; return function(){return $m || ($m = L_isToken()(L_item))}})())((function(){var $m; return function(){return $m || ($m = L_and()((function(){var $m; return function(){return $m || ($m = L_not()((function(){var $m; return function(){return $m || ($m = L_contains()(L_closes)((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_item))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_and()((function(){var $m; return function(){return $m || ($m = L_not()((function(){var $m; return function(){return $m || ($m = L_isBlockStart()(L_item))}})()))}})())(L_true))}})()))}})()))}})())(L_false))}})()))}})())}})}})())},
  function(){return L_define()(function(){return "isInfix"})(function(){return 4})(function(){return "isInfix opPrec head1 head2 len = and[\n  > len 1\n  > opPrec -1\n  isInfixArg nil head1]"})((function(){var $m; return function(){return $m || ($m = function(L_opPrec){return function(L_head1){return function(L_head2){return function(L_len){return L_and()((function(){var $m; return function(){return $m || ($m = L_$z()(L_len)(function(){return 1}))}})())((function(){var $m; return function(){return $m || ($m = L_and()((function(){var $m; return function(){return $m || ($m = L_$z()(L_opPrec)(function(){return -1}))}})())((function(){var $m; return function(){return $m || ($m = L_and()((function(){var $m; return function(){return $m || ($m = L_isInfixArg()(L_nil)(L_head1))}})())(L_true))}})()))}})())}}}})}})())},
  function(){return L_define()(function(){return "getPrec"})(function(){return 2})(function(){return "getPrec prec token = \\\\\n  str = tokenString token\n  .\n  isToken token\n    findIndex (\\level . contains level str) prec\n    -1"})((function(){var $m; return function(){return $m || ($m = function(L_prec){return function(L_token){return (function(){

var L_str;

L_str = (function(){var $m; return function(){return $m || ($m = L_tokenString()(L_token))}})();
return L_isToken()(L_token)((function(){var $m; return function(){return $m || ($m = L_findIndex()((function(){var $m; return function(){return $m || ($m = function(L_level){return L_contains()(L_level)(L_str)})}})())(L_prec))}})())(function(){return -1})})()}})}})())},
  function(){return L_define()(function(){return "infixShouldEatNext"})(function(){return 8})(function(){return "infixShouldEatNext opPrec prec isRight curArg nextOp nextArg closes len = \\\\\n  nextPrec = getPrec prec nextOp\n  .\n  and[\n    > len 2\n    isInfix nextPrec curArg nextOp len\n    or (> opPrec nextPrec) (and (== opPrec nextPrec) isRight)\n    isInfixArg closes nextArg]"})((function(){var $m; return function(){return $m || ($m = function(L_opPrec){return function(L_prec){return function(L_isRight){return function(L_curArg){return function(L_nextOp){return function(L_nextArg){return function(L_closes){return function(L_len){return (function(){

var L_nextPrec;

L_nextPrec = (function(){var $m; return function(){return $m || ($m = L_getPrec()(L_prec)(L_nextOp))}})();
return L_and()((function(){var $m; return function(){return $m || ($m = L_$z()(L_len)(function(){return 2}))}})())((function(){var $m; return function(){return $m || ($m = L_and()((function(){var $m; return function(){return $m || ($m = L_isInfix()(L_nextPrec)(L_curArg)(L_nextOp)(L_len))}})())((function(){var $m; return function(){return $m || ($m = L_and()((function(){var $m; return function(){return $m || ($m = L_or()((function(){var $m; return function(){return $m || ($m = L_$z()(L_opPrec)(L_nextPrec))}})())((function(){var $m; return function(){return $m || ($m = L_and()((function(){var $m; return function(){return $m || ($m = L_$p$p()(L_opPrec)(L_nextPrec))}})())(L_isRight))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_and()((function(){var $m; return function(){return $m || ($m = L_isInfixArg()(L_closes)(L_nextArg))}})())(L_true))}})()))}})()))}})())})()}}}}}}}})}})())},
  function(){return L_define()(function(){return ":"})(function(){return 2})(function(){return ": x y = cons x y"})((function(){var $m; return function(){return $m || ($m = function(L_x){return function(L_y){return L_cons()(L_x)(L_y)}})}})())},
  function(){return L_define()(function(){return "iprec"})(function(){return 0})(function(){return "iprec = [['*' '/' '%'] ['+' '-'] [':'] ['<' '>' '<=' '>='] ['==' '!=']]"})((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "*"})((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "/"})((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "%"})(L_nil))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "+"})((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "-"})(L_nil))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return ":"})(L_nil))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "<"})((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return ">"})((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "<="})((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return ">="})(L_nil))}})()))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "=="})((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "!="})(L_nil))}})()))}})())(L_nil))}})()))}})()))}})()))}})()))}})())},
  function(){return L_define()(function(){return "rightAssoc"})(function(){return 0})(function(){return "rightAssoc = [':']"})((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return ":"})(L_nil))}})())},
  function(){return L_setValue()(function(){return "infixPrecedence"})(L_iprec)},
  function(){return L_setValue()(function(){return "infixRightAssociative"})(L_rightAssoc)},
  function(){return L_defTokenPack()(function(){return "infix"})((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_flatten()(L_iprec))}})())((function(){var $m; return function(){return $m || ($m = L_cons()(L_nil)((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_cons()(L_infix)(L_nil))}})())(L_nil))}})()))}})()))}})())},
  function(){return L_useTokenPack()(function(){return "infix"})},
  function(){return L_defMacro()(function(){return "do"})((function(){var $m; return function(){return $m || ($m = function(L_list){return L_handleDo()(L_list)(L_false)(L_id)})}})())},
  function(){return L_define()(function(){return "handleDo"})(function(){return 3})(function(){return "handleDo list inLet cont = list\n  \\h t D . isNil t\n    cont (inLet ['.' h] [h])\n    doClause (stripParens h) h nil inLet \\newInLet chain .\n      handleDo t newInLet \\rest . cont (chain rest)\n  cont nil"})((function(){var $m; return function(){return $m || ($m = function(L_list){return function(L_inLet){return function(L_cont){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_isNil()(L_t)((function(){var $m; return function(){return $m || ($m = L_cont()((function(){var $m; return function(){return $m || ($m = L_inLet()((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "."})((function(){var $m; return function(){return $m || ($m = L_cons()(L_h)(L_nil))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cons()(L_h)(L_nil))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_doClause()((function(){var $m; return function(){return $m || ($m = L_stripParens()(L_h))}})())(L_h)(L_nil)(L_inLet)((function(){var $m; return function(){return $m || ($m = function(L_newInLet){return function(L_chain){return L_handleDo()(L_t)(L_newInLet)((function(){var $m; return function(){return $m || ($m = function(L_rest){return L_cont()((function(){var $m; return function(){return $m || ($m = L_chain()(L_rest))}})())})}})())}})}})()))}})())}}})}})())((function(){var $m; return function(){return $m || ($m = L_cont()(L_nil))}})())}}})}})())},
  function(){return L_define()(function(){return "doClause"})(function(){return 5})(function(){return "doClause steppingClause clause prefix inLet cont = \\\\\n  makeBind var monad = cont false \\rest . inLet (cons '.') id\n    ['bind' monad ['\\\\' var '.' | rest]]\n  .\n  isCons steppingClause\n    steppingClause \\h t . isTokenString h '='\n      inLet\n        cont true \\rest . [clause | rest]\n        cont true \\rest . ['\\\\\\\\' clause | rest]\n      isTokenString h '<-'\n        isNil t\n          parseErr \"No monad in do-clause: \" clause\n          prefix\n            \\ph pt D . isNil pt\n              makeBind (isNil prefix '_' (head prefix)) t\n              parseErr \"More than one variable in do-clause: \" clause\n            makeBind '_' t\n        doClause t clause [h | prefix] inLet cont\n    makeBind '_' clause"})((function(){var $m; return function(){return $m || ($m = function(L_steppingClause){return function(L_clause){return function(L_prefix){return function(L_inLet){return function(L_cont){return (function(){

var L_makeBind;

L_makeBind = (function(){var $m; return function(){return $m || ($m = function(L_var){return function(L_monad){return L_cont()(L_false)((function(){var $m; return function(){return $m || ($m = function(L_rest){return L_inLet()((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "."}))}})())(L_id)((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "bind"})((function(){var $m; return function(){return $m || ($m = L_cons()(L_monad)((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "\\"})((function(){var $m; return function(){return $m || ($m = L_cons()(L_var)((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "."})(L_rest))}})()))}})()))}})())(L_nil))}})()))}})()))}})())})}})())}})}})();
return L_isCons()(L_steppingClause)((function(){var $m; return function(){return $m || ($m = L_steppingClause()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_isTokenString()(L_h)(function(){return "="})((function(){var $m; return function(){return $m || ($m = L_inLet()((function(){var $m; return function(){return $m || ($m = L_cont()(L_true)((function(){var $m; return function(){return $m || ($m = function(L_rest){return L_cons()(L_clause)(L_rest)})}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cont()(L_true)((function(){var $m; return function(){return $m || ($m = function(L_rest){return L_cons()(function(){return "\\\\"})((function(){var $m; return function(){return $m || ($m = L_cons()(L_clause)(L_rest))}})())})}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_isTokenString()(L_h)(function(){return "<-"})((function(){var $m; return function(){return $m || ($m = L_isNil()(L_t)((function(){var $m; return function(){return $m || ($m = L_parseErr()(function(){return "No monad in do-clause: "})(L_clause))}})())((function(){var $m; return function(){return $m || ($m = L_prefix()((function(){var $m; return function(){return $m || ($m = function(L_ph){return function(L_pt){return function(L_D){return L_isNil()(L_pt)((function(){var $m; return function(){return $m || ($m = L_makeBind()((function(){var $m; return function(){return $m || ($m = L_isNil()(L_prefix)(function(){return "_"})((function(){var $m; return function(){return $m || ($m = L_head()(L_prefix))}})()))}})())(L_t))}})())((function(){var $m; return function(){return $m || ($m = L_parseErr()(function(){return "More than one variable in do-clause: "})(L_clause))}})())}}})}})())((function(){var $m; return function(){return $m || ($m = L_makeBind()(function(){return "_"})(L_t))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_doClause()(L_t)(L_clause)((function(){var $m; return function(){return $m || ($m = L_cons()(L_h)(L_prefix))}})())(L_inLet)(L_cont))}})()))}})())}})}})()))}})())((function(){var $m; return function(){return $m || ($m = L_makeBind()(function(){return "_"})(L_clause))}})())})()}}}}})}})())},
  function(){return L_defTokenPack()(function(){return "do"})((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "<-"})(L_nil))}})())((function(){var $m; return function(){return $m || ($m = L_cons()(L_nil)((function(){var $m; return function(){return $m || ($m = L_cons()(L_nil)(L_nil))}})()))}})()))}})())},
  function(){return L_addStdTokenPacks()((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "list"})((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "infix"})((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "do"})(L_nil))}})()))}})()))}})())},
  function(){return L_resetStdTokenPacks()}]);

},{}],6:[function(require,module,exports){
(function(global){/*!
 Lo-Dash 0.7.0 lodash.com/license
 Underscore.js 1.3.3 github.com/documentcloud/underscore/blob/master/LICENSE
*/
;(function(e,t){function s(e){return new o(e)}function o(e){if(e&&e.__wrapped__)return e;this.__wrapped__=e}function u(e,t){return function(n,r,i){return e.call(t,n,r,i)}}function a(e,t,n){t||(t=0);var r=e.length,i=r-t>=(n||W),s=i?{}:e;if(i)for(var o=t-1;++o<r;)n=e[o]+"",(at.call(s,n)?s[n]:s[n]=[]).push(e[o]);return function(e){if(i){var n=e+"";return at.call(s,n)&&-1<L(s[n],e)}return-1<L(s,e,t)}}function f(e,n){var r=e.b,i=n.b,e=e.a,n=n.a;if(e!==n){if(e>n||e===t)return 1;if(e<n||n===t)return-1}return r<
i?-1:1}function l(e,t,n){function r(){var u=arguments,a=s?this:t;return i||(e=t[o]),n.length&&(u=u.length?n.concat(ct.call(u)):n),this instanceof r?(v.prototype=e.prototype,a=new v,(u=e.apply(a,u))&&$t[typeof u]?u:a):e.apply(a,u)}var i=E(e),s=!n,o=e;return s&&(n=t),r}function c(){for(var e,t,n,s=-1,o=arguments.length,a={e:"",f:"",j:"",q:"",c:{d:""},m:{d:""}};++s<o;)for(t in e=arguments[s],e)n=(n=e[t])==r?"":n,/d|i/.test(t)?("string"==typeof n&&(n={b:n,l:n}),a.c[t]=n.b||"",a.m[t]=n.l||""):a[t]=n;e=
a.a,t=/^[^,]+/.exec(e)[0],n=a.s,a.g=t,a.h=Mt,a.k=Rt,a.n=Pt,a.p=rt,a.r=a.r!==i,a.s=n==r?Ut:n,a.o==r&&(a.o=jt),a.f||(a.f="if(!"+t+")return u");if("e"!=t||!a.c.i)a.c=r;t="",a.s&&(t+="'use strict';"),t+="var j,A,k="+a.g+",u",a.j&&(t+="="+a.j),t+=";"+a.f+";"+a.q+";",a.c&&(t+="var l=k.length;j=-1;",a.m&&(t+="if(l===+l){"),a.o&&(t+="if(z.call(k)==x){k=k.split('')}"),t+=a.c.d+";while(++j<l){A=k[j];"+a.c.i+"}",a.m&&(t+="}"));if(a.m){a.c?t+="else{":a.n&&(t+="var l=k.length;j=-1;if(l&&O(k)){while(++j<l){A=k[j+=''];"+
a.m.i+"}}else{"),a.h||(t+="var v=typeof k=='function'&&r.call(k,'prototype');");if(a.k&&a.r)t+="var o=-1,p=X[typeof k]?m(k):[],l=p.length;"+a.m.d+";while(++o<l){j=p[o];",a.h||(t+="if(!(v&&j=='prototype')){"),t+="A=k[j];"+a.m.i+"",a.h||(t+="}");else{t+=a.m.d+";for(j in k){";if(!a.h||a.r)t+="if(",a.h||(t+="!(v&&j=='prototype')"),!a.h&&a.r&&(t+="&&"),a.r&&(t+="h.call(k,j)"),t+="){";t+="A=k[j];"+a.m.i+";";if(!a.h||a.r)t+="}"}t+="}";if(a.h){t+="var g=k.constructor;";for(n=0;7>n;n++)t+="j='"+a.p[n]+"';if("
,"constructor"==a.p[n]&&(t+="!(g&&g.prototype===k)&&"),t+="h.call(k,j)){A=k[j];"+a.m.i+"}"}if(a.c||a.n)t+="}"}return t+=a.e+";return u",Function("D,E,F,c,I,f,J,h,i,M,O,Q,S,T,W,X,m,r,w,x,z","var G=function("+e+"){"+t+"};return G")(zt,R,D,u,f,ut,ln,at,P,L,w,sn,E,on,Ct,$t,gt,lt,ct,Lt,ht)}function h(e,t){return ot[t]}function p(e){return"\\"+Jt[e]}function d(e){return Xt[e]}function v(){}function m(e,t){if(e&&V.test(t))return"<e%-"+t+"%>";var n=ot.length;return ot[n]="'+__e("+t+")+'",it+n+st}function g
(e,t,n,i){return i?(e=ot.length,ot[e]="';"+i+";__p+='",it+e+st):t?m(r,t):y(r,n)}function y(e,t){if(e&&V.test(t))return"<e%="+t+"%>";var n=ot.length;return ot[n]="'+((__t=("+t+"))==null?'':__t)+'",it+n+st}function b(e){return Vt[e]}function w(e){return ht.call(e)==Et}function E(e){return"function"==typeof e}function S(e,t){var n=i;if(!e||"object"!=typeof e||!t&&w(e))return n;var r=e.constructor;return(!Ft||"function"==typeof e.toString||"string"!=typeof (e+""))&&(!E(r)||r instanceof r)?Dt?(ln(e,function(
e,t,r){return n=!at.call(r,t),i}),n===i):(ln(e,function(e,t){n=t}),n===i||at.call(e,n)):n}function x(e,t,s,o,u){if(e==r)return e;s&&(t=i);if(s=$t[typeof e]){var a=ht.call(e);if(!Wt[a]||Ht&&w(e))return e;var f=a==St,s=f||(a==Ct?on(e,n):s)}if(!s||!t)return s?f?ct.call(e):fn({},e):e;s=e.constructor;switch(a){case xt:return new s(e==n);case Tt:return new s(+e);case Nt:case Lt:return new s(e);case kt:return s(e.source,G.exec(e))}o||(o=[]),u||(u=[]);for(a=o.length;a--;)if(o[a]==e)return u[a];var l=f?s(
a=e.length):{};o.push(e),u.push(l);if(f)for(f=-1;++f<a;)l[f]=x(e[f],t,r,o,u);else cn(e,function(e,n){l[n]=x(e,t,r,o,u)});return l}function T(e,t,s,o){if(e==r||t==r)return e===t;if(e===t)return 0!==e||1/e==1/t;if($t[typeof e]||$t[typeof t])e=e.__wrapped__||e,t=t.__wrapped__||t;var u=ht.call(e);if(u!=ht.call(t))return i;switch(u){case xt:case Tt:return+e==+t;case Nt:return e!=+e?t!=+t:0==e?1/e==1/t:e==+t;case kt:case Lt:return e==t+""}var a=zt[u];if(Ht&&!a&&(a=w(e))&&!w(t)||!a&&(u!=Ct||Ft&&("function"!=typeof 
e.toString&&"string"==typeof (e+"")||"function"!=typeof t.toString&&"string"==typeof (t+""))))return i;s||(s=[]),o||(o=[]);for(u=s.length;u--;)if(s[u]==e)return o[u]==t;var u=-1,f=n,l=0;s.push(e),o.push(t);if(a){l=e.length;if(f=l==t.length)for(;l--&&(f=T(e[l],t[l],s,o)););return f}a=e.constructor,f=t.constructor;if(a!=f&&(!E(a)||!(a instanceof a&&E(f)&&f instanceof f)))return i;for(var c in e)if(at.call(e,c)&&(l++,!at.call(t,c)||!T(e[c],t[c],s,o)))return i;for(c in t)if(at.call(t,c)&&!(l--))return i
;if(Mt)for(;7>++u;)if(c=rt[u],at.call(e,c)&&(!at.call(t,c)||!T(e[c],t[c],s,o)))return i;return n}function N(e,t,n,r){if(!e)return n;var i=e.length,s=3>arguments.length;r&&(t=u(t,r));if(i===+i){var o=jt&&ht.call(e)==Lt?e.split(""):e;for(i&&s&&(n=o[--i]);i--;)n=t(n,o[i],i,e);return n}o=vn(e);for((i=o.length)&&s&&(n=e[o[--i]]);i--;)s=o[i],n=t(n,e[s],s,e);return n}function C(e,t,n){if(e)return t==r||n?e[0]:ct.call(e,0,t)}function k(e,t){var n=[];if(!e)return n;for(var r,i=-1,s=e.length;++i<s;)r=e[i],
sn(r)?ft.apply(n,t?r:k(r)):n.push(r);return n}function L(e,t,n){if(!e)return-1;var r=-1,i=e.length;if(n){if("number"!=typeof n)return r=M(e,t),e[r]===t?r:-1;r=(0>n?yt(0,i+n):n)-1}for(;++r<i;)if(e[r]===t)return r;return-1}function A(e,t,n){var r=-Infinity,i=r;if(!e)return i;var s=-1,o=e.length;if(!t){for(;++s<o;)e[s]>i&&(i=e[s]);return i}for(n&&(t=u(t,n));++s<o;)n=t(e[s],s,e),n>r&&(r=n,i=e[s]);return i}function O(e,t,n){return e?ct.call(e,t==r||n?1:t):[]}function M(e,t,n,r){if(!e)return 0;var i=0,
s=e.length;if(n){r&&(n=D(n,r));for(t=n(t);i<s;)r=i+s>>>1,n(e[r])<t?i=r+1:s=r}else for(;i<s;)r=i+s>>>1,e[r]<t?i=r+1:s=r;return i}function _(e,t,n,r){var s=[];if(!e)return s;var o=-1,a=e.length,f=[];"function"==typeof t&&(r=n,n=t,t=i);for(n?r&&(n=u(n,r)):n=P;++o<a;)if(r=n(e[o],o,e),t?!o||f[f.length-1]!==r:0>L(f,r))f.push(r),s.push(e[o]);return s}function D(e,t){return qt||pt&&2<arguments.length?pt.call.apply(pt,arguments):l(e,t,ct.call(arguments,2))}function P(e){return e}function H(e){Cn(hn(e),function(
t){var r=s[t]=e[t];o.prototype[t]=function(){var e=[this.__wrapped__];return arguments.length&&ft.apply(e,arguments),e=r.apply(s,e),this.__chain__&&(e=new o(e),e.__chain__=n),e}})}var n=!0,r=null,i=!1,B,j,F,I,q="object"==typeof exports&&exports&&("object"==typeof global&&global&&global==global.global&&(e=global),exports),R=Array.prototype,U=Object.prototype,z=0,W=30,X=e._,V=/[-?+=!~*%&^<>|{(\/]|\[\D|\b(?:delete|in|instanceof|new|typeof|void)\b/,$=/&(?:amp|lt|gt|quot|#x27);/g,J=/\b__p\+='';/g,K=/\b(__p\+=)''\+/g
,Q=/(__e\(.*?\)|\b__t\))\+'';/g,G=/\w*$/,Y=/(?:__e|__t=)\(\s*(?![\d\s"']|this\.)/g,Z=RegExp("^"+(U.valueOf+"").replace(/[.*+?^=!:${}()|[\]\/\\]/g,"\\$&").replace(/valueOf|for [^\]]+/g,".+?")+"$"),et=/__token(\d+)__/g,tt=/[&<>"']/g,nt=/['\n\r\t\u2028\u2029\\]/g,rt="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" "),it="__token",st="__",ot=[],ut=R.concat,at=U.hasOwnProperty,ft=R.push,lt=U.propertyIsEnumerable,ct=R.slice,ht=U.toString,pt=Z.test(
pt=ct.bind)&&pt,dt=Math.floor,vt=Z.test(vt=Array.isArray)&&vt,mt=e.isFinite,gt=Z.test(gt=Object.keys)&&gt,yt=Math.max,bt=Math.min,wt=Math.random,Et="[object Arguments]",St="[object Array]",xt="[object Boolean]",Tt="[object Date]",Nt="[object Number]",Ct="[object Object]",kt="[object RegExp]",Lt="[object String]",At=e.clearTimeout,Ot=e.setTimeout,Mt,_t,Dt,Pt=n;(function(){function e(){this.x=1}var t={0:1,length:1},n=[];e.prototype={valueOf:1,y:1};for(var r in new e)n.push(r);for(r in arguments)Pt=!r;Mt=4>
(n+"").length,Dt="x"!=n[0],_t=(n.splice.call(t,0,1),t[0])})(1);var Ht=!w(arguments),Bt="x"!=ct.call("x")[0],jt="xx"!="x"[0]+Object("x")[0];try{var Ft=("[object Object]",ht.call(e.document||0)==Ct)}catch(It){}var qt=pt&&/\n|Opera/.test(pt+ht.call(e.opera)),Rt=gt&&/^.+$|true/.test(gt+!!e.attachEvent),Ut=!qt,zt={};zt[xt]=zt[Tt]=zt["[object Function]"]=zt[Nt]=zt[Ct]=zt[kt]=i,zt[Et]=zt[St]=zt[Lt]=n;var Wt={};Wt[Et]=Wt["[object Function]"]=i,Wt[St]=Wt[xt]=Wt[Tt]=Wt[Nt]=Wt[Ct]=Wt[kt]=Wt[Lt]=n;var Xt={"&"
:"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;"},Vt={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#x27;":"'"},$t={"boolean":i,"function":n,object:n,number:i,string:i,"undefined":i,unknown:n},Jt={"\\":"\\","'":"'","\n":"n","\r":"r","	":"t","\u2028":"u2028","\u2029":"u2029"};s.templateSettings={escape:/<%-([\s\S]+?)%>/g,evaluate:/<%([\s\S]+?)%>/g,interpolate:/<%=([\s\S]+?)%>/g,variable:""};var Kt={a:"e,d,y",j:"e",q:"if(!d)d=i;else if(y)d=c(d,y)",i:"if(d(A,j,e)===false)return u"},Qt={j:"{}"
,q:"var q;if(typeof d!='function'){var hh=d;d=function(A){return A[hh]}}else if(y)d=c(d,y)",i:"q=d(A,j,e);(h.call(u,q)?u[q]++:u[q]=1)"},Gt={j:"true",i:"if(!d(A,j,e))return!u"},Yt={r:i,s:i,a:"n",j:"n",q:"for(var a=1,b=arguments.length;a<b;a++){if(k=arguments[a]){",i:"u[j]=A",e:"}}"},Zt={j:"[]",i:"d(A,j,e)&&u.push(A)"},en={q:"if(y)d=c(d,y)"},tn={i:{l:Kt.i}},nn={j:"",f:"if(!e)return[]",d:{b:"u=Array(l)",l:"u="+(Rt?"Array(l)":"[]")},i:{b:"u[j]=d(A,j,e)",l:"u"+(Rt?"[o]=":".push")+"(d(A,j,e))"}},rn={r:
i,a:"n,d,y",j:"{}",q:"var R=typeof d=='function';if(!R){var t=f.apply(E,arguments)}else if(y)d=c(d,y)",i:"if(R?!d(A,j,n):M(t,j)<0)u[j]=A"};Ht&&(w=function(e){return!!e&&!!at.call(e,"callee")});var sn=vt||function(e){return ht.call(e)==St};E(/x/)&&(E=function(e){return"[object Function]"==ht.call(e)});var on=$t.__proto__!=U?S:function(e,t){if(!e)return i;var n=e.valueOf,r="function"==typeof n&&(r=n.__proto__)&&r.__proto__;return r?e==r||e.__proto__==r&&(t||!w(e)):S(e)},un=c({a:"n",j:"[]",i:"u.push(j)"
}),an=c(Yt,{i:"if(u[j]==null)"+Yt.i}),fn=c(Yt),ln=c(Kt,en,tn,{r:i}),cn=c(Kt,en,tn),hn=c({r:i,a:"n",j:"[]",i:"if(S(A))u.push(j)",e:"u.sort()"}),pn=c({a:"n",j:"{}",i:"u[A]=j"}),dn=c({a:"A",j:"true",q:"var H=z.call(A),l=A.length;if(D[H]"+(Ht?"||O(A)":"")+"||(H==W&&l===+l&&S(A.splice)))return!l",i:{l:"return false"}}),vn=gt?function(e){var t=typeof e;return"function"==t&&lt.call(e,"prototype")?un(e):e&&$t[t]?gt(e):[]}:un,mn=c(Yt,{a:"n,cc,N",q:"var b,P,dd,ee,C=arguments,a=0;if(N==T){b=2;dd=C[3];ee=C[4]}else{b=C.length;dd=[];ee=[]}while(++a<b){if(k=C[a]){"
,i:"if((cc=A)&&((P=Q(cc))||T(cc))){var K=false,ff=dd.length;while(ff--)if(K=dd[ff]==cc)break;if(K){u[j]=ee[ff]}else{dd.push(cc);ee.push(A=(A=u[j])&&P?(Q(A)?A:[]):(T(A)?A:{}));u[j]=G(A,cc,T,dd,ee)}}else if(cc!=null)u[j]=cc"}),gn=c(rn),yn=c({a:"n",j:"[]",i:"u"+(Rt?"[o]=":".push")+"([j,A])"}),bn=c(rn,{q:"if(typeof d!='function'){var q,t=f.apply(E,arguments),l=t.length;for(j=1;j<l;j++){q=t[j];if(q in n)u[q]=n[q]}}else{if(y)d=c(d,y)",i:"if(d(A,j,n))u[j]=A",e:"}"}),wn=c({a:"n",j:"[]",i:"u.push(A)"}),En=
c({a:"e,gg",j:"false",o:i,d:{b:"if(z.call(e)==x)return e.indexOf(gg)>-1"},i:"if(A===gg)return true"}),Sn=c(Kt,Qt),xn=c(Kt,Gt),Tn=c(Kt,Zt),Nn=c(Kt,en,{j:"",i:"if(d(A,j,e))return A"}),Cn=c(Kt,en),kn=c(Kt,Qt,{i:"q=d(A,j,e);(h.call(u,q)?u[q]:u[q]=[]).push(A)"}),Ln=c(nn,{a:"e,U",q:"var C=w.call(arguments,2),R=typeof U=='function'",i:{b:"u[j]=(R?U:A[U]).apply(A,C)",l:"u"+(Rt?"[o]=":".push")+"((R?U:A[U]).apply(A,C))"}}),An=c(Kt,nn),On=c(nn,{a:"e,aa",i:{b:"u[j]=A[aa]",l:"u"+(Rt?"[o]=":".push")+"(A[aa])"}
}),Mn=c({a:"e,d,B,y",j:"B",q:"var V=arguments.length<3;if(y)d=c(d,y)",d:{b:"if(V)u=k[++j]"},i:{b:"u=d(u,A,j,e)",l:"u=V?(V=false,A):d(u,A,j,e)"}}),_n=c(Kt,Zt,{i:"!"+Zt.i}),Dn=c(Kt,Gt,{j:"false",i:Gt.i.replace("!","")}),Pn=c(Kt,Qt,nn,{i:{b:"u[j]={a:d(A,j,e),b:j,c:A}",l:"u"+(Rt?"[o]=":".push")+"({a:d(A,j,e),b:j,c:A})"},e:"u.sort(I);l=u.length;while(l--)u[l]=u[l].c"}),Hn=c(Zt,{a:"e,Z",q:"var t=[];J(Z,function(A,q){t.push(q)});var bb=t.length",i:"for(var q,Y=true,s=0;s<bb;s++){q=t[s];if(!(Y=A[q]===Z[q]))break}Y&&u.push(A)"
}),Bn=c({r:i,s:i,a:"n",j:"n",q:"var L=arguments,l=L.length;if(l>1){for(var j=1;j<l;j++)u[L[j]]=F(u[L[j]],u);return u}",i:"if(S(u[j]))u[j]=F(u[j],u)"});s.VERSION="0.7.0",s.after=function(e,t){return 1>e?t():function(){if(1>--e)return t.apply(this,arguments)}},s.bind=D,s.bindAll=Bn,s.chain=function(e){return e=new o(e),e.__chain__=n,e},s.clone=x,s.compact=function(e){var t=[];if(!e)return t;for(var n=-1,r=e.length;++n<r;)e[n]&&t.push(e[n]);return t},s.compose=function(){var e=arguments;return function(
){for(var t=arguments,n=e.length;n--;)t=[e[n].apply(this,t)];return t[0]}},s.contains=En,s.countBy=Sn,s.debounce=function(e,t,n){function i(){a=r,n||(o=e.apply(u,s))}var s,o,u,a;return function(){var r=n&&!a;return s=arguments,u=this,At(a),a=Ot(i,t),r&&(o=e.apply(u,s)),o}},s.defaults=an,s.defer=function(e){var n=ct.call(arguments,1);return Ot(function(){return e.apply(t,n)},1)},s.delay=function(e,n){var r=ct.call(arguments,2);return Ot(function(){return e.apply(t,r)},n)},s.difference=function(e){
var t=[];if(!e)return t;for(var n=-1,r=e.length,i=ut.apply(t,arguments),i=a(i,r);++n<r;)i(e[n])||t.push(e[n]);return t},s.escape=function(e){return e==r?"":(e+"").replace(tt,d)},s.every=xn,s.extend=fn,s.filter=Tn,s.find=Nn,s.first=C,s.flatten=k,s.forEach=Cn,s.forIn=ln,s.forOwn=cn,s.functions=hn,s.groupBy=kn,s.has=function(e,t){return e?at.call(e,t):i},s.identity=P,s.indexOf=L,s.initial=function(e,t,n){return e?ct.call(e,0,-(t==r||n?1:t)):[]},s.intersection=function(e){var t=[];if(!e)return t;var n
,r=arguments.length,i=[],s=-1,o=e.length;e:for(;++s<o;)if(n=e[s],0>L(t,n)){for(var u=1;u<r;u++)if(!(i[u]||(i[u]=a(arguments[u])))(n))continue e;t.push(n)}return t},s.invert=pn,s.invoke=Ln,s.isArguments=w,s.isArray=sn,s.isBoolean=function(e){return e===n||e===i||ht.call(e)==xt},s.isElement=function(e){return e?1===e.nodeType:i},s.isEmpty=dn,s.isEqual=T,s.isFinite=function(e){return mt(e)&&ht.call(e)==Nt},s.isFunction=E,s.isNaN=function(e){return ht.call(e)==Nt&&e!=+e},s.isNull=function(e){return e===
r},s.isObject=function(e){return e?$t[typeof e]:i},s.isUndefined=function(e){return e===t},s.keys=vn,s.last=function(e,t,n){if(e){var i=e.length;return t==r||n?e[i-1]:ct.call(e,-t||i)}},s.lastIndexOf=function(e,t,n){if(!e)return-1;var r=e.length;for(n&&"number"==typeof n&&(r=(0>n?yt(0,r+n):bt(n,r-1))+1);r--;)if(e[r]===t)return r;return-1},s.lateBind=function(e,t){return l(t,e,ct.call(arguments,2))},s.map=An,s.max=A,s.memoize=function(e,t){var n={};return function(){var r=t?t.apply(this,arguments)
:arguments[0];return at.call(n,r)?n[r]:n[r]=e.apply(this,arguments)}},s.merge=mn,s.min=function(e,t,n){var r=Infinity,i=r;if(!e)return i;var s=-1,o=e.length;if(!t){for(;++s<o;)e[s]<i&&(i=e[s]);return i}for(n&&(t=u(t,n));++s<o;)n=t(e[s],s,e),n<r&&(r=n,i=e[s]);return i},s.mixin=H,s.noConflict=function(){return e._=X,this},s.object=function(e,t){if(!e)return{};for(var n=-1,r=e.length,i={};++n<r;)t?i[e[n]]=t[n]:i[e[n][0]]=e[n][1];return i},s.omit=gn,s.once=function(e){var t,s=i;return function(){return s?
t:(s=n,t=e.apply(this,arguments),e=r,t)}},s.pairs=yn,s.partial=function(e){return l(e,ct.call(arguments,1))},s.pick=bn,s.pluck=On,s.random=function(e,t){return e==r&&t==r?wt():(e=+e||0,t==r&&(t=e,e=0),e+dt(wt()*((+t||0)-e+1)))},s.range=function(e,t,n){e=+e||0,n=+n||1,t==r&&(t=e,e=0);for(var i=-1,t=yt(0,Math.ceil((t-e)/n)),s=Array(t);++i<t;)s[i]=e,e+=n;return s},s.reduce=Mn,s.reduceRight=N,s.reject=_n,s.rest=O,s.result=function(e,t){if(!e)return r;var n=e[t];return E(n)?e[t]():n},s.shuffle=function(
e){if(!e)return[];for(var t,n=-1,r=e.length,i=Array(r);++n<r;)t=dt(wt()*(n+1)),i[n]=i[t],i[t]=e[n];return i},s.size=function(e){if(!e)return 0;var t=e.length;return t===+t?t:vn(e).length},s.some=Dn,s.sortBy=Pn,s.sortedIndex=M,s.tap=function(e,t){return t(e),e},s.template=function(e,t,n){n||(n={});var e=e+"",o,u;o=n.escape;var a=n.evaluate,f=n.interpolate,l=s.templateSettings,c=n=n.variable||l.variable;o==r&&(o=l.escape),a==r&&(a=l.evaluate||i),f==r&&(f=l.interpolate),o&&(e=e.replace(o,m)),f&&(e=e
.replace(f,y)),a!=B&&(B=a,I=RegExp("<e%-([\\s\\S]+?)%>|<e%=([\\s\\S]+?)%>"+(a?"|"+a.source:""),"g")),o=ot.length,e=e.replace(I,g),o=o!=ot.length,e="__p += '"+e.replace(nt,p).replace(et,h)+"';",ot.length=0,c||(n=j||"obj",o?e="with("+n+"){"+e+"}":(n!=j&&(j=n,F=RegExp("(\\(\\s*)"+n+"\\."+n+"\\b","g")),e=e.replace(Y,"$&"+n+".").replace(F,"$1__d"))),e=(o?e.replace(J,""):e).replace(K,"$1").replace(Q,"$1;"),e="function("+n+"){"+(c?"":n+"||("+n+"={});")+"var __t,__p='',__e=_.escape"+(o?",__j=Array.prototype.join;function print(){__p+=__j.call(arguments,'')}"
:(c?"":",__d="+n+"."+n+"||"+n)+";")+e+"return __p}";try{u=Function("_","return "+e)(s)}catch(d){throw d.source=e,d}return t?u(t):(u.source=e,u)},s.throttle=function(e,t){function n(){a=new Date,u=r,s=e.apply(o,i)}var i,s,o,u,a=0;return function(){var r=new Date,f=t-(r-a);return i=arguments,o=this,0>=f?(a=r,s=e.apply(o,i)):u||(u=Ot(n,f)),s}},s.times=function(e,t,n){var r=-1;if(n)for(;++r<e;)t.call(n,r);else for(;++r<e;)t(r)},s.toArray=function(e){if(!e)return[];var t=e.length;return t===+t?(Bt?ht.
call(e)==Lt:"string"==typeof e)?e.split(""):ct.call(e):wn(e)},s.unescape=function(e){return e==r?"":(e+"").replace($,b)},s.union=function(){for(var e=-1,t=[],n=ut.apply(t,arguments),r=n.length;++e<r;)0>L(t,n[e])&&t.push(n[e]);return t},s.uniq=_,s.uniqueId=function(e){var t=z++;return e?e+t:t},s.values=wn,s.where=Hn,s.without=function(e){var t=[];if(!e)return t;for(var n=-1,r=e.length,i=a(arguments,1,20);++n<r;)i(e[n])||t.push(e[n]);return t},s.wrap=function(e,t){return function(){var n=[e];return arguments
.length&&ft.apply(n,arguments),t.apply(this,n)}},s.zip=function(e){if(!e)return[];for(var t=-1,n=A(On(arguments,"length")),r=Array(n);++t<n;)r[t]=On(arguments,t);return r},s.all=xn,s.any=Dn,s.collect=An,s.detect=Nn,s.drop=O,s.each=Cn,s.foldl=Mn,s.foldr=N,s.head=C,s.include=En,s.inject=Mn,s.methods=hn,s.select=Tn,s.tail=O,s.take=C,s.unique=_,Cn({Date:Tt,Number:Nt,RegExp:kt,String:Lt},function(e,t){s["is"+t]=function(t){return ht.call(t)==e}}),o.prototype=s.prototype,H(s),o.prototype.chain=function(
){return this.__chain__=n,this},o.prototype.value=function(){return this.__wrapped__},Cn("pop push reverse shift sort splice unshift".split(" "),function(e){var t=R[e];o.prototype[e]=function(){var e=this.__wrapped__;return t.apply(e,arguments),_t&&e.length===0&&delete e[0],this.__chain__&&(e=new o(e),e.__chain__=n),e}}),Cn(["concat","join","slice"],function(e){var t=R[e];o.prototype[e]=function(){var e=t.apply(this.__wrapped__,arguments);return this.__chain__&&(e=new o(e),e.__chain__=n),e}}),typeof 
define=="function"&&typeof define.amd=="object"&&define.amd?(e._=s,define(function(){return s})):q?"object"==typeof module&&module&&module.exports==q?(module.exports=s)._=s:q._=s:e._=s})(this);
})(self)
},{}],7:[function(require,module,exports){
(function(global){/**
 * marked - A markdown parser (https://github.com/chjj/marked)
 * Copyright (c) 2011-2012, Christopher Jeffrey. (MIT Licensed)
 */

;(function() {

/**
 * Block-Level Grammar
 */

var block = {
  newline: /^\n+/,
  code: /^( {4}[^\n]+\n*)+/,
  fences: noop,
  hr: /^( *[-*_]){3,} *(?:\n+|$)/,
  heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
  lheading: /^([^\n]+)\n *(=|-){3,} *\n*/,
  blockquote: /^( *>[^\n]+(\n[^\n]+)*\n*)+/,
  list: /^( *)(bull) [^\0]+?(?:hr|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
  html: /^ *(?:comment|closed|closing) *(?:\n{2,}|\s*$)/,
  def: /^ *\[([^\]]+)\]: *([^\s]+)(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
  paragraph: /^([^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+\n*/,
  text: /^[^\n]+/
};

block.bullet = /(?:[*+-]|\d+\.)/;
block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
block.item = replace(block.item, 'gm')
  (/bull/g, block.bullet)
  ();

block.list = replace(block.list)
  (/bull/g, block.bullet)
  ('hr', /\n+(?=(?: *[-*_]){3,} *(?:\n+|$))/)
  ();

block.html = replace(block.html)
  ('comment', /<!--[^\0]*?-->/)
  ('closed', /<(tag)[^\0]+?<\/\1>/)
  ('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)
  (/tag/g, tag())
  ();

block.paragraph = replace(block.paragraph)
  ('hr', block.hr)
  ('heading', block.heading)
  ('lheading', block.lheading)
  ('blockquote', block.blockquote)
  ('tag', '<' + tag())
  ('def', block.def)
  ();

block.normal = {
  fences: block.fences,
  paragraph: block.paragraph
};

block.gfm = {
  fences: /^ *(```|~~~) *(\w+)? *\n([^\0]+?)\s*\1 *(?:\n+|$)/,
  paragraph: /^/
};

block.gfm.paragraph = replace(block.paragraph)
  ('(?!', '(?!' + block.gfm.fences.source.replace('\\1', '\\2') + '|')
  ();

/**
 * Block Lexer
 */

block.lexer = function(src) {
  var tokens = [];

  tokens.links = {};

  src = src
    .replace(/\r\n|\r/g, '\n')
    .replace(/\t/g, '    ');

  return block.token(src, tokens, true);
};

block.token = function(src, tokens, top) {
  var src = src.replace(/^ +$/gm, '')
    , next
    , loose
    , cap
    , item
    , space
    , i
    , l
    , start;

  while (src) {
    start = src.length;
    // newline
    if (cap = block.newline.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[0].length > 1) {
        tokens.push({
          type: 'space'
        });
      }
    }

    // code
    if (cap = block.code.exec(src)) {
      src = src.substring(cap[0].length);
      cap = cap[0].replace(/^ {4}/gm, '');
      tokens.push({
        type: 'code',
        text: !options.pedantic
          ? cap.replace(/\n+$/, '')
          : cap,
        textLen: start - src.length,
        remain: src.length
      });
      continue;
    }

    // fences (gfm)
    if (cap = block.fences.exec(src)) {
      src = src.substring(cap[0].length);
      tokens.push({
        type: 'code',
        lang: cap[2],
        text: cap[3],
        textLen: start - src.length,
        remain: src.length
      });
      continue;
    }

    // heading
    if (cap = block.heading.exec(src)) {
      src = src.substring(cap[0].length);
      tokens.push({
        type: 'heading',
        depth: cap[1].length,
        text: cap[2]
      });
      continue;
    }

    // lheading
    if (cap = block.lheading.exec(src)) {
      src = src.substring(cap[0].length);
      tokens.push({
        type: 'heading',
        depth: cap[2] === '=' ? 1 : 2,
        text: cap[1]
      });
      continue;
    }

    // hr
    if (cap = block.hr.exec(src)) {
      src = src.substring(cap[0].length);
      tokens.push({
        type: 'hr'
      });
      continue;
    }

    // blockquote
    if (cap = block.blockquote.exec(src)) {
      src = src.substring(cap[0].length);

      tokens.push({
        type: 'blockquote_start'
      });

      cap = cap[0].replace(/^ *> ?/gm, '');

      // Pass `top` to keep the current
      // "toplevel" state. This is exactly
      // how markdown.pl works.
      block.token(cap, tokens, top);

      tokens.push({
        type: 'blockquote_end'
      });

      continue;
    }

    // list
    if (cap = block.list.exec(src)) {
      src = src.substring(cap[0].length);

      tokens.push({
        type: 'list_start',
        ordered: isFinite(cap[2])
      });

      // Get each top-level item.
      cap = cap[0].match(block.item);

      next = false;
      l = cap.length;
      i = 0;

      for (; i < l; i++) {
        item = cap[i];

        // Remove the list item's bullet
        // so it is seen as the next token.
        space = item.length;
        item = item.replace(/^ *([*+-]|\d+\.) +/, '');

        // Outdent whatever the
        // list item contains. Hacky.
        if (~item.indexOf('\n ')) {
          space -= item.length;
          item = !options.pedantic
            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
            : item.replace(/^ {1,4}/gm, '');
        }

        // Determine whether item is loose or not.
        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
        // for discount behavior.
        loose = next || /\n\n(?!\s*$)/.test(item);
        if (i !== l - 1) {
          next = item[item.length-1] === '\n';
          if (!loose) loose = next;
        }

        tokens.push({
          type: loose
            ? 'loose_item_start'
            : 'list_item_start'
        });

        // Recurse.
        block.token(item, tokens);

        tokens.push({
          type: 'list_item_end'
        });
      }

      tokens.push({
        type: 'list_end'
      });

      continue;
    }

    // html
    if (cap = block.html.exec(src)) {
      src = src.substring(cap[0].length);
      tokens.push({
        type: options.sanitize
          ? 'paragraph'
          : 'html',
        pre: cap[1] === 'pre',
        text: cap[0]
      });
      continue;
    }

    // def
    if (top && (cap = block.def.exec(src))) {
      src = src.substring(cap[0].length);
      tokens.links[cap[1].toLowerCase()] = {
        href: cap[2],
        title: cap[3]
      };
      continue;
    }

    // top-level paragraph
    if (top && (cap = block.paragraph.exec(src))) {
      src = src.substring(cap[0].length);
      tokens.push({
        type: 'paragraph',
        text: cap[0]
      });
      continue;
    }

    // text
    if (cap = block.text.exec(src)) {
      // Top-level should never reach here.
      src = src.substring(cap[0].length);
      tokens.push({
        type: 'text',
        text: cap[0]
      });
      continue;
    }
  }

  return tokens;
};

/**
 * Inline Processing
 */

var inline = {
  escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
  autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
  url: noop,
  tag: /^<!--[^\0]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
  link: /^!?\[(inside)\]\(href\)/,
  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
  nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
  strong: /^__([^\0]+?)__(?!_)|^\*\*([^\0]+?)\*\*(?!\*)/,
  em: /^\b_((?:__|[^\0])+?)_\b|^\*((?:\*\*|[^\0])+?)\*(?!\*)/,
  code: /^(`+)([^\0]*?[^`])\1(?!`)/,
  br: /^ {2,}\n(?!\s*$)/,
  text: /^[^\0]+?(?=[\\<!\[_*`]| {2,}\n|$)/
};

inline._linkInside = /(?:\[[^\]]*\]|[^\]]|\](?=[^\[]*\]))*/;
inline._linkHref = /\s*<?([^\s]*?)>?(?:\s+['"]([^\0]*?)['"])?\s*/;

inline.link = replace(inline.link)
  ('inside', inline._linkInside)
  ('href', inline._linkHref)
  ();

inline.reflink = replace(inline.reflink)
  ('inside', inline._linkInside)
  ();

inline.normal = {
  url: inline.url,
  strong: inline.strong,
  em: inline.em,
  text: inline.text
};

inline.pedantic = {
  strong: /^__(?=\S)([^\0]*?\S)__(?!_)|^\*\*(?=\S)([^\0]*?\S)\*\*(?!\*)/,
  em: /^_(?=\S)([^\0]*?\S)_(?!_)|^\*(?=\S)([^\0]*?\S)\*(?!\*)/
};

inline.gfm = {
  url: /^(https?:\/\/[^\s]+[^.,:;"')\]\s])/,
  text: /^[^\0]+?(?=[\\<!\[_*`]|https?:\/\/| {2,}\n|$)/
};

/**
 * Inline Lexer
 */

inline.lexer = function(src) {
  var out = ''
    , links = tokens.links
    , link
    , text
    , href
    , cap;

  while (src) {
    // escape
    if (cap = inline.escape.exec(src)) {
      src = src.substring(cap[0].length);
      out += cap[1];
      continue;
    }

    // autolink
    if (cap = inline.autolink.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[2] === '@') {
        text = cap[1][6] === ':'
          ? mangle(cap[1].substring(7))
          : mangle(cap[1]);
        href = mangle('mailto:') + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      out += '<a href="'
        + href
        + '">'
        + text
        + '</a>';
      continue;
    }

    // url (gfm)
    if (cap = inline.url.exec(src)) {
      src = src.substring(cap[0].length);
      text = escape(cap[1]);
      href = text;
      out += '<a href="'
        + href
        + '">'
        + text
        + '</a>';
      continue;
    }

    // tag
    if (cap = inline.tag.exec(src)) {
      src = src.substring(cap[0].length);
      out += options.sanitize
        ? escape(cap[0])
        : cap[0];
      continue;
    }

    // link
    if (cap = inline.link.exec(src)) {
      src = src.substring(cap[0].length);
      out += outputLink(cap, {
        href: cap[2],
        title: cap[3]
      });
      continue;
    }

    // reflink, nolink
    if ((cap = inline.reflink.exec(src))
        || (cap = inline.nolink.exec(src))) {
      src = src.substring(cap[0].length);
      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = links[link.toLowerCase()];
      if (!link || !link.href) {
        out += cap[0][0];
        src = cap[0].substring(1) + src;
        continue;
      }
      out += outputLink(cap, link);
      continue;
    }

    // strong
    if (cap = inline.strong.exec(src)) {
      src = src.substring(cap[0].length);
      out += '<strong>'
        + inline.lexer(cap[2] || cap[1])
        + '</strong>';
      continue;
    }

    // em
    if (cap = inline.em.exec(src)) {
      src = src.substring(cap[0].length);
      out += '<em>'
        + inline.lexer(cap[2] || cap[1])
        + '</em>';
      continue;
    }

    // code
    if (cap = inline.code.exec(src)) {
      src = src.substring(cap[0].length);
      out += '<code>'
        + escape(cap[2], true)
        + '</code>';
      continue;
    }

    // br
    if (cap = inline.br.exec(src)) {
      src = src.substring(cap[0].length);
      out += '<br>';
      continue;
    }

    // text
    if (cap = inline.text.exec(src)) {
      src = src.substring(cap[0].length);
      out += escape(cap[0]);
      continue;
    }
  }

  return out;
};

function outputLink(cap, link) {
  if (cap[0][0] !== '!') {
    return '<a href="'
      + escape(link.href)
      + '"'
      + (link.title
      ? ' title="'
      + escape(link.title)
      + '"'
      : '')
      + '>'
      + inline.lexer(cap[1])
      + '</a>';
  } else {
    return '<img src="'
      + escape(link.href)
      + '" alt="'
      + escape(cap[1])
      + '"'
      + (link.title
      ? ' title="'
      + escape(link.title)
      + '"'
      : '')
      + '>';
  }
}

/**
 * Parsing
 */

var tokens
  , token;

function next() {
  return token = tokens.pop();
}

function tok() {
  switch (token.type) {
    case 'space': {
      return '';
    }
    case 'hr': {
      return '<hr>\n';
    }
    case 'heading': {
      return '<h'
        + token.depth
        + '>'
        + inline.lexer(token.text)
        + '</h'
        + token.depth
        + '>\n';
    }
    case 'code': {
      if (options.highlight) {
        token.code = options.highlight(token.text, token.lang);
        if (token.code != null && token.code !== token.text) {
          token.escaped = true;
          token.text = token.code;
        }
      }

      if (!token.escaped) {
        token.text = escape(token.text, true);
      }

      return '<pre><code'
        + (token.lang
        ? ' class="lang-'
        + token.lang
        + '"'
        : '')
        + '>'
        + token.text
        + '</code></pre>\n';
    }
    case 'blockquote_start': {
      var body = '';

      while (next().type !== 'blockquote_end') {
        body += tok();
      }

      return '<blockquote>\n'
        + body
        + '</blockquote>\n';
    }
    case 'list_start': {
      var type = token.ordered ? 'ol' : 'ul'
        , body = '';

      while (next().type !== 'list_end') {
        body += tok();
      }

      return '<'
        + type
        + '>\n'
        + body
        + '</'
        + type
        + '>\n';
    }
    case 'list_item_start': {
      var body = '';

      while (next().type !== 'list_item_end') {
        body += token.type === 'text'
          ? parseText()
          : tok();
      }

      return '<li>'
        + body
        + '</li>\n';
    }
    case 'loose_item_start': {
      var body = '';

      while (next().type !== 'list_item_end') {
        body += tok();
      }

      return '<li>'
        + body
        + '</li>\n';
    }
    case 'html': {
      return !token.pre && !options.pedantic
        ? inline.lexer(token.text)
        : token.text;
    }
    case 'paragraph': {
      return '<p>'
        + inline.lexer(token.text)
        + '</p>\n';
    }
    case 'text': {
      return '<p>'
        + parseText()
        + '</p>\n';
    }
  }
}

function parseText() {
  var body = token.text
    , top;

  while ((top = tokens[tokens.length-1])
         && top.type === 'text') {
    body += '\n' + next().text;
  }

  return inline.lexer(body);
}

function parse(src) {
  tokens = src.reverse();

  var out = '';
  while (next()) {
    out += tok();
  }

  tokens = null;
  token = null;

  return out;
}

/**
 * Helpers
 */

function escape(html, encode) {
  return html
    .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function mangle(text) {
  var out = ''
    , l = text.length
    , i = 0
    , ch;

  for (; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = 'x' + ch.toString(16);
    }
    out += '&#' + ch + ';';
  }

  return out;
}

function tag() {
  var tag = '(?!(?:'
    + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
    + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
    + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|@)\\b';

  return tag;
}

function replace(regex, opt) {
  regex = regex.source;
  opt = opt || '';
  return function self(name, val) {
    if (!name) return new RegExp(regex, opt);
    val = val.source || val;
    val = val.replace(/(^|[^\[])\^/g, '$1');
    regex = regex.replace(name, val);
    return self;
  };
}

function noop() {}
noop.exec = noop;

/**
 * Marked
 */

function marked(src, opt) {
  setOptions(opt);
  if (opt && opt.saveLex) {
    return [parse(block.lexer(src)), block.lexer(src)];
  } else {
    return parse(block.lexer(src));
  }
}

/**
 * Options
 */

var options
  , defaults;

function setOptions(opt) {
  if (!opt) opt = defaults;
  if (options === opt) return;
  options = opt;

  if (options.gfm) {
    block.fences = block.gfm.fences;
    block.paragraph = block.gfm.paragraph;
    inline.text = inline.gfm.text;
    inline.url = inline.gfm.url;
  } else {
    block.fences = block.normal.fences;
    block.paragraph = block.normal.paragraph;
    inline.text = inline.normal.text;
    inline.url = inline.normal.url;
  }

  if (options.pedantic) {
    inline.em = inline.pedantic.em;
    inline.strong = inline.pedantic.strong;
  } else {
    inline.em = inline.normal.em;
    inline.strong = inline.normal.strong;
  }
}

marked.options =
marked.setOptions = function(opt) {
  defaults = opt;
  setOptions(opt);
  return marked;
};

marked.setOptions({
  gfm: true,
  pedantic: false,
  sanitize: false,
  highlight: null
});

/**
 * Expose
 */

marked.parser = function(src, opt) {
  setOptions(opt);
  return parse(src);
};

marked.lexer = function(src, opt) {
  setOptions(opt);
  return block.lexer(src);
};

marked.parse = marked;

if (typeof module !== 'undefined') {
  module.exports = marked;
} else {
  this.marked = marked;
}

}).call(function() {
  return this || (typeof window !== 'undefined' ? window : global);
}());

})(self)
},{}],8:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var $, DOWN_ARROW, END, ENTER, ESC, HOME, LEFT_ARROW, Notebook, PAGE_DOWN, PAGE_UP, Q, RIGHT_ARROW, UP_ARROW, arrows, bindMarkupDiv, bindSlider, chooseSlide, cleanEmptyNodes, closeWindow, countSlide, createNode, delay, getElementCode, handleInternalSections, hideSlide, insertControls, isLeisureCode, jQuery, lastSlide, makeMarkupDiv, makeSection, makeSlideDiv, markupButtons, markupElement, markupSlideContent, markupSlides, mergeLeisureCode, mergeUp, nextSibling, nthSlide, oldSlide, padSlide, presentLeisureCode, previousSibling, remove, showSlide, slideControls, slideKeyListener, slideName, slidePat, slides, sliding, textNode, unwrap, unwrapContent, _, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  jQuery = window.jQuery, $ = window.$, _ = window._;

  _ref = Notebook = require('./notebook'), ENTER = _ref.ENTER, delay = _ref.delay, textNode = _ref.textNode, createNode = _ref.createNode, remove = _ref.remove, unwrap = _ref.unwrap, insertControls = _ref.insertControls, cleanEmptyNodes = _ref.cleanEmptyNodes, isLeisureCode = _ref.isLeisureCode, getElementCode = _ref.getElementCode, previousSibling = _ref.previousSibling, nextSibling = _ref.nextSibling, presentLeisureCode = _ref.presentLeisureCode, mergeLeisureCode = _ref.mergeLeisureCode, closeWindow = _ref.closeWindow, markupButtons = _ref.markupButtons, ESC = _ref.ESC, HOME = _ref.HOME, END = _ref.END, PAGE_UP = _ref.PAGE_UP, PAGE_DOWN = _ref.PAGE_DOWN, LEFT_ARROW = _ref.LEFT_ARROW, RIGHT_ARROW = _ref.RIGHT_ARROW, UP_ARROW = _ref.UP_ARROW, DOWN_ARROW = _ref.DOWN_ARROW, arrows = _ref.arrows;

  Q = 81;

  window.markup = function(md) {
    var maindoc, nodes, _ref1;

    nodes = document.querySelectorAll('[maindoc]');
    if (nodes.length === 0) {
      maindoc = createNode("<div maindoc></div>");
      document.body.insertBefore(maindoc, document.body.firstChild);
      nodes = [maindoc];
    } else {
      maindoc = nodes[0];
    }
    md = ((_ref1 = md != null ? md.replace(/\r\n/mg, '\n') : void 0) != null ? _ref1 : maindoc.innerHTML.replace(/^\s*<!--*/, '').replace(/-->\s*\n*/m, '')).trim();
    document.body.classList.add('hideControls');
    markupSlides(maindoc, md);
    return insertControls(maindoc);
  };

  lastSlide = null;

  if (typeof console !== "undefined" && console !== null) {
    if (typeof console.error === "function") {
      console.error(new Error("REMINDER: Incompatibility: using -webkit-calc").stack);
    }
  }

  slidePat = /^(\*\*\*[^\n]*\n(?:--?\n)?)/m;

  slideName = /^\*\*\*([^\n]*)\n(?:--?\n)?/m;

  sliding = false;

  markupSlides = function(el, md) {
    var div, hasCode, slides;

    hasCode = markupSlideContent(el, md);
    slides = el.querySelectorAll('[leisureSection]');
    if (slides.length <= (el.querySelector('[leisureSection="Leisure Controls"]') ? 2 : 1)) {
      document.body.classList.add("oneSlide");
    }
    div = createNode("<div class='slide-controls'>\n  <div id='slide-killbutton' onclick='toggleSlideShow()' style='float: right'><button>Slides</button></div>\n  <div id='slide-num' style='float: right; margin-right: 10px'></div>\n</div>");
    markupButtons(div);
    el.appendChild(div);
    if (location.search && _.find(location.search.slice(1).split('&'), (function(p) {
      return p.match(/^slides=/);
    }))) {
      sliding = true;
      showSlide($(chooseSlide()));
    } else {
      document.body.classList.add('scroll');
    }
    return hasCode;
  };

  markupSlideContent = function(el, md, noMain) {
    var content, hasCode, i, m, p, pageType, pages, _i, _ref1, _ref2;

    pages = md.split(slidePat);
    hasCode = false;
    if (pages.length > 1) {
      console.log("PAGES:", JSON.stringify(pages));
      document.body.classList.add('slide-container');
      el.innerHTML = '';
      bindSlider();
      el.removeAttribute('doc');
      if (pages.length === 3 && !pages[0] && !pages[2]) {
        pages[2] = '\n';
      }
      for (i = _i = 0, _ref1 = pages.length; _i < _ref1; i = _i += 2) {
        p = pages[i];
        if (p) {
          pageType = i > 0 ? (m = (_ref2 = pages[i - 1].match(slidePat)) != null ? _ref2[1] : void 0, m.match(/\n-\n/) ? ['continuation', 'hiddenPage'] : m.match(/\n--\n/) ? ['hiddenPage'] : []) : [];
          content = makeSlideDiv(el, pageType, (i > 0 ? pages[i - 1].match(slideName)[1].trim() : 'Main'));
          if (i > 0) {
            hasCode = (markupElement(content, pages[i - 1] + p)) || hasCode;
          } else {
            hasCode = (markupElement(content, '***\n' + p)) || hasCode;
          }
          padSlide(content, (i > 0 ? pages[i - 1] : '***\n'));
        }
      }
    } else {
      content = makeSlideDiv(el, ['page'], 'Main');
      while (el.firstChild !== content.parentNode) {
        content.appendChild(el.firstChild);
      }
      hasCode = markupElement(content, md);
      padSlide(content, '***\n');
      if (noMain) {
        unwrapContent(content);
      }
    }
    return hasCode;
  };

  padSlide = function(content, header) {
    var div, range;

    if (!content.firstChild || isLeisureCode(content.firstChild)) {
      range = document.createRange();
      range.setStart(content, 0);
      range.setEnd(content, 0);
      div = makeMarkupDiv(range, header);
      div.appendChild(createNode('<br>'));
    }
    if (isLeisureCode(content.lastChild)) {
      range = document.createRange();
      range.setStartAfter(content.lastChild);
      range.setEndAfter(content.lastChild);
      div = makeMarkupDiv(range, '\n');
      return div.appendChild(createNode('<br>'));
    }
  };

  unwrapContent = function(content) {
    var el, section;

    section = content.parentNode;
    el = section.parentNode;
    el.insertBefore(content, section);
    remove(section);
    return unwrap(content);
  };

  makeSlideDiv = function(el, pageTypes, title) {
    var content, div, pageType, sectionTitle, _i, _len;

    lastSlide = div = createNode("<div class='leisure_page'></div>");
    div.setAttribute('leisureSection', title);
    div.setAttribute('doc', '');
    div.setAttribute('slide', '');
    div.classList.add('slide');
    div.classList.add('ui-corner-all');
    div.classList.add('ui-widget');
    div.classList.add('ui-widget-content');
    for (_i = 0, _len = pageTypes.length; _i < _len; _i++) {
      pageType = pageTypes[_i];
      div.classList.add(pageType);
    }
    el.appendChild(div);
    sectionTitle = createNode("<div class='pageTitle'>" + title + "</div>");
    sectionTitle.setAttribute('leisureoutput', '');
    div.appendChild(sectionTitle);
    content = createNode("<div class='pageContent'></div>");
    div.appendChild(content);
    return content;
  };

  chooseSlide = function() {
    var param;

    param = _.find(location.search.slice(1).split('&'), (function(p) {
      return p.match(/^slide=.*/);
    }));
    console.log(param);
    if (param) {
      return document.querySelector("[slide='" + (param.split('=')[1]) + "']");
    } else {
      return document.querySelector('[maindoc]').firstElementChild;
    }
  };

  oldSlide = 0;

  window.toggleSlideShow = function() {
    sliding = $(document.body).is('.scroll');
    if (sliding) {
      $(document.body).removeClass('scroll');
      return showSlide(nthSlide(oldSlide));
    } else {
      oldSlide = $('.slide.showing').attr('slide');
      hideSlide($('.slide.showing'));
      $(document.body).addClass('scroll');
      return $('#slide-num').html('');
    }
  };

  bindSlider = function() {
    return document.body.addEventListener('keydown', slideKeyListener);
  };

  slideControls = [Q, ESC, LEFT_ARROW, RIGHT_ARROW, HOME, END, PAGE_UP, PAGE_DOWN];

  slideKeyListener = function(e) {
    var c, cur, n, next, s;

    if (sliding) {
      window.evt = e;
      c = e.charCode || e.keyCode || e.which;
      if ((__indexOf.call(slideControls, c) >= 0) && !$(e.target).is('[leisurenode=code],[leisurenode=code] *')) {
        e.preventDefault();
        if (c === ESC) {
          return toggleSlideShow();
        } else if (c === Q) {
          return closeWindow();
        } else {
          cur = $('.slide.showing');
          next = (function() {
            switch (c) {
              case HOME:
                return slides();
              case END:
                return s = slides().last();
              case LEFT_ARROW:
              case PAGE_UP:
                n = cur.prev('[slide]').not('[leisureSection="Leisure Controls"]');
                if (n.length) {
                  return n;
                } else {
                  return slides();
                }
                break;
              case RIGHT_ARROW:
              case PAGE_DOWN:
                n = cur.next('[slide]').not('[leisureSection="Leisure Controls"]');
                if (n.length) {
                  return n;
                } else {
                  return slides().last();
                }
            }
          })();
          hideSlide(cur);
          return showSlide(next);
        }
      }
    }
  };

  slides = function() {
    return $('[slide]').not('[leisureSection="Leisure Controls"]').not('.hiddenPage');
  };

  nthSlide = function(n) {
    return slides().slice(n);
  };

  countSlide = function(el) {
    var count, n, slide, _i, _len, _ref1;

    n = -1;
    count = 0;
    _ref1 = slides();
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      slide = _ref1[_i];
      count++;
      if (slide === el) {
        n = count;
      }
    }
    return [n, count];
  };

  showSlide = function(el) {
    var count, n, _ref1;

    _ref1 = countSlide(el[0]), n = _ref1[0], count = _ref1[1];
    oldSlide = n;
    $('#slide-num').html("" + n + " / " + count);
    return $(el).first().removeClass('hidden').addClass('showing');
  };

  hideSlide = function(el) {
    return $(el).first().addClass('hidden').removeClass('showing');
  };

  markupElement = function(el, md) {
    var code, codePos, len, lex, markup, node, prev, prevCodePos, range, slide, _i, _len, _ref1, _ref2, _ref3;

    len = md.length;
    slide = (_ref1 = md.match(slidePat)) != null ? _ref1 : '';
    _ref2 = window.marked((slide ? md.slice(slide[0].length) : md), {
      saveLex: true,
      gfm: true
    }), markup = _ref2[0], lex = _ref2[1];
    el.innerHTML = markup.trim() || '<br>';
    prev = null;
    range = document.createRange();
    prevCodePos = -1;
    codePos = 0;
    _ref3 = el.querySelectorAll('code');
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      node = _ref3[_i];
      while (lex[codePos].type !== 'code') {
        codePos++;
      }
      if (node.parentNode.tagName !== 'PRE') {
        code = node;
      } else {
        code = node.parentNode;
        code.innerHTML = node.innerHTML;
      }
      code.setAttribute('noLeisureBar', '');
      code.setAttribute('leisureNode', 'code');
      code.md = lex[codePos].text;
      if (code.parentNode.firstChild !== code) {
        if (prev === null || prev.parentNode !== code.parentNode) {
          range.setStart(code.parentNode, 0);
        } else {
          range.setStartAfter(prev);
        }
        range.setEndBefore(code);
        makeMarkupDiv(range, md.substring((prevCodePos === -1 ? 0 : len - lex[prevCodePos].remain), len - lex[codePos].remain - lex[codePos].textLen));
      }
      prevCodePos = codePos;
      codePos++;
      prev = code;
    }
    if (prevCodePos > -1) {
      if (lex[prevCodePos].remain > 0) {
        range.selectNodeContents(prev.parentNode);
        range.setStartAfter(prev);
        makeMarkupDiv(range, md.substring(len - lex[prevCodePos].remain));
      }
    } else {
      range.selectNodeContents(el);
      makeMarkupDiv(range, md);
    }
    return prevCodePos > -1;
  };

  handleInternalSections = function(content) {
    var before, firstSlide, innerSections, marker, node, nodeContent, nodeTitle, prev, section, sectionHolder, title, _i, _j, _len, _len1, _ref1;

    section = content.parentNode;
    sectionHolder = section.parentNode;
    innerSections = section.querySelectorAll('[leisureSection]');
    if (innerSections.length === 0) {
      if (!((_ref1 = content.firstChild.md) != null ? _ref1.match(/^\*\*\*/) : void 0)) {
        if (!section.previousSibling) {
          return section.setAttribute('leisureSection', 'Main');
        } else {
          prev = section.previousSibling.querySelector('.pageContent');
          while (content.firstChild) {
            mergeUp(content.firstChild, prev);
          }
          return remove(section);
        }
      }
    } else {
      title = section.getAttribute('leisureSection');
      firstSlide = !section.previousSibling || section.previousSibling.getAttribute('leisureSection') === 'Leisure Controls';
      before = false;
      for (_i = 0, _len = innerSections.length; _i < _len; _i++) {
        node = innerSections[_i];
        if (node.getAttribute('leisureSection') === title) {
          before = true;
          break;
        }
      }
      before = before || (!innerSections[0].previousSibling);
      marker = section;
      for (_j = 0, _len1 = innerSections.length; _j < _len1; _j++) {
        node = innerSections[_j];
        nodeTitle = node.getAttribute('leisureSection');
        nodeContent = node.querySelector('.pageContent');
        if (nodeTitle === title || (node.previousSibling && nodeTitle === 'Main')) {
          if (nodeTitle === title) {
            before = false;
          }
          while (nodeContent.firstChild) {
            content.insertBefore(nodeContent.firstChild, node);
            mergeLeisureCode(node.previousSibling, node);
          }
          remove(node);
        } else {
          while (node.nextSibling && !node.nextSibling.getAttribute('leisureSection')) {
            mergeUp(node.nextSibling, nodeContent);
          }
          padSlide(nodeContent, "***" + nodeTitle + "\n");
          if (before) {
            section.parentNode.insertBefore(node, section);
          } else {
            section.parentNode.insertBefore(node, marker.nextSibling);
            marker = node;
          }
        }
      }
      if (!content.firstChild) {
        return remove(section);
      } else {
        return padSlide(content, "***" + title + "\n");
      }
    }
  };

  mergeUp = function(el, newParent) {
    newParent.appendChild(el);
    return mergeLeisureCode(newParent.lastChild.previousSibling, newParent.lastChild);
  };

  makeSection = function(title, node, next) {
    var div;

    div = createNode("<div leisureSection='" + title + "'></div>");
    node.parentNode.insertBefore(div, node);
    while (div.nextSibling && div.nextSibling !== next) {
      div.appendChild(div.nextSibling);
    }
    return div;
  };

  makeMarkupDiv = function(range, md) {
    var div;

    div = document.createElement('div');
    range.surroundContents(div);
    div.md = md;
    bindMarkupDiv(div);
    return div;
  };

  bindMarkupDiv = function(div) {
    var editing;

    div.bound = true;
    div.setAttribute('leisureNode', 'markdown');
    div.setAttribute('contenteditable', 'false');
    editing = false;
    div.addEventListener('dblclick', function(e) {
      if (!editing) {
        div.innerHTML = '';
        div.appendChild(textNode(div.md));
        div.style.whiteSpace = 'pre-wrap';
        div.setAttribute('contenteditable', 'true');
        editing = true;
        div.parentNode.setAttribute('editing', 'true');
        return div.focus();
      }
    });
    div.addEventListener('keypress', function(e) {
      var br, r, s;

      if (editing) {
        s = window.getSelection();
        r = s.getRangeAt(0);
        if ((e.charCode || e.keyCode || e.which) === ENTER) {
          br = textNode('\n');
          r.insertNode(br);
          r = document.createRange();
          r.setStart(br, 1);
          s.removeAllRanges();
          s.addRange(r);
          return e.preventDefault();
        }
      }
    });
    return div.addEventListener('blur', function(e) {
      var first, frag, last, node, parent, prevSection, r, scroll, _i, _len, _ref1, _ref2;

      if (editing) {
        scroll = document.body.scrollTop;
        div.style.whiteSpace = '';
        editing = false;
        div.parentNode.removeAttribute('editing');
        div.setAttribute('contenteditable', 'false');
        prevSection = (_ref1 = div.parentNode.parentNode.previousSibling) != null ? _ref1.getAttribute('leisureSection') : void 0;
        parent = div.parentNode;
        if (markupSlideContent(div, div.textContent, prevSection && prevSection !== 'Leisure Controls')) {
          _ref2 = div.querySelectorAll("[leisurenode='code']");
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            node = _ref2[_i];
            presentLeisureCode(node, true);
          }
        } else if (div.textContent.trim() === '') {
          cleanEmptyNodes(div);
        }
        r = document.createRange();
        r.selectNodeContents(div);
        frag = r.extractContents();
        first = frag.childNodes[0];
        last = frag.childNodes[frag.childNodes.length - 1];
        parent.replaceChild(frag, div);
        mergeLeisureCode(previousSibling(first), first);
        mergeLeisureCode(last, nextSibling(last));
        handleInternalSections(parent);
        return delay(function() {
          return document.body.scrollTop = scroll;
        });
      }
    });
  };

  Notebook.markupElement = markupElement;

}).call(this);

/*
*/

},{"./notebook":9}],9:[function(require,module,exports){
(function(global){// Generated by CoffeeScript 1.6.2
/*
# use an element as a Leisure notebook
# Only runs in the context of a browser
*/


(function() {
  var $, BS, DEL, DOWN_ARROW, END, ENTER, ESC, HOME, LEFT_ARROW, Leisure_anno, Nil, PAGE_DOWN, PAGE_UP, RIGHT_ARROW, TAB, UP_ARROW, URI, Xus, acceptCode, addBoxClasses, addDefControls, addsLine, allowEvents, arrows, autoRun, baseElements, basePresentValue, baseStrokeWidth, bindAll, bindNotebook, bootNotebook, box, boxClasses, buttonClasses, c, changeTheme, changeView, checkDeleteExpr, checkHideSource, checkMutateFromModification, cleanEmptyNodes, cleanOutput, clearAst, clearOutputBox, clearUpdates, clickTest, closeWindow, codeBox, codeFocus, codeSpan, configureSaveLink, continueRangePosition, createFragment, createNode, createPeer, createSlider, debug, defaultEnv, define, delay, docFocus, envFor, errString, escapeHtml, evalBox, evalDoc, evalDocCode, evalOutput, filename, findCurrentCodeHolder, findDefs, findUpdateSelector, focusBox, foldLeft, gen, getAnnoBody, getAnnoData, getAnnoName, getAst, getBox, getDefName, getElementCode, getElements, getExprSource, getMDDocument, getMaxStrokeWidth, getRangePosition, getRangeText, getRanges, getRefName, getSvgElement, getType, grp, handleKey, hasFunc, hasMonadOutput, head, hideControlSection, hideOutputSource, hideSlider, highlightNotebookFunction, highlightPosition, id, identity, ignoreDeleteOutputBox, initNotebook, insertControls, isDef, isLeisureCode, isMonad, isOutput, isSlider, laz, leisureContextString, linePat, linkSource, loadProgram, loaded, makeId, makeLabel, makeMonad, makeOption, makeOutputBox, makeOutputControls, makeRange, makeSyncMonad, makeTestBox, makeTestCase, markPartialApplies, markupButton, markupButtons, markupDefs, mergeLeisureCode, nameSub, nextId, nextSibling, nodeEnd, nodeFor, nonprintable, numberEnd, numberStart, oldBrackets, owner, patchFuncAst, peer, peerGetDocument, peerGetFunctions, peerNotifySelection, postLoadQueue, prepExpr, presentLeisureCode, presentValue, previousBoxRangeInternal, previousBoxRangeStart, previousSibling, primSvgMeasure, primconcatNodes, printable, printableControlCharacters, processLine, psgn, queueAfterLoad, remove, removeBoxClasses, removeOldDefs, replaceContents, replaceRange, replicate, req, root, runMonad, runTest, runTests, saveProgram, setAst, setFilename, setMinMax, setSnapper, setUpdate, showAst, showError, showFilename, showFilenames, showOutputSource, showResult, showSliderButton, showSource, skipLeftOverOutputBox, slider, snapshot, svgBetterMeasure, svgMeasure, svgMeasureText, tail, testPat, textNode, toDefBox, toExprBox, toggleEdit, transformStrokeWidth, transformedPoint, unwrap, update, updatePat, wrapRange, xusEnv, _ref, _ref1,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  console.log("LOADING NOTEBOOK");

  _ref = root = module.exports = require('./ast'), nameSub = _ref.nameSub, getRefName = _ref.getRefName, define = _ref.define, foldLeft = _ref.foldLeft, Nil = _ref.Nil, getType = _ref.getType, getAnnoName = _ref.getAnnoName, getAnnoData = _ref.getAnnoData, getAnnoBody = _ref.getAnnoBody, Leisure_anno = _ref.Leisure_anno;

  _ref1 = require('./runtime'), isMonad = _ref1.isMonad, runMonad = _ref1.runMonad, makeMonad = _ref1.makeMonad, makeSyncMonad = _ref1.makeSyncMonad, identity = _ref1.identity, defaultEnv = _ref1.defaultEnv;

  gen = require('./gen').gen;

  URI = window.URI;

  Xus = window.Xus;

  $ = window.$;

  debug = false;

  BS = 8;

  TAB = 9;

  ENTER = 13;

  ESC = 27;

  PAGE_UP = 33;

  PAGE_DOWN = 34;

  END = 35;

  HOME = 36;

  LEFT_ARROW = 37;

  UP_ARROW = 38;

  RIGHT_ARROW = 39;

  DOWN_ARROW = 40;

  DEL = 46;

  arrows = [37, 38, 39, 40];

  updatePat = /(^|\n)(#@update )([^\n]+)(?:^|\n)/;

  peer = null;

  nextId = 0;

  filename = null;

  snapshot = function(el, pgm) {};

  setSnapper = function(snapFunc) {
    return snapshot = snapFunc;
  };

  delay = function(func) {
    return window.setTimeout(func, 1);
  };

  basePresentValue = null;

  presentValue = function(v) {
    var content;

    if ((getType(v)) === 'svgNode') {
      content = v(laz(id));
      return _svgPresent()(laz(content))(laz(id));
    } else {
      return basePresentValue(v);
    }
  };

  bootNotebook = function(el) {
    if ((document.getElementById('channelList')) == null) {
      document.body.appendChild(createNode("<datalist id='channelList'>\n   <option value=''></option>\n   <option value='app'>app</option>\n   <option value='compile'>compile</option>\n   <option value='editorFocus'>editorFocus</option>\n</datalist>"));
    }
    return createPeer();
  };

  closeWindow = function() {
    console.log("CLOSING WINDOW");
    window.open('', '_self', '');
    return window.close();
  };

  createPeer = function() {
    var k, param, params, server, v, _i, _len, _ref2, _ref3;

    root.xusServer = server = new Xus.Server();
    root.xusServer.verbose = function(str) {
      return console.log(str);
    };
    server.exit = function() {
      return closeWindow();
    };
    peer = root.peer = Xus.createDirectPeer(server);
    peer.server = server;
    peer.listen('leisure/selection/contents', true, function(key, value) {
      var node, r, s;

      if (key === 'leisure/selection/contents') {
        s = window.getSelection();
        if (s.rangeCount && s.toString() !== value) {
          r = s.getRangeAt(0);
          r.deleteContents();
          node = textNode(value.toString());
          r.insertNode(node);
          s.removeAllRanges();
          r.selectNode(node);
          return s.addRange(r);
        }
      }
    });
    peer.set('leisure/evalExpr', null, 'transient');
    peer.listen('leisure/evalExpr', false, function(key, value) {
      var env, expr, result;

      if (key === 'leisure/evalExpr' && (value != null)) {
        expr = value[0], result = value[1];
        console.log("EVAL: " + expr + ", RESULT: " + result);
        env = xusEnv(result, expr);
        return processLine(expr, env, function() {
          return typeof env.cleanup === "function" ? env.cleanup() : void 0;
        });
      }
    });
    peer.set('leisure/document', peerGetDocument);
    peer.set('leisure/functions', peerGetFunctions);
    peer.set('leisure/storage', []);
    if (Boot.documentFragment) {
      params = {};
      _ref2 = Boot.documentFragment.substring(1).split('&');
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        param = _ref2[_i];
        _ref3 = param.split('='), k = _ref3[0], v = _ref3[1];
        params[k.toLowerCase()] = decodeURIComponent(v);
      }
      if (params.xusproxy != null) {
        return Xus.xusToProxy(server, params.xusproxy);
      }
    }
  };

  replaceContents = function(uri, contents) {
    if (!contents) {
      contents = uri;
      uri = null;
    }
    if (uri) {
      setFilename(uri.toString());
    }
    document.body.setAttribute('doc', '');
    window.leisureAutoRunAll = true;
    window.markup(contents);
    return bindAll();
  };

  bindAll = function() {
    var node, _i, _len, _ref2;

    _ref2 = document.querySelectorAll("[leisurenode='code']");
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      node = _ref2[_i];
      node.setAttribute('contentEditable', 'true');
      bindNotebook(node);
      changeTheme(node, 'thin');
      evalDoc(node);
    }
    return showFilenames();
  };

  xusEnv = function(resultVar, expr) {
    var env, result;

    result = '';
    env = {
      debug: debug,
      finishedEvent: function() {},
      owner: null,
      require: req,
      write: function(msg) {
        return result += "" + msg + "\n";
      },
      prompt: function(msg, cont) {
        return result += "Attempt to prompt with " + msg;
      },
      processResult: function(res, ast) {
        result += res;
        return peer.set(resultVar, JSON.stringify(result));
      },
      presentValue: function(x) {
        return x;
      },
      fileSettings: {
        uri: new URI(document.location.href)
      },
      err: function(err) {
        result += err.leisureContext ? "ERROR: " + err + ":\n" + (leisureContextString(err)) + "\n" + err.stack : "Couldn't parse: " + expr;
        return peer.set(resultVar, result);
      }
    };
    env.__proto__ = root.defaultEnv;
    return env;
  };

  peerGetDocument = function() {
    var nodes;

    nodes = document.querySelectorAll("[leisurenode='code']");
    if (nodes.length > 1 || Notebook.md) {
      return getMDDocument();
    } else {
      return getSimpleDocument();
    }
  };

  peerGetFunctions = function() {
    return (_.uniq(window.leisureFuncNames.toArray().sort(), true)).sort();
  };

  getMDDocument = function() {
    var md, node, _i, _len, _ref2, _ref3;

    md = '';
    _ref2 = document.querySelectorAll('[doc] [leisureNode]');
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      node = _ref2[_i];
      md += isLeisureCode(node) ? "```\n" + (getElementCode(node)) + "\n```\n" : (_ref3 = node.md) != null ? _ref3 : '';
    }
    return md;
  };

  makeId = function(el) {
    if (!el.id) {
      return el.id = "Leisure-" + (nextId++);
    }
  };

  allowEvents = true;

  bindNotebook = function(el) {
    if (!basePresentValue) {
      basePresentValue = function(value) {
        return String(value);
      };
      defaultEnv.presentValue = presentValue;
      defaultEnv.write = function(msg) {
        return console.log(msg);
      };
      defaultEnv.owner = document.body;
      defaultEnv.finishedEvent = function(evt, channel) {
        return update(channel != null ? channel : 'app', defaultEnv);
      };
      defaultEnv.debug = debug;
    }
    if (el.bound == null) {
      makeId(el);
      el.bound = true;
      el.addEventListener('DOMCharacterDataModified', (function(evt) {
        if (allowEvents && !el.replacing) {
          return delay(function() {
            return checkMutateFromModification(evt);
          });
        }
      }), true);
      el.addEventListener('DOMSubtreeModified', (function(evt) {
        if (allowEvents && !el.replacing) {
          return delay(function() {
            return checkMutateFromModification(evt);
          });
        }
      }), true);
      el.addEventListener('mousedown', (function(e) {
        if (!isSlider(e.srcElement)) {
          return delay(function() {
            return highlightPosition(e);
          });
        }
      }), true);
      el.addEventListener('mousemove', (function(e) {
        if (!isSlider(e.srcElement)) {
          return delay(function() {
            return highlightPosition(e);
          });
        }
      }), true);
      el.addEventListener('mouseup', (function(e) {
        if (!isSlider(e.srcElement)) {
          return delay(function() {
            return highlightPosition(e);
          });
        }
      }), true);
      el.addEventListener('keydown', function(e) {
        var c, r, s;

        c = e.charCode || e.keyCode || e.which;
        if (c === DEL || c === BS) {
          s = window.getSelection();
          r = s.getRangeAt(0);
          if (c === BS) {
            checkDeleteExpr(getBox(r.startContainer));
            if (skipLeftOverOutputBox(el, r)) {
              return e.preventDefault();
            }
          } else if (c === DEL) {
            checkDeleteExpr(getBox(r.startContainer));
            if (ignoreDeleteOutputBox(el, r)) {
              return e.preventDefault();
            }
          }
        }
        if (printable(c)) {
          clearAst(getBox(window.getSelection().focusNode));
        }
        if ((__indexOf.call(arrows, c) >= 0) || printable(c)) {
          delay(function() {
            return highlightPosition(e);
          });
        }
        if (e.ctrlKey && c === ENTER) {
          return handleKey("C-ENTER");
        } else if (e.altKey && c === ENTER) {
          return handleKey("M-ENTER");
        } else if (c === TAB) {
          handleKey("TAB");
          return e.preventDefault();
        }
      });
      el.addEventListener('keypress', function(e) {
        var br, bx, r, s, sp;

        s = window.getSelection();
        r = s.getRangeAt(0);
        if ((e.charCode || e.keyCode || e.which) === ENTER) {
          br = textNode('\n');
          r.insertNode(br);
          r = document.createRange();
          r.setStart(br, 1);
          s.removeAllRanges();
          s.addRange(r);
          return e.preventDefault();
        } else if (r.startContainer.parentNode === el) {
          sp = codeSpan('\n', 'codeExpr');
          sp.setAttribute('generatedNL', '');
          bx = box(s.getRangeAt(0), 'codeMainExpr', true);
          bx.appendChild(sp);
          makeOutputBox(bx);
          r = document.createRange();
          r.setStart(sp, 0);
          s.removeAllRanges();
          return s.addRange(r);
        }
      });
      el.addEventListener('focus', (function() {
        if (allowEvents) {
          return findCurrentCodeHolder();
        }
      }), true);
      el.addEventListener('blur', (function() {
        if (allowEvents) {
          return findCurrentCodeHolder();
        }
      }), true);
      if (window.leisureAutoRunAll) {
        autoRun(el, true);
        return window.setTimeout((function() {
          return runTests(el);
        }), 1);
      } else {
        return el.autorunState = false;
      }
    }
  };

  checkDeleteExpr = function(node) {
    var out;

    if (isOutput(node && node.output)) {
      out = node.output;
      return window.setTimeout((function() {
        if (!node.textContent.trim()) {
          node.parentNode.removeChild(node);
        }
        if ((node.parentNode == null) && ((out != null ? out.parentNode : void 0) != null)) {
          return out.parentNode.removeChild(out);
        }
      }), 1);
    }
  };

  skipLeftOverOutputBox = function(el, r) {
    var box, s;

    el.normalize();
    box = previousBoxRangeInternal(r) || previousBoxRangeStart(r);
    if (isOutput(box)) {
      s = window.getSelection();
      r.selectNode(box);
      r.collapse(true);
      s.removeAllRanges();
      s.addRange(r);
      return true;
    } else {
      return false;
    }
  };

  previousBoxRangeInternal = function(r) {
    return r.startContainer.nodeType === 1 && r.startOffset > 0 && r.startContainer.childNodes[r.startOffset - 1];
  };

  previousBoxRangeStart = function(r) {
    return r.startContainer.nodeType === 3 && r.startOffset === 0 && previousSibling(r.startContainer);
  };

  ignoreDeleteOutputBox = function(el, r) {
    var n;

    el.normalize();
    if (r.startContainer.nodeType === 3 && r.startOffset === r.startContainer.length) {
      n = r.startContainer;
      while (n && n.nextSibling === null) {
        n = n.parentNode;
      }
      return isOutput(n != null ? n.nextSibling : void 0);
    } else {
      return false;
    }
  };

  isOutput = function(el) {
    return (el != null ? el.nodeType : void 0) === 1 && el.hasAttribute('LeisureOutput');
  };

  isLeisureCode = function(el) {
    return (el != null ? el.nodeType : void 0) === 1 && el.getAttribute('leisureNode') === 'code';
  };

  peerNotifySelection = function(el, str) {};

  printableControlCharacters = (function() {
    var _i, _len, _ref2, _results;

    _ref2 = "\r\i\n\b";
    _results = [];
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      c = _ref2[_i];
      _results.push(c.charCodeAt(0));
    }
    return _results;
  })();

  printable = function(code) {
    return (code > 0xf && code < 37) || code > 40 || __indexOf.call(printableControlCharacters, code) >= 0;
  };

  nonprintable = null;

  (function() {
    var i, s, _i;

    s = '';
    for (i = _i = 0; 0 <= 0xf ? _i <= 0xf : _i >= 0xf; i = 0 <= 0xf ? ++_i : --_i) {
      s += String.fromCharCode(i);
    }
    s.replace(/[\i\r\f]/g, '');
    return nonprintable = new RegExp("[" + s + "]");
  })();

  handleKey = function(key) {
    var box;

    switch (key) {
      case "C-ENTER":
      case "TAB":
        box = getBox(window.getSelection().focusNode);
        if ((box.getAttribute('codeMainExpr')) != null) {
          return evalOutput(box.output);
        } else if ((box.getAttribute('codeMain')) != null) {
          return acceptCode(box);
        }
        break;
      case "M-ENTER":
        box = getBox(window.getSelection().focusNode);
        if ((box.getAttribute('codeMainExpr')) != null) {
          return clearOutputBox(box.output);
        }
    }
  };

  clearAst = function(box) {
    var cbox;

    cbox = getBox(box);
    return cbox != null ? cbox.ast = null : void 0;
  };

  oldBrackets = [null, Nil];

  cleanEmptyNodes = function(el) {
    var next, prev, _ref2;

    if (el.nodeType === 3 && (el.parentNode != null)) {
      return cleanEmptyNodes(el.parentNode);
    } else {
      prev = el.previousSibling;
      next = el.nextSibling;
      if (el.nodeType === 1 && el.textContent.trim() === '' && ((_ref2 = el.parentNode) != null ? _ref2.hasAttribute('doc') : void 0)) {
        el.parentNode.removeChild(el);
      }
      if (next === nextSibling(prev)) {
        return mergeLeisureCode(prev, next);
      }
    }
  };

  presentLeisureCode = function(node, doEval) {
    node.setAttribute('contentEditable', 'true');
    Notebook.bindNotebook(node);
    Notebook.changeTheme(node, 'thin');
    if (doEval) {
      return Notebook.evalDoc(node);
    } else {
      return Notebook.initNotebook(node);
    }
  };

  mergeLeisureCode = function(el1, el2) {
    var newCode, r;

    if (el1 && el2) {
      if (el1.nodeType === 1 && el2.nodeType === 3) {
        el1.appendChild(el2);
        return el1.normalize();
      } else if (el1.nodeType === 3 && el2.nodeType === 1) {
        el2.insertBefore(el1, el2.firstChild);
        return el2.normalize();
      } else if (el1.hasAttribute('leisureNode') && el1.getAttribute('leisureNode') === el2.getAttribute('leisureNode')) {
        newCode = textNode(el1.md = el1.getAttribute('leisureNode') === 'code' ? "" + (getElementCode(el1)) + "\n" + (getElementCode(el2)) : "" + el1.md + "\n" + el2.md);
        r = document.createRange();
        r.selectNodeContents(el2);
        el1.appendChild(textNode('\n'));
        el1.appendChild(r.extractContents());
        return el2.parentNode.removeChild(el2);
      }
    }
  };

  highlightPosition = function(e) {
    var ast, b, brackets, changed, i, node, parent, pos, r, ranges, s, span, _i, _j, _k, _len, _len1, _len2, _ref2, _ref3, _ref4;

    parent = null;
    s = window.getSelection();
    if (s.rangeCount) {
      if (cleanEmptyNodes(s.getRangeAt(0).startContainer)) {
        return;
      }
      focusBox(s.focusNode);
      parent = getBox(s.focusNode);
      if ((_ref2 = s.getRangeAt(0)) != null ? _ref2.collapsed : void 0) {
        if (!parent || isOutput(parent)) {
          return;
        }
        if (parent.parentNode && (ast = getAst(parent))) {
          r = s.getRangeAt(0);
          r.setStart(parent, 0);
          pos = getRangeText(r).length;
          changed = false;
          if (false) {
            brackets = Leisure.bracket(ast.leisureBase, pos);
            if (oldBrackets[0] !== parent || !oldBrackets[1].equals(brackets)) {
              oldBrackets = [parent, brackets];
              _ref3 = document.querySelectorAll("[LeisureBrackets]");
              for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
                node = _ref3[_i];
                unwrap(node);
              }
              _ref4 = parent.querySelectorAll(".partialApply");
              for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
                node = _ref4[_j];
                unwrap(node);
              }
              parent.normalize();
              markPartialApplies(parent);
              b = brackets;
              ranges = [];
              while (b !== Nil) {
                ranges.push(makeRange(parent, b.head().head(), b.head().tail().head()));
                b = b.tail();
              }
              for (i = _k = 0, _len2 = ranges.length; _k < _len2; i = ++_k) {
                r = ranges[i];
                span = document.createElement('span');
                span.setAttribute('LeisureBrackets', '');
                span.setAttribute('class', i === 0 ? 'LeisureFunc' : 'LeisureArg');
                wrapRange(r, span);
              }
              changed = true;
            }
          }
          if (e instanceof KeyboardEvent) {
            if (hideSlider()) {
              pos += 1;
            }
          } else if (e instanceof MouseEvent && e.type === 'mousedown' && (e.target === parent || parent.contains(e.target)) && showSliderButton(parent, pos, e)) {
            changed = true;
            pos += 1;
          }
          if (changed) {
            window.EVT = e;
            s.removeAllRanges();
            s.addRange(makeRange(parent, pos));
          }
        }
      }
      return peerNotifySelection(parent, s.toString());
    }
  };

  numberEnd = /(?:^|.*[^0-9.])([0-9]+\.?[0-9]*|\.[0-9]*)$/;

  numberStart = /^([0-9]+\.[0-9]+|[0-9]+|\.[0-9]+)/;

  slider = [];

  showSliderButton = function(parent, pos, e) {
    var changed, len, m, oldPos, r, sParent, sPos, sValue, span, text;

    if (slider.length) {
      hideSlider();
      return false;
    } else {
      text = parent.textContent;
      oldPos = pos;
      changed = 0;
      if (m = text.substring(0, pos).match(numberEnd)) {
        pos -= m[1].length;
      }
      if (m = text.substring(pos).match(numberStart)) {
        len = m[1].length;
        if (oldPos <= pos + len) {
          sParent = slider[0], sPos = slider[1], sValue = slider[2];
          if (parent !== sParent || pos !== sPos || m[1] !== sValue) {
            hideSlider();
            r = makeRange(parent, pos, pos + m[1].length);
            span = createNode("<span class='leisureRangeNumber ui-widget-content'></span>");
            wrapRange(r, span);
            changed = 1;
            span.normalize();
            slider = [parent, pos, m[1], span];
            createSlider();
          }
        }
        return changed;
      } else {
        return hideSlider();
      }
    }
  };

  isSlider = function(el) {
    while (el !== document) {
      if (el.hasAttribute('slider')) {
        return true;
      }
      el = el.parentNode;
    }
    return false;
  };

  createSlider = function() {
    var d, div, inside, max, min, parent, pos, sl, sliding, span, value;

    parent = slider[0], pos = slider[1], value = slider[2], span = slider[3], div = slider[4];
    if (div) {
      return;
    }
    inside = false;
    sliding = false;
    d = createNode("<div style='z-index: 1; position: absolute; width: 200px; background: white; border: solid green 1px' slider contentEditable='false'></div>");
    slider.push(d);
    d.style.top = "" + (span.offsetTop + span.offsetHeight + 5) + "px";
    d.style.minTop = '0px';
    d.style.left = "" + (Math.max(0, (span.offsetLeft + span.offsetWidth) / 2 - 100)) + "px";
    d.addEventListener('mouseover', function(e) {
      if (!inside) {
        return inside = true;
      }
    });
    d.addEventListener('mouseout', function(e) {
      if (e.toElement !== d && !d.contains(e.toElement)) {
        inside = false;
        if (!sliding) {
          return hideSlider();
        }
      }
    });
    value = Number(value);
    min = value < 0 ? value * 2 : value / 2;
    max = value === 0 ? 10 : value * 2;
    sl = $(d).slider({
      animate: 'fast',
      start: function() {
        sliding = true;
        return delay(function() {
          return allowEvents = false;
        });
      },
      stop: function(event, ui) {
        setMinMax(sl);
        allowEvents = true;
        sliding = false;
        if (!inside) {
          return hideSlider();
        }
      },
      slide: function(event, ui) {
        var ast, _ref2;

        if (span.firstChild) {
          span.firstChild.nodeValue = String(ui.value);
        }
        if (isDef(parent)) {
          parent.ast = null;
          acceptCode(parent);
          ast = getAst(parent);
          if ((_ref2 = parent.ast) != null ? _ref2.leisureName : void 0) {
            return update("sel-" + parent.ast.leisureName);
          }
        } else {
          makeId(parent);
          if (!parent.getAttribute(parent.output, 'leisureUpdate')) {
            setUpdate(parent.output, "id-" + parent.id + " compile", true);
          }
          update("id-" + parent.id);
          return update("compile");
        }
      },
      value: value
    });
    setMinMax(sl, value);
    parent.insertBefore(d, parent.firstChild);
    return d.focus();
  };

  psgn = function(x) {
    if (x < 0) {
      return -1;
    } else {
      return 1;
    }
  };

  setMinMax = function(sl, value) {
    var max, min, step, _ref2;

    value = value || sl.slider("value");
    min = 0;
    max = (1 <= (_ref2 = Math.abs(value)) && _ref2 < 50) || value === 0 ? 100 * psgn(value) : value * 2;
    if (Math.round(value) === value) {
      step = Math.round((max - min) / 100);
      step = step - step % (max - min);
    } else {
      step = (max - min) / 100;
    }
    sl.slider("option", "min", min);
    sl.slider("option", "max", max);
    return sl.slider("option", "step", step);
  };

  hideSlider = function() {
    var div, parent, sPos, sValue, span;

    if (slider.length) {
      parent = slider[0], sPos = slider[1], sValue = slider[2], span = slider[3], div = slider[4];
      unwrap(span);
      if (div) {
        remove(div);
      }
      parent.normalize();
      slider = [];
      return 2;
    } else {
      return 0;
    }
  };

  wrapRange = function(range, node) {
    var contents, err;

    try {
      return range.surroundContents(node);
    } catch (_error) {
      err = _error;
      contents = range.cloneContents();
      replaceRange(range, node);
      return node.appendChild(contents);
    }
  };

  replaceRange = function(range, node) {
    range.deleteContents();
    return range.insertNode(node);
  };

  getRangeText = function(r) {
    return r.cloneContents().textContent;
  };

  getBox = function(node) {
    while ((node != null) && ((typeof node.getAttribute === "function" ? node.getAttribute('LeisureBox') : void 0) == null)) {
      node = node.parentElement;
    }
    return node;
  };

  checkMutateFromModification = function(evt) {
    var b, b2;

    b = getBox(evt.target);
    b2 = getBox(window.getSelection().focusNode);
    if (b && b === b2) {
      if ((isDef(b)) && b.classList.contains('codeMainExpr')) {
        toDefBox(b);
      } else if (!(isDef(b)) && b.classList.contains('codeMain')) {
        toExprBox(b);
      }
      return replicate(b);
    }
  };

  replicate = function(b) {
    if (b.replicator) {
      return delay(function() {
        return b.replicator.replicate(b);
      });
    }
  };

  buttonClasses = 'ui-button ui-widget ui-state-default ui-corner-all ui-button-text-only'.split(' ');

  boxClasses = {
    codeMainExpr: ['codeMainExpr', 'ui-widget', 'ui-widget-content', 'ui-corner-all'],
    codeMain: ['codeMain', 'ui-widget', 'ui-widget-content', 'ui-corner-all'],
    codeMainTest: ['codeMainTest'],
    output: ['output', 'ui-widget', 'ui-widget-content', 'ui-corner-all']
  };

  addBoxClasses = function(box, type) {
    var cl, _i, _len, _ref2, _results;

    box.setAttribute(type, '');
    _ref2 = boxClasses[type];
    _results = [];
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      cl = _ref2[_i];
      _results.push(box.classList.add(cl));
    }
    return _results;
  };

  removeBoxClasses = function(box, type) {
    var cl, _i, _len, _ref2, _results;

    box.removeAttribute(type);
    _ref2 = boxClasses[type];
    _results = [];
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      cl = _ref2[_i];
      _results.push(box.classList.remove(cl));
    }
    return _results;
  };

  toExprBox = function(b) {
    var node, _i, _j, _len, _len1, _ref2, _ref3;

    removeBoxClasses(b, 'codeMain');
    addBoxClasses(b, 'codeMainExpr');
    _ref2 = b.querySelectorAll('[codename]');
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      node = _ref2[_i];
      unwrap(node);
    }
    _ref3 = b.querySelectorAll('.astbutton');
    for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
      node = _ref3[_j];
      remove(node);
    }
    return makeOutputBox(b);
  };

  toDefBox = function(b) {
    if (b.output) {
      remove(b.output);
    }
    removeBoxClasses(b, 'codeMainExpr');
    addBoxClasses(b, 'codeMain');
    return addDefControls(b);
  };

  addDefControls = function(box) {
    var btn;

    btn = createNode("<button onclick='Notebook.showAst(this.parentNode)' class='astbutton' title='Show AST'></button>");
    markupButton(btn);
    return box.appendChild(btn);
  };

  remove = function(node) {
    var _ref2;

    return (_ref2 = node.parentNode) != null ? _ref2.removeChild(node) : void 0;
  };

  showAst = function(box) {
    var name, node, output;

    name = (getAst(box)).leisureName;
    if (box.astOut != null) {
      remove(box.astOut.output);
      remove(box.astOut);
      return box.astOut = null;
    } else if (name != null) {
      node = codeBox('codeMainExpr');
      box.astOut = node;
      node.setAttribute('leisureOutput', '');
      box.parentNode.insertBefore(node, box.nextSibling);
      node.textContent = "#@update sel-" + name + "\ntreeForNotebook " + name;
      output = makeOutputBox(node);
      toggleEdit(output);
      return evalOutput(output, true);
    }
  };

  highlightNotebookFunction = function(funcName, start, stop) {
    var box, offset, sel;

    box = document.body.querySelector("[leisurefunc=" + funcName + "]");
    offset = 0;
    sel = window.getSelection();
    sel.removeAllRanges();
    return sel.addRange(makeRange(box, start + offset, stop + offset));
  };

  isDef = function(box) {
    var defType, leading, m, matched, name, txt;

    txt = box.textContent;
    if ((m = txt.match(L_defPat()))) {
      matched = m[0], leading = m[1], name = m[2], defType = m[3];
      return (defType != null ? defType.length : void 0) > 0;
    }
    return false;
  };

  initNotebook = function(el) {
    var pgm;

    el.replacing = true;
    removeOldDefs(el);
    pgm = markupDefs(el, findDefs(el));
    el.normalize();
    el.replacing = false;
    if (!el.hasAttribute('noLeisureBar')) {
      insertControls(el);
      el.testResults.innerHTML = pgm[2];
    }
    snapshot(el, pgm);
    return pgm;
  };

  makeLabel = function(text, c) {
    var node;

    node = document.createElement('SPAN');
    node.innerHTML = text;
    node.setAttribute('class', c);
    return node;
  };

  makeOption = function(name) {
    var opt;

    opt = document.createElement('OPTION');
    opt.text = name;
    return opt;
  };

  createNode = function(txt) {
    var scratch;

    scratch = document.createElement('DIV');
    scratch.innerHTML = txt;
    return scratch.firstChild;
  };

  createFragment = function(txt) {
    var frag, scratch;

    scratch = document.createElement('DIV');
    scratch.innerHTML = txt;
    frag = document.createDocumentFragment();
    while (scratch.firstChild) {
      frag.appendChild(scratch.firstChild);
    }
    return frag;
  };

  insertControls = function(el) {
    var controlDiv, saveButton, spacer, testButton, themeSelect, viewSelect, _ref2, _ref3;

    controlDiv = createNode("<div LeisureOutput contentEditable='false' class='leisure_bar'><div class=\"leisure_bar_contents\">\n  <button leisureId='saveButton' class=\"leisure_start\">Save</button>\n  <button leisureId='testButton'>Run Tests</button> <span leisureId='testResults' class=\"notrun\"></span>\n  <input type='checkbox' leisureId='autorunTests'><b>Auto</b></input>\n  <span class=\"leisure_theme\">Theme: </span>\n  <select leisureId='themeSelect'>\n    <option value=thin>Thin</option>\n    <option value=gaudy>Gaudy</option>\n    <option value=cthulhu>Cthulhu</option>\n  </select>\n  <span>View: </span>\n  <select leisureId='viewSelect'>\n    <option value=coding>Coding</option>\n    <option value=debugging>Debugging</option>\n    <option value=testing>Testing</option>\n    <option value=running>Running</option>\n  </select>\n</div>");
    spacer = createNode("<div LeisureOutput  contentEditable='false' class='leisure_space'></div>");
    el.insertBefore(spacer, el.firstChild);
    el.insertBefore(controlDiv, el.firstChild);
    _ref2 = getElements(el, ['downloadLink', 'viewLink', 'saveButton', 'testButton', 'testResults', 'autorunTests', 'themeSelect', 'viewSelect']), el.leisureDownloadLink = _ref2[0], el.leisureViewLink = _ref2[1], saveButton = _ref2[2], testButton = _ref2[3], el.testResults = _ref2[4], el.autorun = _ref2[5], themeSelect = _ref2[6], viewSelect = _ref2[7];
    controlDiv.addEventListener('click', function(evt) {
      if (document.body.classList.contains('hideControls')) {
        return document.body.classList.remove('hideControls');
      } else {
        return document.body.classList.add('hideControls');
      }
    });
    saveButton.addEventListener('click', function(evt) {
      return saveProgram(el);
    });
    testButton.addEventListener('click', function() {
      return runTests(el);
    });
    themeSelect.value = (_ref3 = el.leisureTheme) != null ? _ref3 : 'thin';
    themeSelect.addEventListener('change', function(evt) {
      return changeTheme(el, evt.target.value);
    });
    viewSelect.addEventListener('change', function(evt) {
      return changeView(el, evt.target.value);
    });
    el.autorun.checked = el.autorunState;
    el.autorun.addEventListener('change', function(evt) {
      el.autorunState = el.autorun.checked;
      if (el.autorunState) {
        return runTests(el);
      }
    });
    return markupButtons(controlDiv);
  };

  saveProgram = function() {
    return write(filename, getMDDocument(), (function() {
      return alert("Saving " + filename);
    }), function(err) {
      console.log(err);
      alert(err.stack);
      throw err;
    });
  };

  showFilename = function(el) {
    if (el && filename) {
      el.innerHTML = "Save: " + (filename.pathName());
      return el.title = filename.toString();
    }
  };

  showFilenames = function() {
    var node, _i, _len, _ref2, _results;

    _ref2 = document.body.querySelectorAll('[leisureId=saveButton]');
    _results = [];
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      node = _ref2[_i];
      _results.push(showFilename(node));
    }
    return _results;
  };

  setFilename = function(newName) {
    filename = newName instanceof URI ? newName : new URI(newName);
    return showFilenames();
  };

  markupButtons = function(el) {
    var btn, _i, _len, _ref2, _results;

    _ref2 = el.querySelectorAll('button');
    _results = [];
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      btn = _ref2[_i];
      _results.push(markupButton(btn));
    }
    return _results;
  };

  markupButton = function(btn) {
    var cl, _i, _len, _results;

    _results = [];
    for (_i = 0, _len = buttonClasses.length; _i < _len; _i++) {
      cl = buttonClasses[_i];
      _results.push(btn.classList.add(cl));
    }
    return _results;
  };

  getElements = function(el, ids) {
    var els, id, node, _i, _j, _len, _len1, _ref2, _results;

    els = {};
    _ref2 = el.querySelectorAll('[leisureId]');
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      node = _ref2[_i];
      els[node.getAttribute('leisureId')] = node;
    }
    _results = [];
    for (_j = 0, _len1 = ids.length; _j < _len1; _j++) {
      id = ids[_j];
      _results.push(els[id]);
    }
    return _results;
  };

  escapeHtml = function(str) {
    if (typeof str === 'string') {
      return str.replace(/[<>]/g, function(c) {
        switch (c) {
          case '<':
            return '&lt;';
          case '>':
            return '&gt;';
        }
      });
    } else {
      return str;
    }
  };

  loadProgram = function(el, files) {
    var fr;

    el = getBox;
    fr = new FileReader();
    fr.onloadend = function(evt) {
      el.innerHTML = escapeHtml(fr.result);
      return initNotebook(el);
    };
    return fr.readAsBinaryString(files.item(0));
  };

  configureSaveLink = function(el) {
    var blob, builder;

    window.URL = window.URL || window.webkitURL;
    builder = new WebKitBlobBuilder();
    builder.append(getElementCode(el));
    blob = builder.getBlob('text/plain');
    el.leisureDownloadLink.href = window.URL.createObjectURL(blob);
    return el.leisureViewLink.href = window.URL.createObjectURL(blob);
  };

  getElementCode = function(el) {
    var r;

    r = document.createRange();
    r.selectNode(el);
    c = r.cloneContents().firstChild;
    removeOldDefs(c);
    return c.textContent;
  };

  runTests = function(el) {
    var failed, passed, resultsClass, test, _i, _len, _ref2;

    passed = 0;
    failed = 0;
    _ref2 = el.querySelectorAll('.codeMainTest');
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      test = _ref2[_i];
      if (runTest(test)) {
        passed++;
      } else {
        failed++;
      }
    }
    if (el.testResults) {
      resultsClass = el.testResults.classList;
      resultsClass.remove('notrun');
      if (!failed) {
        resultsClass.remove('failed');
        resultsClass.add('passed');
        return el.testResults.innerHTML = passed;
      } else {
        resultsClass.remove('passed');
        resultsClass.add('failed');
        return el.testResults.innerHTML = "" + passed + "/" + failed;
      }
    }
  };

  changeTheme = function(el, value) {
    var theme;

    theme = value;
    el.leisureTheme = theme;
    return el.className = theme;
  };

  changeView = function(el, value) {
    debug = value === 'debugging';
    return alert('new view: ' + value + ", debug: " + debug);
  };

  unwrap = function(node) {
    var parent;

    parent = node.parentNode;
    if (parent) {
      while (node.firstChild != null) {
        parent.insertBefore(node.firstChild, node);
      }
      return parent.removeChild(node);
    }
  };

  removeOldDefs = function(el) {
    var extracted, m, node, txt, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref2, _ref3, _ref4;

    el.leisureDownloadLink = null;
    el.leisureViewLink = null;
    extracted = [];
    _ref2 = el.querySelectorAll("[LeisureOutput]");
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      node = _ref2[_i];
      remove(node);
    }
    _ref3 = el.querySelectorAll("[generatednl]");
    for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
      node = _ref3[_j];
      txt = node.lastChild;
      if (txt.nodeType === 3 && txt.data[txt.data.length - 1] === '\n') {
        txt.data = txt.data.substring(0, txt.data.length - 1);
      }
    }
    _ref4 = el.querySelectorAll("[Leisure]");
    for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
      node = _ref4[_k];
      if (addsLine(node) && (node.firstChild != null)) {
        extracted.push(node.firstChild);
      }
      unwrap(node);
    }
    for (_l = 0, _len3 = extracted.length; _l < _len3; _l++) {
      node = extracted[_l];
      if ((node.parentNode != null) && !addsLine(node) && (node.previousSibling != null) && !addsLine(node.previousSibling)) {
        node.parentNode.insertBefore(text('\n'), node);
      }
    }
    el.textContent = el.textContent.replace(/\uFEFF/g, '');
    txt = el.lastChild;
    if ((txt != null ? txt.nodeType : void 0) === 3 && (m = txt.data.match(/(^|[^\n])(\n+)$/))) {
      return txt.data = txt.data.substring(0, txt.data.length - m[2].length);
    }
  };

  markupDefs = function(el, defs) {
    var auto, bod, body, bx, def, i, main, name, notebookAutoNodes, pgm, s, test, tests, totalTests, _i, _j, _len, _len1, _ref2, _ref3;

    pgm = '';
    auto = '';
    totalTests = 0;
    notebookAutoNodes = [];
    for (_i = 0, _len = defs.length; _i < _len; _i++) {
      i = defs[_i];
      main = i.main, name = i.name, def = i.def, body = i.body, tests = i.tests;
      if (name) {
        bx = box(main, 'codeMain', true);
        bx.appendChild(codeSpan(name, 'codeName'));
        bx.appendChild(textNode(def));
        bod = codeSpan(textNode(body), 'codeBody');
        bod.appendChild(textNode('\n'));
        bod.setAttribute('generatedNL', '');
        bx.appendChild(bod);
        bx.addEventListener('blur', (function() {
          return evalDoc(el);
        }), true);
        markPartialApplies(bx);
        addDefControls(bx);
        pgm += "" + name + " " + def + " " + body + "\n";
      } else if (main != null) {
        bx = box(main, 'codeMainExpr', true);
        s = codeSpan(textNode(body), 'codeExpr');
        s.setAttribute('generatedNL', '');
        s.appendChild(textNode('\n'));
        bx.appendChild(s);
        markPartialApplies(bx);
        if (((_ref2 = main.leisureAuto) != null ? _ref2.mode : void 0) === 'silent') {
          auto += "" + body + "\n";
        } else {
          if (((_ref3 = main.leisureAuto) != null ? _ref3.mode : void 0) === 'notebook') {
            notebookAutoNodes.push(bx);
          }
          makeOutputBox(bx);
        }
      }
      for (_j = 0, _len1 = tests.length; _j < _len1; _j++) {
        test = tests[_j];
        replaceRange(test, makeTestBox(test.leisureTest));
        totalTests++;
      }
    }
    return [pgm, auto, totalTests, notebookAutoNodes];
  };

  getDefName = function(ast) {
    if (ast instanceof Leisure_anno && getAnnoName(ast) === 'definition') {
      return getAnnoData(ast);
    } else {
      return null;
    }
  };

  getAst = function(bx, def) {
    var defName, _ref2;

    if (bx.ast != null) {
      patchFuncAst(bx.ast);
      bx.setAttribute('leisureFunc', (_ref2 = bx.ast.leisureName) != null ? _ref2 : '');
      return bx.ast;
    } else {
      def = def || bx.textContent;
      defName = getDefName(runMonad(L_newParseLine()(function() {
        return Nil;
      })(function() {
        return def;
      })));
      setAst(bx, (defName ? {
        leisureName: defName,
        leisureSource: def
      } : {}));
      return bx.ast;
    }
  };

  setAst = function(bx, ast) {
    bx.ast = ast;
    return patchFuncAst(ast);
  };

  patchFuncAst = function(ast) {
    var parent;

    if ((ast != null ? ast.leisureName : void 0) != null) {
      parent = window[nameSub(ast.leisureName)];
      if (parent != null) {
        parent.ast = ast;
        parent.src = ast.leisureSource;
        return update("ast-" + ast.leisureName);
      }
    }
  };

  markPartialApplies = function(bx, def) {};

  textNode = function(text) {
    return document.createTextNode(text);
  };

  nodeFor = function(text) {
    if (typeof text === 'string') {
      return textNode(text);
    } else {
      return text;
    }
  };

  evalOutput = function(exBox, nofocus) {
    var selector, stopUpdates, updateSelector, _ref2;

    exBox = getBox(exBox);
    if (!nofocus) {
      focusBox(exBox);
    }
    cleanOutput(exBox, true);
    selector = findUpdateSelector(exBox.source);
    if (selector) {
      exBox.setAttribute('leisureUpdate', selector);
    }
    makeOutputControls(exBox);
    _ref2 = getElements(exBox.firstChild, ['chooseUpdate', 'stopUpdates']), updateSelector = _ref2[0], stopUpdates = _ref2[1];
    updateSelector.addEventListener('change', function(evt) {
      return setUpdate(exBox, evt.target.value, true);
    });
    updateSelector.addEventListener('keydown', function(e) {
      c = e.charCode || e.keyCode || e.which;
      if (c === ENTER) {
        e.preventDefault();
        return updateSelector.blur();
      }
    });
    updateSelector.value = (exBox.getAttribute('leisureUpdate')) || '';
    exBox.updateSelector = updateSelector;
    return evalBox(exBox.source, exBox);
  };

  findUpdateSelector = function(box) {
    var def, defType, leading, matched, name, u;

    if (def = box.textContent.match(L_defPat())) {
      matched = def[0], leading = def[1], name = def[2], defType = def[3];
      if (u = leading.match(updatePat)) {
        return u[3];
      }
    }
  };

  getExprSource = function(box) {
    var b, s;

    s = window.getSelection();
    b = getBox(s.focusNode);
    if (b !== box || !s.rangeCount || s.getRangeAt(0).collapsed) {
      return box.textContent;
    } else {
      return getRangeText(s.getRangeAt(0));
    }
  };

  setUpdate = function(el, channel, preserveSource) {
    var ast, def, defType, index, leading, matched, name, r, txt, u;

    el.setAttribute('leisureUpdate', channel);
    if (channel) {
      el.classList.add('ui-state-highlight');
    } else {
      el.classList.remove('ui-state-highlight');
    }
    ast = getAst(el.source);
    txt = el.source.textContent;
    if (!preserveSource && (def = txt.match(L_defPat()))) {
      matched = def[0], leading = def[1], name = def[2], defType = def[3];
      index = def.index;
      if (u = leading.match(updatePat)) {
        index += u.index + u[1].length + u[2].length;
        r = makeRange(el.source, index, index + u[3].length);
        r.deleteContents();
      } else {
        r = makeRange(el.source, index + leading.length, index + leading.length);
      }
      r.insertNode(textNode(channel));
      return el.source.normalize();
    }
  };

  hasMonadOutput = function(box) {
    var _ref2, _ref3;

    return ((_ref2 = box.firstElementChild) != null ? (_ref3 = _ref2.nextElementSibling) != null ? _ref3.nextElementSibling : void 0 : void 0) != null;
  };

  checkHideSource = function(box) {
    var hs;

    if (!box.hideOutputSource && hasMonadOutput(box)) {
      box.hideOutputSource = true;
      hs = createNode("<button class='editToggle' style='float:right'></button>");
      markupButton(hs);
      hs.addEventListener('click', function() {
        return toggleEdit(hs);
      });
      return box.firstElementChild.appendChild(hs);
    }
  };

  makeOutputControls = function(exBox) {
    if (exBox.firstChild.firstChild === exBox.firstChild.lastChild) {
      exBox.firstChild.insertBefore(createFragment("<button onclick='Notebook.clearOutputBox(this)'>X</button>"), exBox.firstChild.firstChild);
      exBox.firstChild.appendChild(createFragment("<button onclick='Notebook.makeTestCase(this)' leisureId='makeTestCase'>Make test\ncase</button><b>Update: </b><input type='text'\nplaceholder='Click for updating' list='channelList' leisureId='chooseUpdate'></input><button\nonclick='Notebook.clearUpdates(this)' leisureId='stopUpdates'>Stop Updates</button>"));
      markupButtons(exBox);
      return exBox.classList.add('fatControls');
    }
  };

  showOutputSource = function(output) {
    output.classList.remove('hidingSource');
    return output.source.style.display = '';
  };

  hideOutputSource = function(output) {
    output.classList.add('hidingSource');
    return output.source.style.display = 'none';
  };

  toggleEdit = function(toggleButton) {
    var output;

    output = getBox(toggleButton);
    if (output.classList.contains('hidingSource')) {
      return showOutputSource(output);
    } else {
      return hideOutputSource(output);
    }
  };

  clearUpdates = function(widget, preserveSource) {
    var exBox;

    exBox = getBox(widget);
    exBox.updateSelector.value = '';
    return setUpdate(exBox, '', preserveSource);
  };

  update = function(type, env) {
    var node, _i, _len, _ref2, _results;

    env = env != null ? env : defaultEnv;
    _ref2 = env.owner.querySelectorAll("[leisureUpdate~='" + type + "']");
    _results = [];
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      node = _ref2[_i];
      _results.push(evalOutput(node, true));
    }
    return _results;
  };

  clearOutputBox = function(exBox) {
    clearUpdates(exBox, true);
    return cleanOutput(exBox);
  };

  cleanOutput = function(exBox, preserveControls) {
    var fc, _results;

    exBox = getBox(exBox);
    exBox.classList.remove('fatControls');
    if (!preserveControls) {
      exBox.hideOutputSource = null;
      fc = exBox.firstChild;
      fc.removeChild(fc.firstChild);
      while (fc.firstChild !== fc.lastChild) {
        fc.removeChild(fc.lastChild);
      }
    }
    _results = [];
    while (exBox.firstChild !== exBox.lastChild) {
      _results.push(exBox.removeChild(exBox.lastChild));
    }
    return _results;
  };

  makeTestCase = function(exBox) {
    var box, output, source, test;

    output = getBox(exBox);
    source = output.source;
    test = {
      expr: source.textContent.trim(),
      expected: escapeHtml(Parse.print(output.result))
    };
    box = makeTestBox(test, owner(exBox));
    source.parentNode.insertBefore(box, source);
    remove(source);
    remove(output);
    box.parentNode.insertBefore(textNode('\uFEFF'), box);
    box.parentNode.insertBefore(textNode('\uFEFF'), box.nextSibling);
    if (owner(box).autorunState) {
      return clickTest(box);
    }
  };

  makeTestBox = function(test, owner, src) {
    var bx, s;

    src = src != null ? src : "#@test " + (JSON.stringify(test.expr)) + "\n#@expected " + (JSON.stringify(test.expected));
    s = codeSpan(src, 'codeTest');
    s.appendChild(textNode('\n'));
    s.setAttribute('generatedNL', '');
    bx = codeBox('codeMainTest');
    bx.testSrc = s;
    bx.setAttribute('class', 'codeMainTest notrun');
    bx.setAttribute('contenteditable', 'false');
    bx.appendChild(s);
    bx.addEventListener('click', (function() {
      return clickTest(bx);
    }), true);
    bx.test = test;
    return bx;
  };

  clickTest = function(bx) {
    var exprBox, r, sp;

    if (bx.classList.contains('notrun')) {
      return runTest(bx);
    } else {
      r = document.createRange();
      r.setStartBefore(bx);
      r.setEndAfter(bx);
      r.deleteContents();
      sp = codeSpan(bx.test.expr, 'codeExpr');
      sp.setAttribute('generatedNL', '');
      exprBox = box(r, 'codeMainExpr', true);
      exprBox.appendChild(sp);
      return makeOutputBox(exprBox);
    }
  };

  runTest = function(bx) {
    var passed, test;

    test = bx.test;
    passed = true;
    processLine(prepExpr(test.expr), {
      require: req,
      write: function(str) {
        return console.log(str);
      },
      debug: debug,
      prompt: function(msg, cont) {
        return cont(null);
      },
      processResult: function(result, ast) {
        return passed = showResult(bx, escapeHtml(String(result)), escapeHtml(test.expected));
      },
      err: function() {
        return passed = false;
      },
      presentValue: function(x) {
        return x;
      }
    }, identity);
    return passed;
  };

  showResult = function(bx, actual, expected) {
    var cl;

    cl = bx.classList;
    cl.remove('notrun');
    if (actual === expected) {
      cl.remove('failed');
      cl.add('passed');
      bx.testSrc.innerHTML = "#@test " + (JSON.stringify(bx.test.expr)) + "\n#@expected " + (JSON.stringify(bx.test.expected));
    } else {
      cl.remove('passed');
      cl.add('failed');
      bx.testSrc.innerHTML = "#@test " + (JSON.stringify(bx.test.expr)) + "\n#@expected " + (JSON.stringify(bx.test.expected)) + "\n#@result " + (JSON.stringify(actual));
      console.log("expected <" + expected + "> but got <" + actual + ">");
    }
    return actual === expected;
  };

  prepExpr = function(txt) {
    return txt;
  };

  envFor = function(box) {
    var env, exBox, widget;

    exBox = getBox(box);
    widget = null;
    env = {
      fileSettings: {},
      debug: debug,
      finishedEvent: function(evt, channel) {
        return update(channel != null ? channel : 'app', this);
      },
      owner: owner(box),
      box: box,
      require: req,
      write: function(msg) {
        var div;

        div = document.createElement('div');
        div.classList.add('outputDiv');
        div.innerHTML = "" + msg + "\n";
        exBox.appendChild(div);
        checkHideSource(exBox);
        return markupButtons(exBox);
      },
      getWidget: function() {
        if (!widget) {
          widget = document.createElement("DIV");
          exBox.appendChild(widget);
        }
        return widget;
      },
      destroyWidget: function() {
        if (widget) {
          return remove(widget);
        }
      },
      prompt: function(msg, cont) {
        return cont(window.prompt(msg));
      },
      processResult: function(result, ast) {
        box.result = result;
        return setAst(box, ast);
      },
      presentValue: presentValue,
      err: function(err) {
        var btn, _ref2;

        btn = box.querySelector('[leisureId="makeTestCase"]');
        if (btn) {
          remove(btn);
        }
        return this.write("<div class='errorDiv'>" + escapeHtml("ERROR: " + (err.leisureContext ? "" + err + ":\n" + (leisureContextString(err)) + "\n" : '') + ((_ref2 = err.stack) != null ? _ref2 : err)) + "</div>");
      },
      cleanup: function() {
        this.destroyWidget();
        if (root.lastEnv === env) {
          return root.lastEnv = null;
        }
      }
    };
    env.__proto__ = defaultEnv;
    env.fileSettings.uri = new URI(document.location.href);
    root.lastEnv = env;
    return env;
  };

  leisureContextString = function(err) {
    var func, offset;

    return ((function() {
      var _i, _len, _ref2, _ref3, _results;

      _ref2 = err.leisureContext.toArray();
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        _ref3 = _ref2[_i], func = _ref3[0], offset = _ref3[1];
        _results.push(linkSource(func, offset));
      }
      return _results;
    })()).join('\n');
  };

  linkSource = function(funcName, offset) {};

  showSource = function(funcName, offset) {};

  makeOutputBox = function(source) {
    var cl, node, _i, _len, _ref2;

    node = document.createElement('div');
    node.setAttribute('LeisureOutput', '');
    node.setAttribute('Leisure', '');
    node.setAttribute('LeisureBox', '');
    _ref2 = boxClasses.output;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      cl = _ref2[_i];
      node.classList.add(cl);
    }
    node.setAttribute('contentEditable', 'false');
    node.source = source;
    source.output = node;
    node.innerHTML = "<div class='controls'><button onclick='Notebook.evalOutput(this)'>-&gt;</button></div>";
    markupButtons(node);
    source.parentNode.insertBefore(node, source.nextSibling);
    return node;
  };

  codeSpan = function(text, boxType) {
    var node;

    node = document.createElement('span');
    node.setAttribute(boxType, '');
    node.setAttribute('Leisure', '');
    node.setAttribute('class', boxType);
    if (text) {
      node.appendChild(nodeFor(text));
    }
    return node;
  };

  codeBox = function(boxType) {
    var node;

    node = document.createElement('div');
    addBoxClasses(node, boxType);
    node.setAttribute('LeisureBox', '');
    node.setAttribute('Leisure', '');
    node.addEventListener('compositionstart', function(e) {
      return checkMutateFromModification(e);
    });
    return node;
  };

  box = function(range, boxType, empty) {
    var node;

    node = codeBox(boxType);
    if (empty) {
      range.deleteContents();
    } else {
      node.appendChild(range.extractContents());
    }
    range.insertNode(node);
    return node;
  };

  linePat = new RegExp("(" + (L_linePat().source) + ")");

  findDefs = function(el) {
    var def, ranges, rest, rng, txt;

    txt = el.textContent;
    rest = txt;
    ranges = [];
    console.log("FIND DEFS IN " + txt);
    while ((def = rest.match(L_unanchoredDefPat())) && def[1].length !== rest.length) {
      console.log("def: " + def);
      rng = getRanges(el, txt, rest, def, txt.length - rest.length);
      if (rng) {
        rest = rng.next;
        if (rng) {
          ranges.push(rng);
        } else {
          break;
        }
      } else {
        break;
      }
    }
    return ranges;
  };

  testPat = /(#@test([^\n]*)\n#@expected([^\n]*))\n/m;

  getRanges = function(el, txt, rest, def, restOff) {
    var body, bodyStart, defType, endPat, ex, exEnd, leadOff, leading, leadingSpaces, lm, m, m2, mainEnd, mainStart, matchStart, matched, name, nameEnd, nameRaw, next, outerRange, r, rest1, t, tOff, tests, textStart, _ref2, _ref3, _ref4, _ref5;

    _ref2 = m = def, matched = _ref2[0], leading = _ref2[1], nameRaw = _ref2[2], defType = _ref2[3];
    if (!rest.trim()) {
      return null;
    } else if (m == null) {
      return [makeRange(el, restOff, txt.length), null, null, [], ''];
    } else {
      tests = [];
      matchStart = restOff + m.index;
      if (defType == null) {
        name = null;
      } else if (nameRaw[0] === ' ') {
        name = null;
        defType = null;
      } else {
        name = nameRaw.trim() || null;
      }
      rest1 = rest.substring((defType ? matched : leading).length);
      endPat = rest1.match(/\n+[^\s]|\n?$/);
      next = endPat ? rest1.substring(endPat.index) : rest1;
      mainEnd = txt.length - next.length;
      t = leading;
      leadOff = tOff = restOff;
      while (m2 = t.match(testPat)) {
        r = makeRange(el, tOff + m2.index, tOff + m2.index + m2[1].length);
        r.leisureTest = {
          expr: JSON.parse(m2[2]),
          expected: JSON.parse(m2[3])
        };
        tests.push(r);
        tOff += m2.index + m2[1].length;
        t = leading.substring(tOff - leadOff);
      }
      if (name) {
        mainStart = matchStart + ((_ref3 = leading != null ? leading.length : void 0) != null ? _ref3 : 0);
        nameEnd = mainStart + name.length;
        leadingSpaces = (rest1.match(/^\s*/))[0].length;
        bodyStart = txt.length - (rest1.length - leadingSpaces);
        outerRange = makeRange(el, mainStart, mainEnd);
        return {
          main: outerRange,
          name: txt.substring(mainStart, nameEnd),
          def: defType,
          body: txt.substring(bodyStart, mainEnd),
          tests: tests,
          next: next
        };
      } else {
        mainStart = defType === '=' ? restOff + m.index + m[0].length : matchStart + ((_ref4 = leading != null ? leading.length : void 0) != null ? _ref4 : 0);
        ex = txt.substring(mainStart, mainEnd).match(/^(.*[^ \n])[ \n]*$/);
        exEnd = ex ? mainStart + ex[1].length : mainEnd;
        body = txt.substring(mainStart, exEnd);
        if (body.trim()) {
          textStart = restOff + m.index + (t ? leading.length - t.length : 0);
          if ((t != null) && (lm = t.match(/^[ \n]+/))) {
            textStart += lm[0].length;
          }
          console.log("CHECKING AUTO...");
          if (m = t.match(/(?:^|\n)#@auto( +[^\n]*)?(\n|$)/)) {
            outerRange = makeRange(el, textStart, exEnd);
            outerRange.leisureAuto = JSON.parse("{" + ((_ref5 = m[1]) != null ? _ref5 : '') + "}");
            if (outerRange.leisureAuto.mode === 'notebook') {
              outerRange.leisureNode = el;
              outerRange.leisureStart = textStart;
            }
            console.log("Auto expr: " + (txt.substring(textStart, exEnd)) + ", attrs: " + m[1]);
            return {
              main: outerRange,
              name: null,
              def: null,
              body: txt.substring(textStart, exEnd),
              tests: tests,
              fullText: txt.substring(textStart, exEnd),
              next: next
            };
          } else {
            outerRange = makeRange(el, textStart, exEnd);
            return {
              main: outerRange,
              name: null,
              def: null,
              body: txt.substring(textStart, exEnd),
              tests: tests,
              next: next
            };
          }
        } else {
          return {
            main: null,
            name: null,
            def: null,
            body: null,
            tests: tests,
            next: next
          };
        }
      }
    }
  };

  makeRange = function(el, off1, off2) {
    var node, offset, range, _ref2, _ref3;

    range = document.createRange();
    _ref2 = grp(el, off1, false), node = _ref2[0], offset = _ref2[1];
    if ((offset != null) && offset > 0) {
      range.setStart(node, offset);
    } else {
      range.setStartBefore(node);
    }
    if (off2 != null) {
      _ref3 = grp(el, off2, true), node = _ref3[0], offset = _ref3[1];
      if (offset != null) {
        range.setEnd(node, offset);
      } else {
        range.setEndAfter(node);
      }
    }
    return range;
  };

  grp = function(node, charOffset, end) {
    var child, offset, ret, _ref2;

    _ref2 = ret = getRangePosition(node.firstChild, charOffset, end), child = _ref2[0], offset = _ref2[1];
    if (child) {
      return ret;
    } else if (node.lastChild) {
      return nodeEnd(node.lastChild);
    } else {
      return [node, end ? 1 : 0];
    }
  };

  getRangePosition = function(node, charOffset, end) {
    var newNode, newOff, ret, _ref2;

    if (!node) {
      return [null, charOffset];
    } else if (node.nodeType === 3) {
      if (node.length > (end ? charOffset - 1 : charOffset)) {
        return [node, charOffset];
      } else {
        ret = continueRangePosition(node, charOffset - node.length, end);
        return ret;
      }
    } else if (node.nodeName === 'BR') {
      if (charOffset === (end ? 1 : 0)) {
        return [node];
      } else {
        return continueRangePosition(node, charOffset, end);
      }
    } else if (node.firstChild != null) {
      _ref2 = getRangePosition(node.firstChild, charOffset, end), newNode = _ref2[0], newOff = _ref2[1];
      if (newNode != null) {
        return [newNode, newOff];
      } else {
        return continueRangePosition(node, newOff, end);
      }
    } else {
      return continueRangePosition(node, charOffset, end);
    }
  };

  continueRangePosition = function(node, charOffset, end) {
    var newOff;

    newOff = charOffset - ((addsLine(node)) || ((node.nextSibling != null) && (addsLine(node.nextSibling))) ? 1 : 0);
    if (end && (newOff === 1 || charOffset === 1)) {
      return nodeEnd(node);
    } else if (node.nextSibling != null) {
      return getRangePosition(node.nextSibling, newOff, end);
    } else {
      return continueRangePosition(node.parentNode, newOff, end);
    }
  };

  nodeEnd = function(node) {
    return [node, node.nodeType === 3 ? node.length : node.childNodes.length - 1];
  };

  addsLine = function(node) {
    return (node != null ? node.nodeType : void 0) === 1 && (node.nodeName === 'BR' || (getComputedStyle(node, null).display === 'block' && node.childNodes.length > 0));
  };

  req = function(file, cont) {
    var name, s;

    if (!(file.match(/\.js$/))) {
      file = "" + file + ".js";
    }
    name = file.substring(0, file.length - 3);
    s = document.createElement('script');
    s.setAttribute('src', file);
    s.addEventListener('load', function() {
      Leisure.processDefs(global[name], global);
      if (cont) {
        return cont(L_false());
      }
    });
    return document.head.appendChild(s);
  };

  postLoadQueue = [];

  loaded = false;

  queueAfterLoad = function(func) {
    if (loaded) {
      return func();
    } else {
      return postLoadQueue.push(func);
    }
  };

  /*
  # handle focus manually, because grabbing focus and blur events doesn't seem to work for the parent
  */


  docFocus = null;

  codeFocus = null;

  findCurrentCodeHolder = function() {
    var _ref2;

    return focusBox((_ref2 = window.getSelection()) != null ? _ref2.focusNode : void 0);
  };

  focusBox = function(box) {
    var newCode, old, _ref2;

    newCode = null;
    while (box && (box.nodeType !== 1 || !isLeisureCode(box))) {
      if (box.nodeType === 1 && ((box.getAttribute('LeisureBox')) != null)) {
        newCode = box;
      }
      box = box.parentNode;
    }
    if (box !== docFocus) {
      if (docFocus != null) {
        docFocus.classList.remove('focused');
      }
      docFocus = box;
      if (box != null) {
        if ((_ref2 = box.classList) != null) {
          _ref2.add('focused');
        }
      }
    }
    if (newCode !== codeFocus) {
      old = codeFocus;
      codeFocus = newCode;
      if (old) {
        return acceptCode(old);
      }
    }
  };

  owner = function(box) {
    while (box && (box.nodeType !== 1 || !isLeisureCode(box))) {
      box = box.parentNode;
    }
    return box;
  };

  evalBox = function(box, envBox) {
    var env;

    env = envBox != null ? envFor(envBox) : null;
    processLine(box.textContent, env, function() {
      return env != null ? typeof env.cleanup === "function" ? env.cleanup() : void 0 : void 0;
    });
    getAst(box);
    if (box.output && hasMonadOutput(box.output) && box.textContent.match(/(^|\n)#@hidden *(\n|$)/)) {
      return hideOutputSource(box.output);
    }
  };

  acceptCode = function(box) {
    if ((box.getAttribute('codemain')) != null) {
      evalBox(box);
      update('compile');
      if (owner(box).autorunState) {
        return runTests(owner(box));
      }
    }
  };

  errString = function(err) {
    return err.stack;
  };

  evalDoc = function(el) {
    var auto, autoNodes, e, err, pgm, x, _ref2;

    _ref2 = initNotebook(el), pgm = _ref2[0], auto = _ref2[1], x = _ref2[2], autoNodes = _ref2[3];
    try {
      if (auto || autoNodes) {
        auto = "do\n  " + ((auto != null ? auto : '#\n').trim().replace(/\n/g, '\n  ')) + "\n  finishLoading 'fred'";
        global.noredefs = false;
        Notebook.queueAfterLoad(function() {
          var node, _i, _len, _results;

          evalDocCode(el, pgm);
          if (el.autorunState) {
            runTests(el);
          }
          _results = [];
          for (_i = 0, _len = autoNodes.length; _i < _len; _i++) {
            node = autoNodes[_i];
            console.log("evalOutput", node, node.output);
            _results.push(evalOutput(node.output));
          }
          return _results;
        });
        e = envFor(el);
        e.write = function() {};
        e.err = function(err) {
          return alert('bubba ' + errString(err));
        };
        return processLine(auto, e, identity);
      } else {
        return evalDocCode(el, pgm);
      }
    } catch (_error) {
      err = _error;
      return showError(err, "Error compiling " + pgm);
    }
  };

  processLine = function(text, env, cont) {
    var err;

    if (text) {
      try {
        return runMonad(L_newParseLine()(function() {
          return Nil;
        })(function() {
          return text;
        }), env, function(ast) {
          var err, result;

          try {
            result = eval("(" + (gen(ast)) + ")");
            if (isMonad(result)) {
              console.log("INTERMEDIATE RESULT");
              return runMonad(result, env, function(result) {
                console.log("RESULT: " + result);
                env.processResult(result);
                return cont(result);
              });
            } else {
              console.log("DIRECT RESULT: " + result);
              env.write(env.presentValue(result));
              if (typeof env.processResult === "function") {
                env.processResult(result);
              }
              return cont(result);
            }
          } catch (_error) {
            err = _error;
            return cont(err.stack);
          }
        });
      } catch (_error) {
        err = _error;
        return cont(err.stack);
      }
    } else {
      return cont('');
    }
  };

  showError = function(e, msg) {
    console.log(msg);
    console.log(e);
    console.log(e.stack);
    return alert(e.stack);
  };

  evalDocCode = function(el, pgm) {
    return runMonad(L_runFile(function() {
      return pgm;
    }), defaultEnv, function(result) {
      var node, _i, _len, _ref2, _results;

      _ref2 = el.querySelectorAll('[codeMain]');
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        node = _ref2[_i];
        _results.push(getAst(node));
      }
      return _results;
    });
  };

  define('getDocument', function() {
    return makeSyncMonad(function(env, cont) {
      return cont(peerGetDocument());
    });
  });

  define('getLink', function() {
    return 0;
  });

  define('replaceDocument', function() {
    return function(str) {
      return makeSyncMonad(function(env, cont) {
        replaceContents(str());
        return cont(L_true());
      });
    };
  });

  define('gdriveOpen', function() {
    return makeMonad(function(env, cont) {
      return GdriveStorage.runOpen(function(json) {
        var _ref2;

        if ((json != null ? json.action : void 0) === 'picked' && ((_ref2 = json.docs) != null ? _ref2.length : void 0) > 0) {
          return GdriveStorage.loadFile(json.docs[0].id, function() {
            return cont(_some()(laz(json.docs[0].title)));
          });
        } else {
          return cont(_none());
        }
      });
    });
  });

  define('getFilename', function() {
    return makeSyncMonad(function(env, cont) {
      var _ref2;

      return cont((_ref2 = filename != null ? filename.pathName() : void 0) != null ? _ref2 : '');
    });
  });

  define('setURI', function() {
    return function(uri) {
      return makeSyncMonad(function(env, cont) {
        setFilename(uri());
        return cont(L_true());
      });
    };
  });

  define('getURI', function() {
    return makeSyncMonad(function(env, cont) {
      var _ref2;

      return cont((_ref2 = filename != null ? filename.toString() : void 0) != null ? _ref2 : '');
    });
  });

  define('finishLoading', function() {
    return function(bubba) {
      return makeSyncMonad(function(env, cont) {
        var i, _i, _len;

        loaded = true;
        for (_i = 0, _len = postLoadQueue.length; _i < _len; _i++) {
          i = postLoadQueue[_i];
          i();
        }
        postLoadQueue = [];
        return cont(L_false());
      });
    };
  });

  define('markupButtons', function() {
    return makeSyncMonad(function(env, cont) {
      if (env.box) {
        markupButtons(env.box);
      }
      return cont(L_false());
    });
  });

  define('alert', function() {
    return function(str) {
      return makeSyncMonad(function(env, cont) {
        window.alert(str());
        return cont(L_false());
      });
    };
  });

  define('bindEvent', function() {
    return function(selector) {
      return function(eventName) {
        return function(func) {
          return makeSyncMonad(function(env, cont) {
            var node;

            node = env.box.querySelector(selector());
            if (node) {
              node.addEventListener(eventName(), function(e) {
                return runMonad(func()(laz(e)), envFor(e.target), function() {});
              });
            }
            return cont(L_false());
          });
        };
      };
    };
  });

  define('quit', function() {
    return window.close();
  });

  define('config', function() {
    return function(expr) {
      return makeSyncMonad(function(env, cont) {
        switch (expr()) {
          case 'autoTest':
            autoRun(env.owner, true);
        }
        return cont(L_false());
      });
    };
  });

  define('notebookSelection', function() {
    return function(func) {
      return makeSyncMonad(function(env, cont) {
        var bx, offset, p1, p2, r, r2, sel;

        sel = window.getSelection();
        bx = getBox(sel.focusNode);
        if ((bx != null) && hasFunc(bx, func)) {
          offset = 0;
          r = sel.getRangeAt(0);
          window.r = r;
          r2 = document.createRange();
          r2.setStart(bx, 0);
          r2.setEnd(r.startContainer, r.startOffset);
          p1 = r2.cloneContents().textContent.length - offset;
          if (!r.collapsed) {
            r2.setEnd(r.endContainer, r.endOffset);
          }
          p2 = r2.cloneContents().textContent.length - offset;
          return cont(_some2()(function() {
            return p1;
          })(function() {
            return p2;
          }));
        } else {
          return cont(_none());
        }
      });
    };
  });

  hasFunc = function(bx, func) {
    var ast;

    ast = getAst(bx);
    return ast === func().ast || ast === func.ast;
  };

  define('notebookAst', function() {
    return function(func) {
      return makeSyncMonad(function(env, cont) {
        var ast, node;

        if (func.leisureName != null) {
          node = document.querySelector("[LeisureFunc=" + func.leisureName + "]");
          if (node != null) {
            ast = getAst(node);
            return cont(_some()(function() {
              return ast;
            }));
          }
        }
        return cont(_none());
      });
    };
  });

  autoRun = function(el, state) {
    var _ref2;

    el.autorunState = state;
    return (_ref2 = el.autorun) != null ? _ref2.checked = state : void 0;
  };

  head = function(l) {
    return l(function() {
      return function(hh) {
        return function(tt) {
          return hh();
        };
      };
    });
  };

  tail = function(l) {
    return l(function() {
      return function(hh) {
        return function(tt) {
          return tt();
        };
      };
    });
  };

  id = function(v) {
    return v();
  };

  laz = Leisure.laz;

  getSvgElement = function(id) {
    var el, svg;

    if ((el = document.getElementById(id))) {
      return el;
    } else {
      svg = createNode("<svg id='HIDDEN_SVG' xmlns='http://www.w3.org/2000/svg' version='1.1' style='top: -100000; position: absolute'><text id='HIDDEN_TEXT'>bubba</text></svg>");
      document.body.appendChild(svg);
      return document.getElementById(id);
    }
  };

  svgMeasureText = function(text) {
    return function(style) {
      return function(f) {
        var bx, txt;

        txt = getSvgElement('HIDDEN_TEXT');
        if (style()) {
          txt.setAttribute('style', style());
        }
        txt.lastChild.textContent = text();
        bx = txt.getBBox();
        return f()(laz(bx.width))(laz(bx.height));
      };
    };
  };

  primconcatNodes = function(nodes) {
    if (nodes === _nil()) {
      return "";
    } else {
      return (head(nodes))(id) + concatNodes(tail(nodes));
    }
  };

  transformedPoint = function(pt, x, y, ctm, ictm) {
    pt.x = x;
    pt.y = y;
    return pt.matrixTransform(ctm).matrixTransform(ictm);
  };

  svgMeasure = function(content) {
    return primSvgMeasure(content, baseStrokeWidth);
  };

  svgBetterMeasure = function(content) {
    return primSvgMeasure(content, transformStrokeWidth);
  };

  primSvgMeasure = function(content, transformFunc) {
    return function(f) {
      var bbox, g, pad, svg;

      svg = createNode("<svg xmlns='http://www.w3.org/2000/svg' version='1.1' style='top: -100000'><g>" + (content()) + "</g></svg>");
      document.body.appendChild(svg);
      g = svg.firstChild;
      bbox = g.getBBox();
      pad = getMaxStrokeWidth(g, g, svg, transformFunc);
      document.body.removeChild(svg);
      return f()(laz(bbox.x - Math.ceil(pad / 2)))(laz(bbox.y - Math.ceil(pad / 2)))(laz(bbox.width + pad))(laz(bbox.height + pad));
    };
  };

  baseElements = ['path', 'rect', 'circle', 'ellipse', 'line', 'polyline', 'polygon'];

  getMaxStrokeWidth = function(el, base, svg, transformFunc) {
    var _ref2, _ref3;

    if (_ref2 = base.nodeName, __indexOf.call(baseElements, _ref2) >= 0) {
      svg.setAttribute('width', (_ref3 = getComputedStyle(base).strokeWidth) != null ? _ref3 : '0', svg);
      return transformFunc(el, svg.width.baseVal.value);
    } else if (base.nodeName === 'use') {
      return getMaxStrokeWidth(base, base.instanceRoot.correspondingElement, svg, transformFunc);
    } else if (base.nodeName === 'g') {
      return foldLeft((function(v, n) {
        return Math.max(v, getMaxStrokeWidth(n, n, svg, transformFunc));
      }), 0, el.childNodes);
    } else {
      return 0;
    }
  };

  baseStrokeWidth = function(el, w) {
    return w;
  };

  transformStrokeWidth = function(el, w) {
    var ctm, tp1, tp2, x, y;

    if (w === 0) {
      return 0;
    } else {
      ctm = el.getScreenCTM();
      tp1 = transformedPoint(pt, bx.x - Math.ceil(w), bx.y - Math.ceil(w), ctm, isctm);
      tp2 = transformedPoint(pt, bx.x + bx.width + Math.ceil(w), bx.y + bx.height + Math.ceil(w), ctm, isctm);
      x = tp2.x - tp1.x;
      y = tp2.y - tp1.y;
      return Math.sqrt(x * x + y * y);
    }
  };

  previousSibling = function(node) {
    while ((node != null ? node.parentNode : void 0) && !node.previousSibling) {
      node = node.parentNode;
    }
    return node != null ? node.previousSibling : void 0;
  };

  nextSibling = function(node) {
    while ((node != null ? node.parentNode : void 0) && !node.nextSibling) {
      node = node.parentNode;
    }
    return node != null ? node.nextSibling : void 0;
  };

  hideControlSection = function() {
    var controlSection;

    controlSection = document.body.querySelector('[leisureSection="Leisure Controls"]');
    if (!controlSection) {
      controlSection = document.createElement('DIV');
      document.body.insertBefore(controlSection, document.body.firstChild);
      root.markupElement(controlSection, "# Leisure Controls\n\n## File Save and Load\n```\nsaveFile\n\nsaveAs 'filename'\n\nsaveAs pickFile\n\nloadFile\n\nemptyFile\n```");
      unwrap(controlSection);
    }
    controlSection.classList.add(leisure_controls);
    return controlSection.classList.add(hidden);
  };

  define('printValue', function() {
    return function(value) {
      return makeMonad(function(env, cont) {
        if (value() !== L_nil()) {
          env.write("" + (env.presentValue(value())) + "\n");
        }
        return cont(L_false());
      });
    };
  });

  defaultEnv.require = req;

  root.svgMeasureText = svgMeasureText;

  root.svgMeasure = svgMeasure;

  root.initNotebook = initNotebook;

  root.bindNotebook = bindNotebook;

  root.bindAll = bindAll;

  root.evalOutput = evalOutput;

  root.makeTestCase = makeTestCase;

  root.cleanOutput = cleanOutput;

  root.clearOutputBox = clearOutputBox;

  root.envFor = envFor;

  root.queueAfterLoad = queueAfterLoad;

  root.evalDoc = evalDoc;

  root.getBox = getBox;

  root.makeRange = makeRange;

  root.grp = grp;

  root.changeTheme = changeTheme;

  root.setSnapper = setSnapper;

  root.update = update;

  root.clearUpdates = clearUpdates;

  root.showAst = showAst;

  root.toggleEdit = toggleEdit;

  root.showSource = showSource;

  root.bootNotebook = bootNotebook;

  root.createNode = createNode;

  root.ENTER = ENTER;

  root.textNode = textNode;

  root.cleanEmptyNodes = cleanEmptyNodes;

  root.isLeisureCode = isLeisureCode;

  root.getElementCode = getElementCode;

  root.runTests = runTests;

  root.previousSibling = previousSibling;

  root.nextSibling = nextSibling;

  root.presentLeisureCode = presentLeisureCode;

  root.mergeLeisureCode = mergeLeisureCode;

  root.highlightNotebookFunction = highlightNotebookFunction;

  root.ESC = ESC;

  root.HOME = HOME;

  root.END = END;

  root.PAGE_UP = PAGE_UP;

  root.PAGE_DOWN = PAGE_DOWN;

  root.LEFT_ARROW = LEFT_ARROW;

  root.UP_ARROW = UP_ARROW;

  root.RIGHT_ARROW = RIGHT_ARROW;

  root.DOWN_ARROW = DOWN_ARROW;

  root.arrows = arrows;

  root.closeWindow = closeWindow;

  root.markupButton = markupButton;

  root.markupButtons = markupButtons;

  root.getAst = getAst;

  root.insertControls = insertControls;

  root.delay = delay;

  root.setFilename = setFilename;

  root.unwrap = unwrap;

  root.remove = remove;

  root.wrapRange = wrapRange;

  root.replaceContents = replaceContents;

}).call(this);

/*
*/

})(self)
},{"./ast":1,"./gen":4,"./runtime":10}],10:[function(require,module,exports){
(function(process,global){// Generated by CoffeeScript 1.6.2
/*
Copyright (C) 2013, Bill Burdick, Tiny Concepts: https://github.com/zot/Leisure

(licensed with ZLIB license)

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software
in a product, an acknowledgment in the product documentation would be
appreciated but is not required.

2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.

3. This notice may not be removed or altered from any source distribution.
*/


(function() {
  var Monad, Nil, ast2Json, asyncMonad, booleanFor, cons, consFrom, continueMonads, defaultEnv, define, ensureLeisureClass, getDataType, getMonadSyncMode, getType, getValue, head, identity, isMonad, left, makeMonad, makeSyncMonad, monadModeSync, newRunMonad, nextMonad, none, parensContent, parensEnd, parensStart, readFile, replaceErr, right, root, runMonad, setDataType, setType, setValue, setWarnAsync, some, strCoord, strFromList, strToList, tail, tokenPos, tokenString, values, warnAsync, withSyncModeDo, _, _false, _identity, _ref, _true;

  readFile = (root = module.exports = require('./base')).readFile;

  _ref = require('./ast'), define = _ref.define, consFrom = _ref.consFrom, cons = _ref.cons, Nil = _ref.Nil, head = _ref.head, tail = _ref.tail, getType = _ref.getType, getDataType = _ref.getDataType, ast2Json = _ref.ast2Json, ensureLeisureClass = _ref.ensureLeisureClass, setType = _ref.setType, setDataType = _ref.setDataType;

  _ = require('./lodash.min');

  identity = function(x) {
    return x;
  };

  _identity = function(x) {
    return x();
  };

  _true = setType((function(a) {
    return function(b) {
      return a();
    };
  }), 'true');

  _false = setType((function(a) {
    return function(b) {
      return b();
    };
  }), 'false');

  left = function(x) {
    return setType((function(lCase) {
      return function(rCase) {
        return lCase()(function() {
          return x;
        });
      };
    }), 'left');
  };

  right = function(x) {
    return setType((function(lCase) {
      return function(rCase) {
        return rCase()(function() {
          return x;
        });
      };
    }), 'right');
  };

  some = function(x) {
    return setType((function(someCase) {
      return function(noneCase) {
        return someCase()(function() {
          return x;
        });
      };
    }), 'some');
  };

  none = setType((function(someCase) {
    return function(noneCase) {
      return noneCase();
    };
  }), 'none');

  booleanFor = function(bool) {
    if (bool) {
      return L_true();
    } else {
      return L_false();
    }
  };

  define('eq', function() {
    return function(a) {
      return function(b) {
        return booleanFor(a() === b());
      };
    };
  });

  define('==', function() {
    return function(a) {
      return function(b) {
        return booleanFor(a() === b());
      };
    };
  });

  define('hasType', function() {
    return function(data) {
      return function(func) {
        return booleanFor(getType(data()) === getDataType(func()));
      };
    };
  });

  define('+', function() {
    return function(x) {
      return function(y) {
        return x() + y();
      };
    };
  });

  define('-', function() {
    return function(x) {
      return function(y) {
        return x() - y();
      };
    };
  });

  define('*', function() {
    return function(x) {
      return function(y) {
        return x() * y();
      };
    };
  });

  define('/', function() {
    return function(x) {
      return function(y) {
        return x() / y();
      };
    };
  });

  define('%', function() {
    return function(x) {
      return function(y) {
        return x() % y();
      };
    };
  });

  define('<', function() {
    return function(x) {
      return function(y) {
        return booleanFor(x() < y());
      };
    };
  });

  define('<=', function() {
    return function(x) {
      return function(y) {
        return booleanFor(x() <= y());
      };
    };
  });

  define('>', function() {
    return function(x) {
      return function(y) {
        return booleanFor(x() > y());
      };
    };
  });

  define('>=', function() {
    return function(x) {
      return function(y) {
        return booleanFor(x() >= y());
      };
    };
  });

  define('floor', function() {
    return function(x) {
      return Math.floor(x());
    };
  });

  define('ceil', function() {
    return function(x) {
      return Math.ceil(x());
    };
  });

  define('min', function() {
    return function(x) {
      return function(y) {
        return Math.min(x(), y());
      };
    };
  });

  define('max', function() {
    return function(x) {
      return function(y) {
        return Math.max(x(), y());
      };
    };
  });

  define('round', function() {
    return function(x) {
      return Math.round(x());
    };
  });

  define('abs', function() {
    return function(x) {
      return Math.abs(x());
    };
  });

  define('sqrt', function() {
    return function(x) {
      return Math.sqrt(x());
    };
  });

  define('acos', function() {
    return function(x) {
      return Math.acos(x());
    };
  });

  define('asin', function() {
    return function(x) {
      return Math.asin(x());
    };
  });

  define('atan', function() {
    return function(x) {
      return Math.atan(x());
    };
  });

  define('atan2', function() {
    return function(x) {
      return function(y) {
        return Math.atan2(x(), y());
      };
    };
  });

  define('cos', function() {
    return function(x) {
      return Math.cos(x());
    };
  });

  define('log', function() {
    return function(x) {
      return Math.log(x());
    };
  });

  define('sin', function() {
    return function(x) {
      return Math.sin(x());
    };
  });

  define('tan', function() {
    return function(x) {
      return Math.tan(x());
    };
  });

  define('rand', function() {
    return makeSyncMonad(function(env, cont) {
      return cont(Math.random());
    });
  });

  define('randInt', function() {
    return function(low) {
      return function(high) {
        return makeSyncMonad(function(env, cont) {
          return cont(Math.floor(low() + Math.random() * high()));
        });
      };
    };
  });

  define('^', function() {
    return function(x) {
      return function(y) {
        return Math.pow(x(), y());
      };
    };
  });

  define('strString', function() {
    return function(data) {
      return String(data());
    };
  });

  define('strAt', function() {
    return function(str) {
      return function(index) {
        return str()[strCoord(str(), index())];
      };
    };
  });

  define('strStartsWith', function() {
    return function(str) {
      return function(prefix) {
        return booleanFor(str().substring(0, prefix().length) === prefix());
      };
    };
  });

  define('strLen', function() {
    return function(str) {
      return str().length;
    };
  });

  define('strToLowerCase', function() {
    return function(str) {
      return str().toLowerCase();
    };
  });

  define('strToUpperCase', function() {
    return function(str) {
      return str().toUpperCase();
    };
  });

  define('strReplace', function() {
    return function(str) {
      return function(pat) {
        return function(repl) {
          return str().replace(pat(), repl());
        };
      };
    };
  });

  strCoord = function(str, coord) {
    if (coord < 0) {
      return str.length + coord;
    } else {
      return coord;
    }
  };

  define('strSubstring', function() {
    return function(str) {
      return function(start) {
        return function(end) {
          var a, b;

          a = strCoord(str(), start());
          b = strCoord(str(), end());
          if (b < a && end() === 0) {
            b = str().length;
          }
          return str().substring(a, b);
        };
      };
    };
  });

  define('strSplit', function() {
    return function(str) {
      return function(pat) {
        return consFrom(str().split(pat() instanceof RegExp ? pat() : new RegExp(pat())));
      };
    };
  });

  define('strCat', function() {
    return function(list) {
      return list().toArray().join('');
    };
  });

  define('strAdd', function() {
    return function(s1) {
      return function(s2) {
        return s1() + s2();
      };
    };
  });

  define('strMatch', function() {
    return function(str) {
      return function(pat) {
        var groups, m, pos;

        m = str().match((pat() instanceof RegExp ? pat() : new RegExp(pat())));
        if (m) {
          groups = [];
          pos = 1;
          while (m[pos]) {
            groups.push(m[pos++]);
          }
          if (typeof m.index !== 'undefined') {
            return consFrom([m[0], consFrom(groups), m.index, m.input]);
          } else {
            return consFrom([m[0], consFrom(groups)]);
          }
        } else {
          return Nil;
        }
      };
    };
  });

  define('strToList', function() {
    return function(str) {
      return strToList(str());
    };
  });

  strToList = function(str) {
    if (str === '') {
      return Nil;
    } else {
      return cons(str[0], strToList(str.substring(1)));
    }
  };

  define('strFromList', function() {
    return function(list) {
      return strFromList(list());
    };
  });

  strFromList = function(list) {
    if (list instanceof Leisure_nil) {
      return '';
    } else {
      return head(list) + strFromList(tail(list));
    }
  };

  define('regexp', function() {
    return function(str) {
      return new RegExp(str());
    };
  });

  define('regexpFlags', function() {
    return function(str) {
      return function(flags) {
        return new RegExp(str(), flags());
      };
    };
  });

  define('jsonParse', function() {
    return function(str) {
      return function(failCont) {
        return function(successCont) {
          var err, p;

          try {
            p = JSON.parse(str());
            return successCont()(function() {
              return p;
            });
          } catch (_error) {
            err = _error;
            return failCont()(function() {
              return err;
            });
          }
        };
      };
    };
  });

  define('jsonStringify', function() {
    return function(obj) {
      return function(failCont) {
        return function(successCont) {
          var err, s;

          try {
            s = JSON.stringify(obj());
            return successCont()(function() {
              return s;
            });
          } catch (_error) {
            err = _error;
            return failCont()(function() {
              return err;
            });
          }
        };
      };
    };
  });

  define('log', function() {
    return function(str) {
      return function(res) {
        console.log(String(str()));
        return res();
      };
    };
  });

  makeMonad = function(guts) {
    var m;

    m = function() {};
    m.__proto__ = Monad.prototype;
    m.cmd = guts;
    m.type = 'monad';
    return m;
  };

  makeSyncMonad = function(guts) {
    var m;

    m = makeMonad(guts);
    m.sync = true;
    return m;
  };

  nextMonad = function(cont) {
    return cont;
  };

  replaceErr = function(err, msg) {
    err.message = msg;
    return err;
  };

  defaultEnv = {
    write: function(str) {
      return process.stdout.write(str);
    },
    err: function(err) {
      var _ref1;

      return this.write("Error: " + ((_ref1 = err.stack) != null ? _ref1 : err));
    },
    prompt: function() {
      throw new Error("Environment does not support prompting!");
    }
  };

  monadModeSync = false;

  getMonadSyncMode = function() {
    return monadModeSync;
  };

  withSyncModeDo = function(newMode, block) {
    var oldMode;

    oldMode = monadModeSync;
    monadModeSync = newMode;
    try {
      return block();
    } finally {

    }
  };

  runMonad = function(monad, env, cont) {
    env = env != null ? env : root.defaultEnv;
    return withSyncModeDo(true, function() {
      return newRunMonad(monad, env, cont, []);
    });
  };

  isMonad = function(m) {
    return typeof m === 'function' && (m.cmd != null);
  };

  continueMonads = function(contStack, env) {
    return function(result) {
      return withSyncModeDo(false, function() {
        return newRunMonad(result, env, null, contStack);
      });
    };
  };

  asyncMonad = {
    toString: function() {
      return "<asyncMonadResult>";
    }
  };

  warnAsync = false;

  setWarnAsync = function(state) {
    return warnAsync = state;
  };

  newRunMonad = function(monad, env, cont, contStack) {
    var err, result;

    if (cont) {
      contStack.push(cont);
    }
    try {
      while (true) {
        if (isMonad(monad)) {
          if (monad.binding) {
            contStack.push((function(bnd) {
              return function(x) {
                return bnd(function() {
                  return x;
                });
              };
            })(monad.binding()));
            monad = monad.monad();
            continue;
          } else if (!monad.sync) {
            monadModeSync = false;
            if (warnAsync) {
              console.log("async monad");
            }
            monad.cmd(env, continueMonads(contStack, env));
            return asyncMonad;
          }
          result = monad.cmd(env, identity);
        } else {
          monadModeSync = true;
          result = monad;
        }
        if (!contStack.length) {
          return result;
        }
        monad = contStack.pop()(result);
      }
    } catch (_error) {
      err = _error;
      err = replaceErr(err, "\nERROR RUNNING MONAD, MONAD: " + monad + ", ENV: " + env + "...\n" + err.message);
      console.log(err.stack);
      return (cont != null ? cont : identity)(err);
    }
  };

  Monad = (function() {
    function Monad() {}

    Monad.prototype.toString = function() {
      return "Monad: " + (this.cmd.toString());
    };

    return Monad;

  })();

  global.L_runMonads = function(monadArray) {
    monadArray.reverse();
    return newRunMonad(0, defaultEnv, null, monadArray);
  };

  define('define', function() {
    return function(name) {
      return function(arity) {
        return function(src) {
          return function(def) {
            return makeSyncMonad(function(env, cont) {
              define(name(), def, arity(), src());
              return cont(typeof L_true !== "undefined" && L_true !== null ? L_true : _true);
            });
          };
        };
      };
    };
  });

  define('bind', function() {
    return function(m) {
      return function(binding) {
        var bindMonad;

        bindMonad = makeMonad(function(env, cont) {});
        bindMonad.monad = m;
        bindMonad.binding = binding;
        return bindMonad;
      };
    };
  });

  values = {};

  define('hasValue', function() {
    return function(name) {
      return makeSyncMonad(function(env, cont) {
        return cont(booleanFor(values[name()] != null));
      });
    };
  });

  define('getValueOr', function() {
    return function(name) {
      return function(defaultValue) {
        return makeSyncMonad(function(env, cont) {
          var _ref1;

          return cont((_ref1 = values[name()]) != null ? _ref1 : defaultValue());
        });
      };
    };
  });

  define('getValue', function() {
    return function(name) {
      return makeSyncMonad(function(env, cont) {
        if (!(name() in values)) {
          throw new Error("No value named '" + (name()) + "'");
        }
        return cont(values[name()]);
      });
    };
  });

  setValue = function(key, value) {
    return values[key] = value;
  };

  getValue = function(key) {
    return values[key];
  };

  define('setValue', function() {
    return function(name) {
      return function(value) {
        return makeSyncMonad(function(env, cont) {
          values[name()] = value();
          return cont(_true);
        });
      };
    };
  });

  define('createS', function() {
    return makeSyncMonad(function(env, cont) {
      return cont(_true);
    });
  });

  define('getS', function() {
    return function(state) {
      return makeSyncMonad(function(env, cont) {
        return cont(state().value);
      });
    };
  });

  define('setS', function() {
    return function(state) {
      return function(value) {
        return makeSyncMonad(function(env, cont) {
          state().value = value();
          return cont(_false);
        });
      };
    };
  });

  setValue('macros', Nil);

  define('defMacro', function() {
    return function(name) {
      return function(def) {
        return makeSyncMonad(function(env, cont) {
          values.macros = cons(cons(name(), def()), values.macros);
          return cont(_false);
        });
      };
    };
  });

  define('funcs', function() {
    return makeSyncMonad(function(env, cont) {
      console.log("Leisure functions:\n" + (_(global.leisureFuncNames.toArray()).sort().join('\n')));
      return cont(_false);
    });
  });

  define('funcSrc', function() {
    return function(func) {
      if (typeof func() === 'function' && func().src) {
        return some(func().src);
      } else {
        return none;
      }
    };
  });

  define('ast2Json', function() {
    return function(ast) {
      return JSON.stringify(ast2Json(ast()));
    };
  });

  define('print', function() {
    return function(msg) {
      return makeSyncMonad(function(env, cont) {
        var m;

        m = msg();
        env.write("" + m + "\n");
        return cont(_false);
      });
    };
  });

  define('readFile', function() {
    return function(name) {
      return makeMonad(function(env, cont) {
        return readFile(name(), function(err, contents) {
          return cont((err ? left(err.stack) : right(contents)));
        });
      });
    };
  });

  define('prompt', function() {
    return function(msg) {
      return makeMonad(function(env, cont) {
        return env.prompt(String(msg()), function(input) {
          return cont(input);
        });
      });
    };
  });

  define('rand', function() {
    return makeSyncMonad(function(env, cont) {
      return cont(Math.random());
    });
  });

  ensureLeisureClass('token');

  Leisure_token.prototype.toString = function() {
    return "Token(" + (JSON.stringify(tokenString(this))) + ", " + (tokenPos(this)) + ")";
  };

  tokenString = function(t) {
    return t(function() {
      return function(txt) {
        return function(pos) {
          return txt();
        };
      };
    });
  };

  tokenPos = function(t) {
    return t(function() {
      return function(txt) {
        return function(pos) {
          return pos();
        };
      };
    });
  };

  ensureLeisureClass('parens');

  Leisure_parens.prototype.toString = function() {
    return "Parens(" + (parensStart(this)) + ", " + (parensEnd(this)) + ", " + (parensContent(this)) + ")";
  };

  parensStart = function(p) {
    return p(function() {
      return function(s) {
        return function(e) {
          return function(l) {
            return s();
          };
        };
      };
    });
  };

  parensEnd = function(p) {
    return p(function() {
      return function(s) {
        return function(e) {
          return function(l) {
            return e();
          };
        };
      };
    });
  };

  parensContent = function(p) {
    return p(function() {
      return function(s) {
        return function(e) {
          return function(l) {
            return l();
          };
        };
      };
    });
  };

  ensureLeisureClass('true');

  Leisure_true.prototype.toString = function() {
    return "true";
  };

  ensureLeisureClass('false');

  Leisure_false.prototype.toString = function() {
    return "false";
  };

  ensureLeisureClass('left');

  Leisure_left.prototype.toString = function() {
    return "Left(" + (this(function() {
      return _identity;
    })(function() {
      return _identity;
    })) + ")";
  };

  ensureLeisureClass('right');

  Leisure_right.prototype.toString = function() {
    return "Right(" + (this(function() {
      return _identity;
    })(function() {
      return _identity;
    })) + ")";
  };

  root._false = _false;

  root.stateValues = values;

  root.runMonad = runMonad;

  root.isMonad = isMonad;

  root.identity = identity;

  root.defaultEnv = defaultEnv;

  root.setValue = setValue;

  root.getValue = getValue;

  root.makeMonad = makeMonad;

  root.makeSyncMonad = makeSyncMonad;

  root.replaceErr = replaceErr;

  root.left = left;

  root.right = right;

  root.getMonadSyncMode = getMonadSyncMode;

  root.asyncMonad = asyncMonad;

  root.setWarnAsync = setWarnAsync;

  if (typeof window !== "undefined" && window !== null) {
    window.runMonad = runMonad;
    window.setType = setType;
    window.setDataType = setDataType;
    window.defaultEnv = defaultEnv;
    window.identity = identity;
  }

}).call(this);

/*
*/

})(require("__browserify_process"),self)
},{"./ast":1,"./base":2,"./lodash.min":6,"__browserify_process":13}],11:[function(require,module,exports){
L_runMonads([
  function(){return L_define()(function(){return "if"})(function(){return 0})(function(){return "if = id"})(L_id)},
  function(){return L_defMacro()(function(){return "when"})((function(){var $m; return function(){return $m || ($m = function(L_line){return L_line()((function(){var $m; return function(){return $m || ($m = function(L_cond){return function(L_rest){return L_cons()(L_cond)((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "do"})(L_rest))}})())((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "nil"})(L_nil))}})()))}})())}})}})())})}})())},
  function(){return L_define()(function(){return "iszero"})(function(){return 0})(function(){return "iszero = eq 0"})((function(){var $m; return function(){return $m || ($m = L_eq()(function(){return 0}))}})())},
  function(){return L_define()(function(){return "positive"})(function(){return 0})(function(){return "positive = 0 <"})((function(){var $m; return function(){return $m || ($m = L_$y()(function(){return 0}))}})())},
  function(){return L_addToken()(function(){return "--"})},
  function(){return L_addToken()(function(){return "++"})},
  function(){return L_define()(function(){return "--"})(function(){return 0})(function(){return "-- = (flip (-)) 1"})((function(){var $m; return function(){return $m || ($m = L_flip()(L_$_)(function(){return 1}))}})())},
  function(){return L_define()(function(){return "++"})(function(){return 0})(function(){return "++ = (1 +)"})((function(){var $m; return function(){return $m || ($m = L_$o()(function(){return 1}))}})())},
  function(){return L_define()(function(){return "intercalate"})(function(){return 2})(function(){return "intercalate x l = concat (intersperse x l)"})((function(){var $m; return function(){return $m || ($m = function(L_x){return function(L_l){return L_concat()((function(){var $m; return function(){return $m || ($m = L_intersperse()(L_x)(L_l))}})())}})}})())},
  function(){return L_define()(function(){return "visit"})(function(){return 2})(function(){return "visit func l = \\\\\n  result = func func l\n  .\n  isCons result\n    result \\h t . cons (visit func h) (visit func t)\n    result"})((function(){var $m; return function(){return $m || ($m = function(L_func){return function(L_l){return (function(){

var L_result;

L_result = (function(){var $m; return function(){return $m || ($m = L_func()(L_func)(L_l))}})();
return L_isCons()(L_result)((function(){var $m; return function(){return $m || ($m = L_result()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_cons()((function(){var $m; return function(){return $m || ($m = L_visit()(L_func)(L_h))}})())((function(){var $m; return function(){return $m || ($m = L_visit()(L_func)(L_t))}})())}})}})()))}})())(L_result)})()}})}})())},
  function(){return L_define()(function(){return "simplify"})(function(){return 1})(function(){return "simplify exprString = do\n  list <- scanLineM exprString\n  visit (\\func x . isToken x (tokenString x) ((isParens x) (visit func (parensContent x)) x)) list"})((function(){var $m; return function(){return $m || ($m = function(L_exprString){return L_bind()((function(){var $m; return function(){return $m || ($m = L_scanLineM()(L_exprString))}})())((function(){var $m; return function(){return $m || ($m = function(L_list){return L_visit()((function(){var $m; return function(){return $m || ($m = function(L_func){return function(L_x){return L_isToken()(L_x)((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_x))}})())((function(){var $m; return function(){return $m || ($m = L_isParens()(L_x)((function(){var $m; return function(){return $m || ($m = L_visit()(L_func)((function(){var $m; return function(){return $m || ($m = L_parensContent()(L_x))}})()))}})())(L_x))}})())}})}})())(L_list)})}})())})}})())},
  function(){return L_define()(function(){return "dlempty"})(function(){return 0})(function(){return "dlempty = id"})(L_id)},
  function(){return L_define()(function(){return "dl"})(function(){return 1})(function(){return "dl item = \\rest . [item | rest]"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_item){return setType(function(L_rest){return L_cons()(L_item)(L_rest)}, 'dl')}, 'dl'))}})())},
  function(){return L_define()(function(){return "dlPush"})(function(){return 2})(function(){return "dlPush list item = dlAppend list (dl item)"})((function(){var $m; return function(){return $m || ($m = function(L_list){return function(L_item){return L_dlAppend()(L_list)((function(){var $m; return function(){return $m || ($m = L_dl()(L_item))}})())}})}})())},
  function(){return L_define()(function(){return "dlAppend"})(function(){return 2})(function(){return "dlAppend a b = \\rest . a (b rest)"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_a){return function(L_b){return setType(function(L_rest){return L_a()((function(){var $m; return function(){return $m || ($m = L_b()(L_rest))}})())}, 'dlAppend')}}, 'dlAppend'))}})())},
  function(){return L_define()(function(){return "remove"})(function(){return 2})(function(){return "remove x l = removeIf (eq x) l"})((function(){var $m; return function(){return $m || ($m = function(L_x){return function(L_l){return L_removeIf()((function(){var $m; return function(){return $m || ($m = L_eq()(L_x))}})())(L_l)}})}})())},
  function(){return L_define()(function(){return "removeIf"})(function(){return 2})(function(){return "removeIf f l = filter (compose not f) l"})((function(){var $m; return function(){return $m || ($m = function(L_f){return function(L_l){return L_filter()((function(){var $m; return function(){return $m || ($m = L_compose()(L_not)(L_f))}})())(L_l)}})}})())},
  function(){return L_define()(function(){return "any"})(function(){return 2})(function(){return "any f l = find f l (\\el . true) false"})((function(){var $m; return function(){return $m || ($m = function(L_f){return function(L_l){return L_find()(L_f)(L_l)((function(){var $m; return function(){return $m || ($m = function(L_el){return L_true()})}})())(L_false)}})}})())},
  function(){return L_define()(function(){return "all"})(function(){return 2})(function(){return "all f l = not any (compose not f) l"})((function(){var $m; return function(){return $m || ($m = function(L_f){return function(L_l){return L_not()(L_any)((function(){var $m; return function(){return $m || ($m = L_compose()(L_not)(L_f))}})())(L_l)}})}})())},
  function(){return L_define()(function(){return "take"})(function(){return 2})(function(){return "take n list = positive n\n  list\n    \\h t D . cons h (take (-- n) t)\n    nil\n  nil"})((function(){var $m; return function(){return $m || ($m = function(L_n){return function(L_list){return L_positive()(L_n)((function(){var $m; return function(){return $m || ($m = L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_take()((function(){var $m; return function(){return $m || ($m = L_$_$_()(L_n))}})())(L_t))}})())}}})}})())(L_nil))}})())(L_nil)}})}})())},
  function(){return L_define()(function(){return "takeWhile"})(function(){return 2})(function(){return "takeWhile predicate list = list\n  \\h t D . predicate (head list)\n    cons h (takeWhile predicate t)\n    nil\n  nil"})((function(){var $m; return function(){return $m || ($m = function(L_predicate){return function(L_list){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_predicate()((function(){var $m; return function(){return $m || ($m = L_head()(L_list))}})())((function(){var $m; return function(){return $m || ($m = L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_takeWhile()(L_predicate)(L_t))}})()))}})())(L_nil)}}})}})())(L_nil)}})}})())},
  function(){return L_define()(function(){return "drop"})(function(){return 2})(function(){return "drop x list = positive x\n  list\n    \\h t D . drop (-- x) t\n    nil\n  list"})((function(){var $m; return function(){return $m || ($m = function(L_x){return function(L_list){return L_positive()(L_x)((function(){var $m; return function(){return $m || ($m = L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_drop()((function(){var $m; return function(){return $m || ($m = L_$_$_()(L_x))}})())(L_t)}}})}})())(L_nil))}})())(L_list)}})}})())},
  function(){return L_define()(function(){return "dropWhile"})(function(){return 2})(function(){return "dropWhile predicate list = list\n  \\h t D . predicate h\n    dropWhile predicate t\n    list\n  nil"})((function(){var $m; return function(){return $m || ($m = function(L_predicate){return function(L_list){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_predicate()(L_h)((function(){var $m; return function(){return $m || ($m = L_dropWhile()(L_predicate)(L_t))}})())(L_list)}}})}})())(L_nil)}})}})())},
  function(){return L_define()(function(){return "dropLast"})(function(){return 2})(function(){return "dropLast n list = reverse (drop n (reverse list))"})((function(){var $m; return function(){return $m || ($m = function(L_n){return function(L_list){return L_reverse()((function(){var $m; return function(){return $m || ($m = L_drop()(L_n)((function(){var $m; return function(){return $m || ($m = L_reverse()(L_list))}})()))}})())}})}})())},
  function(){return L_define()(function(){return "box"})(function(){return 2})(function(){return "box n list = list == nil\n  nil\n  [(take n list) | box n (drop n list)]"})((function(){var $m; return function(){return $m || ($m = function(L_n){return function(L_list){return L_$p$p()(L_list)(L_nil)(L_nil)((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_take()(L_n)(L_list))}})())((function(){var $m; return function(){return $m || ($m = L_box()(L_n)((function(){var $m; return function(){return $m || ($m = L_drop()(L_n)(L_list))}})()))}})()))}})())}})}})())},
  function(){return L_define()(function(){return "at"})(function(){return 2})(function(){return "at l x = (x == 0) (head l) (at (tail l) (-- (x) ) )"})((function(){var $m; return function(){return $m || ($m = function(L_l){return function(L_x){return L_$p$p()(L_x)(function(){return 0})((function(){var $m; return function(){return $m || ($m = L_head()(L_l))}})())((function(){var $m; return function(){return $m || ($m = L_at()((function(){var $m; return function(){return $m || ($m = L_tail()(L_l))}})())((function(){var $m; return function(){return $m || ($m = L_$_$_()(L_x))}})()))}})())}})}})())},
  function(){return L_define()(function(){return "series"})(function(){return 2})(function(){return "series func n = [n | (series func (func n))]"})((function(){var $m; return function(){return $m || ($m = function(L_func){return function(L_n){return L_cons()(L_n)((function(){var $m; return function(){return $m || ($m = L_series()(L_func)((function(){var $m; return function(){return $m || ($m = L_func()(L_n))}})()))}})())}})}})())},
  function(){return L_define()(function(){return "from"})(function(){return 1})(function(){return "from n = series ++ n"})((function(){var $m; return function(){return $m || ($m = function(L_n){return L_series()(L_$o$o)(L_n)})}})())},
  function(){return L_define()(function(){return "fromBy"})(function(){return 2})(function(){return "fromBy n inc = series ((+) inc) n"})((function(){var $m; return function(){return $m || ($m = function(L_n){return function(L_inc){return L_series()((function(){var $m; return function(){return $m || ($m = L_$o()(L_inc))}})())(L_n)}})}})())},
  function(){return L_define()(function(){return "fromTo"})(function(){return 2})(function(){return "fromTo n m = takeWhile ((>) m) (from n)"})((function(){var $m; return function(){return $m || ($m = function(L_n){return function(L_m){return L_takeWhile()((function(){var $m; return function(){return $m || ($m = L_$z()(L_m))}})())((function(){var $m; return function(){return $m || ($m = L_from()(L_n))}})())}})}})())},
  function(){return L_define()(function(){return "fromToBy"})(function(){return 3})(function(){return "fromToBy n m inc = takeWhile ((>) m) (fromBy n inc)"})((function(){var $m; return function(){return $m || ($m = function(L_n){return function(L_m){return function(L_inc){return L_takeWhile()((function(){var $m; return function(){return $m || ($m = L_$z()(L_m))}})())((function(){var $m; return function(){return $m || ($m = L_fromBy()(L_n)(L_inc))}})())}}})}})())},
  function(){return L_define()(function(){return "count"})(function(){return 2})(function(){return "count x l = countIf (eq x) l"})((function(){var $m; return function(){return $m || ($m = function(L_x){return function(L_l){return L_countIf()((function(){var $m; return function(){return $m || ($m = L_eq()(L_x))}})())(L_l)}})}})())},
  function(){return L_define()(function(){return "countIf"})(function(){return 2})(function(){return "countIf f l = (eq l nil) 0\n  + (f (head l) 1 0) (countIf f (tail l))"})((function(){var $m; return function(){return $m || ($m = function(L_f){return function(L_l){return L_eq()(L_l)(L_nil)(function(){return 0})((function(){var $m; return function(){return $m || ($m = L_$o()((function(){var $m; return function(){return $m || ($m = L_f()((function(){var $m; return function(){return $m || ($m = L_head()(L_l))}})())(function(){return 1})(function(){return 0}))}})())((function(){var $m; return function(){return $m || ($m = L_countIf()(L_f)((function(){var $m; return function(){return $m || ($m = L_tail()(L_l))}})()))}})()))}})())}})}})())},
  function(){return L_define()(function(){return "countIfNot"})(function(){return 2})(function(){return "countIfNot f l = countIf (\\x. not (f x)) l"})((function(){var $m; return function(){return $m || ($m = function(L_f){return function(L_l){return L_countIf()((function(){var $m; return function(){return $m || ($m = function(L_x){return L_not()((function(){var $m; return function(){return $m || ($m = L_f()(L_x))}})())})}})())(L_l)}})}})())},
  function(){return L_define()(function(){return "odds"})(function(){return 1})(function(){return "odds l = l\n  \\h t D . [h | evens t]\n  nil"})((function(){var $m; return function(){return $m || ($m = function(L_l){return L_l()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_evens()(L_t))}})())}}})}})())(L_nil)})}})())},
  function(){return L_define()(function(){return "evens"})(function(){return 1})(function(){return "evens l = l\n  \\h t D . odds t\n  nil"})((function(){var $m; return function(){return $m || ($m = function(L_l){return L_l()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_odds()(L_t)}}})}})())(L_nil)})}})())},
  function(){return L_define()(function(){return "cleave"})(function(){return 1})(function(){return "cleave l = [(evens l) | (odds l)]"})((function(){var $m; return function(){return $m || ($m = function(L_l){return L_cons()((function(){var $m; return function(){return $m || ($m = L_evens()(L_l))}})())((function(){var $m; return function(){return $m || ($m = L_odds()(L_l))}})())})}})())},
  function(){return L_define()(function(){return "merge"})(function(){return 3})(function(){return "merge cmp a b = a\n  \\ah at D . b\n    \\bh bt D . cmp ah bh\n      [ah | (merge cmp at b)]\n      [bh | (merge cmp a bt)]\n    a\n  b"})((function(){var $m; return function(){return $m || ($m = function(L_cmp){return function(L_a){return function(L_b){return L_a()((function(){var $m; return function(){return $m || ($m = function(L_ah){return function(L_at){return function(L_D){return L_b()((function(){var $m; return function(){return $m || ($m = function(L_bh){return function(L_bt){return function(L_D_0){return L_cmp()(L_ah)(L_bh)((function(){var $m; return function(){return $m || ($m = L_cons()(L_ah)((function(){var $m; return function(){return $m || ($m = L_merge()(L_cmp)(L_at)(L_b))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cons()(L_bh)((function(){var $m; return function(){return $m || ($m = L_merge()(L_cmp)(L_a)(L_bt))}})()))}})())}}})}})())(L_a)}}})}})())(L_b)}}})}})())},
  function(){return L_define()(function(){return "mergeSort"})(function(){return 2})(function(){return "mergeSort cmp l = l\n  \\h t D . eq (tail l) nil\n    l\n    do\n      cl = cleave l\n      e = head cl\n      o = tail cl\n      merge cmp (mergeSort cmp e) (mergeSort cmp o)\n  nil"})((function(){var $m; return function(){return $m || ($m = function(L_cmp){return function(L_l){return L_l()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_eq()((function(){var $m; return function(){return $m || ($m = L_tail()(L_l))}})())(L_nil)(L_l)(function(){
var L_o, L_e, L_cl;

L_o = (function(){var $m; return function(){return $m || ($m = L_tail()(L_cl))}})();

L_e = (function(){var $m; return function(){return $m || ($m = L_head()(L_cl))}})();

L_cl = (function(){var $m; return function(){return $m || ($m = L_cleave()(L_l))}})();
return L_merge()(L_cmp)((function(){var $m; return function(){return $m || ($m = L_mergeSort()(L_cmp)(L_e))}})())((function(){var $m; return function(){return $m || ($m = L_mergeSort()(L_cmp)(L_o))}})())})}}})}})())(L_nil)}})}})())},
  function(){return L_define()(function(){return "sort"})(function(){return 1})(function(){return "sort l = sortBy lte l"})((function(){var $m; return function(){return $m || ($m = function(L_l){return L_sortBy()(L_lte)(L_l)})}})())},
  function(){return L_define()(function(){return "sortBy"})(function(){return 2})(function(){return "sortBy cmp l = mergeSort cmp l"})((function(){var $m; return function(){return $m || ($m = function(L_cmp){return function(L_l){return L_mergeSort()(L_cmp)(L_l)}})}})())},
  function(){return L_define()(function(){return "html"})(function(){return 1})(function(){return "html x = \\f . f x"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_x){return setType(function(L_f){return L_f()(L_x)}, 'html')}, 'html'))}})())},
  function(){return L_defTokenPack()(function(){return "util"})((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "--"})((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "++"})(L_nil))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cons()(L_nil)((function(){var $m; return function(){return $m || ($m = L_cons()(L_nil)(L_nil))}})()))}})()))}})())},
  function(){return L_addStdTokenPacks()((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "util"})(L_nil))}})())}]);

},{}],12:[function(require,module,exports){
// nothing to see here... no file methods for the browser

},{}],13:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}]},{},[3])
;