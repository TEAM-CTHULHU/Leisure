// Generated by CoffeeScript 1.6.3
(function() {
  var BS, DEL, ENTER, burp, buttons, clean, cleaning, configureCalc, configurePanelToggle, defaultEnv, define, delayedEval, evalCount, evalDiv, genSource, getParseErr, getType, isMonad, lazy, lz, minInt, resetText, resolve, root, runMonad, rz, show, showButton, textNode, toggleAll, toggleButton, updateAllButton, _ref, _ref1, _ref2;

  _ref = root = module.exports = require('./base'), resolve = _ref.resolve, lazy = _ref.lazy, defaultEnv = _ref.defaultEnv, minInt = _ref.minInt;

  rz = resolve;

  lz = lazy;

  genSource = require('./gen').genSource;

  _ref1 = require('./runtime'), runMonad = _ref1.runMonad, isMonad = _ref1.isMonad;

  _ref2 = require('./ast'), getType = _ref2.getType, define = _ref2.define, BS = _ref2.BS, ENTER = _ref2.ENTER, DEL = _ref2.DEL, textNode = _ref2.textNode;

  require('./browserSupport');

  delayedEval = function(env, input, output, simplified, ast, code, count) {
    return setTimeout((function() {
      return evalDiv(input.text(), env, input, output, simplified, ast, code, count);
    }), 1);
  };

  buttons = ['simplified', 'ast', 'code'];

  cleaning = false;

  clean = function(input) {
    burp(input);
    return resetText(input);
  };

  burp = function(input) {
    return console.log("Child nodes: ", input.childNodes);
  };

  resetText = function(input) {
    if (!cleaning) {
      if (input.textContent === '') {
        cleaning = true;
        return setTimeout((function() {
          var r, s;
          input.textContent = '\n';
          s = window.getSelection();
          r = document.createRange();
          r.setStart(input.firstChild, 0);
          s.removeAllRanges();
          s.addRange(r);
          return setTimeout((function() {
            return cleaning = false;
          }), 1);
        }), 1);
      }
    }
  };

  configureCalc = function(input, output, simplified, ast, code) {
    var button, env, inputCount, _i, _len;
    env = {
      write: function(str) {
        return output.append(str);
      }
    };
    env.__proto__ = defaultEnv;
    inputCount = minInt;
    resetText(input[0]);
    input[0].addEventListener('keypress', function(e) {
      var br, len, par, r, s, tc;
      console.log("KEY: " + (e.charCode || e.keyCode || e.which));
      par = e.target;
      s = window.getSelection();
      r = s.getRangeAt(0);
      burp(par);
      inputCount++;
      if ((e.charCode || e.keyCode || e.which) === ENTER) {
        par = e.target;
        e.preventDefault();
        console.log("ENTER");
        br = textNode('\n');
        r.insertNode(br);
        r.setStartBefore(par.firstChild);
        r.setEndAfter(br);
        len = r.cloneContents().textContent.length;
        tc = par.textContent;
        console.log("len: " + len + ", tc.len: " + tc.length);
        if ($.browser.chrome && tc.length === len) {
          if (tc.length < 2 || tc.substring(tc.length - 2, tc.length) !== '\n\n') {
            console.log('ADDING NEWLINE');
            len = tc.length + 1;
            br.nodeValue = '\n\n';
          }
        }
        par.normalize();
        r.setStart(par.firstChild, len);
        r.collapse();
        s.removeAllRanges();
        return s.addRange(r);
      }
    });
    input[0].addEventListener('DOMCharacterDataModified', function(evt) {
      if (!cleaning) {
        clean(input[0]);
        return delayedEval(env, input, output, simplified, ast, code, inputCount);
      }
    });
    input[0].addEventListener('DOMSubtreeModified', function(evt) {
      if (!cleaning) {
        clean(input[0]);
        return delayedEval(env, input, output, simplified, ast, code, inputCount);
      }
    });
    for (_i = 0, _len = buttons.length; _i < _len; _i++) {
      button = buttons[_i];
      configurePanelToggle(button);
    }
    $('#allButton').click(function(evt) {
      return toggleAll();
    });
    return $('body').removeClass('loading');
  };

  updateAllButton = function() {
    var allOn, button, _i, _len;
    allOn = true;
    for (_i = 0, _len = buttons.length; _i < _len; _i++) {
      button = buttons[_i];
      if (!$("#" + button + "Button").hasClass('selected')) {
        allOn = false;
        break;
      }
    }
    if ($('#allButton').hasClass('selected') !== allOn) {
      return $('#allButton').toggleClass('selected');
    }
  };

  toggleAll = function() {
    var allOn, button, _i, _len, _results;
    allOn = $('#allButton').hasClass('selected');
    _results = [];
    for (_i = 0, _len = buttons.length; _i < _len; _i++) {
      button = buttons[_i];
      _results.push(showButton(button, !allOn));
    }
    return _results;
  };

  configurePanelToggle = function(button) {
    return $("#" + button + "Button").click(function(evt) {
      return toggleButton(button);
    });
  };

  toggleButton = function(button) {
    return showButton(button, !$("#" + button + "Button").hasClass('selected'));
  };

  showButton = function(button, state) {
    if (state) {
      $("#" + button + "Button").addClass('selected');
      $("#" + button + "Panel").removeClass('hidden');
    } else {
      $("#" + button + "Button").removeClass('selected');
      $("#" + button + "Panel").addClass('hidden');
    }
    return updateAllButton();
  };

  define('svgMeasureText', (function() {
    return function(text) {
      return typeof Notebook !== "undefined" && Notebook !== null ? Notebook.svgMeasureText(text) : void 0;
    };
  }), 2);

  getParseErr = function(x) {
    return x(lz(function(value) {
      return rz(value);
    }));
  };

  show = function(obj) {
    return rz(L_show)(lz(obj));
  };

  evalCount = minInt;

  evalDiv = function(text, env, input, output, simplified, astDiv, code, count) {
    var err, result;
    if (count < evalCount) {
      return;
    }
    evalCount = count;
    output.html('');
    simplified.html('');
    astDiv.html('');
    code.html('');
    if (text.trim()) {
      try {
        result = rz(L_newParseLine)(lz(0))(L_nil)(lz(text));
        return runMonad(result, env, function(ast) {
          var err, js;
          try {
            if (getType(ast) === 'parseErr') {
              output.addClass('err');
              return output.html("Parse error: " + (getParseErr(ast)));
            } else {
              output.removeClass('err');
              simplified.html(show(lz(runMonad(rz(L_simplify)(lz(text))))));
              js = genSource(text, ast);
              code.html(js);
              result = eval(js);
              output.html((isMonad(result) ? "(processing IO monad)\n" : ''));
              runMonad(result, env, function(res) {
                return output.append(show(res));
              });
              try {
                return astDiv.html(rz(L_wrappedTreeFor)(lz(ast))(L_id));
              } catch (_error) {
                err = _error;
                return console.log(err.stack);
              }
            }
          } catch (_error) {
            err = _error;
            output.addClass('err');
            output.html(err.stack);
            return console.log(err.stack);
          }
        });
      } catch (_error) {
        err = _error;
        output.addClass('err');
        output.addClass('err');
        output.html(err.stack);
        return console.log(err.stack);
      }
    } else {
      return output.html('');
    }
  };

  root.configureCalc = configureCalc;

  root.showButton = showButton;

}).call(this);

/*
//@ sourceMappingURL=calcSupport.map
*/
