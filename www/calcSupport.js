// Generated by CoffeeScript 1.6.3
(function() {
  var ENTER, configureCalc, defaultEnv, define, delayedEval, evalDiv, genSource, getParseErr, getType, isMonad, lazy, lz, resolve, root, runMonad, rz, show, _ref, _ref1, _ref2;

  _ref = root = module.exports = require('./base'), resolve = _ref.resolve, lazy = _ref.lazy, defaultEnv = _ref.defaultEnv;

  rz = resolve;

  lz = lazy;

  genSource = require('./gen').genSource;

  ENTER = require('./notebook').ENTER;

  _ref1 = require('./runtime'), runMonad = _ref1.runMonad, isMonad = _ref1.isMonad;

  _ref2 = require('./ast'), getType = _ref2.getType, define = _ref2.define;

  delayedEval = function(env, input, output, simplified, ast, code) {
    return setTimeout((function() {
      return evalDiv(input.text(), env, input, output, simplified, ast, code);
    }), 1);
  };

  configureCalc = function(input, output, simplified, ast, code) {
    var env;
    env = {
      write: function(str) {
        return output.append(str);
      }
    };
    env.__proto__ = defaultEnv;
    input[0].addEventListener('DOMCharacterDataModified', (function(evt) {
      return delayedEval(env, input, output, simplified, ast, code);
    }));
    return input[0].addEventListener('DOMSubtreeModified', (function(evt) {
      return delayedEval(env, input, output, simplified, ast, code);
    }));
  };

  define('svgMeasureText', (function() {
    return function(text) {
      return typeof Notebook !== "undefined" && Notebook !== null ? Notebook.svgMeasureText(text) : void 0;
    };
  }), 2);

  getParseErr = function(x) {
    return x(lz(function(value) {
      return rz(value);
    }));
  };

  show = function(obj) {
    if (typeof L_show !== "undefined" && L_show !== null) {
      return rz(L_show)(lz(obj));
    } else {
      return String(obj);
    }
  };

  evalDiv = function(text, env, input, output, simplified, astDiv, code) {
    var err, result;
    output.html('');
    simplified.html('');
    astDiv.html('');
    code.html('');
    if (text) {
      try {
        result = rz(L_newParseLine)(lz(0))(L_nil)(lz(text));
        return runMonad(result, env, function(ast) {
          var err, js;
          try {
            if (getType(ast) === 'parseErr') {
              output.addClass('err');
              return output.html("Parse error: " + (getParseErr(ast)));
            } else {
              output.removeClass('err');
              simplified.html(rz(L_show)(lz(runMonad(rz(L_simplify)(lz(text))))));
              js = genSource(text, ast);
              code.html(js);
              result = eval(js);
              output.html((isMonad(result) ? "(processing IO monad)" : ''));
              runMonad(result, env, function(res) {
                return output.append(show(res));
              });
              try {
                return astDiv.html(rz(L_wrappedTreeFor)(lz(ast))(L_id));
              } catch (_error) {
                err = _error;
                return console.log(err.stack);
              }
            }
          } catch (_error) {
            err = _error;
            output.addClass('err');
            output.html(err.stack);
            return console.log(err.stack);
          }
        });
      } catch (_error) {
        err = _error;
        output.addClass('err');
        output.addClass('err');
        output.html(err.stack);
        return console.log(err.stack);
      }
    } else {
      return output.html('');
    }
  };

  root.configureCalc = configureCalc;

}).call(this);

/*
//@ sourceMappingURL=calcSupport.map
*/
