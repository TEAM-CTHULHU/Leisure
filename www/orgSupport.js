// Generated by CoffeeScript 1.6.3
/*
Copyright (C) 2013, Bill Burdick, Tiny Concepts: https://github.com/zot/Leisure

(licensed with ZLIB license)

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software
in a product, an acknowledgement in the product documentation would be
appreciated but is not required.

2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.

3. This notice may not be removed or altered from any source distribution.
*/


(function() {
  var BS, DEL, DOWN, ENTER, HL_TAGS, Headline, Keyword, LEFT, Meat, Nil, PAGEDOWN, PAGEUP, RIGHT, Results, SimpleMarkup, Source, TAB, UP, addKeyPress, backspace, baseEnv, basicOrg, bindContent, boundarySpan, cachedOrgParent, cachedOrgText, checkCollapsed, checkDeleteReparse, checkEnterReparse, checkExtraNewline, checkLast, checkReparse, checkSourceMod, checkStart, cleanHeadline, codeBlockAttrs, collapseNode, cons, consFrom, contains, content, contentSpan, countCharactersFrom, createMarkNode, createResults, crnl, curKeyBinding, currentLine, defaultBindings, defaultEnv, define, displaySource, editDiv, emptyOutNode, escapeAttr, escapeHtml, executeDef, executeSource, executeText, findCharForColumn, findDomPosition, findKeyBinding, findOrgNode, fixupNodes, followingSpan, followsNewline, fs, getCollapsible, getLeft, getMarkPositions, getNodeSource, getNodeText, getOrgParent, getOrgText, getOrgType, getRangeXY, getResultsForSource, getRight, getSource, getStyle, getTags, getTextLine, getTextPosition, getTextPositionNew, getTextPositionOld, getType, getValue, handleMutation, hasParent, hasShadow, headlineRE, id, idCount, initOrg, installOrgDOM, invalidateOrgText, isBoundary, isCollapsed, isCollapsedOld, isCollapsible, isCollapsibleText, isDef, isDocNode, isDynamic, isEmptyCollapsible, isSourceNode, keyCombos, keyFuncs, lastKeys, lazy, loadOrg, lz, markId, markupGuts, markupNode, markupOrg, markupOrgWithNode, markupSimple, matchLine, maxLastKeys, modifiers, modifying, modifyingKey, moveCaret, moveSelectionDown, moveSelectionFB, moveSelectionUp, movementGoal, nativeRange, needsReparse, newConsFrom, newResults, nextOrgId, nextVisibleNewline, nodeAfter, nodeAfterNoChildren, nodeBefore, nodes, oldReparse, optionalBoundary, orgAttrs, orgEnv, orgNotebook, orgSrcAttrs, parentSpec, parseOrgMode, parseTags, presentValue, prevKeybinding, propsFor, rectFor, reparse, reparseListeners, replacements, resolve, restoreMarkPositions, restorePosition, resultsType, root, rz, saveFile, scanForward, selectRange, sensitive, setCurKeyBinding, setTags, setValue, shiftKey, show, sourceDiv, sourceSpec, specialKeys, splitLines, styleCache, swapMarkup, templateExpansions, textNodeAfter, textNodeBefore, unescapePresentationHtml, whenNotCollapsed, _, _ref, _ref1, _ref2, _ref3, _ref4;

  _ref = require('./ast'), getType = _ref.getType, cons = _ref.cons, define = _ref.define, unescapePresentationHtml = _ref.unescapePresentationHtml;

  _ref1 = root = module.exports = require('./base'), resolve = _ref1.resolve, lazy = _ref1.lazy, defaultEnv = _ref1.defaultEnv;

  rz = resolve;

  lz = lazy;

  _ref2 = require('./runtime'), newConsFrom = _ref2.newConsFrom, setValue = _ref2.setValue, getValue = _ref2.getValue;

  consFrom = newConsFrom;

  Nil = rz(L_nil);

  _ref3 = require('./browserSupport'), TAB = _ref3.TAB, ENTER = _ref3.ENTER, BS = _ref3.BS, DEL = _ref3.DEL, LEFT = _ref3.LEFT, RIGHT = _ref3.RIGHT, UP = _ref3.UP, DOWN = _ref3.DOWN;

  _ref4 = require('./org'), parseOrgMode = _ref4.parseOrgMode, Headline = _ref4.Headline, Meat = _ref4.Meat, Keyword = _ref4.Keyword, Source = _ref4.Source, Results = _ref4.Results, SimpleMarkup = _ref4.SimpleMarkup, headlineRE = _ref4.headlineRE, HL_TAGS = _ref4.HL_TAGS, parseTags = _ref4.parseTags, matchLine = _ref4.matchLine;

  _ = require('./lodash.min');

  PAGEUP = 33;

  PAGEDOWN = 34;

  editDiv = null;

  sourceDiv = null;

  modifying = false;

  styleCache = {};

  idCount = 0;

  nodes = {};

  needsReparse = false;

  reparseListeners = [];

  nextOrgId = function() {
    return 'org-node-' + idCount++;
  };

  getOrgType = function(node) {
    return node != null ? typeof node.getAttribute === "function" ? node.getAttribute('data-org-type') : void 0 : void 0;
  };

  root.currentMode = null;

  parentSpec = null;

  sourceSpec = null;

  fs = null;

  initOrg = function(parent, source) {
    var b;
    parentSpec = parent;
    sourceSpec = source;
    $("<div LeisureOutput contentEditable='false' id='leisure_bar'><button id='leisure_grip'><i class='fa fa-angle-left'></i><i class='fa fa-angle-right'></i></button>\n<button id='leisure_button'><i class='fa fa-glass'></i><div></div></button>\n<div id='leisure_rollup'><button id='saveButton' download='leisureFile.lorg'><i class=\"fa fa-save\"></i><div></div></button><div id=\"leisure_theme\"><span>Theme: </span>\n  <select id='themeSelect'>\n    <option value='flat'>Flat</option>\n    <option value=steampunk>Steampunk</option>\n   <option value=googie>Googie</option>\n   <option value=cthulhu>Cthulhu</option>\n  <option value=console>Console</option>\n  </select></div>\n<input id='nwSaveButton' type='file' nwsaveas onchange='Leisure.saveFile(this)'></input><a id='tc' target='_blank' href='http://www.teamcthulhu.com'><button id='team_cthulhu'><span><img src='images/eldersign.png'>TEAM CTHULHU</span></button></a></div></div><div id='leisure_dummy'></div>").prependTo(document.body).find('#leisure_button').mousedown(function(e) {
      e.preventDefault();
      return root.currentMode.leisureButton();
    });
    $("#leisure_grip").click(function(e) {
      var g;
      g = $("body");
      if (g.hasClass('bar_collapse')) {
        return g.removeClass('bar_collapse');
      } else {
        return g.addClass('bar_collapse');
      }
    });
    $("#themeSelect").change(function(e) {
      return Leisure.setTheme(e.target.value);
    });
    b = $('#saveButton');
    if (typeof nwDispatcher !== "undefined" && nwDispatcher !== null) {
      $(document.body).addClass('nw');
      $('#nwSaveButton')[0].parentSpec = parentSpec;
      fs = require('fs');
    }
    b.mousedown(function() {
      if (root.repo) {
        return root.storeInGit($(parent).text(), null, null, function(err) {
          if (err) {
            return alert("Conflict while attempting to save file to Git.\nPlease take recovery measures.");
          }
        });
      } else if (typeof nwDispatcher !== "undefined" && nwDispatcher !== null) {
        return $('#nwSaveButton').click();
      } else {
        console.log("SAVE: data:text/plain," + (encodeURIComponent($(parent).text())));
        return b.attr('href', "data:text/plain," + (encodeURIComponent($(parent).text())));
      }
    });
    (root.currentMode = Leisure.fancyOrg).useNode($(parent)[0], source);
    return Leisure.initStorage('#login', '#panel', root.currentMode);
  };

  saveFile = function(fileInput) {
    var file;
    if (file = fileInput.files[0]) {
      fileInput.files.clear();
      return fs.writeFile(file.path, $(fileInput.parentSpec).text(), function(err) {
        if (err) {
          return alert("Error saving file " + file.path + ": " + err);
        }
      });
    }
  };

  splitLines = function(str) {
    var nl, pos, result;
    result = [];
    pos = 0;
    while (pos < str.length) {
      nl = str.indexOf('\n', pos);
      if (nl === -1) {
        result.push((str.substring(pos)) + '\n');
        break;
      } else {
        result.push(str.substring(pos, nl + 1));
      }
      pos = nl + 1;
    }
    return result;
  };

  moveCaret = function(r, node, offset) {
    r.setStart(node, offset);
    r.collapse(true);
    return selectRange(r);
  };

  selectRange = function(r) {
    var sel;
    sel = getSelection();
    sel.removeAllRanges();
    return sel.addRange(r);
  };

  contains = function(parent, child) {
    return child !== null && (parent === child || (contains(parent, child.parentNode)));
  };

  getRangeXY = function(r) {
    var leftMost, rect, rects, _i, _len;
    rects = r.getClientRects();
    leftMost = rects[0];
    for (_i = 0, _len = rects.length; _i < _len; _i++) {
      rect = rects[_i];
      if (rect.left < leftMost.left) {
        leftMost = rect;
      }
    }
    return leftMost;
  };

  findCharForColumn = function(node, col, start, end) {
    var i, testRct, testRng, _i, _ref5;
    testRng = document.createRange();
    testRng.setStart(node, start);
    testRng.collapse(true);
    for (i = _i = _ref5 = end - 1; _i >= start; i = _i += -1) {
      testRng.setStart(node, i);
      testRct = getRangeXY(testRng);
      if (testRct.left <= col) {
        moveCaret(testRng, node, testRng.startOffset);
        return true;
      }
    }
    return false;
  };

  rectFor = function(node) {
    var r, rect;
    r = document.createRange();
    if (node.nodeType === 3 && node.data[node.length - 1] === '\n') {
      r.setStart(node, 0);
      r.setEnd(node, node.length - 1);
    } else {
      r.selectNode(node);
    }
    rect = r.getBoundingClientRect();
    if (rect.width === 0) {
      return getRangeXY(r);
    } else {
      return rect;
    }
  };

  movementGoal = null;

  moveSelectionUp = function(parent, r, start) {
    var container, elRect, first, prev, prevEnd, prevRect, prevStart, startRect, txt, _ref5;
    container = r.startContainer;
    startRect = getRangeXY(r);
    if (!(prevKeybinding === keyFuncs.nextLine || prevKeybinding === keyFuncs.previousLine)) {
      movementGoal = startRect.left;
    }
    elRect = rectFor(container);
    if (startRect.top > elRect.top) {
      txt = r.startContainer.textContent;
      prevEnd = txt.substring(0, r.startOffset).lastIndexOf('\n');
      prevStart = txt.substring(0, prevEnd).lastIndexOf('\n') + 1;
      if (findCharForColumn(r.startContainer, movementGoal, prevStart, prevEnd)) {
        return;
      }
    }
    first = textNodeAfter(parent);
    prev = null;
    prevRect = null;
    while (container !== first) {
      if (!(isCollapsed(container))) {
        prev = container;
        prevRect = elRect;
      }
      container = textNodeBefore(container);
      if (!isCollapsed(container)) {
        elRect = rectFor(container);
        if ((elRect.top < (_ref5 = prevRect.top) && _ref5 < startRect.top)) {
          if (!findCharForColumn(prev, movementGoal, 0, prev.length)) {
            moveCaret(r, prev, 0);
          }
          return;
        }
        if ((elRect.left <= movementGoal && movementGoal < elRect.right) && findCharForColumn(container, movementGoal, 0, container.length)) {
          return;
        }
      }
    }
  };

  moveSelectionDown = function(parent, r, start) {
    var container, elRect, end, last, prev, prevRect, startRect, txt, _ref5;
    container = r.startContainer;
    startRect = getRangeXY(r);
    if (!(prevKeybinding === keyFuncs.nextLine || prevKeybinding === keyFuncs.previousLine)) {
      movementGoal = startRect.left;
    }
    elRect = rectFor(container);
    if (startRect.bottom < elRect.bottom) {
      txt = r.startContainer.textContent;
      start = txt.indexOf('\n', r.startOffset + 1);
      if (start > -1) {
        end = txt.indexOf('\n', start + 1);
        if (end === -1) {
          end = r.startContainer.length;
        }
        if (findCharForColumn(r.startContainer, movementGoal, start, end)) {
          return;
        }
      }
    }
    last = textNodeBefore(parent);
    prev = null;
    prevRect = null;
    while (container !== last) {
      if (!(isCollapsed(container))) {
        prev = container;
        prevRect = elRect;
      }
      container = textNodeAfter(container);
      if (!isCollapsed(container)) {
        elRect = rectFor(container);
        if ((startRect.bottom < (_ref5 = prevRect.bottom) && _ref5 < elRect.bottom)) {
          if (!findCharForColumn(prev, movementGoal, 0, prev.length)) {
            moveCaret(r, prev, 0);
          }
          return;
        }
        if ((elRect.left <= movementGoal && movementGoal < elRect.right)) {
          end = container.data.indexOf('\n');
          if (end === -1) {
            end = container.length;
          }
          if (findCharForColumn(container, movementGoal, 0, end)) {
            return;
          }
        }
      }
    }
  };

  nextVisibleNewline = function(textNode, offset) {
    return scanForward(textNode, -1, whenNotCollapsed(function(node) {
      return node.data.indexOf('\n', offset + 1);
    }), whenNotCollapsed(function(node) {
      return node.data.indexOf('\n');
    }));
  };

  whenNotCollapsed = function(block) {
    return function(node) {
      if (isCollapsed(node)) {
        return -1;
      } else {
        return block(node);
      }
    };
  };

  scanForward = function(textNode, falseValue, firstBlock, block) {
    var val;
    if ((val = firstBlock(textNode)) !== falseValue) {
      return [textNode, val];
    } else {
      while ((textNode = textNodeAfter(textNode)) && (val = block(textNode)) === falseValue) {
        true;
      }
      if (textNode) {
        return [textNode, val];
      } else {
        return [];
      }
    }
  };

  moveSelectionFB = function(parent, r, start, delta) {
    var move, startContainer, startOffset;
    r.collapse(start);
    startContainer = r.startContainer;
    startOffset = r.startOffset + delta;
    move = (delta < 0 ? textNodeBefore : textNodeAfter);
    while (true) {
      if (isCollapsed(startContainer)) {
        startContainer = move(startContainer);
      } else {
        if (!((0 <= startOffset && startOffset <= startContainer.length))) {
          startContainer = move(startContainer);
          if (isCollapsed(startContainer)) {
            while (isCollapsed(startContainer)) {
              startContainer = move(startContainer);
            }
          }
          if (delta < 0 && startContainer !== null) {
            startOffset = startContainer.length - 1;
          } else {
            startOffset = 1;
          }
        }
        if (startContainer !== null && contains(parent, startContainer)) {
          if (startOffset < startContainer.length) {
            r.setStart(startContainer, startOffset);
            r.collapse(true);
            selectRange(r);
            return;
          } else {
            startContainer = move(startContainer);
            startOffset = 0;
          }
        } else {
          return;
        }
      }
    }
  };

  keyFuncs = {
    backwardChar: function(e, parent, r) {
      e.preventDefault();
      moveSelectionFB(parent, r, true, -1);
      return false;
    },
    forwardChar: function(e, parent, r) {
      e.preventDefault();
      moveSelectionFB(parent, r, false, 1);
      return false;
    },
    previousLine: function(e, parent, r) {
      e.preventDefault();
      moveSelectionUp(parent, r);
      return false;
    },
    nextLine: function(e, parent, r) {
      e.preventDefault();
      moveSelectionDown(parent, r);
      return false;
    },
    swapMarkup: function(e, parent, r) {
      e.preventDefault();
      swapMarkup();
      return false;
    },
    expandTemplate: function(e, parent, r) {
      var exp, first, next, pos, second, start, str, txt;
      e.preventDefault();
      txt = r.startContainer;
      if (r.collapsed && txt.nodeType === 3 && ((r.startOffset > 2 && txt.data[r.startOffset - 3] === '\n') || (r.startOffset === 2 && followsNewline(txt)))) {
        str = txt.data.substring(r.startOffset - 2, r.startOffset);
        if (exp = templateExpansions[str]) {
          start = r.startOffset;
          first = exp[0], second = exp[1];
          pos = (getTextPosition(parent, txt, start)) - 2;
          if (start === txt.data.length) {
            next = null;
            txt.data = txt.data.substring(0, txt.data.length - 2);
          } else {
            next = (start === 2 ? txt : txt.splitText(start - 2));
            next.data = next.data.substring(2);
          }
          txt.parentNode.insertBefore(document.createTextNode(first + second), next);
          selectRange(nativeRange(findDomPosition(parent, pos + first.length)));
          return reparse(parent);
        }
      }
    }
  };

  followsNewline = function(txt) {
    var prev;
    prev = textNodeBefore(txt);
    return !prev || prev.data[prev.data.length - 1] === '\n';
  };

  templateExpansions = {
    '<s': ['#+BEGIN_SRC leisure\n', '\n#+END_SRC'],
    '<=': ['#+BEGIN_SRC leisure :results def\n', '\n#+END_SRC'],
    '<d': ['#+BEGIN_SRC leisure :results dynamic\n', '\n#+END_SRC'],
    '<h': ['#+BEGIN_HTML\n', '\n#+END_HTML']
  };

  defaultBindings = {
    'C-C C-C': keyFuncs.swapMarkup,
    'C-F': keyFuncs.forwardChar,
    'C-B': keyFuncs.backwardChar,
    'C-P': keyFuncs.previousLine,
    'C-N': keyFuncs.nextLine,
    'UP': keyFuncs.previousLine,
    'DOWN': keyFuncs.nextLine,
    'LEFT': keyFuncs.backwardChar,
    'RIGHT': keyFuncs.forwardChar,
    'TAB': keyFuncs.expandTemplate
  };

  swapMarkup = function() {
    root.currentMode = (root.currentMode === Leisure.fancyOrg ? Leisure.basicOrg : Leisure.fancyOrg);
    return root.restorePosition(parentSpec, function() {
      return root.currentMode.useNode($(parentSpec)[0], sourceSpec);
    });
  };

  getStyle = function(node) {
    var style;
    if (!node.orgId) {
      node.orgId = node.getAttribute('data-org-id');
      if (!node.orgId) {
        modifying = true;
        node.setAttribute('data-org-id', (node.orgId = nextOrgId()));
        modifying = false;
      }
    }
    style = styleCache[node.orgId];
    if (!style) {
      style = styleCache[node.orgId] = getComputedStyle(node);
    }
    return style;
  };

  isCollapsedOld = function(node) {
    var type;
    if (node) {
      type = node.nodeType;
      return type === 7 || type === 8 || (type === 3 && (node.data === '' || isCollapsed(node.parentNode))) || /^(script|style)$/i.test(node.nodeName) || (type === 1 && (node.classList.contains('collapsed') || getStyle(node).display === 'none' || isCollapsed(node.parentNode)));
    } else {
      return false;
    }
  };

  isCollapsed = function(node) {
    var type;
    if (node) {
      type = node.nodeType;
      return type === 7 || type === 8 || (type === 3 && (node.data === '' || isCollapsed(node.parentNode))) || /^(script|style)$/i.test(node.nodeName) || (type === 1 && (node.offsetWidth === 0 || node.offsetHeight === 0));
    } else {
      return false;
    }
  };

  markupOrg = function(text) {
    var node, result, _ref5;
    _ref5 = markupOrgWithNode(text), node = _ref5[0], result = _ref5[1];
    return result;
  };

  markupOrgWithNode = function(text) {
    var org;
    nodes = {};
    if (text[text.length - 1] !== '\n') {
      text = text + '\n';
    }
    org = parseOrgMode(text);
    return [org, markupNode(org, true)];
  };

  boundarySpan = "<span data-org-type='boundary'>\n</span>";

  sensitive = /^srcStart|^headline-|^keyword/;

  orgAttrs = function(org) {
    var extra, rt, t, _ref5;
    if (!org.nodeId) {
      org.nodeId = nextOrgId();
    }
    nodes[org.nodeId] = org;
    extra = (rt = resultsType(org)) ? " data-org-results='" + rt + "'" : '';
    t = org.allTags();
    if (t.length) {
      extra += " data-org-tags='" + (escapeAttr(t.join(' '))) + "'";
      global.ORG = org;
    }
    if (org instanceof Keyword && !(org instanceof Source) && org.next instanceof Source && ((_ref5 = org.name) != null ? _ref5.toLowerCase() : void 0) === 'name') {
      extra += " data-org-name='" + (escapeAttr(org.info)) + "'";
    }
    if (org instanceof Headline) {
      extra += " data-org-headline='" + (escapeAttr(org.level)) + "'";
    }
    if (org.srcId) {
      extra += " data-org-srcid='" + (escapeAttr(org.srcId)) + "'";
    }
    return "id='" + (escapeAttr(org.nodeId)) + "' data-org-type='" + (escapeAttr(org.type)) + "'" + extra;
  };

  resultsType = function(org) {
    var _ref5;
    return org instanceof Source && ((_ref5 = org.info.match(/:results *([^ ]*)/)) != null ? _ref5[1].toLowerCase() : void 0);
  };

  isDynamic = function(org) {
    return resultsType(org) === 'dynamic';
  };

  isDef = function(org) {
    return resultsType(org) === 'def';
  };

  orgSrcAttrs = function(org) {
    return "data-org-src='" + (isDef(org) ? 'def' : isDynamic(org) ? 'dynamic' : 'example') + "'";
  };

  markupNode = function(org, start) {
    var pos, text;
    if (org instanceof Source || org instanceof Results) {
      pos = org.contentPos - org.offset - 1;
      text = org.text.substring(pos);
      return "<span " + (orgAttrs(org)) + (codeBlockAttrs(org)) + "><span data-org-type='text'>" + (escapeHtml(org.text.substring(0, pos))) + "</span><span " + (orgSrcAttrs(org)) + ">" + (contentSpan(text)) + "</span></span>";
    } else if (org instanceof Headline) {
      return "<span " + (orgAttrs(org)) + ">" + (contentSpan(org.text, 'text')) + (markupGuts(org, checkStart(start, org.text))) + "</span>";
    } else if (org instanceof SimpleMarkup) {
      return markupSimple(org);
    } else {
      return "<span " + (orgAttrs(org)) + ">" + (content(org.text)) + "</span>";
    }
  };

  markupSimple = function(org) {
    var c, guts, t, _i, _len, _ref5;
    guts = '';
    _ref5 = org.children;
    for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
      c = _ref5[_i];
      guts += markupNode(c);
    }
    t = org.text[0];
    switch (org.markupType) {
      case 'bold':
        return "<b>" + t + guts + t + "</b>";
      case 'italic':
        return "<i>" + t + guts + t + "</i>";
      case 'underline':
        return "<span style='text-decoration: underline'>" + t + guts + t + "</span>";
      case 'strikethrough':
        return "<span style='text-decoration: line-through'>" + t + guts + t + "</span>";
      case 'code':
        return "<code>" + t + guts + t + "</code>";
      case 'verbatim':
        return "<code>" + t + guts + t + "</code>";
    }
  };

  codeBlockAttrs = function(org) {
    while ((org = org.prev) instanceof Meat) {
      if (org instanceof Keyword && org.name.match(/^name$/i)) {
        return " data-org-codeblock='" + (escapeAttr(org.info.trim())) + "'";
      }
    }
    return '';
  };

  createResults = function(srcNode) {};

  checkStart = function(start, text) {
    return start && (!text || text === '\n');
  };

  isSourceNode = function(node) {
    return (node != null ? typeof node.getAttribute === "function" ? node.getAttribute('data-org-type') : void 0 : void 0) === 'source';
  };

  isDocNode = function(node) {
    return node != null ? typeof node.hasAttribute === "function" ? node.hasAttribute('maindoc') : void 0 : void 0;
  };

  markupGuts = function(org, start) {
    var c, p, prev, s;
    if (!org.children.length) {
      return '';
    } else {
      prev = start ? null : org;
      return ((function() {
        var _i, _len, _ref5, _results;
        _ref5 = org.children;
        _results = [];
        for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
          c = _ref5[_i];
          s = start;
          start = false;
          p = prev;
          prev = c;
          _results.push(optionalBoundary(p, c) + markupNode(c, s));
        }
        return _results;
      })()).join("");
    }
  };

  optionalBoundary = function(prev, node) {
    if (prev && prev.text[prev.text.length - 1] === '\n') {
      return boundarySpan;
    } else {
      return '';
    }
  };

  contentSpan = function(str, type) {
    str = content(str);
    if (str) {
      return "<span" + (type ? " data-org-type='" + (escapeAttr(type)) + "'" : '') + ">" + (escapeHtml(str)) + "</span>";
    } else {
      return '';
    }
  };

  content = function(str) {
    return escapeHtml((str[str.length - 1] === '\n' ? str.substring(0, str.length - 1) : str));
  };

  fixupNodes = function(node) {
    var n, _i, _len, _ref5, _results;
    _ref5 = $(node).find('[data-org-type="headline"]');
    _results = [];
    for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
      n = _ref5[_i];
      _results.push(setTags(n));
    }
    return _results;
  };

  isCollapsibleText = function(node) {
    var _ref5;
    return node.nodeType === 3 && ((_ref5 = node.parentNode.getAttribute('data-org-type')) === 'text' || _ref5 === 'meat');
  };

  shiftKey = function(c) {
    return (15 < c && c < 19);
  };

  specialKeys = {};

  specialKeys[TAB] = 'TAB';

  specialKeys[ENTER] = 'ENTER';

  specialKeys[BS] = 'BS';

  specialKeys[DEL] = 'DEL';

  specialKeys[LEFT] = 'LEFT';

  specialKeys[RIGHT] = 'RIGHT';

  specialKeys[UP] = 'UP';

  specialKeys[DOWN] = 'DOWN';

  specialKeys[PAGEUP] = 'PAGEUP';

  specialKeys[PAGEDOWN] = 'PAGEDOWN';

  modifiers = function(e, c) {
    var res;
    res = specialKeys[c] || String.fromCharCode(c);
    if (e.altKey) {
      res = "M-" + res;
    }
    if (e.ctrlKey) {
      res = "C-" + res;
    }
    if (e.shiftKey) {
      res = "S-" + res;
    }
    return res;
  };

  lastKeys = [];

  maxLastKeys = 4;

  keyCombos = [];

  addKeyPress = function(e, c) {
    var i, notShift, _i, _ref5;
    if (notShift = !shiftKey(c)) {
      lastKeys.push(modifiers(e, c));
      while (lastKeys.length > maxLastKeys) {
        lastKeys.shift();
      }
      keyCombos = new Array(maxLastKeys);
      for (i = _i = 0, _ref5 = Math.min(lastKeys.length, maxLastKeys); 0 <= _ref5 ? _i < _ref5 : _i > _ref5; i = 0 <= _ref5 ? ++_i : --_i) {
        keyCombos[i] = lastKeys.slice(lastKeys.length - i - 1, lastKeys.length).join(' ');
      }
      keyCombos.reverse();
    }
    return notShift;
  };

  prevKeybinding = curKeyBinding = null;

  setCurKeyBinding = function(f) {
    prevKeybinding = curKeyBinding;
    return curKeyBinding = f;
  };

  findKeyBinding = function(e, parent, r) {
    var f, k, _i, _len;
    for (_i = 0, _len = keyCombos.length; _i < _len; _i++) {
      k = keyCombos[_i];
      if (f = root.currentMode.bindings[k]) {
        lastKeys = [];
        keyCombos = [];
        setCurKeyBinding(f);
        return [true, f(e, parent, r)];
      }
    }
    setCurKeyBinding(null);
    return [false];
  };

  bindContent = function(div) {
    fixupNodes(div);
    div.addEventListener('mousedown', function(e) {
      return setCurKeyBinding(null);
    });
    div.addEventListener('keydown', function(e) {
      var bound, br, c, cancelled, checkMod, currentMatch, el, inCollapsedText, n, par, r, s, _ref5;
      c = e.charCode || e.keyCode || e.which;
      if (!addKeyPress(e, c)) {
        return;
      }
      s = getSelection();
      r = s.getRangeAt(0);
      el = r.startContainer;
      par = el.parentNode;
      _ref5 = findKeyBinding(e, div, r), bound = _ref5[0], checkMod = _ref5[1];
      if (bound) {
        cancelled = !checkMod;
      } else {
        checkMod = modifyingKey(c);
        cancelled = false;
      }
      if (!bound) {
        if (c === TAB) {
          e.preventDefault();
          cancelled = true;
          collapseNode();
        } else if (String.fromCharCode(c) === 'C' && e.altKey) {
          root.orgApi.executeSource(div, getSelection().focusNode);
        } else if (c === ENTER) {
          e.preventDefault();
          cancelled = true;
          n = s.focusNode;
          inCollapsedText = r.collapsed && isCollapsibleText(el && par.parentElement.classList.contains('collapsed') && el.nextSibling === null);
          if (inCollapsedText && r.startOffset === el.length) {
            return;
          } else if (r.collapsed && r.startOffset === n.length && isCollapsibleText(n)) {
            br = document.createTextNode('\n');
            $(br).prependTo(followingSpan(n.parentNode));
            r.setStart(br, br.length);
            r.setEnd(br, br.length);
          } else {
            window.N = n;
            r.insertNode(br = document.createTextNode(checkExtraNewline(r, n, div)));
            br.parentNode.normalize();
          }
          r.collapse();
          selectRange(r);
          checkEnterReparse(div, r);
        } else if (c === DEL || c === BS) {
          inCollapsedText = r.collapsed && isCollapsibleText(el && par.parentElement.classList.contains('collapsed') && el.nextSibling === null);
          if (inCollapsedText && ((c === DEL && r.startOffset === el.length - 1) || (c === BS && r.startOffset === el.length))) {
            e.preventDefault();
            cancelled = true;
            el.data = el.data.substring(0, el.data.length - 1);
            r.setStart(el, el.data.length);
            r.setEnd(el, el.data.length);
            selectRange(r);
          } else if (c === DEL && inCollapsedText && r.startOffset >= el.length - 1) {
            e.preventDefault();
            cancelled = true;
          } else if (backspace(div, e)) {
            cancelled = true;
          } else if (c !== BS) {
            checkDeleteReparse(div, c === BS);
          }
        }
      }
      if (!cancelled && checkMod) {
        if ((getOrgType(getOrgParent(el))) === 'boundary') {
          needsReparse = true;
        }
        currentMatch = matchLine(currentLine(div));
        return setTimeout((function() {
          return checkSourceMod(div, currentMatch);
        }), 1);
      }
    });
    div.addEventListener('DOMCharacterDataModified', handleMutation, true);
    div.addEventListener('DOMSubtreeModified', handleMutation, true);
    return displaySource();
  };

  modifyingKey = function(c) {
    return ((47 < c && c < 58)) || c === 32 || c === ENTER || c === BS || c === DEL || ((64 < c && c < 91)) || ((95 < c && c < 112)) || ((185 < c && c < 193)) || ((218 < c && c < 223));
  };

  currentLine = function(parent) {
    var lineEnd, lineStart, lineText, nl, node, r;
    r = getSelection().getRangeAt(0);
    if (r.collapsed && r.startContainer.nodeType === 3) {
      nl = r.startContainer.data.substring(0, r.startOffset).lastIndexOf('\n');
      lineText = r.startContainer.data;
      lineStart = -1;
      lineEnd = -1;
      if ((-1 < nl && nl < r.startOffset)) {
        lineStart = nl;
      } else {
        node = r.startContainer;
        while (node && lineStart === -1) {
          if (node = textNodeBefore(node)) {
            lineText = node.data + lineText;
            lineStart = node.data.lastIndexOf('\n');
          }
        }
      }
      nl = r.startContainer.data.indexOf('\n', r.startOffset);
      if (nl >= r.startOffset) {
        lineEnd = nl + lineText.length - r.startContainer.data.length;
      } else {
        node = r.startContainer;
        while (node && lineEnd === -1) {
          if (node = textNodeAfter(node)) {
            lineText += node.data;
            if ((nl = node.data.indexOf('\n')) > -1) {
              lineEnd = nl + lineText.length - r.startContainer.data.length;
            }
          }
        }
      }
      if (lineEnd === -1) {
        lineEnd = lineText.length;
      }
      return lineText.substring(lineStart + 1, lineEnd);
    } else {
      return '';
    }
  };

  collapseNode = function() {
    var node;
    node = getCollapsible(getSelection().focusNode);
    if (node) {
      if (!isEmptyCollapsible(node)) {
        modifying = true;
        $(node).toggleClass('collapsed');
        styleCache = {};
        return modifying = false;
      } else {
        return status("EMPTY ENTRY");
      }
    }
  };

  isBoundary = function(node) {
    return (node.nodeType === 1 && node.getAttribute('data-org-type') === 'boundary' && node) || (node.nodeType === 3 && isBoundary(node.parentElement));
  };

  backspace = function(parent, e) {
    if (checkCollapsed(-1)) {
      e.preventDefault();
      return true;
    } else {
      return false;
    }
  };

  checkCollapsed = function(delta) {
    var node;
    node = getSelection().focusNode;
    return node && (isCollapsed((delta < 0 ? textNodeBefore : textNodeAfter)(node)));
  };

  checkSourceMod = function(parent, oldMatch) {
    var n, newMatch, r, _ref5;
    r = getSelection().getRangeAt(0);
    if ((newMatch = matchLine(currentLine(parent))) !== oldMatch || (newMatch && newMatch.match(sensitive))) {
      return reparse(parent);
    } else if ($(r.startContainer).closest('[data-org-src]').length && (n = getOrgParent(r.startContainer))) {
      switch ((_ref5 = n.getAttribute('data-org-results')) != null ? _ref5.toLowerCase() : void 0) {
        case 'dynamic':
          return root.orgApi.executeSource(parent, r.startContainer);
        case 'def':
          return root.orgApi.executeDef(n);
      }
    }
  };

  replacements = {
    '<': '&lt;',
    '>': '&gt;'
  };

  escapeHtml = function(str) {
    if (typeof str === 'string') {
      return str.replace(/[<>]/g, function(c) {
        return replacements[c];
      });
    } else {
      return str;
    }
  };

  escapeAttr = function(str) {
    if (typeof str === 'string') {
      return str.replace(/['"&]/g, function(c) {
        switch (c) {
          case '"':
            return '&quot;';
          case "'":
            return '&#39;';
          case '&':
            return '&amp;';
        }
      });
    } else {
      return str;
    }
  };

  presentValue = function(v) {
    return rz(L_showHtml)(lz(v));
  };

  orgEnv = function(parent, node) {
    var env, r;
    r = getResultsForSource(parent, node);
    env = {
      presentValue: presentValue,
      readFile: function(filename, cont) {
        return window.setTimeout((function() {
          return $.get(filename, function(data) {
            return cont(false, data);
          });
        }), 1);
      },
      writeFile: function() {},
      newCodeContent: function(name, con) {
        return console.log("NEW CODE CONTENT: " + name + ", " + con);
      },
      __proto__: defaultEnv
    };
    if (r) {
      r.innerHTML = '';
      env.write = function(str) {
        return r.textContent += "\n: " + (str.replace(/\n/g, '\n: '));
      };
    } else {
      env.write = function(str) {
        return console.log(": " + (str.replace(/\n/g, '\n: ')) + "\n");
      };
    }
    return env;
  };

  baseEnv = {
    __proto__: defaultEnv,
    readFile: function(filename, cont) {
      return window.setTimeout((function() {
        return $.get(filename, function(data) {
          return cont(false, data);
        });
      }), 1);
    },
    write: function(str) {
      return console.log(unescapePresentationHtml(str));
    },
    newCodeContent: function(name, con) {
      return console.log("NEW CODE CONTENT: " + name + ", " + con);
    }
  };

  getResultsForSource = function(parent, node) {
    var org, pos, res, results, src;
    checkReparse(parent);
    res = node;
    while (getOrgType(res.nextSibling) === 'boundary' || (getOrgType(res.nextSibling) === 'meat' && res.textContent.match(/^[ \n]*$/))) {
      res = res.nextSibling;
    }
    res = res.nextSibling;
    if ((res != null ? res.getAttribute('data-org-type') : void 0) === 'results') {
      return res.lastChild;
    } else {
      org = parseOrgMode(getNodeText(parent));
      pos = getTextPosition(parent, node, 0);
      src = org.findNodeAt(pos);
      if (pos > -1) {
        results = src.next;
        if (!(results instanceof Results)) {
          results = results instanceof Meat && results.text.match(/^[ \n]*$/) ? results.next : void 0;
          if (!(results instanceof Results)) {
            results = newResults(parent, src);
          }
        }
        return getCollapsible(findDomPosition(parent, results.offset + 1)[0]).lastChild;
      } else {
        return null;
      }
    }
  };

  checkReparse = function(parent) {
    if (needsReparse) {
      return reparse(parent);
    }
  };

  nativeRange = function(r) {
    var container, offset, r2;
    if (r instanceof Range) {
      return r;
    } else {
      r2 = document.createRange();
      container = r instanceof Array ? r[0] : r.startContainer;
      if (!container) {
        return null;
      } else {
        offset = r instanceof Array ? r[1] : r.startOffset;
        r2.setStart(container, offset);
        r2.collapse(true);
        return r2;
      }
    }
  };

  hasParent = function(node, ancestor) {
    return node === ancestor || (node && hasParent(node.parent, ancestor));
  };

  restorePosition = function(parent, offset, block) {
    var end, endContainer, endOffset, r, sel, start, _ref5;
    if (!block) {
      block = offset;
      offset = 0;
    }
    sel = getSelection();
    if (sel != null ? sel.rangeCount : void 0) {
      r = sel.getRangeAt(0);
      start = offset + getTextPosition($(parent)[0], r.startContainer, r.startOffset);
      end = offset + getTextPosition($(parent)[0], r.endContainer, r.endOffset);
      block();
      if (start > -1 && (r = nativeRange(findDomPosition($(parent)[0], start)))) {
        _ref5 = findDomPosition($(parent)[0], end), endContainer = _ref5[0], endOffset = _ref5[1];
        r.setEnd(endContainer, endOffset);
        return selectRange(r);
      }
    } else {
      return block();
    }
  };

  crnl = function(data) {
    return data.replace(/\r\n/g, '\n');
  };

  loadOrg = function(parent, text, path) {
    text = crnl(text);
    if (typeof nwDispatcher !== "undefined" && nwDispatcher !== null) {
      $('#nwSaveButton').attr('nwsaveas', path);
    } else {
      $('#saveButton').attr('download', path);
    }
    reparse(parent, text);
    return setTimeout((function() {
      var node, _i, _len, _ref5, _results;
      _ref5 = $(parent).find('[data-org-src="def"]');
      _results = [];
      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
        node = _ref5[_i];
        _results.push(executeDef(node));
      }
      return _results;
    }), 1);
  };

  reparse = function(parent, text) {
    var orgNode, orgText, sel, _ref5;
    styleCache = {};
    text = text != null ? text : getNodeText(parent);
    sel = getSelection();
    _ref5 = root.orgApi.markupOrgWithNode(text), orgNode = _ref5[0], orgText = _ref5[1];
    root.restorePosition(parent, function() {
      return root.orgApi.installOrgDOM(parent, orgNode, orgText);
    });
    needsReparse = false;
    return setTimeout((function() {
      var l, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = reparseListeners.length; _i < _len; _i++) {
        l = reparseListeners[_i];
        _results.push(l(parent, orgNode, orgText));
      }
      return _results;
    }), 1);
  };

  installOrgDOM = function(parent, orgNode, orgText) {
    var markPositions;
    markPositions = getMarkPositions(parent);
    parent.innerHTML = orgText;
    return restoreMarkPositions(parent, markPositions);
  };

  getMarkPositions = function(node) {
    var cur, offset, positions, _i, _len, _ref5;
    positions = [];
    offset = 0;
    cur = node;
    _ref5 = $('[data-mark]');
    for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
      node = _ref5[_i];
      while ((cur = nodeAfter(cur)) && cur !== node) {
        if (cur.nodeType === 3) {
          offset += cur.data.length;
        }
      }
      positions.push(offset, node.getAttribute('data-mark'));
    }
    return positions;
  };

  markId = 0;

  createMarkNode = function() {
    return $("<span data-mark=" + (markId++) + "></span>");
  };

  restoreMarkPositions = function(node, positions) {
    var count, limit, newMark, next, offset, oldOffset, _results;
    offset = 0;
    count = 0;
    limit = nodeAfterNoChildren(node);
    _results = [];
    while (count < positions.length && node !== limit) {
      next = positions[count];
      while (node && node !== limit && offset < next) {
        node = nodeAfter(node);
        if (node.nodeType === 3) {
          oldOffset = offset;
          offset += node.data.length;
          if (offset >= next) {
            newMark = createMarkNode();
            if (offset > next) {
              node.splitText(next - oldOffset);
            }
            node.parentNode.insertBefore(newMark, node.nextSibling);
          }
        }
      }
      _results.push(count++);
    }
    return _results;
  };

  checkDeleteReparse = function(parent, backspace) {
    var next, prev, r;
    r = getSelection().getRangeAt(0);
    if (backspace) {
      if (r.startOffset === 0) {
        return (prev = textNodeBefore(r.startContainer)) && prev.data[prev.data.length - 1] === '\n';
      } else {
        return r.startContainer.data[r.startOffset - 1] === '\n';
      }
    } else {
      if (r.startOffset === r.startContainer.data.length) {
        return (next = textNodeAfter(r.startContainer)) && next.data[0] === '\n';
      } else {
        return r.startContainer.data[r.startOffset + 1] === '\n';
      }
    }
  };

  checkEnterReparse = function(parent, r) {
    var result;
    if ((result = getCollapsible(r.startContainer))) {
      reparse(parent);
    }
    return result;
  };

  newResults = function(parent, src) {
    var srcEnd, text;
    text = src.top().allText();
    srcEnd = src.end();
    reparse(parent, text.substring(0, srcEnd) + "#+RESULTS:\n: \n" + text.substring(srcEnd));
    return findOrgNode(parent, srcEnd + 1);
  };

  id = lz(function(x) {
    return rz(x);
  });

  getLeft = function(x) {
    return x(id)(id);
  };

  getRight = function(x) {
    return x(id)(id);
  };

  show = function(obj) {
    if (typeof L_show !== "undefined" && L_show !== null) {
      return rz(L_show)(lz(obj));
    } else {
      return console.log(obj);
    }
  };

  propsFor = function(node) {
    var name, props, tags;
    props = Nil;
    tags = (node.getAttribute('data-org-tags') || '').trim();
    if (tags) {
      props = cons(cons('tags', consFrom(tags.trim().split(' '))), props);
    }
    name = (node.getAttribute('data-org-codeblock') || '').trim();
    if (name) {
      props = cons(cons('block', name), props);
    }
    return props;
  };

  executeText = function(text, props, env, cont) {
    var old, result;
    old = getValue('parser_funcProps');
    setValue('parser_funcProps', props);
    result = rz(L_baseLoadString)('notebook')(text);
    return runMonad(result, env, function(results) {
      var res;
      while (results !== L_nil()) {
        res = results.head().tail();
        if (getType(res) === 'left') {
          env.write("PARSE ERROR: " + (getLeft(res)));
        } else {
          env.write(String(env.presentValue(getRight(res))));
        }
        results = results.tail();
      }
      setValue('parser_funcProps', old);
      return typeof cont === "function" ? cont() : void 0;
    });
  };

  getSource = function(node) {
    var m, txt;
    while (node && !isSourceNode(node)) {
      node = node.parentNode;
    }
    if (node) {
      txt = $(node).text().substring($(node).find('[data-org-type="text"]').text().length);
      m = txt.match(/(^|\n)#\+end_src/i);
      if (m) {
        return txt.substring(0, m.index);
      } else {
        return null;
      }
    }
  };

  executeSource = function(parent, node, cont) {
    var txt;
    if (isSourceNode(node)) {
      checkReparse(parent);
      if (txt = getSource(node)) {
        return executeText(txt, propsFor(node), orgEnv(parent, node), cont);
      } else {
        return console.log("No end for src block");
      }
    } else if (getOrgType(node) === 'text') {
      return needsReparse = true;
    } else {
      return !isDocNode(node) && executeSource(parent, node.parentElement);
    }
  };

  getNodeSource = function(node) {
    while (!isSourceNode(node)) {
      node = node.parentNode;
      if (!node) {
        return [];
      }
    }
    return [node, $(node).find('[data-org-src]')[0].textContent];
  };

  executeDef = function(node, cont) {
    var srcNode, text, _ref5;
    _ref5 = getNodeSource(node), srcNode = _ref5[0], text = _ref5[1];
    if (srcNode) {
      return executeText(text, propsFor(srcNode), baseEnv, cont);
    }
  };

  followingSpan = function(node) {
    var _ref5;
    return (_ref5 = node.nextElementSibling) != null ? _ref5 : $('<span></span>').appendTo(node.parentNode)[0];
  };

  checkExtraNewline = function(range, n, parent) {
    if (range.collapsed && n.nodeType === 3 && range.startOffset === n.length && n.textContent[n.length - 1] !== '\n') {
      return checkLast(n, parent);
    } else {
      return '\n';
    }
  };

  checkLast = function(n, parent) {
    if (n === parent) {
      return '\n\n';
    } else if (n.nextSibling) {
      return '\n';
    } else {
      return checkLast(n.parentNode, parent);
    }
  };

  getTags = function(headline) {
    if (headline.getAttribute('dirty')) {
      cleanHeadline(headline);
      setTags(headline);
    }
    return headline.getAttribute('data-org-tags');
  };

  setTags = function(headline) {
    var m, tags;
    m = headline.firstChild.textContent.match(headlineRE);
    tags = ((m && parseTags(m[HL_TAGS])) || []).join(' ');
    if (headline.getAttribute('data-org-tags') !== tags) {
      return headline.setAttribute('data-org-tags', tags);
    }
  };

  cleanHeadline = function(node) {
    modifying = true;
    node.removeAttribute('dirty');
    return modifying = false;
  };

  handleMutation = function(evt) {
    var node;
    if (!modifying) {
      invalidateOrgText();
      modifying = true;
      if ((node = getCollapsible(evt.srcElement)) && (node.getAttribute('data-org-type') === 'headline')) {
        node.setAttribute('dirty', 'true');
      }
      displaySource();
      return modifying = false;
    }
  };

  displaySource = function() {
    return $(sourceDiv).html('').text($(editDiv).text());
  };

  isCollapsible = function(node) {
    var _ref5;
    return (_ref5 = node.getAttribute('data-org-type')) === 'headline' || _ref5 === 'source' || _ref5 === 'results';
  };

  getCollapsible = function(node) {
    var _ref5;
    if (node.nodeType === 1) {
      if (isCollapsible(node)) {
        return node;
      } else {
        return ((_ref5 = node.getAttribute('data-org-type')) === 'text' || _ref5 === 'meat') && getCollapsible(node.parentElement);
      }
    } else {
      return node.nodeType === 3 && getCollapsible(node.parentElement);
    }
  };

  getOrgParent = function(node) {
    return node && ((node.nodeType === 1 && isCollapsible(node) && node) || getOrgParent(node.parentElement));
  };

  isEmptyCollapsible = function(node) {
    var firstLine;
    firstLine = getTextLine(node);
    return node.firstChild === node.lastChild;
  };

  getTextLine = function(node) {
    var c;
    c = node.firstElementChild;
    while (c) {
      if (c.getAttribute('data-org-type') === 'text') {
        return c;
      }
      c = c.nextElementSibling;
    }
    return null;
  };

  findOrgNode = function(parent, pos) {
    var org, orgNode;
    org = parseOrgMode(getNodeText(parent));
    return orgNode = org.findNodeAt(pos);
  };

  getTextPosition = function(node, target, pos) {
    var n, o;
    o = getTextPositionOld(node, target, pos);
    n = getTextPositionNew(node, target, pos);
    if (o !== n) {
      console.log("OLD: " + o + ", NEW: " + n);
    }
    return n;
  };

  getTextPositionNew = function(node, target, pos) {
    var childPos, limit, offset;
    if (node) {
      offset = 0;
      childPos = 0;
      limit = (function() {
        switch (target.nodeType) {
          case 1:
            if (pos + 1 < node.childNodes.length) {
              return node.childNodes[pos + 1];
            } else {
              return nodeAfterNoChildren(node);
            }
            break;
          case 3:
            return target;
          default:
            return nodeAfter(node);
        }
      })();
      while (node && node !== limit) {
        if (node.nodeType === 3) {
          offset += node.data.length;
        }
        node = nodeAfter(node);
      }
      if (target.nodeType === 3) {
        return offset + pos;
      } else {
        return offset;
      }
    } else {
      return -1;
    }
  };

  getTextPositionOld = function(node, target, pos) {
    var r;
    if (node && target && pos) {
      r = document.createRange();
      r.setStart(node, 0);
      r.setEnd(target, pos);
      return r.cloneContents().textContent.length;
    } else {
      return -1;
    }
  };

  countCharactersFrom = function(start, end) {
    var total;
    total = 0;
    while (start && start !== end) {
      if (start.nodeType === 3) {
        total += start.data.length;
      }
      start = nodeAfter(start);
    }
    if (start === end) {
      return total;
    } else {
      return -1;
    }
  };

  findDomPosition = function(node, pos) {
    var n, parent;
    parent = node;
    while (node) {
      if (node.nodeType === 3) {
        if (pos < node.length) {
          n = node;
          while (n !== parent && n !== null) {
            n = n.parentNode;
          }
          if (n === null) {
            return [null, null];
          } else {
            return [node, pos];
          }
        }
        pos -= node.length;
      }
      node = textNodeAfter(node);
    }
    return [null, null];
  };

  nodeAfterNoChildren = function(node) {
    return nodeAfter(nodeBefore(node));
  };

  nodeAfter = function(node) {
    var up;
    up = false;
    while (node) {
      if (node.nodeType === 1 && !up && node.childNodes.length) {
        return node.childNodes[0];
      } else if (node.nextSibling) {
        return node.nextSibling;
      } else {
        up = true;
        node = node.parentNode;
      }
    }
    return null;
  };

  textNodeAfter = function(node) {
    while (node = nodeAfter(node)) {
      if (node.nodeType === 3) {
        return node;
      }
    }
  };

  nodeBefore = function(node) {
    var up;
    up = false;
    while (node) {
      if (node.nodeType === 1 && !up && node.childNodes.length) {
        return node.childNodes[node.childNodes.length - 1];
      } else if (node.previousSibling) {
        return node.previousSibling;
      } else {
        up = true;
        node = node.parentNode;
      }
    }
    return null;
  };

  textNodeBefore = function(node) {
    while (node = nodeBefore(node)) {
      if (node.nodeType === 3) {
        return node;
      }
    }
  };

  getNodeText = function(node) {
    return node.textContent;
  };

  if (Element.prototype.webkitCreateShadowRoot != null) {
    Element.prototype.createShadowRoot = Element.prototype.webkitCreateShadowRoot;
    Element.prototype.__defineGetter__('shadowRoot', function() {
      return this.webkitShadowRoot;
    });
    Element.prototype.__defineSetter__('shadowRoot', function(val) {
      return this.webkitShadowRoot = val;
    });
  } else if (document.body.createShadowRoot == null) {
    hasShadow = false;
    Element.prototype.createShadowRoot = function() {
      hasShadow = true;
      return this.setAttribute('data-org-shadow', 'true');
    };
    Element.prototype.__defineGetter__('shadowRoot', function() {
      return (this.hasAttribute('data-org-shadow') && this) || null;
    });
    getNodeText = function(node) {
      var copy;
      if (hasShadow) {
        copy = $(node).clone();
        copy.find('[data-org-shadow]').remove();
        return copy.text();
      } else {
        return node.textContent;
      }
    };
    oldReparse = reparse;
    reparse = function(parent, text) {
      oldReparse(parent, text);
      return hasShadow = false;
    };
  }

  emptyOutNode = function(node) {
    var newNode;
    node.innerHTML = '';
    newNode = $(node)[0].cloneNode(false);
    $(node).after(newNode);
    $(node).remove();
    return newNode;
  };

  root.orgApi = null;

  cachedOrgText = null;

  cachedOrgParent = null;

  invalidateOrgText = function() {
    return cachedOrgParent = cachedOrgText = null;
  };

  getOrgText = function(parent) {
    return (cachedOrgParent === parent && cachedOrgText) || (cachedOrgParent = parent, cachedOrgText = parent.textContent);
  };

  orgNotebook = {
    useNode: function(node, source) {
      var lastOrgText, newNode, oldContent, orgNode, _ref5,
        _this = this;
      root.orgApi = this;
      sourceDiv = source;
      oldContent = $(node).text();
      newNode = emptyOutNode(node);
      editDiv = newNode;
      _ref5 = this.markupOrgWithNode(oldContent), orgNode = _ref5[0], lastOrgText = _ref5[1];
      root.restorePosition(newNode, function() {
        return _this.installOrgDOM(newNode, orgNode, lastOrgText);
      });
      return this.bindContent(newNode);
    },
    installOrgDOM: installOrgDOM,
    redrawIssue: function(i) {
      return console.log("REDRAW ISSUE: " + i);
    }
  };

  basicOrg = {
    __proto__: orgNotebook,
    markupOrg: markupOrg,
    markupOrgWithNode: markupOrgWithNode,
    bindContent: bindContent,
    executeDef: executeDef,
    executeSource: executeSource,
    createResults: createResults,
    installOrgDOM: function(parent, orgNode, orgText) {
      parent.setAttribute('class', 'org-plain');
      return orgNotebook.installOrgDOM(parent, orgNode, orgText);
    },
    bindings: defaultBindings,
    leisureButton: swapMarkup
  };

  root.basicOrg = basicOrg;

  root.orgNotebook = orgNotebook;

  root.markupOrg = markupOrg;

  root.bindContent = bindContent;

  root.cleanHeadline = cleanHeadline;

  root.getTags = getTags;

  root.reparse = reparse;

  root.reparseListeners = reparseListeners;

  root.findDomPosition = findDomPosition;

  root.getCollapsible = getCollapsible;

  root.getNodeText = getNodeText;

  root.parseOrgMode = parseOrgMode;

  root.orgAttrs = orgAttrs;

  root.content = content;

  root.contentSpan = contentSpan;

  root.checkStart = checkStart;

  root.optionalBoundary = optionalBoundary;

  root.boundarySpan = boundarySpan;

  root.displaySource = displaySource;

  root.checkEnterReparse = checkEnterReparse;

  root.checkCollapsed = checkCollapsed;

  root.checkExtraNewline = checkExtraNewline;

  root.followingSpan = followingSpan;

  root.currentLine = currentLine;

  root.checkSourceMod = checkSourceMod;

  root.getTextPosition = getTextPosition;

  root.isCollapsed = isCollapsed;

  root.nextOrgId = nextOrgId;

  root.modifyingKey = modifyingKey;

  root.getOrgParent = getOrgParent;

  root.getOrgType = getOrgType;

  root.executeText = executeText;

  root.executeDef = executeDef;

  root.propsFor = propsFor;

  root.orgEnv = orgEnv;

  root.baseEnv = baseEnv;

  root.getResultsForSource = getResultsForSource;

  root.initOrg = initOrg;

  root.swapMarkup = swapMarkup;

  root.modifiers = modifiers;

  root.keyFuncs = keyFuncs;

  root.defaultBindings = defaultBindings;

  root.addKeyPress = addKeyPress;

  root.findKeyBinding = findKeyBinding;

  root.invalidateOrgText = invalidateOrgText;

  root.setCurKeyBinding = setCurKeyBinding;

  root.presentValue = presentValue;

  root.escapeHtml = escapeHtml;

  root.escapeAttr = escapeAttr;

  root.restorePosition = restorePosition;

  root.splitLines = splitLines;

  root.orgSrcAttrs = orgSrcAttrs;

  root.getNodeSource = getNodeSource;

  root.loadOrg = loadOrg;

  root.resultsType = resultsType;

  root.isDynamic = isDynamic;

  root.isDef = isDef;

  root.nativeRange = nativeRange;

  root.textNodeBefore = textNodeBefore;

  root.textNodeAfter = textNodeAfter;

  root.PAGEUP = PAGEUP;

  root.PAGEDOWN = PAGEDOWN;

  root.saveFile = saveFile;

  root.nextVisibleNewline = nextVisibleNewline;

  root.countCharactersFrom = countCharactersFrom;

  root.nodeAfter = nodeAfter;

  root.nodeAfterNoChildren = nodeAfterNoChildren;

  root.nodeBefore = nodeBefore;

}).call(this);

/*
//@ sourceMappingURL=orgSupport.map
*/
