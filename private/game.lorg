* Intro
Leisure documents can contain any sort of web application,
say a classic game like Connect Four...

[[http://www.abstractstrategy.com/connect-four.jpg]]










* Game
:properties:
:note: sidebar
:end:
[[org:user1/userName]][[org:board1]][[org:board1/playerList]]
* Data
:properties:
:hidden: true
:end:
This is the board data and the user data...
- w = white
- b = black
- r = red
#+NAME: board1
#+BEGIN_SRC yaml :flowLevel 2
type: board
pieces:
  - [w, w, w, w, w, w, w]
  - [w, w, w, w, w, w, w]
  - [w, w, w, w, w, w, w]
  - [w, w, w, w, w, w, w]
  - [w, w, w, w, w, w, w]
  - [w, w, w, w, w, w, w]
cols: 7
rows: 6
players: []
turn: 0
#+END_SRC
#+NAME: user1
#+BEGIN_SRC yaml :local
type: user
color: r
number: -1
name: Anonymous
#+END_SRC

* Data Observers
:properties:
:hidden: true
:end:

This observer updates the board when the user changes their name.
#+BEGIN_SRC coffee :results def :observe user
@update = App.updateUser = (user)->
  board = Leisure.getDataNamed 'board1'
  board.players[user.number] = user
  Leisure.setDataNamed 'board1', board
#+END_SRC

This observer keeps the board valid, stubbornly fixing things...
#+BEGIN_SRC coffee :results def :observe board
@update = (board, block)->
  user = Leisure.getDataNamed 'user1'
  if user.number > 1 then return
  changed = false
  if !(board.pieces instanceof Array) then (changed = board).pieces = []
  if typeof board.rows != 'number' then (changed = board).rows = 6
  if typeof board.cols != 'number' then (changed = board).cols = 7
  while board.pieces.length < board.rows then (changed = board).pieces.unshift []
  while board.pieces.length > board.rows then (changed = board).pieces.shift()
  for row in [0 ... board.rows]
    if !(r = board.pieces[row]) instanceof Array then r = (changed = board).pieces[row] = []
    while r.length < board.cols then (changed = r).push 'w'
    while r.length > board.cols then (changed = r).pop()
    for col in [0 ... board.cols]
      if !(board.pieces[row][col] in 'wrb') then (changed = board).pieces[row][col] = 'w'
  if changed then Leisure.setDataNamed 'board1', board
#+END_SRC

* Views
:properties:
:hidden: true
:end:

Create a view for letting players pick a name and start a new game
#+BEGIN_SRC html :defview user/userName
<table style='width: 100%; white-space: nowrap'>
  <tr>
    <td style='width: 1px'>Name:</td>
    <td><input type='text' data-value='name'></input></td>
    <td style='width: 1px'>
      <button onclick="App.newGame(this)">New Game</button>
    </td>
  </tr>
</table>
#+END_SRC

Create a view to display the game board
#+BEGIN_SRC html :defview board
<div board onmousedown='App.handleClick(event)'>
  <div id='boardDiv'>
    <table>
      {{#each pieces}}
      <tr>
        {{#each this}}
          <td>
            <img src='/connect4/{{this}}Piece.svg' onerror='this.src="/connect4/gPiece.svg"'>
          </td>
        {{/each}}
      </tr>
      {{/each}}
    </table>
  </div>
  <h2>Players</h2>
  <div>
    {{#each players}}
      <span class='user' style='{{userStyle @index}}'>{{this.name}}</span>
    {{/each}}
  </div>
</div>
<script>App.hookupTable()</script>
#+END_SRC

Add some audio controls for sound effects
#+BEGIN_HTML
<div style='padding-left: 5ex; color: orange'>
  <i>HIDDEN AUDIO ELEMENTS HERE</i><br>
  &lt;audio id="clickSound" src="sounds/click.wav">&lt;/audio><br>
  &lt;audio id="buzzerSound" src="sounds/buzz.wav">&lt;/audio>
</div>
<audio id="clickSound" src="sounds/click.wav"></audio>
<audio id="buzzerSound" src="sounds/buzz.wav"></audio>
#+END_HTML


Handlebars helper to compute styling the active player
#+BEGIN_SRC coffee :results def
Handlebars.registerHelper 'userStyle', (index)->
  color = if index % 2 == 0 then 'black' else 'red'
  if App.isPlayersTurn index then "color: white; background-color: #{color}"
  else "color: #{color}; background-color: white"
#+END_SRC
* Game play
:properties:
:hidden: true
:end:

Determine whether it's a player's turn
#+BEGIN_SRC coffee :results def
App.isPlayersTurn = (index)->
  board = Leisure.getDataNamed 'board1'
  return board.turn % board.players.length == index
#+END_SRC

Reset the game board for a new game
#+BEGIN_SRC coffee :results def
App.newGame = (node)->
  data = Leisure.getDataNamed 'board1'
  data.pieces = for row in [0 ... data.rows]
    'w' for col in [0 ... data.cols]
  data.turn = 0
  Leisure.setDataNamed 'board1', data
#+END_SRC

Process a player clicking the board and provide audio feedback
          [[http://imgs.xkcd.com/comics/incision.png][At one point, by force of childhood habit, the doctor accidentally removed three or four organs.]]
#+BEGIN_SRC coffee :results def
App.handleClick = (e)->
  sound = if App.takeTurn e then '#clickSound' else '#buzzerSound'
  $('[data-org-html]').shadow().find(sound)[0].play()
#+END_SRC

Add a piece to the board on the column clicked (if there's room for it) Return success or failure
#+BEGIN_SRC coffee :results def
App.takeTurn = (e)->
  user = Leisure.getDataNamed 'user1'
  if user.number >= 0 && App.isPlayersTurn user.number
    data = Leisure.getDataNamed 'board1'
    col = e.target.parentElement.cellIndex
    if col? && empties = L(data.pieces).takeWhile((row)-> row[col] == 'w').size()
      data.pieces[empties - 1][col] = user.color
      ++data.turn
      Leisure.setDataNamed 'board1', data
      true
#+END_SRC
* Initialization
:properties:
:hidden: true
:end:

Set the game attribute so we can float the board
#+BEGIN_SRC coffee :results def
App.hookupTable = ->
  $(Templating.currentViewLink).closest("[data-org-headline='1']").attr 'game', ''
#+END_SRC

Each time a new player connects, we need to initialize them and add them into the game
Just use a random delay to prevent contention, for now
#+BEGIN_SRC coffee :results def
user = Leisure.getDataNamed 'user1'
if user.number == -1
  setTimeout (->
    board = Leisure.getDataNamed 'board1'
    user.number = board.players.length
    user.color = if 0 == user.number % 2 then 'b' else 'r'
    Leisure.setDataNamed 'user1', user
    App.updateUser user), Math.random() * 500
#+END_SRC
* Appearance
:properties:
:hidden: true
:end:

Splice in some special CSS for the board so it floats and looks nice with diff themes
#+BEGIN_SRC coffee :results def
$(document.head).prepend """
<style>
[game] {
  position: fixed !important;
  top: 50px !important;
  right: 10px !important;
  z-index: 1 !important;
}
.slides [game] { left: auto !important; }
.googie.slides [game] { top: 300px !important; }
.cthulhu.slides [game] { top: 300px !important; }
.steampunk.slides [game] { top: 150px !important; }
.flat.slides [game] { top: 182px !important; }
.console.slides [game] { top: 182px !important; }
.slides [game] [data-org-type='text'] { display: none; }
.slides .slideholder.firstSlide {
  display: inherit;
}
.slides .slideholder.firstSlide:not(.currentSlide) > * {
  display: none;
}
.slides .slideholder.firstSlide:not(.currentSlide) /deep/ .border {
  border: none;
}
.slides .slideholder.firstSlide:not(.currentSlide) > [game] {
  display: inherit;
}
</style>
"""
#+END_SRC


Styles for views
#+BEGIN_SRC coffee :results def
$(document.head).prepend """
<style>
  * /deep/ input[data-value='name'] {
    width: 100%;
    margin-left: 5px;
    margin-right: 5px;
  }
  * /deep/ #boardDiv {
    background: url(/connect4/board.svg) 0 0 / 100% 100% no-repeat;
    padding: 10px;
    display: inline-block;
  }
  * /deep/ #boardDiv table {
    text-align: center;
  }
  * /deep/ #boardDiv img {
    vertical-align: middle;
  }
  * /deep/ [board] h2 {
    margin-top: 0;
  }
  * /deep/ .user {
    padding: 10px;
  }
</style>
"""
#+END_SRC

Adjust Leisure settings on startup
Delay so it happens after the page draws
#+BEGIN_SRC coffee :results def
setTimeout (->
  Leisure.toggleLeisureBar()
  Leisure.setTheme 'googie'
  Leisure.toggleSlides()
  Leisure.toggleShowHidden()), 1
#+END_SRC
