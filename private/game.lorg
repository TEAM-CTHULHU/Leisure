* Intro
Leisure documents can contain any sort of web application,
say a classic game like Connect Four...

[[http://www.abstractstrategy.com/connect-four.jpg]]










* Game
:properties:
:note: sidebar
:end:
[[org:user1/userName]][[org:board1]][[org:board1/playerList]]
* Data
:properties:
:hidden: true
:end:
This is the board data and the user data...
- w = white
- b = black
- r = red
#+NAME: board1
#+BEGIN_SRC yaml :flowLevel 2
type: board
pieces:
  - [w, w, w, w, w, w, w]
  - [w, w, w, w, w, w, w]
  - [w, w, w, w, w, w, w]
  - [w, w, w, w, w, w, w]
  - [w, w, w, w, w, w, w]
  - [w, w, w, w, w, w, w]
max_col: 7
max_row: 6
players: []
turn: 0
#+END_SRC
#+NAME: user1
#+BEGIN_SRC yaml :local
type: user
color: r
number: -1
name: Anonymous
#+END_SRC

* Data Observers
:properties:
:hidden: true
:end:

This observer updates the board when the user changes their name.
#+BEGIN_SRC coffee :results def :observe user
@update = App.updateUser = (user)->
  console.log "updating from change to user data"
  board = Leisure.getDataNamed 'board1'
  board.players[user.number] = user
  Leisure.setDataNamed 'board1', board
#+END_SRC

This observer keeps the board valid, stubbornly fixing things...
#+BEGIN_SRC coffee :results def :observe board
@update = (board, block)->
  user = Leisure.getDataNamed 'user1'
  if user.number > 1 then return
  changed = false
  if !(board.pieces instanceof Array) then (changed = board).pieces = []
  if typeof board.max_row != 'number' then (changed = board).max_row = 6
  if typeof board.max_col != 'number' then (changed = board).max_col = 7
  while board.pieces.length < board.max_row then (changed = board).pieces.unshift []
  while board.pieces.length > board.max_row then (changed = board).pieces.shift()
  for row in [0 ... board.max_row]
    if !(r = board.pieces[row]) instanceof Array then r = (changed = board).pieces[row] = []
    while r.length < board.max_col then (changed = r).push 'w'
    while r.length > board.max_col then (changed = r).pop()
    for col in [0 ... board.max_col]
      if !(board.pieces[row][col] in 'wrb') then (changed = board).pieces[row][col] = 'w'
  if changed then Leisure.setData block._id, board
#+END_SRC

* Views
:properties:
:hidden: true
:end:

Create a view for letting players pick a name and start a new game
#+BEGIN_SRC html :defview user/userName
<table style='width: 100%; white-space: nowrap'>
  <tr>
    <td style='width: 1px'>Name:</td>
    <td><input style='width: 100%; margin-left: 5px; margin-right: 5px' type='text' data-value='name'></input></td>
    <td style='width: 1px'>
      <button onclick="App.newGame(this)">New Game</button>
    </td>
  </tr>
</table>
#+END_SRC

Create a view to display the game board
#+BEGIN_SRC html :defview board
<style>
  #boardDiv {
    background: url(/connect4/board.svg) 0 0 / 100% 100% no-repeat;
    padding: 10px;
    display: inline-block;
  }
  #boardDiv table {
    text-align: center;
  }
  #boardDiv img {
    vertical-align: middle;
  }
  h2 {
    margin-top: 0;
  }
  .user {
    padding: 10px;
  }
</style>
<div onmousedown='App.handleClick(event)'>
  <div id='boardDiv'>
    <table>
      {{#each pieces}}
      <tr>
        {{#each this}}
          <td>
            <img src='/connect4/{{this}}Piece.svg' onerror='this.src="/connect4/gPiece.svg"'>
          </td>
        {{/each}}
      </tr>
      {{/each}}
    </table>
  </div>
  <h2>Players</h2>
  <div>
    {{#each players}}
      <span class='user' style='{{userStyle @index}}'>{{this.name}}</span>
    {{/each}}
  </div>
</div>
<script>App.hookupTable()</script>
#+END_SRC

Add some audio controls for sound effects
#+BEGIN_HTML
<div style='padding-left: 5ex; color: orange'>
  <i>HIDDEN AUDIO ELEMENTS HERE</i><br>
  &lt;audio id="clickSound" src="sounds/click.wav">&lt;/audio><br>
  &lt;audio id="buzzerSound" src="sounds/buzz.wav">&lt;/audio>
</div>
<audio id="clickSound" src="sounds/click.wav"></audio>
<audio id="buzzerSound" src="sounds/buzz.wav"></audio>
#+END_HTML


Handlebars helper to compute the active player
#+BEGIN_SRC coffee :results def
Handlebars.registerHelper 'userStyle', (index)->
  color = if index % 2 == 0 then 'black' else 'red'
  if App.isPlayersTurn index then "color: white; background-color: #{color}"
  else "color: #{color}; background-color: white"
#+END_SRC
* Game play
:properties:
:hidden: true
:end:

Determine whether it's a player's turn
#+BEGIN_SRC coffee :results def
App.isPlayersTurn = (index)->
  board = Leisure.getDataNamed 'board1'
  return board.turn % board.players.length == index
#+END_SRC

Reset the game board for a new game
#+BEGIN_SRC coffee :results def
App.newGame = (node)->
  block = Leisure.getBlock($(node).closest("[data-view-id]").attr 'data-view-id')
  data = block.yaml
  col = 0
  while col < data.max_col
    row = 0
    while row < data.max_row
      data.pieces[row][col] = 'w'
      ++row
    ++col
  data.turn = 0
  Leisure.setData block._id, data
#+END_SRC

Process a player clicking the board and provide audio feedback
          [[http://imgs.xkcd.com/comics/incision.png][At one point, by force of childhood habit, the doctor accidentally removed three or four organs.]]
#+BEGIN_SRC coffee :results def
App.handleClick = (e)->
  turn = App.takeTurn e
  sound = if turn then '#clickSound' else '#buzzerSound'
  $('[data-org-html]').shadow().find(sound)[0].play()
  if turn then console.log "click" else console.log "buzzer"
#+END_SRC

Add a piece to the board on the column clicked (if there's room for it) Return success or failure
#+BEGIN_SRC coffee :results def
App.takeTurn = (e)->
    user = Leisure.getDataNamed 'user1'
    if user.number < 0 then return false
    if !App.isPlayersTurn user.number then return false
    if block = Leisure.viewBlock e.target
      data = block.yaml
      td = e.target.parentElement
      col = td.cellIndex
      row = td.parentElement.rowIndex
      if col?
        row = data.max_row - 1
        while data.pieces[row][col] != 'w'
          if -1 == --row then break
        if row > -1
          data.pieces[row][col] = user.color
          ++data.turn
          Leisure.setData block._id, data
          return true
        return false
    return false
#+END_SRC
* Initialization
:properties:
:hidden: true
:end:

Set the game attribute so we can float the board
#+BEGIN_SRC coffee :results def
App.hookupTable = ->
  $(Templating.currentViewLink)
    .closest("[data-org-headline='1']")
    .attr 'game', ''
#+END_SRC

Each time a new player connects, we need to initialize them and add them into the game
#+BEGIN_SRC coffee :results def
user = Leisure.getDataNamed 'user1'
if user.number == -1
  setTimeout (->
    board = Leisure.getDataNamed 'board1'
    console.log JSON.stringify board
    user.number = board.players.length
    user.color = if 0 == user.number % 2 then 'b' else 'r'
    Leisure.setDataNamed 'user1', user
    App.updateUser user), Math.random() * 500
#+END_SRC
* Appearance
:properties:
:hidden: true
:end:

Splice in some special CSS for the board so it floats and looks nice with diff themes
#+BEGIN_SRC coffee :results def
$(document.head).prepend $("""
<style>
[game] {
  position: fixed !important;
  top: 50px !important;
  right: 10px !important;
  z-index: 1 !important;
}
.slides [game] { left: auto !important; }
.googie.slides [game] { top: 300px !important; }
.cthulhu.slides [game] { top: 300px !important; }
.steampunk.slides [game] { top: 150px !important; }
.flat.slides [game] { top: 182px !important; }
.console.slides [game] { top: 182px !important; }
.slides [game] [data-org-type='text'] { display: none; }
.slides .slideholder.firstSlide {
  display: inherit;
}
.slides .slideholder.firstSlide:not(.currentSlide) > * {
  display: none;
}
.slides .slideholder.firstSlide:not(.currentSlide) /deep/ .border {
  border: none;
}
.slides .slideholder.firstSlide:not(.currentSlide) > [game] {
  display: inherit;
}
</style>
""")
#+END_SRC

Adjust Leisure settings on startup
#+BEGIN_SRC coffee :results def
Leisure.toggleLeisureBar()
Leisure.setTheme 'googie'
Leisure.toggleSlides()
#+END_SRC
