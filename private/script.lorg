* Images
#+NAME: il
#+BEGIN_SRC yaml
type: imageList
images:
- i1
- i2
#+END_SRC
#+NAME: i1
#+BEGIN_SRC yaml
type: image
src: tinyconcepts.png
left: 150
top: 30
#+END_SRC
#+NAME: i2
#+BEGIN_SRC yaml
type: image
src: tinyconcepts.png
left: 250
top: 40
#+END_SRC

[[leisure:il]]
* Image Views
:PROPERTIES:
:note: sidebar
:hidden: true
:END:
#+BEGIN_SRC html :defview image
<div style='display: inline-block'>
  <table>
    <tr>
      <td><img src={{src}}></td>
      <td><h1>DRAG ME</h1>({{left}},{{top}})</td>
    </tr>
  </table>
</div>
<script>
  App.hookupImage();
</script>
#+END_SRC

#+BEGIN_SRC html :defview imageList
<div style='border: solid red 1px; display: inline-block'>
  <div style='display: inline-block; width: 800px; height: 800px; position: relative'>
    {{#each images}}
    {{{view this}}}
    {{/each}}
  </div>
</div>
#+END_SRC

* Records
[[leisure:a]] [[leisure:b]] [[leisure:c]] [[leisure:a]]

#+NAME: a
#+BEGIN_SRC yaml
type: gump
name: fred
number: 35
#+END_SRC
#+NAME: b
#+BEGIN_SRC yaml
type: gump
name: george
number: 72
#+END_SRC
#+NAME: c
#+BEGIN_SRC yaml
type: gump
name: mary
number: 89
#+END_SRC
* Views
:PROPERTIES:
:note: sidebar
:hidden: true
:END:
#+BEGIN_SRC html :defview gump
<div style='display: inline-block; border: solid blue 2px; padding: 5px'>
  Name: <input data-value='name'><br>
  Number: {{number}}
</div>
#+END_SRC
* Support code
:PROPERTIES:
:hidden: true
:END:
We can indicate movement, here, with another view that's a line connected
to the original center that disappears on mouse up.  Each player could get
their own view.

#+BEGIN_SRC coffee :results def
App.hookupImage = ->
  if Templating.currentScript
    view = $(Templating.currentScript).closest('[data-view-block]')
    id = view.attr 'data-view-block'
    data = Leisure.getBlock(id).yaml
    v = view[0]

    App.drag v,
      init: ->
        view
          .css 'zIndex', '100'
          .css 'top', "#{data.top}px"
          .css 'left', "#{data.left}px"
      constrain: 'container'
      update: (image, id, data)->
        data.left = image.offsetLeft
        data.top = image.offsetTop
        Leisure.setData id, data
#+END_SRC

View dragging -- jQueryUI's dragging seems to have trouble with shadow

#+BEGIN_SRC coffee :results def
dragUpdate = Lodash.throttle ((view, func)->
  id = view.getAttribute 'data-view-block'
  data = Leisure.getBlock(id).yaml
  Leisure.blockViewUpdatesWhile $("[data-view-ids~='#{id}']"), -> func view, id, data
  ), 200, leading: true, trailing: true

App.drag = (el, options)->
  if !el.drag
    el.drag = {}
    el.drag.move = if !options?.constrain then setOffsets
    else if options.constrain == 'container'
      constrainToElement App.getContainer el
    else if options.constrain instanceof Element
      constrainToElement options.constrain
    else setOffsets
    $(el)
      .css '-webkit-user-select', 'none'
      .css 'user-select', 'none'
    $(el).on 'mousedown', el.drag.downFunc = (e)->
      e.preventDefault()
      el.drag.dragging = true
      {top, left} = el.getBoundingClientRect()
      offsetX = left - e.clientX
      offsetY = top - e.clientY
      move = (e)->
        if el.drag.move(el, e.clientX + offsetX, e.clientY + offsetY) && options?.update
          dragUpdate el, options.update
        options?.drag? el
      up = (e)->
        if el.drag.move(el, e.clientX + offsetX, e.clientY + offsetY) && options?.update
          dragUpdate el, options.update
        el.drag.dragging = false
        $(document).off 'mouseup', up
        $(document).off 'mousemove', move
        options?.end? el
      $(document).on 'mouseup', up
      $(document).on 'mousemove', move
    if getComputedStyle(el).position != 'absolute'
      $(el).css 'position', 'absolute'
  if !el.drag.dragging then options?.init? el

setOffsets = (el, newLeft, newTop)->
  {left, top} = el.getBoundingClientRect()
  newLeft = Math.round newLeft
  newTop = Math.round newTop
  left = Math.round left
  top = Math.round top
  changed = false
  if newLeft != left then changed = el.style.left = "#{el.offsetLeft + newLeft - left}px"
  if newTop != top then changed = el.style.top = "#{el.offsetTop + newTop - top}px"
  changed

constrainToElement = (constraintElement)-> (el, newLeft, newTop)->
  constrainToClientRect el, constraintElement.getBoundingClientRect(), newLeft, newTop

constrainToClientRect = (el, rect, newLeft, newTop)->
  r = el.getBoundingClientRect()
  offLeft = newLeft - r.left
  offTop = newTop - r.top
  if r.bottom + offTop > rect.bottom then newTop -= r.bottom + offTop - rect.bottom
  if r.right + offLeft > rect.right then newLeft -= r.right + offLeft - rect.right
  setOffsets el, Math.max(newLeft, rect.left), Math.max(newTop, rect.top)

App.nodrag = (el)->
  if el.drag.downFunc
    $(el).off 'mousedown', el.drag.downFunc
    delete el.drag

App.getContainer = (el)->
  parent = el
  while parent = parent.parentNode
    if getComputedStyle(parent).position in ['absolute', 'relative', 'fixed']
      return parent
  document.body
#+END_SRC
