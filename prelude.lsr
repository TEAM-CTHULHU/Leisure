# primitives
#
# eq a b -> true if they are equal or false otherwise
#
# getType value -> an option containing the type
# 
# is value type -> true if the value has type type, false otherwise
#
# eval ast -> evaluates ast and returns the result
#
# parse string -> an Either with ast or error msg (give it two functions)
#
# pretty value -> pretty print a value
#
# funcSource func -> option with function's src or none if no source (e.g. primitive or lambda)
#
#    MONADS
#
# bind m binding -> transform a monad with a function and continue with result of function
#
# print string -> print a string and continue with false
#
# prompt string -> ask user for input and continue with value
#
# return value -> continus with value
#
# js string -> run JS code and continue with value
#
# createS -> create a new state variable and continue with it
#
# getS var -> get the value from the state variable var and continue with it
#
# setS var val -> set the state variable var to val and continue with false
#
#    STRING functions
#
# concat list -> string
#
#    AST-constructors
#
# lit value -> a lit AST node, containing value
#
# ref var-name -> a ref AST node, containing var-name
#
# lambda var-name body-ast -> a lambda AST node, with var-name and the body AST
#
# apply func-ast body-ast -> an apply AST node, with func and body ASTs
#
# prim arg rest-ast -> a prim AST node, rest-ast should either be a ref or a prim
#

#@auto
defGroup '[' ']'
#@auto
defToken '|'
#@auto
defToken ','

id x = x

# make a new function that takes two args in opposite order than the original function
# eq. flip cons nil 1 gives cons: [1]
flip f = \a b . f b a

# booleans
true = \a b . a
false = \a b . b
and a b = a b false
or a = a true
not a = a false true
neq a b = not (eq a b)

# choices
left v = \l r . l v
right v = \l r . r v
some x = \yes no . yes x
some2 a b = \yes no . yes a b
none = \yes no . no

# The Y combinator, for reference
#
# Y = \g  .  (\x  .  g (x x)) \x  .  g (x x)
# rec = \f . f (Y f)

# lists
#cons a b =
#  \f . f
#    a
#    b

head l::cons = l \h t . h
tail l::cons = l \h t . t
head l::lexCons = l \h s t e . h
tail l::lexCons = l \h s t e . t
startPos l::lexCons = lexStart l
startPos t::token = t \t p . p
endPos l::lexCons = lexEnd l
endPos t::token = + (tokenStart t) (strlen (tokenName t))
pairFunc l = false
pairFunc l::cons = cons
pairFunc l::lexCons = \h t . null? t
  lexCons h (startPos h) nil (endPos h)
  lexCons h (startPos h) t (endPos t)
#nil = \a b . b
null? x = false
null? x::nil = true
#foldl func arg list = null? list
#  arg
#  foldl func (func arg (head list)) (tail list)
foldl func arg list = foldl func (func arg (head list)) (tail list)
foldl func arg list::nil = arg
#foldl1 func list = null? list
#  nil
#  foldl func (head list) (tail list)
foldl1 func list = foldl func (head list) (tail list)
foldl1 func list::nil = nil
foldr func arg list = null? list
  arg
  func (head list) (foldr func arg (tail list))
#foldr func arg list = func (head list) (foldr func arg (tail list))
#foldr func arg list::nil = arg
foldr1 func list = null? list
  nil
  eq (tail list) nil
    head list
    func (head list) (foldr1 func (tail list))
#foldr1 func list = eq (tail list) nil
#  head list
#  func (head list) (foldr1 func (tail list))
#foldr1 func list::nil = nil
append l1 l2 = _append (pairFunc l1) l1 l2
append l1::nil l2 = l2
#_append pairF l1 l2 = null? l1
#  l2
#  pairF (head l1) (_append pairF (tail l1) l2)
_append pairF l1 l2 = pairF (head l1) (_append pairF (tail l1) l2)
_append pairF l1::nil l2 = l2
compose f g = \x . f ( g x)

# numerics

iszero = eq 0
positive = < 0
length l = (eq l nil) 0 (++ (length (tail l) ) )

-- = (flip -) 1
++ = + 1
even? x = iszero (% x 2)
odd? x = eq 1 (% x 2)
max a b = (gt a b) a b
min a b = (lt a b) a b

# some basic list functions
# some list functions are primitives, for the time being: cons, nil, head, tail
# cons a b = \f . f a b
# nil = \a b . b
# head l = l \h t . h
# tail l = l \h t . t
reverse l = subreverse l nil
subreverse l result = l (\h t D . subreverse t (cons h result)) result
addstr a b = concat [a b]
if = id
at l x = (iszero (x)) (head l) (at (tail l) (-- (x) ) )
take n list = _take (pairFunc list) n list
_take pairF n list = positive n
  null? list
    nil
    pairF (head list) (_take pairF (-- n) (tail list))
  nil
takeWhile predicate list = _takeWhile (pairFunc list) predicate list
_takeWhile pairF predicate list = null? list
  nil
  predicate (head list)
    pairF (head list) (_takeWhile pairF predicate (tail list))
    nil
drop x list = positive x
  null? list
    nil
    drop (-- x) (tail list)
  list
dropWhile predicate list = null? list
  nil
  predicate (head list)
    dropWhile predicate (tail list)
    list
dropLast n list = tail (_dropLast (pairFunc list) n list)
_dropLast pairF n list = eq list nil
  [0]
  (\next . gt n (head next)
    [(+ 1 (head next))]
    [n | (pairF (head list) (tail next))]) (_dropLast pairF n (tail list))

series func n = cons n (series func (func n))
from n = series ++ n
fromBy n inc = series (+ inc) n
fromTo n m = takeWhile (> m) (from n)
fromToBy n m inc = takeWhile (> m) (fromBy n inc)

# return true if any elements of l satisfy f, which takes exactly one arg
# eg. any (eq 0) [1 2 0] gives true: true
any f l = _any (pairFunc l) f l
_any pairF f l = null? l
  false
  or
    f (head l)
    _any pairF f (tail l)

# return true if ALL elements of l satisfy f, which takes exactly one arg
# eg. all (eq 0) [0 0 0] gives true: true
# caveat!  return true for nil lists
all f l = _all (pairFunc l) f l
_all pairF f l = null? l
  true
  and
    f (head l)
    _all pairF f (tail l)

index_combine x y = (or (eq x nil) (eq y nil)) (nil) (+ x y)
# return nil if not found, or 0 based index of the first match
indexof l x = if (eq l nil) (nil) (if (eq x (head l)) (0) (index_combine 1 (indexof (tail l) x ) ) )

# position does the same thing as indexof, but takes the args in opposite order
position l x = indexof x l

# find returns x if x is present inside l, otherwise returns nil.
find x l = findIf (eq x) l

findIf f l = null? l
  nil
  (f (head l)) (head l) (findIf f (tail l))

findIfOpt f l = null? l
  none
  (f (head l)) (some (head l)) (findIfOpt f (tail l))

# count returns the number of times x appears in l
count x l = countIf (eq x) l

# countIf returns the number of times x satifies f in l, f must take a single argument
# eg. countIf odd? [3 1] gives number: 2
countIf f l = if (eq l nil) 0
  + (f (head l) 1 0) (countIf f (tail l))
countIfNot f l = countIf (\x. not (f x)) l

# remove any x's found in list
remove x l = removeIf (eq x) l

# remove any elements where f evals to true, f must take exactly one argument
removeIf f l = _removeIf (pairFunc l) f l
_removeIf pairF f l  = if (eq l nil) nil
  if (f (head l)) (_removeIf pairF f (tail l))
    pairF (head l) (_removeIf pairF f (tail l))
removeIfNot f l = removeIf (\x. not (f x)) l

filter f = removeIf (compose not f)

# make a new list by applying func (which takes exactly 1 arg) to each element of list
# eg. map (+ 1) [4 27 54] gives cons: [5 28 55]
#map func list = list (\h t D . cons (func h) (map func t)) nil
map func list = _map (pairFunc list) func list
_map pairF func list = null? list
  nil
  pairF (func (head list)) (_map pairF func (tail list))

# call func on the elements of list, 'joining' each with the previous result of func,
# however func chooses to do so
# if the list is only one element long, just return the first element
# eg. reduce + [3 5] gives number: 8
reduce func list = foldl1 func list
#reduce func list = if (eq list nil) nil
#  if (eq 1 (length list)) (head list)
#    func (head list) (reduce func (tail list))

# foldr, foldl
# these are primitives, for the time being
# call func on list items and previous result of fold
# foldl uses the head of the list for the previous results
# foldr uses the tail of the list for the previous results
# foldr can work on infinite lists, but foldl cannot

#foldr func value list = list (\h t D . func h (foldr func value t)) value
#foldr1 func list = list
#  \h t D . null? t
#     h
#     func h (foldr1 func t)
#  nil

#foldl func value list = list (\h t D . foldl func (func value h) t) value
#foldl1 func list = list (\h t D. foldl func h t) nil

# simple list constructor syntax
# pure Lambda Calculus definition
#[ =(]= \item c . c \rest . cons item rest
#, =.= \f item c . c \rest . f (cons item rest)
#] =)= \f . f nil
#| =.= \f rest g . f rest

# simple list constructor syntax
# Leisure definition relies 
[ item = eq item `]`
  nil
  nextListItem (dl item)
# These are just punctuation, used by the '[' continuation function
] = \x . x
| = \x . x
, = \x . x
nextListItem items next = eq next `]`
  items nil
  eq next `|`
    \tail close . items tail
    eq next `,`
      nextListItem items
      nextListItem (dlAppend items (dl next))

# difference lists
dlempty = id
dl item = \rest . cons item rest
dlAppend a b = \rest . a (b rest)

# Macros
#the Lex functions will change with type assertions

identMacro list =M= tail list

macroCons list =M= cons 'cons' (tail list)

do list =M= foldr1 (\el . doClause el) (tail list)

doClause clause rest = doExtractVar clause '<-'
  \var . ['bind' (tail (tail clause)) '\\' var '.' rest]
  doExtractVar clause '='
    \var . [['\\' var '.' rest] (tail (tail clause))]
    ['bind' clause '\\' '_' '.' rest]

doExtractVar list tokName = and
  is list lexCons
  and
    is (tail list) lexCons
    and
      is (head (tail list)) token
      eq tokName (tokenName (head (tail list)))
  some (head list)
  none

######################
# output tag functions
######################

html x = \f . f x

###########
# Assoc lists (from Roy's hashmap code)
###########

assocFromList l = if (null? l) nil
  assocSet (head l) (head (tail l)) (assocFromList (tail (tail l)))

assocKey cons = head cons
assocValue cons = tail cons

assocGetPair k anAssoc = findIf (\x . eq (head x) k) anAssoc

# assocGetPairOpt returns a 2Valued option
assocGetPairOpt k l = l (\h t D . h (\kk vv . (eq k kk) (some2 kk vv) (assocGetPairOpt k t))) none

valueOrDefault value default = if (neq value nil) value default

assocKeys anAssoc = map (\cell . (assocKey cell)) anAssoc
assocNumKeys anAssoc = length (assocKeys anAssoc)

assocMergeKeys hm1 hm2 keys = if (null? keys) hm1
  if (null? (assocGetPair (head keys) hm1) )
    cons (assocGetPair (head keys) hm2) (assocMergeKeys hm1 hm2 (tail keys))
    assocMergeKeys hm1 hm2 (tail keys)

# keys in hm2 take precedence over keys in hm1
assocMerge hm1 hm2 = assocMergeKeys hm1 hm2 (assocKeys hm2)

assocSet k v anAssoc = cons (cons k v) (assocRemove k anAssoc)

assocGet k anAssoc = (assocGetPair k anAssoc) (\h t D . some h) none

assocGetWithDefault k default anAssoc = valueOrDefault (assocGet k anAssoc) default

assocRemove k anAssoc = removeIf (\x . eq (assocKey x) k) anAssoc
