<html>
<head>
<style>
.debug {
/**/
	height: 0;
	width: 0;
	visibility: hidden;
	display: none;
/**/
}
</style>
<script>
var defName
var def
var output
var code
var debug
var result
var exprs = {}
var order = []
var funcCount = 1

function loaded() {
	defName = document.getElementById("defName")
	def = document.getElementById("def")
	output = document.getElementById("output")
	code = document.getElementById("code")
	debug = document.getElementById("debug")
	result = document.getElementById("result")
	var defs = [
		"true", '\\x y.x',
		"false", '\\x y.y',
		"cons", '\\x y f  .  f x y',
		"first", '\\l  .  l \\a b  .  a',
		"Example", 'first (cons 1 2)',
	]
	for (var i = 0; i < defs.length; i += 2) {
		addExpr(defs[i], defs[i + 1])
	}
}
function input() {
	addExpr(defName.value, def.value)
	defName.value = ''
	def.value = ''
}
function addExpr(name, txt) {
	var expr = new Entry(name, parse(txt.trim(), {})[0])

	if (exprs[expr.name]) {
		var newOutput = ''

		for (var i = 0; i < order.length; i++) {
			if (order[i].name == expr.name) {
				order.splice(i, 1)
			}
			if (i < order.length) {
				newOutput += outputDivFor(i)
			}
		}
		output.innerHTML = newOutput
	}
	order.push(expr)
	if (expr.name) exprs[expr.name] = expr
	output.innerHTML += outputDivFor(order.length - 1)
	output.lastChild.scrollIntoView()
}
function outputDivFor(index) {
	var expr = order[index]
	var ac = expr.alphaConvert()

	return "<div><button onclick='editFunc(\"" + index + "\")'>Edit</button> <button onclick='runFunc(\"" + index + "\")'>Run</button> <b>" + (expr.name  ? expr.name + ':' : '') + '</b>&nbsp;&nbsp;' + expr
		+ "<br><ul><li><b>Names:</b> " + props(expr.names(), props(exprs)).join(", ")
		+ "<br><li><b>Alpha conversion:</b> " + expr.alphaConvert()
		+ "</ul>"
		+ "</div>"
}
function props(obj, p) {
	var p = p || []

	for (i in obj) p.push(i)
	p.sort()
	return p
}
function editFunc(index) {
	defName.value = order[index].name
	def.value = order[index].formatSlash()
}
function runFunc(index) {
	var expr = '(function(){' + constructEnv() + '\nreturn _' + order[index].name + '()})()'
	var res

	debug.innerHTML = "<pre>" + expr + "</pre>"
	try {
		res = eval(expr)
	} catch (err) {
		res = "Error: " + err
	}
	result.innerHTML += "<div>" + order[index] + "&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;&nbsp;" + res + "</div>"
	result.lastChild.scrollIntoView()
}
function constructEnv() {
	var env = []

	for (var i = 0; i < order.length; i++) {
		env.push("var _" + order[i].name + ' = (function(){return ' + order[i].func + '})')
	}
	return env.join("\n")
}
function parse(txt, vars) {
	var expr = null
	var cur
	var newVars = {}

	while (txt.length > 0 && txt[0] != ')') {
		if (txt[0] == '\\' || txt[0] == '&lambda;') {
			var lmb = parseLambda(txt.substring(1).trim(), vars)

			cur = lmb[0]
			txt = lmb[1]
		} else {
			if (txt[0] == '(') {
				var p = parse(txt.substring(1).trim(), vars)

				cur = p[0]
				if (p[1][0] != ')') {
					throw new Error('expected ")"')
				}
				txt = p[1].substring(1).trim()
			} else {
				var name = txt.match('^[^ \t\n.()]+')[0]

				cur = vars[name]
				if (!cur) {
					cur = new Variable(name, !exprs[name])
					newVars[name] = cur
					vars[name] = cur
				}
				txt = txt.substring(name.length).trim()
			}
		}
		expr = expr ? new Apply(expr, cur) : cur
	}
	for (i in newVars) {
		vars[i] = null
	}
	return [expr, txt]
}
function parseLambda(txt, vars) {
	var space = txt.indexOf(' ')
	var dot = txt.indexOf('.')
	var name, old, body, lvar

	if (dot < space || space == -1 || txt.substring(space + 1).trim()[0] == '.') {
		space = dot
		name = txt.substring(0, dot).trim()
		old = vars[name]
		lvar = vars[name] = new Variable(name, false)
		body = parse(txt.substring(dot + 1).trim(), vars)
	} else {
		name = txt.substring(0, space)
		old = vars[name]
		lvar = vars[name] = new Variable(name, false)
		body = parseLambda(txt.substring(space + 1).trim(), vars)
	}
	vars[name] = old
	return [new Lambda(lvar, body[0]), body[1]]
}
function Entry(name, expr) {
	this.name = name
	this.expr = expr
	this.func = expr.ret([]).join("")
}
Entry.prototype = {
	toString: function() {return this.expr.format(false)},
	formatSlash: function() {return this.expr.format(true)},
	names: function() {this.expr.names()},
	alphaConvert: function() {return new Entry(this.name, this.expr.alphaConvert())},
	betaReduce: function() {return this},
	etaConvert: function() {return this},
}

function pre(type, func) {
	return {install: function(trans) {trans.pre[type.name] = func}}
}

function post(type, func) {
	return {install: function(trans) {trans.post[type.name] = func}}
}

function prune(value) {return new Prune(value)}

function Prune(value) {this.value = value}

function identity() {return this}

function Transformer(funcs) {
	this.pre = {Lambda: identity, Variable: identity, Apply: identity}
	this.post = {Lambda: identity, Variable: identity, Apply: identity}
	for (var i = 0; i < funcs.length; i++) {
		funcs[i].install(this)
	}
	this.trail = {}
}
Transformer.prototype = {
	map: function(oldEnt, newEnt) {return this.trail[oldEnt.id] = newEnt},
	getTransform: function(entity) {return this.trail[entity.id]},
}
var entityCounter = 0
function Entity(obj) {
	for (i in obj) {
		this[i] = obj[i]
	}
}
Entity.prototype.__proto__ = {
	transform: function() {return this.doTransform(new Transformer(arguments))},
	startTransform: function(transformer) {return transformer.getTransform(this) || this.doTransform(transformer)},
	doTransform: function(transformer) {
		if (transformer.getTransform[this]) return transformer.getTransform[this]
		var pre = transformer.pre[this.constructor.name].call(this, transformer)

		if (pre instanceof Prune) return transformer.map(this, pre.value)
		return transformer.map(this, pre.propagateTransform(transformer))
	},
	alphaConvert: function() {return this},
	isApply: function() {return false},
	isLambda: function() {return false},
	names: function() {
		var names = {}

		this.transform(pre(Lambda, function(){names[this.lvar.name] = 1; return this}))
		return names
	},
	uniquify: function(names) {
		return this.transform(
			pre(Lambda, function(transformer){transformer.map(this.lvar, this.lvar.rename(names)); return this}),
			post(Lambda, function(newVar, newBod) {return this.same(newVar, newBod) || new Lambda(newVar, newBod)})
		)
	},
}

function Lambda(arg, body) {
	this.lvar = arg
	this.body = body
	this.id = entityCounter++
}
Lambda.prototype.__proto__ = new Entity({
	toString: function() {return "&lambda;(" + this.lvar.name + " . " + this.body + ")"},
	ret: function(stream) {
		stream.push("function(_", this.lvar.name, ") {", "return ")
		this.body.ret(stream)
		stream.push("}")
		return stream
	},
	pass: function(stream) {
		stream.push("function(){return ")
		this.ret(stream)
		stream.push("}")
		return stream
	},
	apply: function(stream) {
		stream.push("(")
		this.ret(stream)
		stream.push(")")
		return stream
	},
	format: function(slash) {return (slash ? '\\' : '&lambda;') + this.formatRest(slash)},
	formatRest: function(slash) {return this.lvar.format(slash) + (this.body instanceof Lambda ? ' ' + this.body.formatRest(slash) : (slash ? '  .  ' : '&nbsp;&nbsp;.&nbsp;&nbsp;') + this.body.format(slash))},
	propagateTransform: function(transformer) {
		var newVar = this.lvar.startTransform(transformer)
		var newBod = this.body.startTransform(transformer)

		return transformer.post.Lambda.call(this, newVar, newBod, transformer)
	},
	same: function(newVar, newBody) {return this.lvar == newVar && this.body == newBody && this},
	isLambda: function() {return true},
})
function numberFor(name, names) {
	var i = 0

	while (!names[name + '-' + ++i]) {}
	return i
}

function Variable(txt, free, num, value) {
	this.name = txt
	this.num = num
	this.free = free
	this.value = value
	this.id = entityCounter++
}
Variable.prototype.__proto__ = new Entity({
	toString: function() {return "Variable(" + this.name + ")"},
	pass: function(stream) {
		stream.push(!this.free ? '_' + this.name
			: this.name.match('^[0-9]+(.[0-9]*)?$') ? "wrap(" + this.name + ")" : "wrap('" + this.name + "')")
		return stream
	},
	ret: function(stream) {
		if (this.free) {
			stream.push("'", this.name, "'")
		} else {
			this.pass(stream)
			stream.push("()")
		}
		return stream
	},
	apply: function(stream) {return this.ret(stream)},
	fname: function() {return this.num ? this.name + '-' + this.num : this.name},
	format: function() {return this.name},
	doTransform: function(transformer) {
		if (this.value) return this.value.transform(transformer)
		return Entity.prototype.doTransform.call(this, transformer)
	},
	propagateTransform: function(transformer) {return transformer.post.Variable.call(this, transformer)},
	rename: function(names) {
		if (!names[this.name]) return this
		var i = 0

		while (names[this.name + '-' + ++i]) {}
		return new Variable(this.name + '-' + i, this.free, i, this.value)
	},
	isLambda: function() {return this.value ? this.value.isLambda() : false},
	isApply: function() {return this.value ? this.value.isApply() : false},
})

function Apply(func, arg) {
	this.func = func
	this.arg = arg
	this.id = entityCounter++
}
Apply.prototype.__proto__ = new Entity({
	apply: function(stream) {
		this.func.apply(stream)
		stream.push("(")
		this.arg.pass(stream)
		stream.push(")")
		return stream
	},
	ret: function(stream) {return this.apply(stream)},
	pass: function(stream) {
		stream.push("function(){return ")
		this.apply(stream)
		stream.push("}")
		return stream
	},
	toString: function() {
		return "Apply(" + this.func + " " + this.arg + ")"
	},
	format: function(slash, inner) {
		var func = this.func.format(slash, true)
		var arg = this.arg.format(slash, true)

		return (this.func instanceof Lambda ? '(' + func + ')' : func) + ' ' + ((inner && this.arg.isLambda()) || this.arg instanceof Apply ? '(' + arg + ')' : arg)
	},
	propagateTransform: function(transformer) {
		var newFunc = this.func.startTransform(transformer)
		var newArg = this.arg.startTransform(transformer)

		return transformer.post.Apply.call(this, newFunc, newArg, transformer)
	},
	innermost: function(func) {
		return this.transform(
			pre(Apply, function(){return this.func.isApply() ? this : prune(func.call(this))}),
			post(Apply, function(func, arg) {return this.same(func, arg) ? this : new Apply(func, arg)})
		)
	},
	same: function(newFunc, newArg) {return newFunc == this.func && newArg == this.arg && this},
	isApply: function() {return true},
	alphaConvert: function() {return this.innermost(function() {return new Apply(this.func, this.arg.uniquify(this.func.names()))})},
})
function wrap(x) {
    return function() {return x}
}
</script>
</head>
<body onload="loaded()" style="margin: 0; position: relative; top: 0; bottom: 0; right: 0; left: 0; overflow: auto; border: 0">
<div style="position: relative; width: 100%; height: 100%">
<table style="position: absolute; height: 100%; width: 100%; border: 0">
<tr style="height: 0"><td style="width: 1px">Name:</td><td style="width: 10em"><input id="defName" style="width: 100%"></input></td><td style="width: 1px">Def:</td><td><input id="def" type="text" onchange="input()" style="width: 100%"></input></td></tr>
<tr style="height: 0"><td colspan="4"><h2>Definitions</h2></td></tr>
<tr style="height: auto; vertical-align: top"><td colspan="4"><div style="height: 100%; position: relative; overflow: auto; outline: solid black 1px"><div id="output"></div></div></td></tr>
<tr style="height: 0"><td colspan="4"><h2>Results</h2></td></tr>
<tr style="height: auto; vertical-align: top"><td colspan="4"><div style="height: 100%; position: relative; overflow: auto; outline: solid black 1px"><div id="result"></div></div></td></tr>
<tr style="height: 0"><td colspan="4" style="padding: 0"><div class="debug">
<h2>Debug</h2>
<div id="debug" style="border: solid black 1px"></div>
<pre id="definitions" style="width: 0; height: 0; visibilty: hidden"></pre>
</div></td></tr>
</table>
</div>
</body>
</html>
