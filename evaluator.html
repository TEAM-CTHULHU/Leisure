<html>
<!--
Copyright (C) 2011, Bill Burdick, Tiny Concepts: http://tinyconcepts.com/fs.pl/lambda.fsl

(licensed with ZLIB license)

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software
in a product, an acknowledgment in the product documentation would be
appreciated but is not required.

2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.

3. This notice may not be removed or altered from any source
distribution.
-->
<head>
<style>
.hidedebug .debug, .shownosubs .subs, .showsubs .nosubs {
	height: 0;
	width: 0;
	visibility: hidden;
	display: none;
}
</style>
<script>
var defName
var def
var output
var code
var result
var exprs = {}
var order = []
var funcs = {}
var funcCount = 1
var hashed = {}
var showDebug = false
var showSubs = true

function loaded() {
	defName = document.getElementById("defName")
	def = document.getElementById("def")
	output = document.getElementById("output")
	code = document.getElementById("code")
	result = document.getElementById("result")
	var defs = [
		"true", '\\x y.x',
		"false", '\\x y.y',
		"cons", '\\x y f  .  f x y',
		"first", '\\l  .  l \\a b  .  a',
		"rest", '\\l  .  l \\a b  .  b',
		"nil", '\\l x y . x',
		"null", '\\p.p (\\a b x y.y)',
		"Example", 'first (cons 1 nil)',
		"Example2", 'rest (cons 1 nil)',
	]
	for (var i = 0; i < defs.length; i += 2) {
		addExpr(defs[i], defs[i + 1])
	}
}
function input() {
	addExpr(defName.value, def.value)
	defName.value = ''
	def.value = ''
}
function addExpr(name, txt) {
	var expr = new Entry(name, parse(txt.trim(), {})[0])

	if (exprs[expr.name]) {
		var newOutput = ''

		for (var i = 0; i < order.length; i++) {
			if (order[i].name == expr.name) {
				order.splice(i, 1)
			}
			if (i < order.length) {
				newOutput += outputDivFor(i)
			}
		}
		output.innerHTML = newOutput
	}
	order.push(expr)
	if (expr.name) exprs[expr.name] = expr
	output.innerHTML += outputDivFor(order.length - 1)
	hashed[expr.expr.hashKey()] = expr
	output.lastChild.scrollIntoView()
}
function outputDivFor(index) {
	var expr = order[index]
	var gl = expr.globalSub()
	var ac = gl.alphaConvert()
	var br = ac.betaReduce()

	return "<div><button onclick='editFunc(\"" + index + "\")'>Edit</button> <button onclick='runFunc(\"" + index + "\")'>Run</button><button onclick='substitutions(" + index + ")'>Substitutions</button> <b>" + (expr.name  ? expr.name + ':' : '') + '</b>&nbsp;&nbsp;<span class="subs">' + expr + "</span><span class='nosubs'>" + expr.expr.format(false, true) + "</span>"
		+ "<div class='debug'><ul>"
		+ "<li><b>Normalized:</b> <span class='subs'>" + expr.normalize() + "</span><span class='nosubs'>" + expr.normalize().expr.format(false, true) + "</span>"
		+ "<li><b>Alpha conversion:</b> <span class='subs'>" + ac + "</span><span class='nosubs'>" + ac.expr.format(false, true) + "</span>"
		+ "<li><b>Beta reduction:</b> <span class='subs'>" + br + "</span><span class='nosubs'>" + br.expr.format(false, true) + "</span>"
		+ "</ul></div>"
		+ "</div>"
}
function props(obj, p) {
	var p = p || []

	for (i in obj) p.push(i)
	p.sort()
	return p
}
function editFunc(index) {
	defName.value = order[index].name
	def.value = order[index].formatSlash()
}
function runFunc(index) {
	var expr = '(function(){' + constructEnv() + '\nreturn _' + order[index].name + '()})()'
	var res

	try {
		res = eval(expr)
	} catch (err) {
		res = "Error: " + err
	}
	var lam = funcs[res]
	if (lam) {
		res = "<span class='subs'>" + lam.format(false, false) + "</span><span class='nosubs'>" + lam.format(false, true) + "</span>"
	}
	result.innerHTML += "<div><span class='subs'>" + order[index] + "</span><span class='nosubs'>" + order[index].expr.format(false, true) + "</span>" + "&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;&nbsp;" + res + "</div>"
	result.lastChild.scrollIntoView()
}
function substitutions(index) {
	result.innerHTML += "Substitutions not implemented, yet"
}
function constructEnv() {
	var env = []

	for (var i = 0; i < order.length; i++) {
		env.push("var _" + order[i].name + ' = (function(){return ' + order[i].func + '})')
	}
	return env.join("\n")
}
function parse(txt, vars) {
	var expr = null
	var cur
	var newVars = {}

	while (txt.length > 0 && txt[0] != ')') {
		if (txt[0] == '\\' || txt[0] == '&lambda;') {
			var lmb = parseLambda(txt.substring(1).trim(), vars)

			cur = lmb[0]
			txt = lmb[1]
		} else {
			if (txt[0] == '(') {
				var p = parse(txt.substring(1).trim(), vars)

				cur = p[0]
				if (p[1][0] != ')') {
					throw new Error('expected ")"')
				}
				txt = p[1].substring(1).trim()
			} else {
				var name = txt.match('^[^ \t\n.()]+')[0]

				cur = vars[name]
				if (!cur) {
					cur = new Variable(name, true)
					newVars[name] = cur
					vars[name] = cur
				}
				txt = txt.substring(name.length).trim()
			}
		}
		expr = expr ? new Apply(expr, cur) : cur
	}
	for (i in newVars) {
		vars[i] = null
	}
	return [expr, txt]
}
function parseLambda(txt, vars) {
	var space = txt.indexOf(' ')
	var dot = txt.indexOf('.')
	var name, old, body, lvar

	if (dot < space || space == -1 || txt.substring(space + 1).trim()[0] == '.') {
		space = dot
		name = txt.substring(0, dot).trim()
		old = vars[name]
		lvar = vars[name] = new Variable(name, false)
		body = parse(txt.substring(dot + 1).trim(), vars)
	} else {
		name = txt.substring(0, space)
		old = vars[name]
		lvar = vars[name] = new Variable(name, false)
		body = parseLambda(txt.substring(space + 1).trim(), vars)
	}
	vars[name] = old
	return [new Lambda(lvar, body[0]), body[1]]
}
function Entry(name, expr) {
	this.name = name
	this.expr = expr
	try {
		this.func = expr && expr.ret([]).join("")
	} catch (err) {
		this.func = function() {return "Error compiling: " + err.toString()}
	}
}
Entry.prototype = {
	toString: function() {return this.expr && this.expr.format(false)},
	formatSlash: function() {return this.expr.format(true)},
	names: function() {this.expr.names()},
	alphaConvert: function() {return new Entry(this.name, this.expr.alphaConvert())},
	betaReduce: function() {return new Entry(this.name, this.expr.betaReduce())},
	etaConvert: function() {return this},
	normalize: function() {return new Entry(this.name, this.expr.normalize())},
	globalSub: function() {return new Entry(this.name, this.expr.globalSub())},
}

function pre(type, func) {
	return function(trans) {trans.pre[type.name] = func}
}

function post(type, func) {
	return function(trans) {trans.post[type.name] = func}
}

function identity() {return this}

function Transformer(funcs) {
	this.pre = {Lambda: identity, Variable: identity, Apply: identity}
	this.post = {Lambda: identity, Variable: identity, Apply: identity}
	for (var i = 0; i < funcs.length; i++) {
		funcs[i](this)
	}
	this.trail = {}
}
Transformer.prototype = {
	prune: function(oldEnt, newEnt) {return this.trail[oldEnt.id] = newEnt},
	getTransform: function(entity) {return this.trail[entity.id]},
	transform: function(entity) {return entity.doTransform(this)},
}
var entityCounter = 0
function Entity(obj) {
	for (i in obj) {
		this[i] = obj[i]
	}
}
Entity.prototype.__proto__ = {
	transform: function() {return this.doTransform(new Transformer(arguments))},
	startTransform: function(transformer) {return transformer.getTransform(this) || this.doTransform(transformer)},
	doTransform: function(transformer) {
		if (transformer.getTransform[this]) return transformer.getTransform[this]
		var pre = transformer.pre[this.constructor.name].call(this, transformer)

		return pre && (transformer.getTransform(this) || transformer.prune(this, transformer.post[pre.constructor.name].call(pre.propagateTransform(transformer))))
	},
	alphaConvert: function() {return this},
	betaReduce: function() {return this},
	isApply: function() {return false},
	names: function() {
		var names = {}

		this.transform(pre(Lambda, function(){names[this.lvar.name] = 1; return this}))
		return names
	},
	uniquify: function(names) {return this.transform(pre(Lambda, function(transformer){transformer.prune(this.lvar, this.lvar.rename(names)); return this}))},
	hashKey: function() {return this.normalize().format(true, true)},
	globalSub: function() {return this.uniquify(props(exprs)).transform(pre(Variable, function() {return exprs[this.name] ? exprs[this.name].expr : this}))},
	normalize: function() {
		var id = 0
		var fid = 0

		return this.globalSub().transform(
			pre(Lambda, function(transformer) {
				transformer.prune(this.lvar, new Variable(id++, this.lvar.free))
				return this
			}),
			pre(Variable, function(transformer) {return this.free ? new Variable("F" + fid++, true) : this})
		)
	},
}

function Lambda(arg, body) {
	this.lvar = arg
	this.body = body
	this.id = entityCounter++
}
Lambda.prototype.__proto__ = new Entity({
	toString: function() {return "&lambda;(" + this.lvar.name + " . " + this.body + ")"},
	ret: function(stream) {
		var index = stream.length

		stream.push("function(_", this.lvar.name, ") {", "return ")
		this.body.ret(stream)
		stream.push("}")
		funcs[eval("(" + stream.slice(index, stream.length).join("") + ")")] = this
		return stream
	},
	pass: function(stream) {
		stream.push("function(){return ")
		this.ret(stream)
		stream.push("}")
		return stream
	},
	apply: function(stream) {
		stream.push("(")
		this.ret(stream)
		stream.push(")")
		return stream
	},
	getHashedName: function() {var d = hashed[this.hashKey()]; return d && d.name},
	format: function(slash, nosubs, func, arg) {return (!nosubs && this.getHashedName()) || ((func ? '(' : '') + (slash ? '\\' : '&lambda;') + this.formatRest(slash, nosubs)) + (func ? ')' : '')},
	formatRest: function(slash, nosubs) {
		var n = !nosubs && this.body instanceof Lambda && this.body.getHashedName()

		return this.lvar.format(slash, nosubs) + (n ? (slash ? '  .  ' : '&nbsp;&nbsp;.&nbsp;&nbsp;') + n : this.body instanceof Lambda ? ' ' + this.body.formatRest(slash, nosubs) : (slash ? '  .  ' : '&nbsp;&nbsp;.&nbsp;&nbsp;') + this.body.format(slash, nosubs))
	},
	propagateTransform: function(transformer) {
		var newVar = this.lvar.startTransform(transformer)
		var newBod = this.body.startTransform(transformer)

		return this.same(newVar, newBod) || new Lambda(newVar, newBod)
	},
	same: function(newVar, newBody) {return this.lvar == newVar && this.body == newBody && this},
	substitute: function(value) {
		var trans = new Transformer([])

		trans.prune(this.lvar, value)
		return trans.transform(this.body)
	},
})
function numberFor(name, names) {
	var i = 0

	while (!names[name + '_' + ++i]) {}
	return i
}

function Variable(txt, free, num) {
	this.name = txt
	this.num = num
	this.free = free
	this.id = entityCounter++
}
Variable.prototype.__proto__ = new Entity({
	toString: function() {return "Variable(" + this.name + ")"},
	pass: function(stream) {
		stream.push(!this.free || exprs[this.name] ? '_' + this.name
			: this.name.match('^[0-9]+(.[0-9]*)?$') ? "wrap(" + this.name + ")" : "wrap('" + this.name + "')")
		return stream
	},
	ret: function(stream) {
		if (!this.free || exprs[this.name]) {
			this.pass(stream)
			stream.push("()")
		} else {
			stream.push("'", this.name, "'")
		}
		return stream
	},
	apply: function(stream) {return this.ret(stream)},
	fname: function() {return this.num ? this.name + '_' + this.num : this.name},
	format: function() {return this.name},
	propagateTransform: function(transformer) {return this},
	rename: function(names) {
		if (!names[this.name]) return this
		var i = 0

		while (names[this.name + '_' + ++i]) {}
		return new Variable(this.name + '_' + i, this.free, i)
	},
	isApply: function() {return this.value ? this.value.isApply() : false},
	substitute: function(value) {return this.value && this.value.substitute(value)},
})

function Apply(func, arg) {
	this.func = func
	this.arg = arg
	this.id = entityCounter++
}
Apply.prototype.__proto__ = new Entity({
	apply: function(stream) {
		this.func.apply(stream)
		stream.push("(")
		this.arg.pass(stream)
		stream.push(")")
		return stream
	},
	ret: function(stream) {return this.apply(stream)},
	pass: function(stream) {
		stream.push("function(){return ")
		this.apply(stream)
		stream.push("}")
		return stream
	},
	toString: function() {return "Apply(" + this.func + " " + this.arg + ")"},
	format: function(slash, nosubs, func, arg) {return (arg ? '(' : '') + this.func.format(slash, nosubs, true, false) + ' ' + this.arg.format(slash, nosubs, func, true) + (arg ? ')' : '')},
	propagateTransform: function(transformer) {
		var newFunc = this.func.startTransform(transformer)
		var newArg = this.arg.startTransform(transformer)

		return this.same(newFunc, newArg) || new Apply(newFunc, newArg)
	},
	innermost: function(func) {return this.transform(pre(Apply, function(transformer){return this.func.isApply() ? this : transformer.prune(this, func.call(this))}))},
	same: function(newFunc, newArg) {return newFunc == this.func && newArg == this.arg && this},
	isApply: function() {return true},
	alphaConvert: function() {return this.innermost(function() {return new Apply(this.func, this.arg.uniquify(this.func.names()))})},
	betaReduce: function() {return this.innermost(function() {return this.func.substitute(this.arg)})},
})
function wrap(x) {return function() {return x}}
function show() {document.getElementById("control").setAttribute("class", (showDebug ? "" : "hidedebug ") + (showSubs ? "showsubs" : "shownosubs"))}
function setShowDebug(state) {
	showDebug = state
	show()
}
function setShowSubs(state) {
	showSubs = state
	show()
}
</script>
</head>
<body onload="loaded()" style="margin: 0; position: relative; top: 0; bottom: 0; right: 0; left: 0; overflow: auto; border: 0">
	<div style="position: relative; width: 100%; height: 100%">
		<table style="position: absolute; height: 100%; width: 100%; border: 0" class="hidedebug showsubs" id="control">
			<tr style="height: 0"><td style="width: 1px">Name:</td><td style="width: 10em"><input id="defName" style="width: 100%"></input></td><td style="width: 1px">Def:</td><td><input id="def" type="text" onchange="input()" style="width: 100%"></input></td></tr>
			<tr style="height: auto"><td colspan="4">
				<div style="position: relative; width: 100%; height: 100%">
					<table style="position: absolute; width: 100%; height: 100%">
						<tr style="height: 0"><td style="width: 50%"><h2>Definitions (show debug <input type="checkbox" onclick="setShowDebug(this.checked)">, show substitutions <input type="checkbox" onclick="setShowSubs(this.checked)" checked="true">)</h2></td><td style="width: 50%"><h2>Results</h2></td></tr>
						<tr style="height: auto"><td style="width: 50%"><div style="height: 100%; position: relative; overflow: auto; outline: solid black 1px"><div id="output"></div></td><td style="width: 50%"><div style="height: 100%; position: relative; overflow: auto; outline: solid black 1px"><div id="result"></div></div></td></tr>
					</table>
				</div>
			</td></tr>
		</table>
	</div>
</body>
</html>
