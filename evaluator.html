<html>
<!--
Copyright (C) 2011, Bill Burdick, Tiny Concepts: http://tinyconcepts.com/fs.pl/lambda.fsl

(licensed with ZLIB license)

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software
in a product, an acknowledgment in the product documentation would be
appreciated but is not required.

2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.

3. This notice may not be removed or altered from any source distribution.
-->
<head>
<style>
#result div .dollar {
	visibility: hidden;
	display: none;
}
#result div:last-child .dollar {
	visibility: inherit;
	display: inherit;
}
.hidden, .hidedebug .debug, .shownosubs .subs, .showsubs .nosubs {
	height: 0;
	width: 0;
	visibility: hidden;
	display: none;
}
</style>
<script>
var defName
var def
var output
var code
var lcons
var lfalse
var result
var results = []
var exprs = {}
var order = []
var funcs = {}
var funcCount = 1
var hashed = {}
var showDebug = false
var showSubs = true
var L = null
var historyCount = 0
var history = []
var historyExprs = []

function loaded() {
	defName = document.getElementById("defName")
	def = document.getElementById("def")
	output = document.getElementById("output")
	code = document.getElementById("code")
	result = document.getElementById("result")
	loadDefs(document.getElementById("initialDefs").innerHTML)
//	alert(Lhead(Lappend(L._true, Lappend(L._false, L._empty))) == L._true)
	def.select()
}
function loadDefs(defs) {
	var d = defs.split('\n')

	exprs = {}
	funcs = {}
	order = []
	funcCount = 1
	hashed = {}
	L = null
	output.innerHTML = ''
	result.innerHTML = ''
	for (var index in d) {
		var line = d[index].trim()

		if (line != "" && line[0] != '#') {
			var name = line.indexOf('=')

			addExpr(line.substring(0, name).trim(), line.substring(name + 1).trim())
		}
	}
	constructEnv()
	findCons();
}
function input() {
	addExpr(defName.value, def.value)
	defName.value = ''
	def.value = ''
}
function addExpr(name, txt) {
	if (name) {
		var expr = new Entry(name, parse(txt.trim(), {})[0])

		if (exprs[expr.name]) {
			var newOutput = ''
	
			hashed = {}
			for (var i = 0; i < order.length; i++) {
				if (order[i].name == expr.name) {
					order.splice(i, 1)
				}
				if (i < order.length) {
					newOutput += outputDivFor(i)
				}
			}
			output.innerHTML = newOutput
			L = null
		}
		order.push(expr)
		if (expr.name) exprs[expr.name] = expr
		output.innerHTML += outputDivFor(order.length - 1)
		hashed[expr.expr.hashKey()] = expr
		output.lastChild.scrollIntoView()
	} else {
		runExpr(txt.trim())
	}
}
function outputDivFor(index) {
	var expr = order[index]
	var gl = expr.globalSub()
	var ac = gl.alphaConvert()
	var br = ac.betaReduce()
	var ec = br.etaConvert()

	return "<div><button onclick='editFunc(\"" + expr.name + "\", \"" + expr.formatSlash().replace(/\\/g, '\\\\') + "\")'>Edit</button> <button onclick='runFunc(\"" + index + "\")'>Run</button><button onclick='runReduce(order[" + index + "].expr)'>Reduce</button> <b>" + (expr.name  ? expr.name + ':' : '') + '</b>&nbsp;&nbsp;<span class="subs">' + expr + "</span><span class='nosubs'>" + expr.expr.format(false, true) + "</span>"
//		+ "<div class='debug'><ul>"
//		+ "<li><b>Normalized:</b> <span class='subs'>" + expr.normalize() + "</span><span class='nosubs'>" + expr.normalize().expr.format(false, true) + "</span>"
//		+ "<li><b>Alpha conversion:</b> <span class='subs'>" + ac + "</span><span class='nosubs'>" + ac.expr.format(false, true) + "</span>"
//		+ "<li><b>Beta reduction:</b> <span class='subs'>" + br + "</span><span class='nosubs'>" + br.expr.format(false, true) + "</span>"
//		+ "<li><b>Eta conversion:</b> <span class='subs'>" + ec + "</span><span class='nosubs'>" + ec.expr.format(false, true) + "</span>"
//		+ "</ul></div>"
		+ "</div>"
}
function editFunc(name, expr) {
	defName.value = name
	def.value = expr
	def.select()
}
function findCons() {
	if (L._cons) {
		lcons = funcs[L._cons].body.body
		lfalse = funcs[L._false]
	}
}
function runFunc(index) {
	runCode(order[index].expr, order[index].code, order[index].toString(), order[index].expr.format(false, true))
}
function runExpr(str) {
	var expr = parse(str.trim(), {})[0]

	runCode(expr, constructEnv('function() {\nreturn ' + expr.ret([]).join("") + '\n}'), expr.format(), expr.format(false, true))
}
function runCode(expr, code, subs, nosubs) {
	var res

	historyExprs[historyCount] = expr
	try {
		constructEnv()
		history[historyCount] = res = code()
	} catch (err) {
		res = "Error: " + err
	}
	var lam = funcs[res]
	if (lam) {
		res = "<span class='subs'>" + pretty(res) + "</span><span class='nosubs'>" + lam.format(false, true) + "</span>" 
	}
	result.innerHTML += "<div><b><span class='dollar'>$: </span>$" + historyCount + ":</b> <button onclick='editResult(\"" + subs.replace(/\\|&lambda;/g, '\\\\') + "\")'>Edit</button><button onclick='runReduce(historyExprs[" + historyCount + "])'>Reduce</button><span class='subs'>" + subs + "</span><span class='nosubs'>" + nosubs + "</span>" + "&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;&nbsp;" + res + "</div>"
	historyCount++
	result.lastChild.scrollIntoView()
	L = null
}
function editResult(str) {
	defName.value = ''
	def.value = str
	def.select()
}
function isCons(l) {return funcs[l] == lcons}
function isFalse(l) {return funcs[l] == lfalse}
function pretty(l) {
	var lam = funcs[l]

	return lam && lam == lcons ? '(' + elements(l, true) + ')' : lam ? lam.format() : l
}
function elements(l, first) {
	return isFalse(l) ? '' : ((first ? '' : ' ') + pretty(Lhead(l)) + elements(Ltail(l), false))
}
function formatExpr(label, expr, prev, array) {
	if (!expr.equals(prev)) {
		array.push("<div><b>", label, ":</b> <span class='subs'>", expr.format(false, false), "</span><span class='nosubs'>", expr.format(false, true), "</span></div>")
	}
}
function runReduce(expr) {
	var reduction = reduce(expr)
	var h = reduction.history
	var results = []

	formatExpr("Start", h[0], null, results)
	for (var i = 1; i < reduction.history.length; i += 3) {
		formatExpr("Eta", h[i], h[i - 1], results)
		formatExpr("Alpha", h[i + 1], h[i], results)
		formatExpr("Beta", h[i + 2], h[i + 1], results)
	}
	if (reduction.good) {
		formatExpr("RESULT", h[h.length - 1], null, results)
	} else {
		results.push('<br><b>...</b>')
	}
	results.push("<br>")
	result.innerHTML += results.join("")
}
function constructEnv(src) {
	if (!L || src) {
		var env = ['(function(){\n']
	
		for (var i = 0; i < order.length; i++) {
			env.push('order[' + i + '].code = ' + order[i].src)
			if (order[i].name != "") {
				env.push("var _" + order[i].name + ' = ' + 'order[' + i + '].code')
				env.push("L._" + order[i].name + " = _" + order[i].name + '()')
			}
		}
		for (var i = 0; i < history.length; i++) {
			env.push("var _$" + i + " = function(){return history[" + i + "]}")
		}
		if (history.length > 0) {
			env.push("var _$ = function(){return history[" + (history.length - 1) + "]}")
		}
		if (src) {
			env.push('return (' + src + ')')
		}
		env.push('\n})()')
		L = {}
		return eval(env.join("\n"))
	}
}
function parse(txt, vars) {
	var expr = null
	var cur
	var newVars = {}

	while (txt.length > 0 && txt[0] != ')') {
		if (txt[0] == '\\' || txt[0] == '&lambda;') {
			var lmb = parseLambda(txt.substring(1).trim(), vars)

			cur = lmb[0]
			txt = lmb[1]
		} else {
			if (txt[0] == '(') {
				var p = parse(txt.substring(1).trim(), vars)

				cur = p[0]
				if (p[1][0] != ')') {
					throw new Error('expected ")"')
				}
				txt = p[1].substring(1).trim()
			} else {
				var name = txt.match('^[^ \t\n.()]+')[0]

				cur = vars[name]
				if (!cur) {
					cur = new Variable(name, true)
					newVars[name] = cur
					vars[name] = cur
				}
				txt = txt.substring(name.length).trim()
			}
		}
		expr = expr ? new Apply(expr, cur) : cur
	}
	for (i in newVars) {
		vars[i] = null
	}
	return [expr, txt]
}
function parseLambda(txt, vars) {
	var space = txt.indexOf(' ')
	var dot = txt.indexOf('.')
	var name, old, body, lvar

	if (dot < space || space == -1 || txt.substring(space + 1).trim()[0] == '.') {
		space = dot
		name = txt.substring(0, dot).trim()
		old = vars[name]
		lvar = vars[name] = new Variable(name, false)
		body = parse(txt.substring(dot + 1).trim(), vars)
	} else {
		name = txt.substring(0, space)
		old = vars[name]
		lvar = vars[name] = new Variable(name, false)
		body = parseLambda(txt.substring(space + 1).trim(), vars)
	}
	vars[name] = old
	return [new Lambda(lvar, body[0]), body[1]]
}
function Entry(name, expr) {
	this.name = name
	this.expr = expr
	if (expr) {
		try {
			this.src = 'function() {\nreturn ' + expr.ret([]).join("") + '\n}'
		} catch (err) {
			this.src = function() {return "Error compiling: " + expr}
		}
	}
}
Entry.prototype = {
	toString: function() {return this.expr && this.expr.format(false)},
	formatSlash: function() {return this.expr.format(true)},
	names: function() {this.expr.names()},
	alphaConvert: function() {return new Entry(this.name, this.expr.alphaConvert())},
	betaReduce: function() {return new Entry(this.name, this.expr.betaReduce())},
	etaConvert: function() {return new Entry(this.name, this.expr.etaConvert())},
	normalize: function() {return new Entry(this.name, this.expr.normalize())},
	globalSub: function() {return new Entry(this.name, this.expr.globalSub())},
}

function reduce(expr) {
	var history = [expr.globalSub()]

	do {
		var ec = history[history.length - 1].etaConvert()
		var ac = ec.alphaConvert()

		history.push(ec, ac, ac.betaReduce())
		if (history.length > 1000) return {good: false, history: history}
	} while (!history[history.length - 1].equals(history[history.length - 4]))
	return {good: true, history: history[history.length - 1] == history[history.length - 3] ? history.slice(0, history.length - 3) : history}
}

function pre(type, func) {
	return function(trans) {trans.pre[type.name] = func}
}

function post(type, func) {
	return function(trans) {trans.post[type.name] = func}
}

function identity() {return this}

function Transformer(funcs) {
	this.pre = {Lambda: identity, Variable: identity, Apply: identity}
	this.post = {Lambda: identity, Variable: identity, Apply: identity}
	for (var i = 0; i < funcs.length; i++) {
		funcs[i](this)
	}
	this.trail = {}
}
Transformer.prototype = {
	prune: function(oldEnt, newEnt) {return this.trail[oldEnt.id] = newEnt},
	getTransform: function(entity) {return this.trail[entity.id]},
	transform: function(entity) {return entity.doTransform(this)},
}
function lCode(name) {
	return eval('(function(){return runLCode(L._' + name + ', arguments)})')
}
function runLCode(func, args) {
	for (var i = 0; i < args.length; i++) {
		func = func.call(null, wrap(args[i]))
	}
//	if (funcs[func]) {
//		func = funcs[func]
//	}
	return func
}
var entityCounter = 0
function Entity(obj) {
	for (i in obj) {
		this[i] = obj[i]
	}
}
Entity.prototype.__proto__ = {
	transform: function() {return this.doTransform(new Transformer(arguments))},
	startTransform: function(transformer) {return transformer.getTransform(this) || this.doTransform(transformer)},
	doTransform: function(transformer) {
		if (transformer.getTransform[this]) return transformer.getTransform[this]
		var pre = transformer.pre[this.constructor.name].call(this, transformer)

		return pre && (transformer.getTransform(this) || transformer.prune(this, transformer.post[pre.constructor.name].call(pre.propagateTransform(transformer), transformer)))
	},
	alphaConvert: function() {return this},
	betaReduce: function() {return this},
	etaConvert: function() {return this.transform(post(Lambda, function(transformer) {
		return this.body instanceof Apply && this.body.arg == this.lvar && !this.body.func.containsVar(this.lvar) ? this.body.func : this
	}))},
	isApply: function() {return false},
	names: function() {
		var names = {}

		this.transform(pre(Lambda, function(){names[this.lvar.name] = 1; return this}))
		return names
	},
	uniquify: function(names) {return this.transform(pre(Lambda, function(transformer){transformer.prune(this.lvar, this.lvar.rename(names)); return this}))},
	hashKey: function() {return this.normalize().format(true, true)},
	globalSub: function() {
//		return this.uniquify(exprs).transform(pre(Variable, function() {return exprs[this.name] ? exprs[this.name].expr : this}))
		var v = this.uniquify(exprs).transform(pre(Variable, function() {
			return exprs[this.name] ? exprs[this.name].expr.globalSub() : this
		}))
		var bad = false

		v.transform(pre(Lambda, function() {
			if (!(this.lvar instanceof Variable)) {
				bad = true; return this
			}
		}))
		if (bad) {
			alert("Error in globalSub for " + this.format(true, true))
		}
		return v
	},
	normalize: function() {
		var id = 0
		var fid = 0

		return this.globalSub().transform(
			pre(Lambda, function(transformer) {
				transformer.prune(this.lvar, new Variable(id++, this.lvar.free))
				return this
			}),
			pre(Variable, function(transformer) {return this.free ? new Variable("F" + fid++, true) : this})
		)
	},
	containsVar: function(targetVar) {
		var contains = false

		this.transform(pre(Variable, function() {contains = contains || this == targetVar; return this}))
		return contains
	},
}

function pfx(prefix) {return prefix == null ? '_' : prefix}

function Lambda(arg, body) {
	this.lvar = arg
	this.body = body
	this.id = entityCounter++
}
Lambda.prototype.__proto__ = new Entity({
	equals: function(obj) {return obj instanceof Lambda && this.lvar.equals(obj.lvar) && this.body.equals(obj.body)},
	toString: function() {return "&lambda;(" + this.lvar.name + " . " + this.body + ")"},
	ret: function(stream, prefix) {
		var index = stream.length

		stream.push("function(", pfx(prefix), this.lvar.name, ") {\n", "return ")
		this.body.ret(stream, prefix)
		stream.push("\n}")
		funcs[eval("(" + stream.slice(index, stream.length).join("") + ")")] = this
		return stream
	},
	pass: function(stream, prefix) {
		stream.push("function(){\nreturn ")
		this.ret(stream, prefix)
		stream.push("\n}")
		return stream
	},
	apply: function(stream, prefix) {
		stream.push("(")
		this.ret(stream, prefix)
		stream.push(")")
		return stream
	},
	getHashedName: function() {var d = hashed[this.hashKey()]; return d && d.name},
	format: function(slash, nosubs, func, arg) {return (!nosubs && this.getHashedName()) || ((func ? '(' : '') + (slash ? '\\' : '&lambda;') + this.formatRest(slash, nosubs)) + (func ? ')' : '')},
	formatRest: function(slash, nosubs) {
		var n = !nosubs && this.body instanceof Lambda && this.body.getHashedName()

		return this.lvar.format(slash, nosubs) + (n ? (slash ? '  .  ' : '&nbsp;&nbsp;.&nbsp;&nbsp;') + n : this.body instanceof Lambda ? ' ' + this.body.formatRest(slash, nosubs) : (slash ? '  .  ' : '&nbsp;&nbsp;.&nbsp;&nbsp;') + this.body.format(slash, nosubs))
	},
	propagateTransform: function(transformer) {
		var newVar = this.lvar.startTransform(transformer)
		var newBod = this.body.startTransform(transformer)

		return this.make(newVar, newBod)
	},
	make: function(newVar, newBody) {return (this.lvar == newVar && this.body == newBody && this) || new Lambda(newVar, newBody)},
	substitute: function(value) {
		var trans = new Transformer([])

		trans.prune(this.lvar, value)
		return trans.transform(this.body)
	},
})
function numberFor(name, names) {
	var i = 0

	while (!names[name + '_' + ++i]) {}
	return i
}

function Variable(txt, free, num) {
	this.name = txt
	this.num = num
	this.free = free
	this.id = entityCounter++
}
Variable.prototype.__proto__ = new Entity({
	equals: function(obj) {return obj instanceof Variable && this.name == obj.name},
	toString: function() {return "Variable(" + this.name + ")"},
	pass: function(stream, prefix) {
		stream.push(!this.free || exprs[this.name] || this.name == "$" || (this.name.match('^\\$[0-9]+$') && Number(this.name.substring(1)) < history.length) ? pfx(prefix) + this.name
			: this.name.match('^[0-9]+(.[0-9]*)?$') ? "wrap(" + this.name + ")" : "wrap('" + this.name + "')")
		return stream
	},
	ret: function(stream, prefix) {
		if (!this.free || exprs[this.name] || this.name == "$" || (this.name.match('^\\$[0-9]+$') && Number(this.name.substring(1)) < history.length)) {
			this.pass(stream, prefix)
			stream.push("()")
		} else {
			stream.push("'", this.name, "'")
		}
		return stream
	},
	apply: function(stream, prefix) {return this.ret(stream, prefix)},
	fname: function() {return this.num ? this.name + '_' + this.num : this.name},
	format: function() {return this.name},
	propagateTransform: function(transformer) {return this},
	rename: function(names) {
		if (!names[this.name]) return this
		var i = 0

		while (names[this.name + '_' + ++i]) {}
		return new Variable(this.name + '_' + i, this.free, i)
	},
})

function Apply(func, arg) {
	this.func = func
	this.arg = arg
	this.id = entityCounter++
}
Apply.prototype.__proto__ = new Entity({
	equals: function(obj) {return obj instanceof Apply && this.func.equals(obj.func) && this.arg.equals(obj.arg)},
	apply: function(stream, prefix) {
		this.func.apply(stream, prefix)
		stream.push("(")
		this.arg.pass(stream, prefix)
		stream.push(")")
		return stream
	},
	ret: function(stream, prefix) {return this.apply(stream, prefix)},
	pass: function(stream, prefix) {
		stream.push("function(){\nreturn ")
		this.apply(stream, prefix)
		stream.push("\n}")
		return stream
	},
	toString: function() {return "Apply(" + this.func + " " + this.arg + ")"},
	format: function(slash, nosubs, func, arg) {return (arg ? '(' : '') + this.func.format(slash, nosubs, true, false) + ' ' + this.arg.format(slash, nosubs, func, true) + (arg ? ')' : '')},
	propagateTransform: function(transformer) {
		var newFunc = this.func.startTransform(transformer)
		var newArg = this.arg.startTransform(transformer)

		return this.make(newFunc, newArg)
	},
	make: function(newFunc, newArg) {return (newFunc == this.func && newArg == this.arg && this) || new Apply(newFunc, newArg)},
	innermost: function(func) {return this.func.isApply() ? new Apply(this.func.innermost(func), this.arg) : func.call(this)},
	isApply: function() {return true},
	alphaConvert: function() {return this.innermost(function() {return new Apply(this.func, this.arg.uniquify(this.func.names()))})},
	betaReduce: function() {return this.innermost(function() {return this.func.substitute(this.arg)})},
	etaConvert: function() {return this.innermost(function() {return new Apply(this.func.etaConvert(), this.arg)})},
})
function wrap(x) {return function() {return x}}
function show() {document.getElementById("control").setAttribute("class", (showDebug ? "" : "hidedebug ") + (showSubs ? "showsubs" : "shownosubs"))}
function setShowDebug(state) {
	showDebug = state
	show()
}
function setShowSubs(state) {
	showSubs = state
	show()
}
function handleFiles(files) {
	var reader = new FileReader()

	reader.onerror = function(e1, e2, e3, e4) {
		alert('error' + exception.getMessage())
	}
	reader.onload = function() {
		loadDefs(reader.result)
	}
	reader.readAsText(files[0])
}
var Ltrue = lCode('true')
var Lfalse = lCode('false')
var Land = lCode('and')
var Lor = lCode('or')
var Leq = lCode('eq')
var Lxor = lCode('xor')
var Lnot = lCode('not')
var Lpair = lCode('pair')
var Lhead = lCode('head')
var Ltail = lCode('tail')
var Lempty = lCode('empty')
var Lappend = lCode('append')
var Lhead = lCode('head')
var Lisempty = lCode('isempty')
var Ltail = lCode('tail')
</script>
</head>
<body onload="loaded()" style="margin: 0; position: relative; top: 0; bottom: 0; right: 0; left: 0; overflow: auto; border: 0">
	<table style="position: absolute; height: 100%; width: 100%; border: 0" class="hidedebug showsubs" id="control">
		<tr style="height: 0"><td colspan="4">Load file: <input type="file" id="input" onchange="handleFiles(this.files)"></input></td></tr>
		<tr style="height: auto"><td colspan="4">
			<div style="position: relative; width: 100%; height: 100%">
				<table style="position: absolute; width: 100%; height: 100%">
					<tr style="height: 0"><td style="width: 50%"><span class='hidden' style="color: red">CURRENT ERROR: reduce on test</span><h2>Definitions (show debug <input type="checkbox" onclick="setShowDebug(this.checked)">, show substitutions <input type="checkbox" onclick="setShowSubs(this.checked)" checked="true">)</h2></td><td style="width: 50%"><h2>Results</h2></td></tr>
					<tr style="height: auto"><td style="width: 50%"><div style="height: 100%; position: relative; overflow: auto; outline: solid black 1px" id="output"></div></td><td style="width: 50%"><div style="height: 100%; position: relative; overflow: auto; outline: solid black 1px" id="result"></div></td></tr>
				</table>
			</div>
		</td></tr>
		<tr style="height: 0"><td style="width: 1px">Name:</td><td style="width: 10em"><input id="defName" style="width: 100%"></input></td><td style="width: 1px">Def:</td><td><input id="def" type="text" onchange="input()" style="width: 100%"></input></td></tr>
	</table>
	<pre class="hidden" id="initialDefs1">
true = \x y.x
false = \x y.y
cons = \x y f  .  f x y
first = \l  .  l \a b  .  a
rest = \l  .  l \a b  .  b
nil = \l x y . x
null = \p.p (\a b x y.y)
# Y combinator
Y = \g  .  (\x  .  g (x x)) \x  .  g (x x)
rec = \f . f (Y f)
last = rec \last list . (null (rest list)) (first list) (last (rest list))
Example = first (cons 1 nil)
Example2 = rest (cons 1 nil)
Example3 = rest (cons 1 (cons 2 nil))
Example4 = (\x y . (\z . z x) y) 1
Example5 = last (cons 1 nil)
Example6 = last (cons 1 (cons 2 nil))
	</pre>
	<pre class="hidden" id="initialDefs2">
# Booleans
true = \x y.x
false = \x y.y
not = \b . b false true
and = \a b . a b false
or = \a b . a true b
eq = \a b . a b (not b)
xor = \a b . a (not b) b
	</pre>
	<pre class="hidden" id="initialDefs">
#rotation
rot2 = \a b f . f b a
f2 = \a b . a
rot3 = \a b c f . f b c a
r3 = rot3 1 2 3
f3 = \a b c . a
rot4 = \a b c d f . f b c d a
f4 = \a b c d . a

# Booleans
true = \x y.x
false = \x y.y
not = \b . b false true
and = \a b . a b false
or = \a b . a true b
eq = \a b . a b (not b)
xor = \a b . a (not b) b

# Y combinator
Y = \g  .  (\x  .  g (x x)) \x  .  g (x x)
rec = \f . f (Y f)

# lists
# using false as "nil" in lists, so you use a list like this:
# DUMMY can be anything, but it needs to be there
# here's how you use a list:
# alist (\h t DUMMY . {list-case}) {empty-case}
# If the list is not empty, h and t are the head and tail of the list and it returns list-case.  DUMMY is not used, but needs to be there
# If the list is empty, it returns empty-case
cons = \a b f.f a b
head = \l . l (\h t D . h) false
tail = \l . l (\h t D . t) false
null = \l . l (\h t D . false) true
last = rec \last l2  . l2 (\h t D . null t h (last t)) false
append = rec \append l1 l2 . l1 (\h t D . cons h (append t l2)) l2

# Random number generator taken from "Xorshift RNGs", by George Marsaglia, Florida State University
# Here's where I found it: http://www.jstatsoft.org/v08/i14/paper
# This works on a list of booleans, using this formula for the next step:
#	x1 = old ^ (old << a)
#	x2 = x1 ^ (x1 >> b)
#	x3 = x2 ^ (x2 << c)
#
#	Small numbers that work are: 1,7,9
#
# so:	x1 = \old . xor old (cons false old)
#	x2 = \x1 . xor x1 (7tail x1)
#	x3 = \x2 . xor x2 (9false x1)
#	rand = \x . x3 (x2 (x1 x))
map = rec \map op l . l (\h t D . cons (op h) (map op t)) false
map2 = rec \map2 op l1 l2 . l1 (\h1 t1 D . l2 (\h2 t2 D . cons (op h1 h2) (map2 op t1 t2)) t1) l2
lxor = \l1 l2 . map2 xor l1 l2
7tail = \l . tail (tail (tail (tail (tail (tail (tail l))))))
3false = \l . cons false (cons false (cons false l))
9false = \l . 3false (3false (3false l))
rand_x1 = \old . lxor old (cons false old)
rand_x2 = \x1 . lxor x1 (7tail x1)
rand_x3 = \x2 . lxor x2 (9false x1)
rand = \current . x3 (x2 (x1 current))

l = append (cons 0 false) (cons 1 (cons 2 (cons 3 false)))
t = last l
	</pre>
</body>
</html>
