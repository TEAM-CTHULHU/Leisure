<html>
<!--
Copyright (C) 2011, Bill Burdick, Tiny Concepts: http://tinyconcepts.com/fs.pl/lambda.fsl

(licensed with ZLIB license)

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software
in a product, an acknowledgment in the product documentation would be
appreciated but is not required.

2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.

3. This notice may not be removed or altered from any source distribution.
-->
<head>
<style>
#result div .dollar {
	visibility: hidden;
	display: none;
}
#result :last-child .dollar {
	visibility: inherit;
	display: inherit;
}
.hidden, .hidedebug .debug, .shownosubs .subs, .showsubs .nosubs {
	height: 0;
	width: 0;
	visibility: hidden;
	display: none;
}
</style>
<script>
var def
var output
var code
var lcons
var lfalse
var result
var exprs = {}
var order = []
var funcs = {}
var funcCount = 1
var hashed = {}
var showDebug = false
var showSubs = true
var L = null
var historyCount = 0
var history = []
var historyExprs = []
var tokenTypes = {}
var tokenPat = null

function loaded() {
	def = document.getElementById("def")
	output = document.getElementById("output")
	code = document.getElementById("code")
	result = document.getElementById("result")
	loadDefs(document.getElementById("initialDefs").innerHTML)
	def.select()
}
function addToken(tok, group) {
	var pat = ''

	tokenTypes[tok] = group
	tokenPat = null
}
function createTokenPat() {
	if (!tokenPat) {
		var types = []

		for (var i in tokenTypes) {
			types.push(i)
		}
		if (types.length) {
			types.sort(function(a, b) {b.length - a.length})
		}
		types.push('=.=|=\\(|=\\)|[().\\\\=]|&lambda;| +')
		tokenPat = new RegExp(types.join('|'))
	}
}
function loadDefs(defs) {
	var d = defs.split('\n')

	exprs = {}
	funcs = {}
	order = []
	funcCount = 1
	hashed = {}
	L = null
	output.innerHTML = ''
	result.innerHTML = ''
	for (var index in d) {
		processLine(d[index].trim())
	}
	constructEnv()
	findCons();
}
function processLine(line) {
	if (line != "" && line[0] != '#') {
		var name = line.indexOf('=')

		addExpr(line.substring(0, name).trim(), line.substring(name + 1).trim())
	}
}
function input() {
//	result.innerHTML += '<b>Tokens:</b> ' + tokenize(def.value.trim()).join(', ') + "<br>"
	processLine(def.value)
	def.value = ''
}
function addExpr(name, txt) {
	if (name) {
		var expr = new Entry(name, parse(txt.trim(), {})[0])

		if (exprs[expr.name]) {
			var newOutput = ''
	
			hashed = {}
			for (var i = 0; i < order.length; i++) {
				if (order[i].name == expr.name) {
					order.splice(i, 1)
				}
				if (i < order.length) {
					newOutput += outputDivFor(i)
				}
			}
			output.innerHTML = newOutput
			L = null
		}
		order.push(expr)
		if (expr.name) exprs[expr.name] = expr
		output.innerHTML += outputDivFor(order.length - 1)
		var hk = expr.expr.hashKey()
		if (!hashed[hk]) hashed[hk] = expr
		output.lastChild.scrollIntoView()
	} else {
		runExpr(txt.trim())
	}
}
function outputDivFor(index) {
	var expr = order[index]
	var gl = expr.globalSub()
	var ac = gl.alphaConvert()
	var br = ac.betaReduce()
	var ec = br.etaConvert()

	return "<div><button onclick='editFunc(\"" + expr.name + "\", \"" + expr.formatSlash(true).replace(/\\/g, '\\\\') + "\")'>Edit</button> <button onclick='runFunc(\"" + index + "\")'>Run</button><button onclick='runReduce(order[" + index + "].expr)'>Reduce</button> <b>" + (expr.name  ? expr.name + ':' : '') + '</b>&nbsp;&nbsp;' + expr.expr.format(false, true)
//		+ "<div class='debug'><ul>"
//		+ "<li><b>Normalized:</b> <span class='subs'>" + expr.normalize() + "</span><span class='nosubs'>" + expr.normalize().expr.format(false, true) + "</span>"
//		+ "<li><b>Alpha conversion:</b> <span class='subs'>" + ac + "</span><span class='nosubs'>" + ac.expr.format(false, true) + "</span>"
//		+ "<li><b>Beta reduction:</b> <span class='subs'>" + br + "</span><span class='nosubs'>" + br.expr.format(false, true) + "</span>"
//		+ "<li><b>Eta conversion:</b> <span class='subs'>" + ec + "</span><span class='nosubs'>" + ec.expr.format(false, true) + "</span>"
//		+ "</ul></div>"
		+ "</div>"
}
function editFunc(name, expr) {
	def.value = name + ' = ' + expr
	def.select()
}
function findCons() {
	if (L._cons) {
		lcons = funcs[L._cons()].body.body
		lfalse = funcs[L._false()]
	}
}
function runFunc(index) {
	runCode(order[index].expr, order[index].code, order[index].toString(), order[index].expr.format(false, true))
}
function runExpr(str) {
	var expr = parse(str.trim(), {})[0]

	runCode(expr, constructEnv('function() {\nreturn ' + expr.ret([]).join("") + '\n}'), expr.format(), expr.format(false, true))
}
function tokenize(str) {
	var pos = 0
	var toks = []

	createTokenPat()
	while (str.length && (pos = str.search(tokenPat)) > -1) {
		if (pos > 0) {
			toks.push(str.substring(0, pos))
		}
		var tok = tokenPat.exec(str.substring(pos))[0]
		if (tok.trim()) {
			toks.push(tok)
		}
		str = str.substring(pos + tok.length)
	}
	if (str.length) {
		toks.push(str)
	}
	return toks
}
function runCode(expr, code, subs, nosubs) {
	var res

	historyExprs[historyCount] = expr
	try {
		constructEnv()
		history[historyCount] = res = code()
	} catch (err) {
		res = "Error: " + err.message
	}
	var lam = funcs[res]
	if (lam) {
		res = "<span class='subs'>" + pretty(res) + "</span><span class='nosubs'>" + lam.format(false, true) + "</span>" 
	}
	result.innerHTML += "<div><b><span class='dollar'>$: </span>$" + historyCount + ":</b> <button onclick='editResult(\"" + subs.replace(/\\|&lambda;/g, '\\\\') + "\")'>Edit</button><button onclick='runReduce(historyExprs[" + historyCount + "])'>Reduce</button><span class='subs'>" + subs + "</span><span class='nosubs'>" + nosubs + "</span>" + "&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;&nbsp;" + res + "<br><br></div>"
	historyCount++
	result.lastChild.scrollIntoView()
	L = null
}
function editResult(str) {
	def.value = str
	def.select()
}
function isCons(l) {return funcs[l].id == lcons.id}
function isFalse(l) {return funcs[l].id == lfalse.id}
function pretty(l) {
	var lam = funcs[l]

	return lam && lam.id == lcons.id ? '(' + elements(l, true) + ')' : lam ? lam.format() : l
}
function elements(l, first) {
	return isFalse(l) ? '' : ((first ? '' : ' ') + pretty(Lhead(l)) + elements(Ltail(l), false))
}
function lpretty(lam) {
	return lam.id == lcons.id ? pretty(constructEnv(lam.ret([]).join(""))) : lam.format()
}
function formatExpr(label, expr, el) {
	el.innerHTML += "<div><b>" + label + ":</b> " + formatSubexpr(expr) + "</div>"
}
function formatSubexpr(expr) {
	return "<span class='subs'>" + lpretty(expr) + "</span><span class='nosubs'>" + expr.format(false, true) + "</span>"
}
function toggleSteps(link) {
	var div = link.parentElement.parentElement.nextElementSibling

	if (div.className) {
		div.className = ''
		link.innerHTML = '+'
	} else {
		div.className = 'hidden'
		link.innerHTML = '-'
	}
}
function runReduce(expr) {
	var last

	formatExpr(" <a style='border: solid black 1px;font-family: monospace' onclick='toggleSteps(this)'>-</a> Reduce", expr, result)
	result.innerHTML += "<div class='hidden'></div>"
	expr = expr.globalSub()
	var trace = result.lastElementChild
	formatExpr("Globals", expr, trace)
	try {
		var success = reduce(expr,
			function(exp) {formatExpr("Eta", last = exp, trace)},
			function(exp) {formatExpr("Alpha", last = exp, trace)},
			function(exp) {formatExpr("Beta", last = exp, trace)}
		)
		result.lastElementChild.previousElementSibling.innerHTML += "&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;&nbsp;" + (success ? formatSubexpr(last) : '<br><b>...</b>')
	} catch (err) {
		result.lastElementChild.previousElementSibling.innerHTML += "&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;&nbsp;" + '<b>' + err + '</b>'
	}
	result.innerHTML += '<br>'
	result.lastElementChild.scrollIntoView()
}
function constructEnv(src) {
	if (!L || src) {
		var env = ['(function(){\n']

		for (var i = 0; i < order.length; i++) {
			env.push('order[' + i + '].code = ' + order[i].src)
			if (order[i].name != "") {
				env.push('\n// ' + order[i].name + ' = ' + order[i].expr.format(true, true))
				env.push("var _" + order[i].cname + ' = ' + 'order[' + i + '].code')
				env.push("L._" + order[i].cname + " = _" + order[i].cname)
			}
		}
		for (var i = 0; i < history.length; i++) {
			env.push("var _" + charCodes['$'] + i + " = function(){return history[" + i + "]}")
		}
		if (history.length > 0) {
			env.push("var _" + charCodes['$'] + " = function(){return history[" + (history.length - 1) + "]}")
		}
		if (src) {
			env.push('return (' + src + ')')
		}
		env.push('\n})()')
		L = {}
		var res
		try {
			res = eval(env.join("\n"))
		} catch (err) {
			res = "ERROR: " + err.message
		}
		return res
	}
}
function parse(txt, vars) {
	var expr = null
	var cur
	var newVars = {}

	while (txt.length > 0 && txt[0] != ')') {
		if (txt[0] == '\\' || txt[0] == '&lambda;') {
			var lmb = parseLambda(txt.substring(1).trim(), vars)

			cur = lmb[0]
			txt = lmb[1]
		} else {
			if (txt[0] == '(') {
				var p = parse(txt.substring(1).trim(), vars)

				cur = p[0]
				if (p[1][0] != ')') {
					throw new Error('expected ")"')
				}
				txt = p[1].substring(1).trim()
			} else {
				var name = txt.match('^[^ \t\n.()]+')[0]

				cur = vars[name]
				if (!cur) {
					cur = new Variable(name, true)
					newVars[name] = cur
					vars[name] = cur
				}
				txt = txt.substring(name.length).trim()
			}
		}
		expr = expr ? new Apply(expr, cur) : cur
	}
	for (i in newVars) {
		vars[i] = null
	}
	return [expr, txt]
}
function parseLambda(txt, vars) {
	var space = txt.indexOf(' ')
	var dot = txt.indexOf('.')
	var name, old, body, lvar

	if (dot < space || space == -1 || txt.substring(space + 1).trim()[0] == '.') {
		space = dot
		name = txt.substring(0, dot).trim()
		old = vars[name]
		lvar = vars[name] = new Variable(name, false)
		body = parse(txt.substring(dot + 1).trim(), vars)
	} else {
		name = txt.substring(0, space)
		old = vars[name]
		lvar = vars[name] = new Variable(name, false)
		body = parseLambda(txt.substring(space + 1).trim(), vars)
	}
	vars[name] = old
	return [new Lambda(lvar, body[0]), body[1]]
}
function Entry(name, expr) {
	this.name = name
	this.cname = nameSub(name)
	this.expr = expr
	if (expr) {
		try {
			this.src = 'function() {\nreturn ' + expr.ret([]).join("") + '\n}'
		} catch (err) {
			this.src = function() {return "Error compiling: " + expr}
		}
	}
}
Entry.prototype = {
	toString: function() {return this.expr && this.expr.format(false)},
	formatSlash: function(nosubs) {return this.expr.format(true, nosubs)},
	names: function() {this.expr.names()},
	alphaConvert: function() {return new Entry(this.name, this.expr.alphaConvert())},
	betaReduce: function() {return new Entry(this.name, this.expr.betaReduce())},
	etaConvert: function() {return new Entry(this.name, this.expr.etaConvert())},
	normalize: function() {return new Entry(this.name, this.expr.normalize())},
	globalSub: function() {return new Entry(this.name, this.expr.globalSub())},
}

function reduce(expr, ecallback, acallback, bcallback) {
	var prev = expr

	for (var count = 0; count < 1000; count++) {
		var ec = prev.etaConvert()
		var ac = ec.alphaConvert()
		var bc = ac.betaReduce()

		if (!ec.equals(prev)) ecallback(ec)
		if (!ac.equals(ec)) acallback(ac)
		if (!bc.equals(ac)) bcallback(bc)
		if (bc.equals(prev)) return true
		prev = bc
	}
	return false
}

function pre(type, func) {
	return function(trans) {trans.pre[type.name] = func}
}

function post(type, func) {
	return function(trans) {trans.post[type.name] = func}
}

function identity() {return this}

function Transformer(funcs) {
	this.pre = {Lambda: identity, Variable: identity, Apply: identity}
	this.post = {Lambda: identity, Variable: identity, Apply: identity}
	for (var i = 0; i < funcs.length; i++) {
		funcs[i](this)
	}
	this.trail = {}
}
Transformer.prototype = {
	prune: function(oldEnt, newEnt) {return this.trail[oldEnt.id] = newEnt},
	getTransform: function(entity) {return this.trail[entity.id]},
	transform: function(entity) {return entity.doTransform(this)},
}
function lCode(name) {
	return eval('(function(){return runLCode(L._' + name + '(), arguments)})')
}
function runLCode(func, args) {
	for (var i = 0; i < args.length; i++) {
		func = func.call(null, wrap(args[i]))
	}
	return func
}
var entityCounter = 0
function Entity(obj) {
	for (i in obj) {
		this[i] = obj[i]
	}
}
Entity.prototype.__proto__ = {
	transform: function() {return this.doTransform(new Transformer(arguments))},
	startTransform: function(transformer) {return transformer.getTransform(this) || this.doTransform(transformer)},
	doTransform: function(transformer) {
		if (transformer.getTransform(this)) return transformer.getTransform(this)
		var pre = transformer.pre[this.constructor.name].call(this, transformer)

		return pre && (transformer.getTransform(this) || transformer.prune(this, transformer.post[pre.constructor.name].call(pre.propagateTransform(transformer), transformer)))
	},
	alphaConvert: function() {return this},
	betaReduce: function() {return this},
	etaConvert: function() {return this.transform(post(Lambda, function(transformer) {
		return this.body instanceof Apply && this.body.arg == this.lvar && !this.body.func.containsVar(this.lvar) ? this.body.func : this
	}))},
	isApply: function() {return false},
	names: function() {
		var names = {}

		this.transform(pre(Lambda, function(){names[this.lvar.name] = 1; return this}))
		return names
	},
	uniquify: function(names) {return this.transform(pre(Lambda, function(transformer){transformer.prune(this.lvar, this.lvar.rename(names)); return this}))},
	hashKey: function() {return this.normalize().format(true, true)},
	globalSub: function() {
		var v = this.uniquify(exprs).transform(pre(Variable, function() {
			return exprs[this.name] ? exprs[this.name].expr.globalSub() : this
		}))
		var bad = false

		v.transform(pre(Lambda, function() {
			if (!(this.lvar instanceof Variable)) {
				bad = true; return this
			}
		}))
		if (bad) {
			alert("Error in globalSub for " + this.format(true, true))
		}
		return v
	},
	normalize: function() {
		var id = 0
		var fid = 0

		return this.globalSub().transform(
			pre(Lambda, function(transformer) {
				transformer.prune(this.lvar, new Variable(id++, this.lvar.free))
				return this
			}),
			pre(Variable, function(transformer) {return this.free ? new Variable("F" + fid++, true) : this})
		)
	},
	containsVar: function(targetVar) {
		var contains = false

		this.transform(pre(Variable, function() {contains = contains || this == targetVar; return this}))
		return contains
	},
}

function pfx(prefix) {return prefix == null ? '_' : prefix}

function Lambda(arg, body, id) {
	this.lvar = arg
	this.body = body
	this.id = id || entityCounter++
}
Lambda.prototype.__proto__ = new Entity({
	equals: function(obj) {return obj instanceof Lambda && this.lvar.equals(obj.lvar) && this.body.equals(obj.body)},
	toString: function() {return this.format()},
	ret: function(stream, prefix) {
		var index = stream.length

		stream.push("function(", pfx(prefix), this.lvar.cname, ") {\n", "return ")
		this.body.ret(stream, prefix)
		stream.push("\n}")
		var str  = eval("(" + stream.slice(index, stream.length).join("") + ")").toString()
		if (!funcs[str]) funcs[str] = this
		return stream
	},
	pass: function(stream, prefix) {
		stream.push("function(){\nreturn ")
		this.ret(stream, prefix)
		stream.push("\n}")
		return stream
	},
	apply: function(stream, prefix) {
		stream.push("(")
		this.ret(stream, prefix)
		stream.push(")")
		return stream
	},
	getHashedName: function() {var d = hashed[this.hashKey()]; return d && d.name},
	format: function(slash, nosubs, func, arg) {return (!nosubs && this.getHashedName()) || ((func ? '(' : '') + (slash ? '\\' : '&lambda;') + this.formatRest(slash, nosubs)) + (func ? ')' : '')},
	formatRest: function(slash, nosubs) {
		var n = !nosubs && this.body instanceof Lambda && this.body.getHashedName()

		return this.lvar.format(slash, nosubs) + (n ? (slash ? '  .  ' : '&nbsp;&nbsp;.&nbsp;&nbsp;') + n : this.body instanceof Lambda ? ' ' + this.body.formatRest(slash, nosubs) : (slash ? '  .  ' : '&nbsp;&nbsp;.&nbsp;&nbsp;') + this.body.format(slash, nosubs))
	},
	propagateTransform: function(transformer) {
		var newVar = this.lvar.startTransform(transformer)
		var newBod = this.body.startTransform(transformer)

		return this.make(newVar, newBod)
	},
	make: function(newVar, newBody) {return (this.lvar == newVar && this.body == newBody && this) || new Lambda(newVar, newBody, this.id)},
	substitute: function(value) {
		var trans = new Transformer([])

		trans.prune(this.lvar, value)
		return trans.transform(this.body)
	},
})
function numberFor(name, names) {
	var i = 0

	while (!names[name + '_' + ++i]) {}
	return i
}

var charCodes = {
	"'": '$a',
	',': '$b',
	'$': '$c',
	'@': '$d',
	'?': '$e',
	'/': '$f',
	'*': '$g',
	'&': '$h',
	'^': '$i',
	'#': '$j',
	'!': '$k',
	'`': '$l',
	'~': '$m',
	'-': '$n',
	'+': '$o',
	'=': '$p',
	'|': '$q',
	'[': '$r',
	']': '$s',
	'{': '$t',
	'}': '$u',
	'"': '$v',
	':': '$w',
	';': '$x',
	'<': '$y',
	'>': '$z',
	'%': '$A',
}
var codeChars = {}

for (i in charCodes) {
	codeChars[charCodes[i].substring(1)] = i
}

function nameSub(name) {
	var s = ''

	for (var i = 0; i < name.length; i++) {
		var code = charCodes[name[i]]

		if (code) {
			if (!s) s = name.substring(0, i)
			s += code
		} else if (s) {
			s += name[i]
		}
	}
	return s || name
}
function nameUnsub(name) {
	var s = ''

	for (var i = 0; i < name.length; i++) {
		if (name[i] == '$') {
			if (!s) s = name.substring(0, i)
			s += codeChars[name[++i]]
		} else {
			if (s) s += name[i]
		}
	}
	return s || name
}

function Variable(txt, free, base, num) {
	this.name = txt
	this.base = base || txt
	this.cname = nameSub(txt)
	this.num = num || 0
	this.free = free
	this.id = entityCounter++
}
var vcount = 0
Variable.prototype.__proto__ = new Entity({
	equals: function(obj) {return obj instanceof Variable && this.name == obj.name},
	toString: function() {return "Variable(" + this.name + ")"},
	pass: function(stream, prefix) {
		stream.push(!this.free || exprs[this.name] || this.name == "$" || (this.name.match('^\\$[0-9]+$') && Number(this.name.substring(1)) < history.length) ? pfx(prefix) + this.cname
			: this.name.match('^[0-9]+(.[0-9]*)?$') ? "wrap(" + this.name + ")" : "wrap('" + this.name + "')")
		return stream
	},
	ret: function(stream, prefix) {
		if (!this.free || exprs[this.name] || this.name == "$" || (this.name.match('^\\$[0-9]+$') && Number(this.name.substring(1)) < history.length)) {
			this.pass(stream, prefix)
			stream.push("()")
		} else {
			stream.push(this.name.match('^[0-9]+(.[0-9]*)?$') ? this.name : "'" + this.name + "'")
		}
		return stream
	},
	apply: function(stream, prefix) {return this.ret(stream, prefix)},
	format: function() {return this.name},
	propagateTransform: function(transformer) {return this},
	rename: function(names) {
		if (!names[this.name]) return this
		var i = this.num

		while (names[this.base + '_' + ++i]) {}
		return new Variable(this.base + '_' + i, this.free, this.base, i)
//		while (names[this.base + '_' + ++vcount]) {}
//		return new Variable(this.base + '_' + vcount, this.free, this.base, vcount)
	},
})

function Apply(func, arg) {
	this.func = func
	this.arg = arg
	this.id = entityCounter++
}
Apply.prototype.__proto__ = new Entity({
	equals: function(obj) {return obj instanceof Apply && this.func.equals(obj.func) && this.arg.equals(obj.arg)},
	apply: function(stream, prefix) {
		this.func.apply(stream, prefix)
		stream.push("(")
		this.arg.pass(stream, prefix)
		stream.push(")")
		return stream
	},
	ret: function(stream, prefix) {return this.apply(stream, prefix)},
	pass: function(stream, prefix) {
		stream.push("function(){\nreturn ")
		this.apply(stream, prefix)
		stream.push("\n}")
		return stream
	},
	toString: function() {return "Apply(" + this.func + " " + this.arg + ")"},
	format: function(slash, nosubs, func, arg) {return (arg ? '(' : '') + this.func.format(slash, nosubs, true, false) + ' ' + this.arg.format(slash, nosubs, func, true) + (arg ? ')' : '')},
	propagateTransform: function(transformer) {
		var newFunc = this.func.startTransform(transformer)
		var newArg = this.arg.startTransform(transformer)

		return this.make(newFunc, newArg)
	},
	make: function(newFunc, newArg) {return (newFunc == this.func && newArg == this.arg && this) || new Apply(newFunc, newArg)},
	innermost: function(func) {return this.func.isApply() ? new Apply(this.func.innermost(func), this.arg) : func.call(this)},
	isApply: function() {return true},
	alphaConvert: function() {return this.innermost(function() {return new Apply(this.func, this.arg.uniquify(this.func.names()))})},
	betaReduce: function() {return this.innermost(function() {return this.func.substitute(this.arg)})},
	etaConvert: function() {return this.innermost(function() {return new Apply(this.func.etaConvert(), this.arg)})},
})
function wrap(x) {return function() {return x}}
function show() {document.getElementById("control").setAttribute("class", (showDebug ? "" : "hidedebug ") + (showSubs ? "showsubs" : "shownosubs"))}
function setShowDebug(state) {
	showDebug = state
	show()
}
function setShowSubs(state) {
	showSubs = state
	show()
}
function handleFiles(files) {
	var reader = new FileReader()

	reader.onerror = function(e1, e2, e3, e4) {
		alert('error' + exception.getMessage())
	}
	reader.onload = function() {
		loadDefs(reader.result)
	}
	reader.readAsText(files[0])
}
var Ltrue = lCode('true')
var Lfalse = lCode('false')
var Land = lCode('and')
var Lor = lCode('or')
var Leq = lCode('eq')
var Lxor = lCode('xor')
var Lnot = lCode('not')
var Lpair = lCode('pair')
var Lhead = lCode('head')
var Ltail = lCode('tail')
var Lempty = lCode('empty')
var Lappend = lCode('append')
var Lhead = lCode('head')
var Lisempty = lCode('isempty')
var Ltail = lCode('tail')
</script>
</head>
<body onload="loaded()" style="margin: 0; position: relative; top: 0; bottom: 0; right: 0; left: 0; overflow: auto; border: 0">
	<table style="position: absolute; height: 100%; width: 100%; border: 0" class="hidedebug showsubs" id="control">
		<tr style="height: 0"><td>Load file: <input type="file" id="input" onchange="handleFiles(this.files)"></input></td></tr>
		<tr style="height: auto"><td>
			<div style="position: relative; width: 100%; height: 100%">
				<table style="position: absolute; width: 100%; height: 100%">
					<tr style="height: 0"><td style="width: 50%"><span class='hidden' style="color: red">CURRENT ERROR: reduce on test</span><h2>Definitions (show debug <input type="checkbox" onclick="setShowDebug(this.checked)">, show substitutions <input type="checkbox" onclick="setShowSubs(this.checked)" checked="true">)</h2></td><td style="width: 50%"><h2>Results <button onclick="result.innerHTML = ''">Clear</button></h2></td></tr>
					<tr style="height: auto"><td style="width: 50%"><div style="height: 100%; position: relative; overflow: auto; outline: solid black 1px" id="output"></div></td><td style="width: 50%"><div style="height: 100%; position: relative; overflow: auto; outline: solid black 1px" id="result"></div></td></tr>
				</table>
			</div>
		</td></tr>
		<tr style="height: 0"><td><input id="def" type="text" onchange="input()" style="width: 100%"></input></td></tr>
	</table>
	<pre class="hidden" id="initialDefs">
# Booleans
true = \x y . x
false = \x y . y
not = \b . b false true
and = \a b . a b false
or = \a b . a true b
eq = \a b . a b (not b)
xor = \a b . a (not b) b

#rotation
rot2 = \a b f . f b a
f2 = \a b . a
rot3 = \a b c f . f b c a
r3 = rot3 1 2 3
f3 = \a b c . a
rot4 = \a b c d f . f b c d a
f4 = \a b c d . a

# Y combinator
Y = \g  .  (\x  .  g (x x)) \x  .  g (x x)
rec = \f . f (Y f)

# lists
# using false as "nil" in lists, so you use a list like this:
# DUMMY can be anything, but it needs to be there
# here's how you use a list:
# alist (\h t DUMMY . {list-case}) {empty-case}
# If the list is not empty, h and t are the head and tail of the list and it returns list-case.  DUMMY is not used, but needs to be there
# If the list is empty, it returns empty-case
cons = \a b f.f a b
nil = false
head = \l . l (\h t D . h) nil
tail = \l . l (\h t D . t) nil
null = \l . l (\h t D . false) true
last = rec \last l  . l (\h t D . null t h (last t)) nil
append = rec \append l1 l2 . l1 (\h t D . cons h (append t l2)) l2
reverse = \l . (rec \rev l res . l (\h t D . rev t (cons h res)) res) l nil
# list constructor: list 1 , 2 , 3 end
#list = (rec \list rest item if-continue . if-continue (list (cons item rest)) (reverse (cons item rest))) nil
#, = true
#end = false
[ = \item f  .  f (cons item nil)
, = \l item f . f (cons item l)
] = reverse

# compose = (rec \compose rest func if-continue . if-continue (compose (\x . rest (func x))) \x . rest (func x)) identity

# Random number generator taken from "Xorshift RNGs", by George Marsaglia, Florida State University
# Here's where I found it: http://www.jstatsoft.org/v08/i14/paper
# This works on a list of booleans, using this formula for the next step:
#	x ^= x << a
#	x ^= x >> b
#	x ^= x << c
#
#	Some small numbers that work are: a = 1, b = 7, c = 9
#
# so:	if we say xorF = \x f . lxor x (f x), that's kind of like x ^= f(x)
#	rand = xorF (xorF (xorF x 1rshift) 7lshift) 9rshift

map = rec \map op l . l (\h t D . cons (op h) (map op t)) false
map2 = rec \map2 op l1 l2 . l1 (\h1 t1 D . l2 (\h2 t2 D . cons (op h1 h2) (map2 op t1 t2)) t1) l2
lxor = \l1 l2 . map2 xor l1 l2
1rshift = \l . cons false l
7lshift = \l . tail (tail (tail (tail (tail (tail (tail l))))))
3rshift = \l . cons false (cons false (cons false l))
9rshift = \l . 3rshift (3rshift (3rshift l))
xorF = \x f . lxor x (f x)
rand = \x . xorF (xorF (xorF x 1rshift) 7lshift) 9rshift

l = append ([ 0 ]) ([ 1 , 2 , 3 ])
t = last l
tt = f3 1 2 3
cons1 = \x . cons 1 x
cons2 = \x . cons 2 x
	</pre>
</body>
</html>
