<html>
<!--
Copyright (C) 2011, Bill Burdick, Tiny Concepts: http://tinyconcepts.com/fs.pl/lambda.fsl

(licensed with ZLIB license)

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software
in a product, an acknowledgment in the product documentation would be
appreciated but is not required.

2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.

3. This notice may not be removed or altered from any source distribution.
-->
<head>
<style>
#result div .dollar {
	visibility: hidden;
	display: none;
}
#result :last-child .dollar {
	visibility: inherit;
	display: inherit;
}
.hidden, .hidedebug .debug, .shownosubs .subs, .showsubs .nosubs {
	height: 0;
	width: 0;
	visibility: hidden;
	display: none;
}
</style>
<script src="lc.js"></script>
<script>
var def
var output
var result
var showDebug = false
var showSubs = true
var results = []

function setShowDebug(state) {
	showDebug = state
	show()
}
function setShowSubs(state) {
	showSubs = state
	show()
}
function show() {document.getElementById("control").setAttribute("class", (showDebug ? "" : "hidedebug ") + (showSubs ? "showsubs" : "shownosubs"))}
function handleFiles(files) {
	var reader = new FileReader()

	reader.onerror = function(e1, e2, e3, e4) {
		alert('error' + exception.getMessage())
	}
	reader.onload = function() {
		LC.loadDefs(reader.result)
		displayOutput()
		displayResults()
		result.innerHTML = ''
	}
	reader.readAsText(files[0])
}
function displayOutput() {
	var outputs = []

	for (var index = 0; index < LC.order.length; index++) {
		var expr = LC.order[index]
//		var gl = expr.globalSub()
//		var ac = gl.alphaConvert()
//		var br = ac.betaReduce()
//		var ec = br.etaConvert()

		outputs.push("<div><button onclick='editFunc(\"" + expr.name + "\", \"" + expr.formatSlash(true).replace(/\\/g, '\\\\') + "\")'>Edit</button> <button onclick='runFunc(\"" + index + "\")'>Run</button><button onclick='runReduce(LC.order[" + index + "].expr)'>Reduce</button> <b>" + (expr.name  ? expr.name + ':' : '') + '</b>&nbsp;&nbsp;' + expr.expr.format(false, true)
//			+ "<div class='debug'><ul>"
//			+ "<li><b>Normalized:</b> <span class='subs'>" + expr.normalize() + "</span><span class='nosubs'>" + expr.normalize().expr.format(false, true) + "</span>"
//			+ "<li><b>Alpha conversion:</b> <span class='subs'>" + ac + "</span><span class='nosubs'>" + ac.expr.format(false, true) + "</span>"
//			+ "<li><b>Beta reduction:</b> <span class='subs'>" + br + "</span><span class='nosubs'>" + br.expr.format(false, true) + "</span>"
//			+ "<li><b>Eta conversion:</b> <span class='subs'>" + ec + "</span><span class='nosubs'>" + ec.expr.format(false, true) + "</span>"
//			+ "</ul></div>"
			+ "</div>"
		)
	}
	output.innerHTML = outputs.join('')
	output.lastChild.scrollIntoView()
}
function runFunc(index) {
	LC.runFunc(index)
	displayResults();
}
function resultCode(expr, res, index) {
	var subs = expr.format()
	var nosubs = expr.format(false, true)
	var lam = res.lambda

	if (lam) {
		res = "<span class='subs'>" + LC.pretty(res) + "</span><span class='nosubs'>" + lam.format(false, true) + "</span>" 
	}
	result.innerHTML += "<div><b><span class='dollar'>$: </span>$" + index + ":</b> <button onclick='editResult(\"" + subs.replace(/\\|&lambda;/g, '\\\\') + "\")'>Edit</button><button onclick='runReduce(LC.historyExprs[" + index + "])'>Reduce</button><span class='subs'>" + subs + "</span><span class='nosubs'>" + nosubs + "</span>" + "&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;&nbsp;" + res + "<br><br></div>"
	result.lastChild.scrollIntoView()
}
function formatExpr(label, expr) {
	results.push("<div><b>" + label + ":</b> " + formatSubexpr(expr) + "</div>")
}
function formatSubexpr(expr) {
	return "<span class='subs'>" + expr.pretty() + "</span><span class='nosubs'>" + expr.format(false, true) + "</span>"
}
function runReduce(expr) {
	var last

	formatExpr(" <a style='border: solid black 1px;font-family: monospace' onclick='toggleSteps(this)'>-</a> Reduce", expr, result)
	results.push("<div class='hidden'></div>")
	displayResults()
	last = expr = expr.globalSub()
	var trace = result.lastElementChild
	formatExpr("Globals", expr)
	try {
		var success = LC.reduce(expr,
			function(exp) {formatExpr("Eta", last = exp)},
			function(exp) {formatExpr("Alpha", last = exp)},
			function(exp) {formatExpr("Beta", last = exp)}
		)
		trace.innerHTML += results.join('')
		results = []
		trace.previousElementSibling.innerHTML += "&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;&nbsp;" + (success ? formatSubexpr(last) : '<br><b>...</b>')
	} catch (err) {
		trace.previousElementSibling.innerHTML += "&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;&nbsp;" + '<b>' + err + '</b>'
	}
	results.push("<br>")
	result.lastElementChild.scrollIntoView()
}
function toggleSteps(link) {
	var div = link.parentElement.parentElement.nextElementSibling

	if (div.className) {
		div.className = ''
		link.innerHTML = '+'
	} else {
		div.className = 'hidden'
		link.innerHTML = '-'
	}
}
function loaded() {
	LC.resultCode = resultCode
	def = document.getElementById("def")
	output = document.getElementById("output")
	code = document.getElementById("code")
	result = document.getElementById("result")
	LC.loadDefs(document.getElementById("initialDefs").innerHTML)
	displayOutput()
	displayResults()
	def.select()
}
function displayResults() {
	if (results.length) {
		result.innerHTML += results.join('')
		result.lastChild.scrollIntoView()
		results = []
	}
}
function input() {
	if (LC.evalLine(def.value)) {
		displayOutput()
	}
	displayResults();
	def.value = ''
}
function editFunc(name, expr) {
	def.value = name + ' = ' + expr
	def.select()
}
function editResult(str) {
	def.value = str
	def.select()
}
</script>
</head>
<body onload="loaded()" style="margin: 0; position: relative; top: 0; bottom: 0; right: 0; left: 0; overflow: auto; border: 0">
	<table style="position: absolute; height: 100%; width: 100%; border: 0" class="hidedebug showsubs" id="control">
		<tr style="height: 0"><td>Load file: <input type="file" id="input" onchange="handleFiles(this.files)"></input></td></tr>
		<tr style="height: auto"><td>
			<div style="position: relative; width: 100%; height: 100%">
				<table style="position: absolute; width: 100%; height: 100%">
					<tr style="height: 0"><td style="width: 50%"><span class='hidden' style="color: red">CURRENT ERROR: reduce on test</span><h2>Definitions (show debug <input type="checkbox" onclick="setShowDebug(this.checked)">, show substitutions <input type="checkbox" onclick="setShowSubs(this.checked)" checked="true">)</h2></td><td style="width: 50%"><h2>Results <button onclick="result.innerHTML = '';def.select()">Clear</button></h2></td></tr>
					<tr style="height: auto"><td style="width: 50%"><div style="height: 100%; position: relative; overflow: auto; outline: solid black 1px" id="output"></div></td><td style="width: 50%"><div style="height: 100%; position: relative; overflow: auto; outline: solid black 1px" id="result">
<h1>Lambda Calculus compiler and interpreter</h1>
Copyright (C) 2011, Bill Burdick, Tiny Concepts: <a href='http://tinyconcepts.com/fs.pl/lambda.fsl'>http://tinyconcepts.com/fs.pl/lambda.fsl</a><br>
Licensed with the ZLIB license.  See source code for details.<br>
<br>
Use the text field below to enter Lambda Calculus expressions.  You can use normal Lambda Calculus syntax, with \ meaning &lambda;, but you have to separate your variables with spaces (click edit on any of the definitions for an example)<br>
<br>
You can define terms using NAME = EXPR<br>
<br>
You can modify the parser in these ways:<br>
<ul>
	<li>You can make your definition a token to the parser using <pre>NAME =.= EXPR</pre>this means that you won't need spaces around NAME.  Good for punctuation, etc.
	<li>You can make your definition a grouping token with <pre>NAME =(CLOSE= EXPR</pre> and <pre>CLOSE =)= EXPR</pre> (for the corresponding closing token).
</ul>
I use these in the example definitions to create an array-like syntax for lists: [1,2,3] is the same as saying cons 1 (cons 2 (cons 3 nil)).  The definitions of '[', ',', and ']' are:<pre>[ =(]= \item f  .  f (cons item nil)
, =.= \l item f . f (cons item l)
] =)= reverse
</pre>
<br>
If you want to get rid of this message, you can click "Clear", above.<br>
<br>
<br>
Have fun!<br>
Bill Burdick (you can send me mail at bill dot burdick on gmail)<br>
<br>
<h2>To do</h2>
save button
</div></td></tr></table>
			</div>
		</td></tr>
		<tr style="height: 0"><td><input id="def" type="text" onchange="input()" style="width: 100%"></input></td></tr>
	</table>
	<pre class="hidden" id="initialDefs">
true = \x y . x
false = \x y . y

cons = \a b f . f a b
nil = false
head = \l . l (\h t D . h) nil
tail = \l . l (\h t D . t) nil
null = \l . l (\h t D . false) true
last = rec \last l  . l (\h t D . null t h (last t)) nil
append = rec \append l1 l2 . l1 (\h t D . cons h (append t l2)) l2
reverse = \l . (rec \rev l res . l (\h t D . rev t (cons h res)) res) l nil
# list constructor: list 1 , 2 , 3 end
#list = (rec \list rest item if-continue . if-continue (list (cons item rest)) (reverse (cons item rest))) nil
#, = true
#end = false
[ =(]= \item f  .  f (cons item nil)
, =.= \l item f . f (cons item l)
] =)= reverse

	</pre>
	<pre class="hidden" id="initialDefs2">
# Booleans
true = \x y . x
false = \x y . y
not = \b . b false true
and = \a b . a b a
or = \a b . a a b
eq = \a b . a b (not b)
xor = \a b . a (not b) b

#rotation
rot2 = \a b f . f b a
f2 = \a b . a
rot3 = \a b c f . f b c a
r3 = rot3 1 2 3
f3 = \a b c . a
rot4 = \a b c d f . f b c d a
f4 = \a b c d . a

# Y combinator
Y = \g  .  (\x  .  g (x x)) \x  .  g (x x)
rec = \f . f (Y f)

# lists
# using false as "nil" in lists, so you use a list like this:
# DUMMY can be anything, but it needs to be there
# here's how you use a list:
# aList (\h t DUMMY . {list-case}) {empty-case}
# If the list is not empty, h and t are the head and tail of the list and it returns list-case.  DUMMY is not used, but needs to be there
# If the list is empty, it returns empty-case
cons = \a b f.f a b
nil = false
head = \l . l (\h t D . h) nil
tail = \l . l (\h t D . t) nil
null = \l . l (\h t D . false) true
last = rec \last l  . l (\h t D . null t h (last t)) nil
append = rec \append l1 l2 . l1 (\h t D . cons h (append t l2)) l2
reverse = \l . (rec \rev l res . l (\h t D . rev t (cons h res)) res) l nil
# list constructor: list 1 , 2 , 3 end
#list = (rec \list rest item if-continue . if-continue (list (cons item rest)) (reverse (cons item rest))) nil
#, = true
#end = false
[ =(]= \item f  .  f (cons item nil)
, =.= \l item f . f (cons item l)
] =)= reverse
	</pre>
</body>
</html>
