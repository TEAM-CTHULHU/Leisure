#################
# Utilities
#################

addTokenGroup '[' ']'
addToken '|'

listify list = list
  \h t D . isTokenString h '|'
    cons t nil
    cons (cons 'cons' (cons h (listify t))) nil
  cons 'nil' nil

defMacro '[' \list . list \h t . listify h

listFilter code = bind (getValue 'listMacros')
  \listMacros . filterApplies code \list . list \h t .
    and (isToken h) (contains listMacros (tokenString h))
      listFilterTail list
      list

listFilterTail list = list
  \h t D . isTokenString h '|'
    > (length t) 2
      cons h (cons (removeLast t) (cons (last t) nil))
      list
    cons h (listFilterTail t)
  nil

filterApplies code func = isParens code
  code \start end contents . parens start end (filterApplies contents func)
  isCons code
    \\
      filtered = filterApplyElements code func
      .
      and (isCons filtered) (isBlockStart (head filtered))
        filtered
        func filtered
    code

filterApplyElements code func = code
  \h t D . isBlockStart h
    cons h (filterBody t func)
    cons (filterApplies h func)
      and (isCons t) (isBlockStart (head t))
        cons (filterApplyElements t func) nil
        filterApplyElements t func
  nil

filterBody code func = code \h t . cons h
  isTokenString h '.'
    filterApplies t func
    filterBody t func

setValue 'listMacros' ['[']

addParseFilter listFilter

### Yay!  From here down, we can use list constructors!

addTokenGroup 'or[' ']'

addTokenGroup 'and[' ']'

listMacroFoldOp op emptyCase list = list \h t . foldr
    \case result . [op case result]
    emptyCase
    h

defMacro 'or[' \list . listMacroFoldOp 'or' 'false' list

defMacro 'and[' \list . listMacroFoldOp 'and' 'true' list

infix code = bind (getValue 'infixPrecedence')
  \prec . bind (getValue 'tokenGroups')
    \groups . filterApplies
      code
      \expr . infixRearrange prec (map (\cell . tail cell) groups) expr

infixRearrange prec closes list = \\
  len = length list
  head1 = head list
  tail1 = tail list
  head2 = head tail1
  tail2 = tail tail1
  head3 = head tail2
  opPrec = getPrec prec head2
  .
  < len 2
    list
    isInfix opPrec head1 head2 len
      or (== len 2) (not (isInfixArg closes head3))
        [[head2 head1] | tail2]
        infixRearrange prec closes (absorbArgument opPrec prec closes head1 head2 tail2 head3 (- len 2))
      [head1 | infixRearrange prec closes tail1]

absorbArgument opPrec prec closes head1 head2 tail2 head3 len = \\
  tail3 = tail tail2
  head4 = head tail3
  tail4 = tail tail3
  head5 = head tail4
  .
  infixShouldEatNext opPrec prec head3 head4 head5 closes len
    [head1 head2 | absorbArgument (getPrec prec head4) prec closes head3 head4 tail4 head5 (- len 2)]
    [[head2 head1 head3] | tail3]

isInfixArg closes item = or[
  isParens item
  isCons item
  and[
    isToken item
    not (contains closes (tokenString item))
    not (isBlockStart item)]]

isInfix opPrec head1 head2 len = and[
  > len 1
  > opPrec -1
  isInfixArg nil head1]

getPrec prec token = \\
  str = tokenString token
  .
  isToken token
    findIndex (\level . contains level str) prec
    -1

infixShouldEatNext opPrec prec curArg nextOp nextArg closes len = \\
  nextPrec = getPrec prec nextOp
  .
  and[
    > len 2
    isInfix nextPrec curArg nextOp len
    > opPrec nextPrec
    isInfixArg closes nextArg]

iprec = [['*' '/' '%'] ['+' '-'] ['<' '>' '<=' '>='] ['==' '!=']]

setValue 'infixPrecedence' iprec
defTokenPack 'infix' [(flatten iprec) [] [infix]]

defTokenPack 'list' [
  ['|']
  [['[' | ']'] ['or[' | ']'] ['and[' | ']']]
  [listFilter]]

useTokenPack 'infix'


################
## DO
################

defMacro 'do' \list . handleDo list false id

handleDo list inLet cont = list
  \h t D . isNil t
    cont (inLet ['.' h] [h])
    doClause (stripParens h) h nil inLet \newInLet chain .
      handleDo t newInLet \rest . cont (chain rest)
  cont nil

doClause steppingClause clause prefix inLet cont = \\
  makeBind var monad = cont false \rest . inLet (cons '.') id
    ['bind' monad ['\\' var '.' | rest]]
  .
  steppingClause
    \h t D . isTokenString h '='
      inLet
        cont true \rest . [clause | rest]
        cont true \rest . ['\\\\' clause | rest]
      isTokenString h '<-'
        isNil t
          parseErr "No monad in do-clause: " clause
          prefix
            \ph pt D . isNil pt
              makeBind (isNil prefix '_' (head prefix)) t
              parseErr "More than one variable in do-clause: " clause
            makeBind '_' t
        doClause t clause [h | prefix] inLet cont
    makeBind '_' clause

defTokenPack 'do' [['<-'] [] []]

addStdTokenPacks ['list' 'infix' 'do']
resetStdTokenPacks
