#################
# Utilities
#################

addTokenGroup '[' ']'
addToken '|'

listify list = list
  \h t D . isTokenString h '|'
    cons t nil
    cons (cons 'cons' (cons h (listify t))) nil
  cons 'nil' nil

defMacro '[' \list . list \h t . listify h

listFilter code = bind (getValue 'listMacros')
  \listMacros . filterApplies code \list . list \h t .
    and (isToken h) (contains listMacros (tokenString h))
      listFilterTail list
      list

listFilterTail list = list
  \h t D . isTokenString h '|'
    > (length t) 2
      cons h (cons (removeLast t) (cons (last t) nil))
      list
    cons h (listFilterTail t)
  nil

filterApplies code func = isParens code
  code \start end contents . parens start end (filterApplies contents func)
  isCons code
    \\
      filtered = filterApplyElements code func
      .
      and (isCons filtered) (isBlockStart (head filtered))
        filtered
        func filtered
    code

filterApplyElements code func = code
  \h t D . isBlockStart h
    cons h (filterBody t func)
    cons (filterApplies h func)
      and (isCons t) (isBlockStart (head t))
        cons (filterApplyElements t func) nil
        filterApplyElements t func
  nil

filterBody code func = code \h t . cons h
  isTokenString h '.'
    filterApplies t func
    filterBody t func

setValue 'listMacros' ['[']

addParseFilter listFilter

defTokenPack 'list' [
  ['|' '='] #adding = here so so we don't need spaces around = in definitions
  [['[' | ']'] ['or[' | ']'] ['and[' | ']'] ['concat[' | ']']]
  [listFilter]]

### Yay!  From here down, we can use list constructors!

addTokenGroup 'or[' ']'

addTokenGroup 'and[' ']'

addTokenGroup 'concat[' ']'

listMacroFoldOp op emptyCase list = list \h t . foldr
    \case result . [op case result]
    emptyCase
    h

defMacro 'or[' \list . listMacroFoldOp 'or' 'false' list

defMacro 'and[' \list . listMacroFoldOp 'and' 'true' list

defMacro 'concat[' \list . ['strCat' (listify (head list))]

infix code = bind (getValue 'infixPrecedence')
  \prec . bind (getValue 'infixRightAssociative')
    \right . bind (getValue 'tokenGroups')
      \groups . filterApplies
        code
        \expr . infixRearrange prec right (map (\cell . tail cell) groups) expr

infixRearrange prec right closes list = \\
  len = length list
  head1 = head list
  tail1 = tail list
  head2 = head tail1
  tail2 = tail tail1
  head3 = head tail2
  opPrec = getPrec prec head2
  .
  < len 2
    list
    isInfix opPrec head1 head2 len
      or (== len 2) (not (isInfixArg closes head3))
        [[head2 head1] | tail2]
        infixRearrange prec right closes (absorbArgument opPrec prec right closes head1 head2 tail2 head3 (- len 2))
      [head1 | infixRearrange prec right closes tail1]

absorbArgument opPrec prec right closes head1 head2 tail2 head3 len = \\
  tail3 = tail tail2
  head4 = head tail3
  tail4 = tail tail3
  head5 = head tail4
  .
  infixShouldEatNext opPrec prec (contains right (strTokenString head2)) head3 head4 head5 closes len
    [head1 head2 | absorbArgument (getPrec prec head4) prec right closes head3 head4 tail4 head5 (- len 2)]
    [[head2 head1 head3] | tail3]

isInfixArg closes item = or[
  isParens item
  isCons item
  and[
    isToken item
    not (contains closes (tokenString item))
    not (isBlockStart item)]]

isInfix opPrec head1 head2 len = and[
  > len 1
  > opPrec -1
  isInfixArg nil head1]

getPrec prec token = \\
  str = tokenString token
  .
  isToken token
    findIndex (\level . contains level str) prec
    -1

infixShouldEatNext opPrec prec isRight curArg nextOp nextArg closes len = \\
  nextPrec = getPrec prec nextOp
  .
  and[
    > len 2
    isInfix nextPrec curArg nextOp len
    or (> opPrec nextPrec) (and (== opPrec nextPrec) isRight)
    isInfixArg closes nextArg]

: x y = cons x y

iprec = [['*' '/' '%'] ['+' '-'] [':'] ['<' '>' '<=' '>='] ['==' '!=']]
rightAssoc = [':']

setValue 'infixPrecedence' iprec
setValue 'infixRightAssociative' rightAssoc
defTokenPack 'infix' [(flatten iprec) [] [infix]]

useTokenPack 'infix'


################
## DO
################

defMacro 'do' \list . handleDo list false id

handleDo list inLet cont = list
  \h t D . isNil t
    cont (inLet ['.' h] [h])
    doClause (stripParens h) h nil inLet \newInLet chain .
      handleDo t newInLet \rest . cont (chain rest)
  cont nil

doClause steppingClause clause prefix inLet cont = \\
  makeBind var monad = cont false \rest . inLet (cons '.') id
    ['bind' monad ['\\' var '.' | rest]]
  .
  isCons steppingClause
    steppingClause \h t . isTokenString h '='
      inLet
        cont true \rest . [clause | rest]
        cont true \rest . ['\\\\' clause | rest]
      isTokenString h '<-'
        isNil t
          parseErr "No monad in do-clause: " clause
          prefix
            \ph pt D . isNil pt
              makeBind (isNil prefix '_' (head prefix)) t
              parseErr "More than one variable in do-clause: " clause
            makeBind '_' t
        doClause t clause [h | prefix] inLet cont
    makeBind '_' clause

defTokenPack 'do' [['<-'] [] []]

addStdTokenPacks ['list' 'infix' 'do']
resetStdTokenPacks
