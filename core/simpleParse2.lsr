#################
# Utilities
#################

addTokenGroup '[' ']'
addToken '|'

listify list = list \h t . isNil t
  cons 'nil' nil
  isTokenString h '|'
    removeLast t
    cons (cons 'cons' (cons h (listify t))) nil

defMacro '[' listify

listFilter code = bind (getValue 'listMacros')
  \listMacros . filterApplies code \list . list \h t .
    and (isToken h) (contains listMacros (tokenString h))
      listFilterTail list
      list

listFilterTail list = list
  \h t D . isTokenString h '|'
    > (length t) 2
      cons h (cons (removeLast t) (cons (last t) nil))
      list
    cons h (listFilterTail t)
  nil

bodyStarts = cons '\\' (cons '\\@' (cons '\\\\' nil))

isBodyStart tok = and
  isToken tok
  contains bodyStarts (tokenString tok)

filterApplies code func = isParens code
  code \start end contents . parens start end (filterApplies contents func)
  isCons code
    \\
      filtered = filterApplyElements code func
      .
      and (isCons filtered) (isBodyStart (head filtered))
        filtered
        func filtered
    code

filterApplyElements code func = code
  \h t D . isBodyStart h
    cons h (filterBody t func)
    cons (filterApplies h func)
      and (isCons t) (isBodyStart (head t))
        cons (filterApplyElements t func) nil
        filterApplyElements t func
  nil

filterBody code func = code \h t . cons h
  isTokenString h '.'
    filterApplies t func
    filterBody t func

setValue 'listMacros' ['[']

addParseFilter listFilter

## Yay!  From here down, we can use list constructors!

addTokenGroup 'or[' ']'

addTokenGroup 'and[' ']'

listMacroFoldOp op list = foldr1
  \result case . [op result case]
  removeLast list

defMacro 'or[' \list . listMacroFoldOp 'or' list

defMacro 'and[' \list . listMacroFoldOp 'and' list

infix code = bind (getValue 'infixPrecedence')
  \prec . bind (getValue 'tokenGroups')
    \groups . filterApplies
      code
      \expr . infixRearrange prec (map (\cell . tail cell) groups) expr

infixRearrange prec closes list = \\
  len = length list
  head1 = head list
  tail1 = tail list
  head2 = head tail1
  tail2 = tail tail1
  head3 = head tail2
  opPrec = getPrec prec head2
  .
  < len 2
    list
    isInfix opPrec head1 head2 len
      or (== len 2) (not (isInfixArg closes head3))
        [[head2 head1] | tail2]
        infixRearrange prec closes (absorbArgument opPrec prec closes head1 head2 tail2 head3 (- len 2))
      [head1 | infixRearrange prec closes tail1]

absorbArgument opPrec prec closes head1 head2 tail2 head3 len = \\
  tail3 = tail tail2
  head4 = head tail3
  tail4 = tail tail3
  head5 = head tail4
  .
  infixShouldEatNext opPrec prec head3 head4 head5 closes len
    [head1 head2 | absorbArgument (getPrec prec head4) prec closes head3 head4 tail4 head5 (- len 2)]
    [[head2 head1 head3] | tail3]

isInfixArg closes item = or[
  isParens item
  isCons item
  and[
    isToken item
    not (contains closes (tokenString item))
    not (contains bodyStarts (tokenString item))]]

isInfix opPrec head1 head2 len = and[
  > len 1
  > opPrec -1
  isInfixArg nil head1]

getPrec prec token = \\
  str = tokenString token
  .
  isToken token
    findIndex (\level . contains level str) prec
    -1

infixShouldEatNext opPrec prec curArg nextOp nextArg closes len = \\
  nextPrec = getPrec prec nextOp
  .
  and[
    > len 2
    isInfix nextPrec curArg nextOp len
    > opPrec nextPrec
    isInfixArg closes nextArg]

iprec = [['*' '/' '%'] ['+' '-'] ['<' '>' '<=' '>='] ['==' '!=']]

setValue 'infixPrecedence' iprec
defTokenPack 'infix' [(flatten iprec) [] [infix]]

defTokenPack 'list' [
  ['|']
  [['[' | ']'] ['or[' | ']'] ['and[' | ']']]
  [listFilter]]

addStdTokenPacks ['list' 'infix']

resetStdTokenPacks
