#################
# Utilities
#################

addTokenGroup '[' ']'
addToken '|'

listify list = list \h t . isNil t
  cons 'nil' nil
  isTokenString h '|'
    removeLast t
    cons (cons 'cons' (cons h (listify t))) nil

defMacro '[' listify

listFilter code = bind (getValue 'listMacros')
  \listMacros . filterApplies code \list . list \h t .
    and (isToken h) (contains listMacros (tokenString h))
      listFilterTail list
      list

listFilterTail list = list
  \h t D . isTokenString h '|'
    > (length t) 2
      cons h (cons (removeLast t) (cons (last t) nil))
      list
    cons h (listFilterTail t)
  nil

bodyStarts = cons '\\' (cons '\\@' (cons '\\\\' nil))

isBodyStart tok = and
  isToken tok
  contains bodyStarts (tokenString tok)

filterApplies code func = isParens code
  code \start end contents . parens start end (filterApplies contents func)
  isCons code
    \\
      filtered = filterApplyElements code func
      .
      and (isCons filtered) (isBodyStart (head filtered))
        filtered
        postProcessMacro -1 -1 (func filtered)
    code

filterApplyElements code func = code
  \h t D . isBodyStart h
    cons h (filterBody t func)
    cons (filterApplies h func) (filterApplyElements t func)
  nil

filterBody code func = code \h t . cons h
  isTokenString h '.'
    filterApplies t func
    filterBody t func

setValue 'listMacros' ['[']

addParseFilter listFilter

## Yay!  From here down, we can use list constructors!

addTokenGroup 'or[' ']'

addTokenGroup 'and[' ']'

listMacroFoldOp op list = foldr1
  \result case . [op result case]
  removeLast list

defMacro 'or[' \list . listMacroFoldOp 'or' list

defMacro 'and[' \list . listMacroFoldOp 'and' list

infix code = bind (getValue 'infixPrecedence')
  \prec . bind (getValue 'tokenGroups')
    \groups . filterApplies
      code
      \expr . infixRearrange prec (map (\cell . tail cell) groups) expr (length expr)

isInfix prec head1 head2 = and[
  not (isBodyStart head1)
  isToken head2
  contains prec (tokenString head2)]

infixRearrange prec closes list length = < length 2
  log "X" list
  \\
    head1 = head list
    tail1 = tail list
    head2 = head tail1
    tail2 = tail tail1
    head3 = head tail2
    tail3 = tail tail2
    head4 = head tail3
    opPrec = index prec (tokenString head2)
    .
    isInfix prec head1 head2
      or (== length 2) (contains closes head3) ## partial application
        log "0" [[head2 head1] | tail2]
        higherPrec opPrec prec head4 length
          log "1" infixRearrange prec closes [[head2 head1 head3] | tail3] (- length 2)
          \\
            rearrangedArg = infixRearrange prec closes tail2 (- length 2)
            .
            log "2" [[head2 head1 (head rearrangedArg)] | (tail rearrangedArg)]
      d "3: " head1 [head1 | (infixRearrange prec closes tail1 (- length 1))]

higherPrec opPrec prec nextOp length = and[
  > length 3
  > (index prec nextOp) opPrec]

setValue 'infixPrecedence' nil

#testInfix line = bind (setValue 'infixPrecedence' ['+' '-' '*' '/'])
#  \_ . bind (scanLineM line)
#    \code . infix code

#defTokenPack 'infix' [['+' '-' '*' '/'] [] [infix]]

defTokenPack 'list' [
  ['|']
  [['[' | ']'] ['or[' | ']'] ['and[' | ']']]
  [listFilter]]
resetTokenPacks ['std' 'list']
#resetTokenPacks ['std' 'list' 'infix']
