Notes on New Leisure Core


Motivation

The fundamental motivation of the new core is to reduce the amount of low-level code and simplify it, so it's easier to provide alternate backends and make improvements at the lowest level.  The new core doesn't parse Leisure, it operates directly on ASTs and JSON-encoded ASTs.  This allows Leisure itself to implement the parsing.  Leisure can send ASTs directly to the core or generate low-level, JSON-encoded *.last files which the core can understand.


The Let AST structure

Let values can refer to all of the names defined by the let structure.  This allows for mutual recursion without polluting the name space.  It also allows do/let to do what programmers might expect when they define terms that reference each other.


The Anno AST structure

Lets programmers associate runtime-accessible key-value pairs with code.  The system will use standard keys for things like definitions and patterns, which are kind of outside the scope of Lambda Calculus, anyway.


Patterm matching

length list = match list
  [] -> 0
  [a | b] -> 1 + length b
  false

translates to

length list =
  eq (getType list) 'nil'
    0
    eq (getType list) 'cons'
      list (\a b . 1 + length b) false


Dispatchers for simple pattern matching

For lets that dispatch on types, we can use "dispatchers" which use double dispatching to resolve inheritance in constant time.  Here's an example:

getLabel x = do
  label x::person = 'person'
  label x::animal = 'animal'
  label x::thing = 'other'
  label x

Using this hierarchy: thing(animal(cat,dog),person,vehicle(car)), a dispatcher could work roughly like this (dispatcher's are generated on demand at compile time)

getLabel = (function() {
  // create reusable dispatcher here
  var disp = newDispatcher({
    Leisure_person: function() {return function(x){return 'person'}},
    Leisure_animal: function() {return function(x){return 'animal'}},
    Leisure_thing: function() {function(x){return 'thing'}},
  })
  // definition that uses the dispatcher
  function(x){return disp.dispatch(x)(x)}
})()


When new types are added, it can invalidate the dispatch cache by incrementing a dispatchCacheCount variable.  The dispatch function can check this to see if it needs to recompute the dispatch methods.  The computed dispatcher would be something like this:

{
  Leisure_cat: function() {return this.Leisure_animal()},
  Leisure_dog: function() {return this.Leisure_animal()},
  Leisure_vehicle: function() {return this.Leisure_thing()},
  Leisure_car: function() {return this.Leisure_thing()}
}

Multiple dispatch could create a dispatchers that return other dispatchers.
