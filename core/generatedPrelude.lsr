############
# LOGIC
############

true = \a b . a
false = \a b . b
not b = b false true
and a b = a b false
or a b = a true b
some x = \someCase noneCase . someCase x
some2 a b = \someCase noneCase . someCase a b
none = \someCase noneCase . noneCase
neq a b = not (eq a b)
left x = \lCase rCase . lCase x
right x = \lCase rCase . rCase x

############
# FUNCTIONS
############
id x = x
compose f g = \x . f (g x)

# make a new function that takes two args in opposite order than the original function
# eq. flip cons nil 1 gives cons: [1]
flip func = \x y . func y x

# The Y combinator, for reference
#
# Y = \g  .  (\x  .  g (x x)) \x  .  g (x x)
# rec = \f . f (Y f)

##############
# CONS LISTS
##############

cons a b = \f . f a b
isCons c = hasType c cons
# nil is the same as false, but it's useful separate as a marker
nil = \a b . b
isNil n = hasType n nil
head l = l \h t . h
tail l = l \h t . t
last l = isCons l
  l \h t . isCons t (last t) h
  nil
removeLast l = isCons l
  l \h t . isCons t (cons h (removeLast t)) nil
  nil
length list = list
  \h t D . + 1 (length t)
  0
append a b = a (\h t D . cons h (append t b)) b
flatten list = isCons list
  subflatten list nil
  list
subflatten list result = isNil list
  result
  isCons list
    list \h t . subflatten h (subflatten t result)
    cons list result
reverse l = rev l nil
rev l result = l (\h t D . rev t (cons h result)) result
filter func list = list (\h t D . func h (cons h) id (filter func t)) nil
find predicate list = list (\h t D . predicate h (some h) (find predicate t)) none
contains list item = find (\el . eq el item) list (\x . true) false

# make a new list by applying func (which takes exactly 1 arg) to each element of list
# eg. map (+ 1) [4 27 54] gives cons: [5 28 55]
map func l = l (\h t D . cons (func h) (map func t)) nil

# map, but preserve the old list where possible, so that == works on it
mapSave func l = l
  \h t D . \\
    newH = func h
    newT = mapSave func t
    .
    and (eq newH h) (eq newT t)
      l
      cons newH newT
  nil

# foldl (\prev el . ...) list
# foldr (\el prev . ...) list
# call func on list items and previous result of fold
# foldl uses the head of the list for the previous results
# foldr uses the tail of the list for the previous results
# foldr can work on infinite lists, but foldl cannot
foldl func initialValue l = l (\h t D . foldl func (func initialValue h) t) initialValue
foldl1 func l = l \h t . foldl func h t
foldr func initialValue list = list
  \h t D . func h (foldr func initialValue t)
  initialValue
foldr1 func list = list \h t . isNil t
  h
  func h (foldr1 func t)

intersperse list element = list (\h t D .
  isNil t
    list
    cons h (cons element (intersperse t element))) nil

join list el = strCat (intersperse list el)
findIndex func list = idx list func 0
idx list func pos = list
  \h t D . func h
    pos
    idx t func (+ 1 pos)
  -1
index list el = find (\item . == el item) list

############
# ASSOC LISTS
############
acons k v alist = cons (cons k v) alist
assoc k alist  = find (\el . eq k (head el)) alist (\cell . cell \head tail . some tail) none
rassoc v alist = find (\el . eq v (tail el)) alist (\cell . cell \head tail . some head) none

############
# SORTING
############
quicksort less list = (qs less list) nil
# qs is written using a difference list so it can append in linear time
# sortedFunc must return whether the two args are in sorted order
# \rest . (qs ... makes a difference list.  id is the empty difference list.
qs sortedFunc list = list
  \h t D . \\
    greater = filter (sortedFunc h) t
    lesser = filter (compose not (sortedFunc h)) t
    .
    \rest . (qs sortedFunc lesser) (cons h ((qs sortedFunc greater) rest))
  id
insertSorted sortFunc item list = list
  \h t D . sortFunc item h (cons item list) (cons h (insertSorted sortFunc item t))
  cons item nil

############
# TOKENS
############

token txt pos = \f . f txt pos
tokenString tok = tok \t p . t
tokenPos tok = tok \t p . p
isToken t = hasType t token

parens start end content = \f . f start end content
parensStart p = p \s e c . s
parensEnd p = p \s e c . e
parensContent p = p \s e c . c
isParens p = hasType p parens
makeParens start end content =
  and (isCons content) (isNil (tail content))
    makeParens start end (head content)
    or (isToken content) (isParens content)
      content
      parens start end content
parensFromToks left right content = \\
  start = tokenPos left
  end = + (tokenPos right) (strLen (tokenString right))
  .
  parens start end content
stripParens p = isParens p (parensContent p) p

parseErr msg1 msg2 = \f . f (strCat (cons msg1 (cons msg2 nil)))
parseErrMsg err = err \m . m
isParseErr thing = hasType thing parseErr

emptyToken = regexp '^\\n[ \\i]*(#|$)'

makeTokens strings start = strings (\h t D . makeMoreTokens h t start) nil
makeMoreTokens h t start = \\
  next = makeTokens t (+ start (strLen h))
  .
  and (strMatches h emptyToken) (or (isNil t) (strStartsWith (head t) '\n'))
    makeTokens t (+ start (strLen h))
    or (strStartsWith h ' ') (strStartsWith h '#')
      next
      and (strStartsWith h '\n') (strStartsWith (head t) '#')
        makeTokens (tail t) (+ start (+ (strLen h) (strLen (head t))))
        cons (token h start) next

splitTokens str pat = filter (\s . not (eq s '')) (basicSplitTokens str pat true)

numberPat = regexp '-?([0-9]+(\\.[0-9]+)?|\\.[0-9]+)'

matchOffset str match = isNil match
  strLen str
  head (tail (tail match))

basicSplitTokens str pat prevIsDel = == str ''
  nil
  \\
    num = strMatch str numberPat
    del = strMatch str pat
    numOffset = matchOffset str num
    delOffset = matchOffset str del
    select = and (== numOffset 0) prevIsDel
      \del num first . num
      == delOffset 0
        \del num first . del
        \del num first . first
    first = select (head del) (head num) (strSubstring str 0 delOffset)
    .
    cons
      first
      basicSplitTokens
        strSubstring str (strLen first) 0
        pat
        select true false false

tokens str pat = makeTokens (splitTokens str pat) 0

#############
## Parsing
#############

isString s = == (getType s) '*string'
isTokenString tok str = or
  and (isToken tok) (eq (tokenString tok) str)
  and (isString tok) (eq tok str)
isTokenStart tok str = or
  and (isToken tok) (strStartsWith (tokenString tok) str)
  and (isString tok) (strStartsWith tok str)
strTokenString tok = withToken tok nil \str pos . str
withToken tok nonTokCase tokCase = isToken tok
  tok tokCase
  isString tok
    tokCase tok -1
    nonTokCase

## withCons is like a safe version of a cons
withCons l nilCase cont = isCons l (l (\h t D . cont h t) nilCase) nilCase

ifNotErr thing cont = hasType thing parseErr thing (cont thing)

parseToks toks groups =
  isNil toks nil
    ifNotErr (parseTok toks groups) \list . list \h t .
      ifNotErr (parseToks t groups) \res .
        cons h
          and (isCons res) (isBlockStart (head res))
            cons res nil
            res

parseTok toks groups = withCons toks nil \h t .
  withToken h toks \txt pos .
    assoc txt groups
      \close . parseGroup h t nil close groups
      isTokenStart h '\n' (parseIndent h t nil groups)
        toks

parseGroup left toks gr close groups = withCons toks (parseErr 'Unterminated group starting ' (loc left))
  \h t . isTokenString h close
    eq close ')'
      cons (parensFromToks left h (reverse gr)) t
      cons (cons left (cons (reverse gr) (cons h nil))) t
    withToken h
      ifNotErr (parseTok toks groups) \list . list \restH restT .
        parseGroup left restT (cons restH gr) close groups
      \txt pos .
        rassoc txt groups
          \open . parseErr (strCat (cons 'Mismatched group: ' (cons (tokenString left) (cons txt (cons ' ' nil))))) (loc left)
          ifNotErr (parseTok toks groups) \list . list \restH restT . parseGroup left restT (cons restH gr) close groups

parseIndent indent toks gr groups =
  withCons toks (cons (makeParens (tokenPos indent) (lexEnd (head gr)) (reverse gr)) nil)
    \h t . or (withToken h false (\txt pos . rassoc txt groups (\open . true) false))
      and (isTokenStart h '\n') (<= (strLen (tokenString h)) (strLen (tokenString indent)))
      cons (makeParens (tokenPos indent) (tokenPos h) (reverse gr)) toks
      ifNotErr (parseTok toks groups) \list . list \restH restT . parseIndent indent restT (cons restH gr) groups

#################
## Creating ASTs
#################

lit value = \f . f value
ref name = \f . f name
lambda name body = \f . f name body
apply func arg = \f . f func arg
let name value body = \f . f name value body
anno name data body = \f . f name data body

withParens p err cont = isParens p (p cont) err
setParens p func = isParens p
  p \start end content . parens start end (func content)
  func p

withStripped list cont = withParens list (cont list) \start end content . withStripped content cont

position thing = isToken thing (tokenPos thing)
  isParens thing (parensStart thing)
    isCons thing (position (head thing))
      -1

lexEnd thing = isToken thing (+ (tokenPos thing) (strLen (tokenString thing)))
  isParens thing (parensEnd thing)
    isCons thing (lexEnd (last thing))
      -1

loc thing = \\
  p = position thing
  l = eq p -1 'an unknown location' p
  .
  strCat (cons 'at ' (cons l nil))

scrub str = strFromList (scrubList (strToList str))

scrubList list = list
  \h t D . \\
    next = scrubList t
    .
    eq h '\\' (cons h (cons (head t) (scrubList (tail t))))
      eq h '\"' (cons '\\' (cons '\"' next))
        cons h next
  nil

createAst inList names cont = withStripped inList \list .
  isToken list (createLitOrRef (tokenString list) names cont)
    list
      \h t D .
        isTokenString h '\\\\' (createLet h t names cont)
          isTokenString h '\\@' (createAnno h t names cont)
            isTokenString h '\\' (createLambda h t names cont)
              createApply list names cont
      cont nil

strMatches str pat = isCons (strMatch str pat)

digit = regexp '^[0-9]+$'

backslashCodes = 'bfnrt'

backslashValues = '\b\f\n\r\t'

convertStringEscape char codes values =
  eq codes ''
    char
    eq char (strAt codes 0)
      strAt values 0
      convertStringEscape char (strSubstring codes 1 0) (strSubstring values 1 0)

convertStringEscapes orig str cont =
  eq str ''
    cont str
    eq (strAt str 0) '\\'
      eq (strLen str) 1 (parseErr "Error, backslash without character in string: " orig)
        convertStringEscapes orig (strSubstring str 2 0) \rest . cont
          strAdd
            convertStringEscape (strAt str 1) backslashCodes backslashValues
            rest
      convertStringEscapes orig (strSubstring str 1 0) \rest . cont
        strAdd
          strAt str 0
          rest

parseString str cont =
  neq (strAt str 0) (strAt str -1) (parseErr "Badly terminated string: " str)
    convertStringEscapes str (strSubstring str 1 -1) cont

createLitOrRef tok names cont =
  contains names tok
    cont (ref tok)
    or (strStartsWith tok '\"') (strStartsWith tok "'")
      parseString tok \str . cont (lit str)
      strStartsWith tok '.'
        jsonParse (strCat (cons '0' (cons tok nil))) (\err . cont (ref tok)) (\item . cont (lit item))
        or (and (>= (strAt tok 0) '0') (<= (strAt tok 0) '9')) (strStartsWith tok '-')
          jsonParse tok (\err . cont (ref tok)) (\item . cont (lit item))
          cont (ref tok)

createLambda start list names cont = \\
  err = parseErr "Lambda needs a variable name, a dot, and a body " (loc start)
  .
  withCons list err \name rest .
    withToken name err \n p .
      withCons rest err \dot body .
        # are these partial applications too hard to read?
        isTokenString dot '.' (createAst body) (createLambda start rest)
          cons n names
          \bodyAst . cont (lambda n bodyAst)

createAnno start list names cont =
  withCons list (parseErr "No annotation name or data in annotation " (loc start)) \name rest .
    withCons rest (parseErr "No data for annotation " (loc start)) \data rest . \\
      finish data body = createAst body names \bodyAst .
        cleanTokens start name \name .
          cleanTokens start data \data .
            cont (anno name data bodyAst)
      .
      isTokenString data '.'
        finish nil rest
        withStripped data \data .
          withCons rest (parseErr "No body for annotation " (loc start)) \dot body .
            isTokenString dot '.'
              finish data body
              parseErr "Annotation expects dot after name and data " (loc start)

bodyStructPat = regexp '\\|\\\\|\\@'

createApply inList names cont = withStripped inList \list .
  withCons list (parseErr "Funcion apply expecting a non-empty list " (loc inList)) \h t .
    createAst h names \func . chainApply func t names cont

blockStarts = cons '\\' (cons '\\\\' (cons '\\@' nil))

chainApply func list names cont = withCons list (cont func) \argItem rest .
  and (isToken argItem) (contains blockStarts (tokenString argItem))
    createAst list names \arg . cont (apply func arg)
    createAst argItem names \arg . chainApply (apply func arg) rest names cont

cleanTokens start toks cont = isToken toks
  cont (tokenString toks)
  withCons toks (cont toks) \head tail .
    cleanTokens start head \head .
      cleanTokens start tail \tail .
        cont (cons head tail)

createLet start list names cont = withCons list
  parseErr "No variable or body for let " (loc start)
  \binding body . eq body nil (createAst binding name cont)
    getLetNames start list names \newNames .
      createSublets start binding body newNames cont

getLetNames start list names cont = \\
  err = parseErr "Let expected binding " (loc start)
  .
  withCons list (cont names) \binding body .
    isTokenString binding '.' (cont names)
      withParens binding err \start end def .
        withCons def err \name rest .
          withToken name err \str pos .
            getLetNames start body (cons str names) cont

createSublets start binding body names cont =
  isTokenString binding '.' (createAst body names cont)
    withCons body (parseErr "Let expected a body " (loc start)) \bodyH bodyT .
      getNameAndDef (parensStart binding) (parensContent binding) names \name def .
        createSublets start bodyH bodyT names \bodyAst .
          cont (let (tokenString name) def bodyAst)

getNameAndDef pos binding names cont =
  withCons (tail binding) (parseErr "Let expected binding at " pos) \snd sndT .
    isTokenString snd '=' (createAst sndT names \def . cont (head binding) def)
      getLetLambda pos (tail binding) nil names \lamb . cont (head binding) lamb

getLetLambda pos def args names cont =
  withCons def (parseErr "Let expected binding at " pos) \arg rest .
    not (isToken arg) (parseErr "Let expected binding at " pos)
      isTokenString arg '='
        createAst (cons (token '\\' pos) (append (reverse args) (cons (token '.' (position arg)) rest))) names cont
        getLetLambda pos rest (cons arg args) names cont

#################
## Compiling
#################

parenGroups = cons (cons '(' ')') nil

scanLineG str pat groups onDef onExpr = \\
  toks = tokens str pat
  groupToks = foldr (\el value . el \h t . cons h (cons t value)) (cons '=' blockStarts) groups
  .
  # check if it's a definition
  find (\tok . or (contains groupToks (tokenString tok)) (isCons (strMatch (tokenString tok) '^\n'))) toks (\item . isTokenString item '=') false
    toks \name rest . \\
      parseIt func = \\
        parsed = parseToks (checkSetDataType func rest name) groups
        .
        onDef (ifNotErr parsed \list . createDef list name (arity rest 0) str)
      .
      isTokenString (head rest) '='
        isTokenString (head (tail rest)) '\\'
          parseIt (setTypeAnno (tail rest) (tokenString name))
          parseIt (tail rest)
        transformDef name rest \def .
          parseIt (cons (token '\\' (- (position (head rest)) 1)) def)
    ifNotErr (parseToks toks groups) \list . onExpr list

parseLineG str pat names groups onDef onExpr = \\
  astCallback cb = \list . createAst list names \ast . cb ast
  .
  scanLineG str pat groups (astCallback onDef) (astCallback onExpr)

transformDef name toks cont = withCons toks (parseErr "Bad definition, expecting tokens" (loc name)) \h t .
  isTokenString h '='
    isTokenString (head t) '\\'
      cont (cons (token '.' (position h)) (setTypeAnno t (tokenString name)))
      cont (cons (token '.' (position h)) t)
    transformDef name t \list . cont (cons h list)

setTypeAnno toks name = \\
  tok = \str . token str (position toks)
  .
  cons (tok '\\@') (cons (tok 'type') (cons (tok name) (cons (tok '.') toks)))

setDataTypeAnno toks name = \\
  tok = \str . token str (position toks)
  .
  cons (tok '\\@') (cons (tok 'dataType') (cons (tok (tokenString name)) (cons (tok '.') toks)))

createDef def name arity src = \\
  tok str = token str (position def)
  .
  jsonStringify (tokenString name) (\err . parseErr (strCat (cons "Bad function name " (cons (loc name) nil))) err) \nameStr .
    jsonStringify src (\err . parseErr (strCat (cons "Bad source " (cons (loc name) nil))) err) \srcStr .
      #cons (tok 'define') (cons (tok nameStr) (cons (tok (strString arity)) (cons (tok srcStr) (cons def nil))))
      cons (tok '\\@') (cons (cons (tok 'definition') (cons (tok name) nil)) (cons (tok '.') (cons (tok 'define') (cons (tok nameStr) (cons (tok (strString arity)) (cons (tok srcStr) (cons def nil)))))))

checkSetDataType toks curToks name = withCons curToks toks \h t .
  isTokenString h '='
    isTokenString (head t) '\\'
      setDataTypeAnno toks name
      toks
    checkSetDataType toks t name

arity toks n = isTokenString (head toks) '=' n (arity (tail toks) (+ n 1))

tokListStr toks = jsonStringify (join (map (\t . tokenString t) toks) ' ')

linePat = regexp '\\r?\\n(?=[^ ]|$)'

emptyLinePat = regexp '(^[ \\i]*\\#.*|^[ \\i]*$|^\\r?\\n[ \\i]*$)'

lineScrub = regexpFlags '\\r\\n' 'g'

linesForFile text = filter
  \line . isNil (strMatch line emptyLinePat)
  strSplit (strReplace text lineScrub '\n') linePat

defPat = regexp '^[^ =]+.* =( |$)'

namesForLines lines = foldl
  \result line . \\
    m = strMatch line defPat
    .
    isNil m result (cons (head (tail m)) result)
  nil
  lines

#################
## Macro system
#################

# what about alpha substitution to make the result hygenic?
# make some let-style macros that use gensyms?

runParseFilters filters line = filters
  \h t D . bind (h line) \filtered . runParseFilters t filtered
  line

isBlockStart tok = and
  isToken tok
  contains blockStarts (tokenString tok)

# macs is an assoc-list (list of (name . definition))
# expr is the tail of the macro expression
macroSub macs expr = postProcessMacro -1 -1 (baseMacroSub macs expr)

consifyMacroValue value = isCons value value (cons value nil)

baseMacroSub macs expr = isToken expr
  expr
  isParens expr
    expr \start end content . \\
      result = baseMacroSub macs content
      .
      isToken result result (parens start end result)
    withCons expr expr \h t .
      isBlockStart h
        cons h
          isTokenString h '\\\\'
            macroSubLet macs t
            macroSubBody '.' macs t
        withToken h
          \\
            subH = baseMacroSub macs h
            .
            withToken subH
              cons subH (map (baseMacroSub macs) t)
              \tok pos . baseMacroSub macs (cons subH t)
          \tok pos . assoc tok macs
            \def . baseMacroSub macs (def t)
            cons h (map (baseMacroSub macs) t)

macroSubLet macs list = list
  \h t D . isTokenString h '.'
    cons h (baseMacroSub macs t)
    cons (setParens h \content . macroSubBody '=' macs content) (macroSubLet macs t)
  # Don't bother with parse errors at this point -- ast generator will detect them
  nil

macroSubBody char macs list = list
  \h t D . cons h
    isTokenString h char baseMacroSub (macroSubBody char)
      macs
      t
  nil

postProcessMacro before after expr = isString expr
  token expr (eq after -1 before after)
  isParens expr
    expr \start end contents . parens start end (postProcessMacro start end contents)
    isCons expr
      expr \h t .
        isToken h
          cons h (postProcessMacro (+ 1 (+ (tokenPos h) (strLen (tokenString h)))) -1 t)
          \\
            posStart = position h
            posEnd = position t
            t2 = postProcessMacro -1 after t
            h2 = postProcessMacro before -1 h
            .
            eq posStart -1
              cons (postProcessMacro before (position t2) h) t2
              cons h2 (postProcessMacro (+ 1 (lexEnd h2)) after t)
      expr

defMacro name def = bind (getValue 'macroDefs') \macs . setValue 'macroDefs' (acons name def macs)

#################
# Token Patterns
#################

delimiterListPrefix = "\"(?:\\\\.|[^\"])*\"|'(?:\\\\.|[^'])*'|\\n *|#.*| +"

regexpEscapePat = regexpFlags '[\\-\\[\\]/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]' 'g'

addToken del = bind (getValue 'tokenList')
  \dels . contains dels del
    false
    \\
      newDels = insertSorted (\a b . > (strLen a) (strLen b)) del dels
      .
      bind (setValue 'tokenList' newDels)
        \_ . computeTokenPat newDels

computeTokenPat dels = \\
  delPats = map (\item . strReplace item regexpEscapePat "\\$&") dels
  newPat = strCat (cons '(' (cons (join (cons delimiterListPrefix delPats) '|') (cons ')' nil)))
  .
  setValue 'tokenPat' newPat

addTokenGroup open close = bind (addToken open)
  \_ . bind (addToken close)
    \_ . bind (getValue 'tokenGroups')
      \gr . setValue 'tokenGroups' (acons open close gr)

#################
## INTERFACE
#################

#################
## TESTING
#################

parse str pat = ifNotErr (parseIndent (token '\n' 0) (tokens str pat) nil parenGroups) \list . list \h t . stripParens h

parseG str pat groups = ifNotErr (parseIndent (token '\n' 0) (tokens str pat) nil groups) \list . list \h t . stripParens h

parseToAst str pat = createAst (parse str pat) nil id

parseM str =
  bind (getValue 'tokenPat')
    \tokPat . bind (getValue 'tokenGroups')
      \groups . parseG str tokPat groups

scanLine str pat onDef onExpr = scanLineG str pat parenGroups onDef onExpr

parseLine str pat names onDef onExpr = parseLineG str pat names parenGroups onDef onExpr

parseLineM str = bind (getValue 'tokenPat')
  \tokPat . bind (getValue 'tokenGroups')
    \groups . parseLineG str tokPat nil groups id id

macroSubM expr =
  bind (getValue 'macroDefs')
    \macs . macroSub macs expr

macroParse str =
  bind (parseM str)
    \ex . macroSubM ex

tokensM str =
  bind (getValue 'tokenPat')
    \delimiterPat . tokens str delimiterPat

parseLines lines result = lines
  \h t D . bind (parseLineM h)
    \ast . parseLines t (cons ast result)
  reverse result

parseFile text = parseLines (linesForFile text) nil

simpleScanLine line = bind (getValue 'tokenPat')
  \tokenPat . bind (getValue 'tokenGroups')
    \groups . scanLineG line tokenPat groups id id

scanLineM line = bind (getValue 'tokenPat')
  \tokenPat . bind (getValue 'tokenGroups')
    \groups . bind (getValue 'parseFilters')
      \filters . bind (getValue 'macroDefs')
        \macros . bind (runParseFilters filters (scanLineG line tokenPat groups id id))
          \scanned . macroSub macros scanned

newParseLine names line = bind (scanLineM line)
  \scanned . createAst scanned names \ast . ast

runLine names line = bind (newParseLine names line)
  \ast . bind (runAst ast)
    \result . cons
      ast
      isParseErr result
        left (parseErrMsg result)
        right result

runLines names lines = lines
  \h t D . bind (runLine names h)
    \line . bind (runLines names t)
      \rest . cons line rest
  nil

runFile text = \\
  lines = linesForFile text
  names = namesForLines lines
  .
  runLines names lines

baseLoad file = bind (readFile file)
  \result . result
    \err . err
    \contents . bind (getValue 'activeTokenPacks')
      \activePacks . bind resetStdTokenPacks
        \_ . bind (runFile contents)
          \result . isNil activePacks
            bind resetStdTokenPacks
              \_ . result
            bind (resetTokenPacks activePacks)
                \_ . result

load file = bind (baseLoad file)
  \result . \\
    errs = foldr (\line results . tail line (\er . cons er results) (\x . results)) nil result
    .
    isNil errs
      right true
      left errs

require file = bind (getValue 'requiredFiles')
  \files . contains files file
    false
    bind (load file)
      \result . result
        \x . left x
        \_ . bind (setValue 'requiredFiles' (cons file files))
          \_ . right true

################
# Token Packs
################

# pack is (tokens groups filters)
defTokenPack name pack = bind (getValue 'tokenPacks')
  \packs . setValue 'tokenPacks' (acons name pack packs)

useTokenPack name = bind (getValue 'tokenPacks')
  \packs . bind (getValue 'tokenGroups')
    \groups . bind (getValue 'tokenList')
      \tokens . bind (getValue 'activeTokenPacks')
        \activePacks . bind (getValue 'parseFilters')
          \filters . assoc name packs
            \pack . \\
              groupToks = foldl (\value el . el \h t . cons h (cons t value)) nil (head (tail pack))
              newToks = quicksort (\a b . > (strLen a) (strLen b)) (append (head pack) (append groupToks tokens))
              .
              bind (setValue 'tokenList' newToks)
                \_ . bind (setValue 'tokenGroups' (append (head (tail pack)) groups))
                  \_ . bind (setValue 'parseFilters' (append filters (head (tail (tail pack)))))
                    \_ . bind (computeTokenPat newToks)
                      \_ . setValue 'activeTokenPacks' (cons name activePacks)
            nil

resetTokenPacks packs = bind (setValue 'tokenGroups' nil)
  \_ . bind (setValue 'tokenList' nil)
    \_ . bind (setValue 'activeTokenPacks' nil)
      \_ . bind (setValue 'parseFilters' nil)
        \_ . foldr1
          \packCmd result . bind packCmd \_ . result
          map useTokenPack packs

resetStdTokenPacks = bind (getValue 'stdTokenPacks')
  \stds . bind (resetTokenPacks stds)
    \_ . setValue 'activeTokenPacks' nil

addStdTokenPacks morePacks = bind (getValue 'stdTokenPacks')
  \stds . setValue 'stdTokenPacks' (append stds morePacks)

addParseFilter filt = bind (getValue 'parseFilters')
  \filters . setValue 'parseFilters' (append filters (cons filt nil))

############
# DIAG
############

d label value expr = log (strCat (cons label (cons value nil))) expr
dd label arg = d label arg arg

############
## SETTINGS
############

setValue 'macroDefs' nil
setValue 'requiredFiles' nil
setValue 'tokenPacks' nil
setValue 'activeTokenPacks' nil
setValue 'stdTokenPacks' (cons 'std' nil)

defTokenPack 'std' (cons (cons '.' (cons '\\' (cons '\\\\' (cons '\\@' nil)))) (cons (acons '(' ')' nil) (cons nil nil)))

resetStdTokenPacks

#################
# Utilities
#################

addTokenGroup '[' ']'
addToken '|'

listify list = list
  \h t D . isTokenString h '|'
    cons t nil
    cons (cons 'cons' (cons h (listify t))) nil
  cons 'nil' nil

defMacro '[' \list . list \h t . listify h

listFilter code = bind (getValue 'listMacros')
  \listMacros . filterApplies code \list . list \h t .
    and (isToken h) (contains listMacros (tokenString h))
      listFilterTail list
      list

listFilterTail list = list
  \h t D . isTokenString h '|'
    > (length t) 2
      cons h (cons (removeLast t) (cons (last t) nil))
      list
    cons h (listFilterTail t)
  nil

filterApplies code func = isParens code
  code \start end contents . parens start end (filterApplies contents func)
  isCons code
    \\
      filtered = filterApplyElements code func
      .
      and (isCons filtered) (isBlockStart (head filtered))
        filtered
        func filtered
    code

filterApplyElements code func = code
  \h t D . isBlockStart h
    cons h (filterBody t func)
    cons (filterApplies h func)
      and (isCons t) (isBlockStart (head t))
        cons (filterApplyElements t func) nil
        filterApplyElements t func
  nil

filterBody code func = code \h t . cons h
  isTokenString h '.'
    filterApplies t func
    filterBody t func

setValue 'listMacros' ['[']

addParseFilter listFilter

defTokenPack 'list' [
  ['|' '='] #adding = here so so we don't need spaces around = in definitions
  [['[' | ']'] ['or[' | ']'] ['and[' | ']'] ['concat[' | ']']]
  [listFilter]]

### Yay!  From here down, we can use list constructors!

addTokenGroup 'or[' ']'

addTokenGroup 'and[' ']'

addTokenGroup 'concat[' ']'

listMacroFoldOp op emptyCase list = list \h t . foldr
    \case result . [op case result]
    emptyCase
    h

defMacro 'or[' \list . listMacroFoldOp 'or' 'false' list

defMacro 'and[' \list . listMacroFoldOp 'and' 'true' list

defMacro 'concat[' \list . ['strCat' ['flatten' [(listify (head list))]]]

bind (getValue 'listMacros')
  \lm . ['concat[' | lm]

infix code = bind (getValue 'infixPrecedence')
  \prec . bind (getValue 'infixRightAssociative')
    \right . bind (getValue 'tokenGroups')
      \groups . filterApplies
        code
        \expr . infixRearrange prec right (map (\cell . tail cell) groups) expr

infixRearrange prec right closes list = \\
  len = length list
  head1 = head list
  tail1 = tail list
  head2 = head tail1
  tail2 = tail tail1
  head3 = head tail2
  opPrec = getPrec prec head2
  .
  < len 2
    list
    isInfix opPrec head1 head2 len
      or (== len 2) (not (isInfixArg closes head3))
        [[head2 head1] | tail2]
        infixRearrange prec right closes (absorbArgument opPrec prec right closes head1 head2 tail2 head3 (- len 2))
      [head1 | infixRearrange prec right closes tail1]

absorbArgument opPrec prec right closes head1 head2 tail2 head3 len = \\
  tail3 = tail tail2
  head4 = head tail3
  tail4 = tail tail3
  head5 = head tail4
  .
  infixShouldEatNext opPrec prec (contains right (strTokenString head2)) head3 head4 head5 closes len
    [head1 head2 | absorbArgument (getPrec prec head4) prec right closes head3 head4 tail4 head5 (- len 2)]
    [[head2 head1 head3] | tail3]

isInfixArg closes item = or[
  isParens item
  isCons item
  and[
    isToken item
    not (contains closes (tokenString item))
    not (isBlockStart item)]]

isInfix opPrec head1 head2 len = and[
  > len 1
  > opPrec -1
  isInfixArg nil head1]

getPrec prec token = \\
  str = tokenString token
  .
  isToken token
    findIndex (\level . contains level str) prec
    -1

infixShouldEatNext opPrec prec isRight curArg nextOp nextArg closes len = \\
  nextPrec = getPrec prec nextOp
  .
  and[
    > len 2
    isInfix nextPrec curArg nextOp len
    or (> opPrec nextPrec) (and (== opPrec nextPrec) isRight)
    isInfixArg closes nextArg]

: x y = cons x y

iprec = [['*' '/' '%'] ['+' '-'] [':'] ['<' '>' '<=' '>='] ['==' '!=']]
rightAssoc = [':']

setValue 'infixPrecedence' iprec
setValue 'infixRightAssociative' rightAssoc
defTokenPack 'infix' [(flatten iprec) [] [infix]]

useTokenPack 'infix'


################
## DO
################

defMacro 'do' \list . handleDo list false id

handleDo list inLet cont = list
  \h t D . isNil t
    cont (inLet ['.' h] [h])
    doClause (stripParens h) h nil inLet \newInLet chain .
      handleDo t newInLet \rest . cont (chain rest)
  cont nil

doClause steppingClause clause prefix inLet cont = \\
  makeBind var monad = cont false \rest . inLet (cons '.') id
    ['bind' monad ['\\' var '.' | rest]]
  .
  isCons steppingClause
    steppingClause \h t . isTokenString h '='
      inLet
        cont true \rest . [clause | rest]
        cont true \rest . ['\\\\' clause | rest]
      isTokenString h '<-'
        isNil t
          parseErr "No monad in do-clause: " clause
          prefix
            \ph pt D . isNil pt
              makeBind (isNil prefix '_' (head prefix)) t
              parseErr "More than one variable in do-clause: " clause
            makeBind '_' t
        doClause t clause [h | prefix] inLet cont
    makeBind '_' clause

defTokenPack 'do' [['<-'] [] []]

addStdTokenPacks ['list' 'infix' 'do']
resetStdTokenPacks

