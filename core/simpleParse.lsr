############
# LOGIC
############

true = \a b . a
false = \a b . b
not b = b false true

############
# CONS
############

cons a b = \f . f a b
# nil is the same as false, but it's useful separate as a marker
nil = \a b . b
filter func list = list (\h t D . \\ (rest = filter func t) . func h (cons h rest) rest) nil

############
# AST
############

lit value = \f . f value
ref name = \f . f name
lambda name body = \f . f name body
apply func arg . \f . f func arg
let name value body . \f . f name value body
anno name data body . \f . f name data body

############
# TOKENS
############

token txt pos = \f . f txt pos
tokenString tok = tok \t p . t
tokenPos tok = tok \t p . p
isToken t = hasType t token

parens start end content = \f . f start end content
parensStart p = p \s e c . s
parensEnd p = p \s e c . e
parensContent p = p \s e c . c
isParens p = eq (getType t) 'parens'
parensFromToks left right content = \\(start = tokenPos left) (end = tokenPos right) . parens start end content

parseErr msg = \f . f msg
parseErrMsg err = err \m . m

makeTokens strings start = strings (\h t D . makeMoreTokens h t start) nil
makeMoreTokens h t start = \\ (next = makeTokens t (+ start (strLen h))) . strStartsWith h ' ' next (cons (token h start) next)

splitTokens str pat = filter (\s . not (eq s '')) (strSplit str pat)

tokens str pat = makeTokens (splitTokens str pat) 0

#############
## Parsing
#############

isTokenString tok str = and (isToken tok) (eq (tokenString tok) str)
withToken tok tokCase nonTokCase = isToken tok (tok tokcase) nonTokCase

## withCons is like a safe version of a cons
withCons l cont nilCase = hasType l cons (l \h t D . cont h t) nilCase

parseToks toks cont = withCons toks (\h t . parseTok toks \h t . parseToks t \res . cont (cons h res)) nil
parseTok toks cont -> withCons toks (\h t . isTokenString h '(' (parseGroup h t nil cont) (cont h t))
