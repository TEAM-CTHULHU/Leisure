############
# LOGIC
############

true = \a b . a
false = \a b . b
not b = b false true

############
# CONS
############

cons a b = \f . f a b
# nil is the same as false, but it's useful separate as a marker
nil = \a b . b
filter func list = list
  (\h t D . \\ (rest = filter func t) . func h (cons h rest) rest)
  nil

############
# AST
############

lit value = \f . f value
ref name = \f . f name
lambda name body = \f . f name body
apply func arg . \f . f func arg
let name value body . \f . f name value body
anno name data body . \f . f name data body

############
# TOKENS
############

token txt pos = \f . f txt pos
tokenString tok = tok \t p . t
tokenPos tok = tok \t p . p
isToken t = hasType t token

parens start end content = \f . f start end content
parensStart p = p \s e c . s
parensEnd p = p \s e c . e
parensContent p = p \s e c . c
isParens p = eq (getType t) 'parens'
parensFromToks left right content = \\
  start = tokenPos left
  end = tokenPos right
  .
  parens start end content
stripParens p = isParens p (parensContent p) p

parseErr msg = \f . f msg
parseErrMsg err = err \m . m

makeTokens strings start = strings (\h t D . makeMoreTokens h t start) nil
makeMoreTokens h t start = \\ (next = makeTokens t (+ start (strLen h))) . strStartsWith h ' ' next (cons (token h start) next)

splitTokens str pat = filter (\s . not (eq s '')) (strSplit str pat)

tokens str pat = makeTokens (splitTokens str pat) 0

#############
## Parsing
#############

isTokenString tok str = and (isToken tok) (eq (tokenString tok) str)
withToken tok tokCase nonTokCase = isToken tok (tok tokcase) nonTokCase

## withCons is like a safe version of a cons
withCons l nilCase cont = hasType l cons (l \h t D . cont h t) nilCase

parseToks toks cont = eq toks nil (cont nil)
  parseTok toks \h t . parseToks t \res . cont (cons h res)

parseTok toks cont = withCons toks nil \h t .
  isTokenString h '('
    parseGroup h t nil cont
    isTokenStart h ' '
      parseTok t cont
      isTokenStart h '\n'
        parseIndent h t nil cont
        cont h t

parseGroup left toks gr cont = withCons toks
  parseErr (strcat (cons 'Unterminated group starting at ' (cons (tokenPos left) nil)))
  \h t . isTokenString h ')'
     cont (parensFromToks left h (reverse gr)) t
     parseTok toks \restH restT . parseGroup left restT (cons restH gr) cont

parseIndent indent toks gr cont = eq toks nil
  cont (parens (tokenPos indent) (lexEnd (head gr)) (reverse gr)) nil
  withCons toks
    parseErr (strcat (cons 'Bad list at' (cons (tokenPos left) nil)))
    \h t . and (isTokenStart h '\n') (le (strlen (tokenString h)) (length (tokenString indent)))
      cont (parens (tokenPos indent) (tokenPos h) (reverse gr)) toks
      parseTok toks \restH restT . parseIndent indent restT (cons restH gr) cont

id x = x

parse str = parseIndent (token '\n' 0) (tokens str) nil \h t . stripParens hn
