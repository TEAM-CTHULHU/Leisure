############
# LOGIC
############

true = \a b . a
false = \a b . b
not b = b false true
and a b = a b false
or a b = a true b
some x = \someCase noneCase . someCase x
none = \someCase noneCase . noneCase
id x = x

############
# CONS
############

cons a b = \f . f a b
isCons c = hasType c cons
# nil is the same as false, but it's useful separate as a marker
nil = \a b . b
isNil n = hasType n nil
head l = l \h t . h
tail l = l \h t . t
append a b = a (\h t D . cons h (append t b)) b
reverse l = rev l nil
rev l result = l (\h t D . rev t (cons h result)) result
filter func list = list (\h t D . func h (cons h) id (filter func t)) nil
find predicate list = list (\h t D . predicate h (some h) (find predicate t)) none
map func l = l (\h t D . cons (func h) (map func t)) nil
foldLeft func value l = l (\h t D . foldLeft func (func value h) t) value
intersperse list element = list (\h t D .
  hasType t nil
    h
    cons h (cons element (intersperse t element))) nil
join list el = strCat (intersperse list el)
acons k v alist = cons (cons k v) alist
assoc k alist = find (\el . eq k (head el)) alist

############
# TOKENS
############

token txt pos = \f . f txt pos
tokenString tok = tok \t p . t
tokenPos tok = tok \t p . p
isToken t = hasType t token

parens start end content = \f . f start end content
parensStart p = p \s e c . s
parensEnd p = p \s e c . e
parensContent p = p \s e c . c
isParens p = hasType p parens
parensFromToks left right content = \\
  start = tokenPos left
  end = + (tokenPos right) (strLen (tokenString right))
  .
  parens start end content
stripParens p = isParens p (parensContent p) p

parseErr msg1 msg2 = \f . f (strCat (cons msg1 (cons msg2 nil)))
parseErrMsg err = err \m . m

makeTokens strings start = strings (\h t D . makeMoreTokens h t start) nil
makeMoreTokens h t start = \\
  next = makeTokens t (+ start (strLen h))
  .
  or (strStartsWith h ' ') (strStartsWith h '#')
    next
    and (strStartsWith h '\n') (strStartsWith (head t) '#')
      makeTokens (tail t) (+ start (+ (strLen h) (strLen (head t))))
      cons (token h start) next

splitTokens str pat = filter (\s . not (eq s '')) (strSplit str pat)

tokens str pat = makeTokens (splitTokens str pat) 0

#############
## Parsing
#############

isTokenString tok str = and (isToken tok) (eq (tokenString tok) str)
isTokenStart tok str = and (isToken tok) (strStartsWith (tokenString tok) str)
withToken tok nonTokCase tokCase = isToken tok (tok tokCase) nonTokCase

## withCons is like a safe version of a cons
withCons l nilCase cont = hasType l cons (l (\h t D . cont h t) nilCase) nilCase

parseToks toks cont = eq toks nil (cont nil)
  parseTok toks \h t . parseToks t \res . cont (cons h res)

parseTok toks cont = withCons toks nil \h t .
  isTokenString h '('
    parseGroup h t nil cont
    isTokenStart h ' '
      parseTok t cont
      isTokenStart h '\n'
        parseIndent h t nil cont
        cont h t

parseGroup left toks gr cont = withCons toks
  parseErr 'Unterminated group starting ' (loc left)
  \h t . isTokenString h ')'
     cont (parensFromToks left h (reverse gr)) t
     parseTok toks \restH restT . parseGroup left restT (cons restH gr) cont

# cont takes the parsed group and the rest of the toks
parseIndent indent toks gr cont = withCons toks
  cont (optParens (tokenPos indent) (lexEnd (head gr)) (reverse gr)) nil
  \h t . or (isTokenStart h ')')
    and (isTokenStart h '\n') (le (strLen (tokenString h)) (strLen (tokenString indent)))
    cont (optParens (tokenPos indent) (tokenPos h) (reverse gr)) toks
    parseTok toks \restH restT . parseIndent indent restT (cons restH gr) cont

optParens start end group = \\
  p = parens start end group
  .
  withCons group
    p
    \h t . isNil t
      h
      p

id x = x

parse str pat = \\
  p = parseIndent (token '\n' 0) (tokens str pat) nil \h t . stripParens h
  .
  isToken p
    cons p nil
    p

#################
## Creating ASTs
#################

lit value = \f . f value
ref name = \f . f name
lambda name body = \f . f name body
apply func arg = \f . f func arg
let name value body = \f . f name value body
anno name data body = \f . f name data body

withParens p err cont = isParens p (cont (parensContent p)) err

strip list cont = withParens list (cont list) \c . strip c cont

position thing = isToken thing (tokenPos thing)
  isParens thing (parensStart thing)
    hasType thing cons (position (head thing))
      -1

lexEnd thing = isToken thing (+ (tokenPos thing) (strLen (tokenString thing)))
  isParens thing (parensEnd thing)
    hasType thing cons (lexEnd (last thing))
      -1

loc thing = \\
  p = position thing
  l = eq p -1 'an unknown location' p
  .
  strCat (cons 'at ' (cons l nil))

charCodes = acons 'b' '\b'
  acons 'f' '\f'
    acons 'n' '\n'
      acons 'r' '\r'
        acons 't' '\t'
          acons 'v' '\v'
            acons "'" "'"
              acons '"' '"'
                acons '\\' '\\'
                  nil

parseString start str cont = parseStringChars start str \strList . cont (strCat strList)

parseStringChars start str cont = eq str '' (cont nil)
  c = (strAt str 0)
  .
  eq c '\\'
    \\
      d = strAt str (+ 1 index)
      .
      assoc d charCodes
        \char . cons char (parseStringChars str (+ 1 index))
        parseErr (strCat (cons "Invalid character code: " (cons (strAt str (+ 1 index)) nil))) (loc start)
    cons c (parseStringChars str (+ 1 index))

scrub str = strFromList (scrubList (strToList str))

scrubList list = list
  \h t D . \\
    next = scrubList t
    .
    eq h '\\' (cons h (cons (head t) (scrubList (tail t))))
      eq h '"' (cons '\\' (cons '"' next))
        cons h next
  nil

createAst inList names cont = strip inList \list .
  isToken list (createLitOrRef list names cont)
    list
      \h t D .
        isTokenString h '\\\\' (createLet h t names cont)
          isTokenString h '\\@' (createAnno h t names cont)
            isTokenString h '\\' (createLambda h t names cont)
              createAst h names \func . createApply func t names cont
      cont nil

strMatches str pat = hasType (strMatch str pat) cons

digit = regexp '^[0-9]+$'

createLitOrRef tok names cont = \\
  tokStr = tokenString tok
  .
  find (\el . eq el tokStr) names
    \el .
      or (strStartsWith tokStr '"') (strStartsWith tokStr "'")
        parseString tok (strSubstring tokStr 1 (- (strLen tokStr) 1)) \str . cont (lit str)
        strMatches tokStr digit
          jsonParse tokStr
            \err . cont (ref tokStr)
            \json . lit json
          cont (ref tokStr)
    cont (ref tokStr)

createLambda start list names cont = \\
  err = parseErr "Lambda needs a variable name, a dot, and a body " (loc start)
  .
  withCons list err \name rest .
    withToken name err \n p .
      withCons rest err \dot body .
        # are these partial applications too hard to read?
        isTokenString dot '.' (createAst body) (createLambda start rest)
          cons n names
          \bodyAst . cont (lambda n bodyAst)

createAnno start list names cont = \\
  err = parseErr "Annotation needs a name, optional data, a dot, and a body " (loc start)
  .
  withCons list err \name rest .
    withCons rest err \data rest .
      not (or (isTokenString data '.') (and (isCons rest) (isTokenString (head rest) '.'))) err
        \\
          body = isTokenString data '.' rest (tail rest)
          data = isTokenString data '.' nil (strip data id)
          .
          createAst body names \bodyAst .
            cleanTokens start name \name .
              cont (anno name data bodyAst)

bodyStructPat = regexp '\\|\\\\|\\@'

createApply func list names cont = withCons list (cont func) \argItem rest .
  and (isToken argItem) (strMatches (tokenString argItem) bodyStructPat)
    createAst list names \arg . cont (apply func arg)
    createAst argItem names \arg . createApply (apply func arg) rest names cont

cleanTokens start toks cont = isToken toks
  cont (tokenString toks)
  withCons toks (cont toks) \head tail .
    cleanTokens start head \head .
      cleanTokens start tail \tail .
        cont (cons head tail)

createLet start list names cont = withCons list
  parseErr "No variable or body for let " (loc start)
  \binding body . eq body nil (createAst binding name cont)
    getLetNames start list names \newNames .
      createSublets start binding body newNames cont

getLetNames start list names cont = \\
  err = parseErr "Let expected binding " (loc start)
  .
  withCons list (cont names) \binding body .
    isTokenString binding '.' (cont names)
      withParens binding err \def .
        withCons def err \name rest .
          withToken name err \str pos .
            getLetNames start body (cons str names) cont

createSublets start binding body names cont =
  isTokenString binding '.' (createAst body names cont)
    withCons body (parseErr "Let expecetd a body " (loc start)) \bodyH bodyT .
      getNameAndDef (parensStart binding) (parensContent binding) names \name def .
        createSublets start bodyH bodyT names \bodyAst .
          cont let (tokenString name) def bodyAst

getNameAndDef pos binding names cont =
  withCons (tail binding) (parseErr "Let expected binding at " pos) \snd sndT .
    isTokenString snd '=' (createAst sndT names \def . cont (head binding) def)
      getLetLambda pos (tail binding) nil names \lamb . cont (head binding) lamb

getLetLambda pos def args names cont =
  withCons def (parseErr "Let expected binding at " pos) \arg rest .
    not (isToken arg) (parseErr "Let expected binding at " pos)
      isTokenString arg '='
        createAst (cons (token '\\' pos) (append (reverse args) (cons (token '.' (position arg)) rest))) names cont
        getLetLambda pos rest (cons arg args) names cont

parseToAst str pat = createAst (parse str pat) nil id

#################
## Compiling
#################

scanLine str pat isDef isExpr = \\
  toks = tokens str pat
  .
  strMatch str pat
    withCons toks (parseErr "No expression to compile" "") \name rest . \\
      func = isTokenString (head rest) '='
        isTokenString (head (tail rest)) '\\'
          setTypeAnno (head (tail rest)) (tail rest) (tokenString name)
          tail rest
        cons (token '\\' (- (position (head rest)) 1)) (transformDef name rest)
      .
      parseToks (checkSetDataType func rest name) \list .
        isDef (createDef list name (arity rest 0) str)
    parseToks toks \list . isExpr list

parseLine str pat names isDef isExpr = \\
  astCallback cb = \list . createAst list names \ast . cb ast
  .
  scanLine str (astCallback isDef) (astCallback isExpr)

genLine str pat names isDef isExpr = parseLine
  str
  names
  \code . isDef (strCat (cons '(' (cons (gen ast) (cons ');\n' nil))))
  \ast . isExpr (strCat (cons '(function(){return ' (cons (gen ast) (cons ';});\n' nil))))

transformDef name toks = withCons toks (parseErr "Bad definition, expecting tokens" "") \h t .
  isTokenString h '='
    isTokenString (head t) '\\'
      cons (token '.' (position h)) (setTypeAnno (head t) t (tokenString name))
      cons (token '.' (position h)) t
    cons h (transformDef name t)

setTypeAnno start toks name = \\
  pos = position def
  tok = \str . token str pos
  .
  cons (tok '\\@') (cons (tok 'type') (cons (tok name) (cons (tok '.') toks)))

createDef def name arity src = \\
  tok str = token str (position def)
  .
  cons (tok 'define') (cons (tok (jsonStringify (tokenString name))) (cons (tok (strString arity)) (cons (tok (jsonStringify src)) (cons (cons def nil) nil))))

checkSetDataType toks curToks name = withCons curToks \h t .
  isTokenString h '='
    isTokenString (head t) '\\' (setDataType toks name) toks
    checkSetDataType toks t name

setDataTypeAnno toks name = \\
  pos = position toks
  .
  cons (token '\\@' pos) (cons (token 'dataType' pos) (cons (token (tokenString name) pos) (cons (token '.' pos) toks)))

arity toks n = isTokenString (head toks) '=' n (arity (tail toks) (+ n 1))

tokListStr toks = jsonStringify (join (map (\t . tokenString t) toks) ' ')

linesForFile text = filter (\line . not (strMatch line '^ *#.*|^ *$')) (strSplit text '\n(?=[^ ])')

defPat = regexp '^([^ =]+).*='

namesForLines lines = foldLeft Nil (\result line . \\
  m = strMatch line defPat
  .
  hasType m nil result (cons (head (tail m)) result)) lines

# This is in JS, because it has to use eval
#
#compileLine str pat names isdef isExpr

jsonForFile text = \\
  lines = linesForFile text
  names = namesForLines lines
  .
  map (\lines . jsonStringify (ast2Json)) lines

#################
## Macros
#################

#macro m def = 
