############
# LOGIC
############

true = \a b . a
false = \a b . b
not b = b false true
and a b = a b false
or a b = a true b
some x = \someCase noneCase . someCase x
none = \someCase noneCase . noneCase
neq a b = not (eq a b)
left x = \lCase rCase . lCase x
right x = \lCase rCase . rCase x

############
# FUNCTIONS
############
id x = x
compose f g = \x . f (g x)

############
# CONS
############

cons a b = \f . f a b
isCons c = hasType c cons
# nil is the same as false, but it's useful separate as a marker
nil = \a b . b
isNil n = hasType n nil
head l = l \h t . h
tail l = l \h t . t
last l = isCons l
  l \h t . isCons t (last t) h
  nil
append a b = a (\h t D . cons h (append t b)) b
reverse l = rev l nil
rev l result = l (\h t D . rev t (cons h result)) result
filter func list = list (\h t D . func h (cons h) id (filter func t)) nil
find predicate list = list (\h t D . predicate h (some h) (find predicate t)) none
contains list item = find (\el . eq el item) list (\x . true) false
map func l = l (\h t D . cons (func h) (map func t)) nil
mapSave func l = l
  \h t D . \\
    newH = func h
    newT = mapSave func t
    .
    and (eq newH h) (eq newT t)
      l
      cons newH newT
  nil
foldl func value l = l (\h t D . foldl func (func value h) t) value
intersperse list element = list (\h t D .
  hasType t nil
    list
    cons h (cons element (intersperse t element))) nil
join list el = strCat (intersperse list el)

############
# ASSOC LISTS
############
acons k v alist = cons (cons k v) alist
assoc k alist  = find (\el . eq k (head el)) alist (\cell . cell \head tail . some tail) none
rassoc v alist = find (\el . eq v (tail el)) alist (\cell . cell \head tail . some head) none

############
# SORTING
############
quicksort less list = (qs less list) nil
# qs is written using a difference list so it can append in linear time
# sortedFunc must return whether the two args are in sorted order
# \rest . (qs ... makes a difference list.  id is the empty difference list.
qs sortedFunc list = list
  \h t D . \\
    greater = filter (sortedFunc h) t
    lesser = filter (compose not (sortedFunc h)) t
    .
    \rest . (qs sortedFunc lesser) (cons h ((qs sortedFunc greater) rest))
  id
insertSorted sortFunc item list = list
  \h t D . sortFunc item h (cons item list) (cons h (insertSorted sortFunc item t))
  cons item nil

############
# TOKENS
############

token txt pos = \f . f txt pos
tokenString tok = tok \t p . t
tokenPos tok = tok \t p . p
isToken t = hasType t token

parens start end content = \f . f start end content
parensStart p = p \s e c . s
parensEnd p = p \s e c . e
parensContent p = p \s e c . c
isParens p = hasType p parens
makeParens start end content =
  and (hasType content cons) (hasType (tail content) nil)
    makeParens start end (head content)
    or (isToken content) (isParens content)
      content
      parens start end content
parensFromToks left right content = \\
  start = tokenPos left
  end = + (tokenPos right) (strLen (tokenString right))
  .
  parens start end content
stripParens p = isParens p (parensContent p) p

parseErr msg1 msg2 = \f . f (strCat (cons msg1 (cons msg2 nil)))
parseErrMsg err = err \m . m

makeTokens strings start = strings (\h t D . makeMoreTokens h t start) nil
makeMoreTokens h t start = \\
  next = makeTokens t (+ start (strLen h))
  .
  or (strStartsWith h ' ') (strStartsWith h '#')
    next
    and (strStartsWith h '\n') (strStartsWith (head t) '#')
      makeTokens (tail t) (+ start (+ (strLen h) (strLen (head t))))
      cons (token h start) next

splitTokens str pat = filter (\s . not (eq s '')) (strSplit str pat)

tokens str pat = makeTokens (splitTokens str pat) 0

#############
## Parsing
#############

isTokenString tok str = and (isToken tok) (eq (tokenString tok) str)
isTokenStart tok str = and (isToken tok) (strStartsWith (tokenString tok) str)
withToken tok nonTokCase tokCase = isToken tok (tok tokCase) nonTokCase

## withCons is like a safe version of a cons
withCons l nilCase cont = hasType l cons (l (\h t D . cont h t) nilCase) nilCase

parseToks toks groups cont =
  isNil toks (cont nil)
    parseTok toks groups \h t .
      parseToks t groups \res .
        cont (cons h res)

parseTok toks groups cont = withCons toks nil \h t .
  withToken h (cont h t) \txt pos .
    assoc txt groups
      \close . parseGroup h t nil close groups cont
      isTokenStart h '\n' (parseIndent h t nil groups cont)
        cont h t

parseGroup left toks gr close groups cont = withCons toks (parseErr 'Unterminated group starting ' (loc left))
  \h t . isTokenString h close
    eq close ')'
      cont (parensFromToks left h (reverse gr)) t
      cont (parensFromToks left h (cons left (reverse (cons h gr)))) t
    withToken h
      parseTok toks groups \restH restT . parseGroup left restT (cons restH gr) close groups cont
      \txt pos .
        rassoc txt groups
          \open . parseErr (strCat (cons 'Mismatched group: ' (cons (tokenString left) (cons txt (cons ' ' nil))))) (loc left)
          parseTok toks groups \restH restT . parseGroup left restT (cons restH gr) close groups cont

parseIndent indent toks gr groups cont =
  withCons toks (cont (makeParens (tokenPos indent) (lexEnd (head gr)) (reverse gr)) nil) \h t .
    or (withToken h false (\txt pos . rassoc txt groups (\open . true) false))
      and (isTokenStart h '\n') (le (strLen (tokenString h)) (strLen (tokenString indent)))
      cont (makeParens (tokenPos indent) (tokenPos h) (reverse gr)) toks
      parseTok toks groups \restH restT . parseIndent indent restT (cons restH gr) groups cont

id x = x

#################
## Creating ASTs
#################

lit value = \f . f value
ref name = \f . f name
lambda name body = \f . f name body
apply func arg = \f . f func arg
let name value body = \f . f name value body
anno name data body = \f . f name data body

withParens p err cont = isParens p (cont (parensContent p)) err

strip list cont = withParens list (cont list) \c . strip c cont

position thing = isToken thing (tokenPos thing)
  isParens thing (parensStart thing)
    isCons thing (position (head thing))
      -1

lexEnd thing = isToken thing (+ (tokenPos thing) (strLen (tokenString thing)))
  isParens thing (parensEnd thing)
    isCons thing (lexEnd (last thing))
      -1

loc thing = \\
  p = position thing
  l = eq p -1 'an unknown location' p
  .
  strCat (cons 'at ' (cons l nil))

scrub str = strFromList (scrubList (strToList str))

scrubList list = list
  \h t D . \\
    next = scrubList t
    .
    eq h '\\' (cons h (cons (head t) (scrubList (tail t))))
      eq h '\"' (cons '\\' (cons '\"' next))
        cons h next
  nil

createAst inList names cont = strip inList \list .
  isToken list (createLitOrRef (tokenString list) names cont)
    list
      \h t D .
        isTokenString h '\\\\' (createLet h t names cont)
          isTokenString h '\\@' (createAnno h t names cont)
            isTokenString h '\\' (createLambda h t names cont)
              createApply list names cont
      cont nil

strMatches str pat = hasType (strMatch str pat) cons

digit = regexp '^[0-9]+$'

backslashCodes = 'bfnrt'

backslashValues = '\b\f\n\r\t'

convertStringEscape char codes values =
  eq codes ''
    char
    eq char (strAt codes 0)
      strAt values 0
      convertStringEscape char (strSubstring codes 1 0) (strSubstring values 1 0)

convertStringEscapes orig str cont =
  eq str ''
    cont str
    eq (strAt str 0) '\\'
      eq (strLen str) 1 (parseErr "Error, backslash without character in string: " orig)
        convertStringEscapes orig (strSubstring str 2 0) \rest . cont
          strAdd
            convertStringEscape (strAt str 1) backslashCodes backslashValues
            rest
      convertStringEscapes orig (strSubstring str 1 0) \rest . cont
        strAdd
          strAt str 0
          rest

parseString str cont =
  neq (strAt str 0) (strAt str -1) (parseErr "Badly terminated string: " str)
    convertStringEscapes str (strSubstring str 1 -1) cont

createLitOrRef tok names cont =
  contains names tok
    cont (ref tok)
    or (strStartsWith tok '\"') (strStartsWith tok "'")
      parseString tok \str . cont (lit str)
      or (and (ge (strAt tok 0) '0') (le (strAt tok 0) '9')) (strStartsWith tok '-')
        jsonParse tok (\err . cont (ref tok)) (\item . cont (lit item))
        cont (ref tok)

createLambda start list names cont = \\
  err = parseErr "Lambda needs a variable name, a dot, and a body " (loc start)
  .
  withCons list err \name rest .
    withToken name err \n p .
      withCons rest err \dot body .
        # are these partial applications too hard to read?
        isTokenString dot '.' (createAst body) (createLambda start rest)
          cons n names
          \bodyAst . cont (lambda n bodyAst)

createAnno start list names cont =
  withCons list (parseErr "No annotation name or data in annotation " (loc start)) \name rest .
    withCons rest (parseErr "No data for annotation " (loc start)) \data rest . \\
      finish data body = createAst body names \bodyAst .
        cleanTokens start name \name .
          cleanTokens start data \data .
            cont (anno name data bodyAst)
      .
      isTokenString data '.'
        finish nil rest
        strip data \data .
          withCons rest (parseErr "No body for annotation " (loc start)) \dot body .
            isTokenString dot '.'
              finish data body
              parseErr "Annotation expects dot after name and data " (loc start)

bodyStructPat = regexp '\\|\\\\|\\@'

createApply inList names cont = strip inList \list .
  withCons list (parseErr "Funcion apply expecting a non-empty list " (loc inList)) \h t .
    createAst h names \func . chainApply func t names cont

blockStarts = cons '\\' (cons '\\\\' (cons '\\@' nil))

chainApply func list names cont = withCons list (cont func) \argItem rest .
  and (isToken argItem) (contains blockStarts (tokenString argItem))
    createAst list names \arg . cont (apply func arg)
    createAst argItem names \arg . chainApply (apply func arg) rest names cont

cleanTokens start toks cont = isToken toks
  cont (tokenString toks)
  withCons toks (cont toks) \head tail .
    cleanTokens start head \head .
      cleanTokens start tail \tail .
        cont (cons head tail)

createLet start list names cont = withCons list
  parseErr "No variable or body for let " (loc start)
  \binding body . eq body nil (createAst binding name cont)
    getLetNames start list names \newNames .
      createSublets start binding body newNames cont

getLetNames start list names cont = \\
  err = parseErr "Let expected binding " (loc start)
  .
  withCons list (cont names) \binding body .
    isTokenString binding '.' (cont names)
      withParens binding err \def .
        withCons def err \name rest .
          withToken name err \str pos .
            getLetNames start body (cons str names) cont

createSublets start binding body names cont =
  isTokenString binding '.' (createAst body names cont)
    withCons body (parseErr "Let expected a body " (loc start)) \bodyH bodyT .
      getNameAndDef (parensStart binding) (parensContent binding) names \name def .
        createSublets start bodyH bodyT names \bodyAst .
          cont (let (tokenString name) def bodyAst)

getNameAndDef pos binding names cont =
  withCons (tail binding) (parseErr "Let expected binding at " pos) \snd sndT .
    isTokenString snd '=' (createAst sndT names \def . cont (head binding) def)
      getLetLambda pos (tail binding) nil names \lamb . cont (head binding) lamb

getLetLambda pos def args names cont =
  withCons def (parseErr "Let expected binding at " pos) \arg rest .
    not (isToken arg) (parseErr "Let expected binding at " pos)
      isTokenString arg '='
        createAst (cons (token '\\' pos) (append (reverse args) (cons (token '.' (position arg)) rest))) names cont
        getLetLambda pos rest (cons arg args) names cont

#################
## Compiling
#################

parenGroups = cons (cons '(' ')') nil

scanLineG str pat groups onDef onExpr = \\
  toks = tokens str pat
  .
  strMatches str defPat
    withCons toks (parseErr "No expression to compile" "") \name rest . \\
      parseIt func = parseToks (checkSetDataType func rest name) groups \list .
        onDef (createDef list name (arity rest 0) str)
      .
      isTokenString (head rest) '='
        isTokenString (head (tail rest)) '\\'
          parseIt (setTypeAnno (tail rest) (tokenString name))
          parseIt (tail rest)
        transformDef name rest \def .
          parseIt (cons (token '\\' (- (position (head rest)) 1)) def)
    parseToks toks groups \list . onExpr list

parseLineG str pat names groups onDef onExpr = \\
  astCallback cb = \list . createAst list names \ast . cb ast
  .
  scanLineG str pat groups (astCallback onDef) (astCallback onExpr)

transformDef name toks cont = withCons toks (parseErr "Bad definition, expecting tokens" (loc name)) \h t .
  isTokenString h '='
    isTokenString (head t) '\\'
      cont (cons (token '.' (position h)) (setTypeAnno t (tokenString name)))
      cont (cons (token '.' (position h)) t)
    transformDef name t \list . cont (cons h list)

setTypeAnno toks name = \\
  tok = \str . token str (position toks)
  .
  cons (tok '\\@') (cons (tok 'type') (cons (tok name) (cons (tok '.') toks)))

setDataTypeAnno toks name = \\
  tok = \str . token str (position toks)
  .
  cons (tok '\\@') (cons (tok 'dataType') (cons (tok (tokenString name)) (cons (tok '.') toks)))

createDef def name arity src = \\
  tok str = token str (position def)
  .
  jsonStringify (tokenString name) (\err . parseErr (strCat (cons "Bad function name " (cons (loc name) nil))) err) \nameStr .
    jsonStringify src (\err . parseErr (strCat (cons "Bad source " (cons (loc name) nil))) err) \srcStr .
      cons (tok 'define') (cons (tok nameStr) (cons (tok (strString arity)) (cons (tok srcStr) (cons def nil))))

checkSetDataType toks curToks name = withCons curToks toks \h t .
  isTokenString h '='
    isTokenString (head t) '\\'
      setDataTypeAnno toks name
      toks
    checkSetDataType toks t name

arity toks n = isTokenString (head toks) '=' n (arity (tail toks) (+ n 1))

tokListStr toks = jsonStringify (join (map (\t . tokenString t) toks) ' ')

linePat = regexp '\\n(?=[^ ]|$)'

emptyLinePat = regexp '^[ \\i]*\\#.*|^[ \\i]*$|^\n[ \\i]*$'

linesForFile text = filter
  \line . isNil (strMatch line emptyLinePat)
  strSplit text linePat

defPat = regexp '^([^ =]+).*='

namesForLines lines = foldl
  \result line . \\
    m = strMatch line defPat
    .
    hasType m nil result (cons (head (tail m)) result)
  nil
  lines

#################
## Macro system
#################

# alpha substitution to make the result hygenic
# make some let-style macros that use gensyms?

# macs is an assoc-list (list of (name . definition))
# expr is the tail of the macro expression
#macroSub macs expr = postProcessMacro (baseMacroSub macs expr)
macroSub macs expr = baseMacroSub macs expr

isString s = eq (getType s) '*string'

baseMacroSub macs expr =
  withCons (stripParens expr) expr \h t . \\
    #newH = baseMacroSub macs h
    strippedH = stripParens h
    newH = stripParens (baseMacroSub macs strippedH)
    subTail = mapSave (baseMacroSub macs) t
    unmod = and (eq strippedH newH) (eq t subTail)
      expr
      cons newH subTail
    .
    withToken newH unmod \txt pos . assoc txt macs (\def . baseMacroSub macs (def t)) unmod

postProcessMacro before after macro = isString macro
  token macro (eq after -1 before after)
  isParens macro
    macro \start end contents . parens start end (postProcessMacro start end contents)
    isCons macro
      macro \h t .
        isToken h
          cons h (postProcessMacro (+ 1 (+ (tokenPos h) (strLen (tokenString h)))) -1 t)
          \\
            posStart = position h
            posEnd = position t
            t2 = postProcessMacro -1 after t
            h2 = postProcessMacro before -1 h
            .
            eq posStart -1
              cons (postProcessMacro before (position t2) h) t2
              cons h2 (postProcessMacro (+ 1 (lexEnd h2)) after t)
      macro

defMacro name def = bind (getValue 'macros') \macs . setValue 'macros' (acons name def macs)

#################
# Token Patterns
#################

delimiterListPrefix = "\"(?:\\\\.|[^\"])*\"|'(?:\\\\.|[^'])*'|\\n *|#.*| +"

regexpEscapePat = regexpFlags '[\\-\\[\\]/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]' 'g'


#smeg newDels = map ( \ item . strReplace item regexpEscapePat "\\$&") newDels

addDelimiter del =
  bind (getValue 'delimiterList')
    \ dels . contains dels del
      false
      \\
        newDels = insertSorted ( \ a b . gt (strLen a) (strLen b)) del dels
        delPats = map ( \ item . strReplace item regexpEscapePat "\\$&") newDels
        .
        bind (setValue 'delimiterList' newDels)
          \ _ . setValue 'delimiterPat' (strCat (cons '(' (cons (join (cons delimiterListPrefix delPats) '|') (cons ')' nil))))

addGroup open close = bind (addDelimiter open)
  \_ . bind (addDelimiter close)
    \_ . bind (getValue 'groups')
      \gr .setValue 'groups' (acons open close gr)

#################
## TESTING
#################

parse str pat = parseIndent (token '\n' 0) (tokens str pat) nil parenGroups \h t . stripParens h

parseG str pat groups = parseIndent (token '\n' 0) (tokens str pat) nil groups \h t . stripParens h

parseToAst str pat = createAst (parse str pat) nil id

parseM str =
  bind (getValue 'delimiterPat')
    \tokPat . bind (getValue 'groups')
      \groups . parseG str tokPat groups

scanLine str pat onDef onExpr = scanLineG str pat parenGroups onDef onExpr

parseLine str pat names onDef onExpr = parseLineG str pat names parenGroups onDef onExpr

parseLineM str = bind (getValue 'delimiterPat')
  \tokPat . bind (getValue 'groups')
    \groups . parseLineG str tokPat nil groups id id

macroSubM expr =
  bind (getValue 'macros')
    \macs . macroSub macs expr

macroParse str =
  bind (parseM str)
    \ex . macroSubM ex

tokensM str =
  bind (getValue 'delimiterPat')
    \delimiterPat . tokens str delimiterPat

parseLines lines result = lines
  \h t D . bind (parseLineM h)
    \ast . parseLines t (cons ast result)
  reverse result

parseFile text = parseLines (linesForFile text) nil

newParseLine names line = bind (getValue 'delimiterPat')
  \delimiterPat . bind (getValue 'groups')
    \groups . bind (getValue 'macros')
      \macros . \\
        astCallback scanned = createAst (macroSub macros scanned) names \ast . ast
        .
        scanLineG line delimiterPat groups astCallback astCallback

runLine names line = bind (getValue 'delimiterPat')
  \delimiterPat . bind (getValue 'groups')
    \groups . bind (getValue 'macros')
      \macros . \\
        #astCallback scanned = createAst scanned names \ast . bind (runAst ast)
        astCallback scanned = createAst (macroSub macros scanned) names \ast . bind (runAst ast)
          \_ . ast
        .
        scanLineG line delimiterPat groups astCallback astCallback

runLines names lines = lines
  \h t D . bind (runLine names h)
    \line . bind (runLines names t)
      \rest . cons line rest
  nil

runFile text = \\
  lines = linesForFile text
  names = namesForLines lines
  .
  runLines names lines

TEST = runLine nil 'h x = x'

############
# DIAG
############

d label value expr = log (strCat (cons label (cons value nil))) expr

dd label arg = d label arg arg

############
## ACTIONS
############

setValue 'groups' (acons '(' ')' nil)
setValue 'delimiterList' nil
setValue 'delimiterPat' (strCat (cons '(' (cons delimiterListPrefix (cons ')' nil))))
setValue 'macros' nil

addDelimiter '('
addDelimiter ')'
addDelimiter '.'
addDelimiter '\\'
addDelimiter '\\\\'
addDelimiter '\\@'
