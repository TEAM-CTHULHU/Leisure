############
# LOGIC
############

true = \a b . a
false = \a b . b
not b = b false true
and a b = a b false

############
# CONS
############

cons a b = \f . f a b
# nil is the same as false, but it's useful separate as a marker
nil = \a b . b
filter func list = list
  (\h t D . \\ (rest = filter func t) . func h (cons h rest) rest)
  nil
reverse l = rev l nil
rev l result = withCons l result \h t . rev t (cons h result)

############
# AST
############

lit value = \f . f value
ref name = \f . f name
lambda name body = \f . f name body
apply func arg . \f . f func arg
let name value body . \f . f name value body
anno name data body . \f . f name data body

############
# TOKENS
############

token txt pos = \f . f txt pos
tokenString tok = tok \t p . t
tokenPos tok = tok \t p . p
isToken t = hasType t token

parens start end content = \f . f start end content
parensStart p = p \s e c . s
parensEnd p = p \s e c . e
parensContent p = p \s e c . c
isParens p = eq (getType p) 'parens'
parensFromToks left right content = \\
  start = tokenPos left
  end = + (tokenPos right) (strLen (tokenString right))
  .
  parens start end content
stripParens p = isParens p (parensContent p) p

parseErr msg = \f . f msg
parseErrMsg err = err \m . m

makeTokens strings start = strings (\h t D . makeMoreTokens h t start) nil
makeMoreTokens h t start = \\ (next = makeTokens t (+ start (strLen h))) . strStartsWith h ' ' next (cons (token h start) next)

splitTokens str pat = filter (\s . not (eq s '')) (strSplit str pat)

tokens str pat = makeTokens (splitTokens str pat) 0

#############
## Parsing
#############

isTokenString tok str = and (isToken tok) (eq (tokenString tok) str)
isTokenStart tok str = and (isToken tok) (strStartsWith (tokenString tok) str)
withToken tok tokCase nonTokCase = isToken tok (tok tokcase) nonTokCase

## withCons is like a safe version of a cons
withCons l nilCase cont = hasType l cons (l (\h t D . cont h t) nilCase) nilCase

parseToks toks cont = eq toks nil (cont nil)
  parseTok toks \h t . parseToks t \res . cont (cons h res)

parseTok toks cont = withCons toks nil \h t .
  isTokenString h '('
    parseGroup h t nil cont
    isTokenStart h ' '
      parseTok t cont
      isTokenStart h '\n'
        parseIndent h t nil cont
        cont h t

parseGroup left toks gr cont = withCons toks
  parseErr (strCat (cons 'Unterminated group starting at ' (cons (tokenPos left) nil)))
  \h t . isTokenString h ')'
     cont (parensFromToks left h (reverse gr)) t
     parseTok toks \restH restT . parseGroup left restT (cons restH gr) cont

parseIndent indent toks gr cont = withCons toks
  cont (parens (tokenPos indent) (lexEnd (head gr)) (reverse gr)) nil
  \h t . and (isTokenStart h '\n') (le (strlen (tokenString h)) (length (tokenString indent)))
    cont (parens (tokenPos indent) (tokenPos h) (reverse gr)) toks
    parseTok toks \restH restT . parseIndent indent restT (cons restH gr) cont

id x = x

parse str pat = parseIndent (token '\n' 0) (tokens str pat) nil \h t . stripParens h

#################
## Creating ASTs
#################
#parseToAst str pat = createAst (parse str pat) nil id
#
#withToken tok nonTokenCase cont = isToken tok
#  cont (tokenString tok) (tokenPos tok)
#  nonTokenCase
#
#withParens p err cont = not (isParens p)
#  err
#  cont (parensContent p)
