make-subtree svg width height root-x root-y = \f . f svg width height root-x root-y

subtree-svg st = st \svg width height root-x root-y . svg
subtree-width st = st \svg width height root-x root-y . width
subtree-height st = st \svg width height root-x root-y . height
subtree-root-x st = st \svg width height root-x root-y . root-x
subtree-root-y st = st \svg width height root-x root-y . root-y

subtree-set-svg st value = st \svg width height root-x root-y . make-subtree value width height root-x root-y
subtree-set-width st value = st \svg width height root-x root-y . make-subtree svg value height root-x root-y
subtree-set-height st value = st \svg width height root-x root-y . make-subtree svg width value root-x root-y
subtree-set-root-x st value = st \svg width height root-x root-y . make-subtree svg width height value root-y
subtree-set-root-y st value = st \svg width height root-x root-y . make-subtree svg width height root-x value

make-box svg width height = \f . f svg width height
box-svg b = b \svg width height . svg
box-width b = b \svg width height . width
box-height b = b \svg width height . height

treeFor ast = svg (subtree-svg (subtreeFor ast)) [['width'|200],['height'|200]]

subtreeFor ast = do
  t = typeof ast
  eq t 'lit'
    createLitSubtree (pretty (ast id))
    eq t 'ref'
      createRefSubtree (pretty (ast id))
      eq t 'lambda'
        ast (\v b . createLambdaSubtree v b)
        eq t 'apply'
          ast (\f a . createApplySubtree f a)
          make-subtree (svg-node '') 0 0 0 0

redStyle = [['stroke'|'black'],['stroke-width'|2],['fill'|'red'],['rx'|8],['ry'|8] ]
greenStyle = [['stroke'|'black'],['stroke-width'|2],['fill'|'green'],['rx'|8],['ry'|8] ]
blueStyle = [['stroke'|'black'],['stroke-width'|2],['fill'|'blue'],['rx'|8],['ry'|8] ]

#    (translate rootSvg (- (/ totalWidth 2) (/ (box-width rootBox) 2)) 0)

createLambdaSubtree v b = do
  rootBox = textBox greenStyle 'lambda'
  rootSvg = box-svg rootBox
  varBox = textBox greenStyle v
  varSvg = box-svg varBox
  bodyTree = subtreeFor b
  bodySvg = subtree-svg bodyTree
  childWidth = + (+ (box-width varBox) 5) (subtree-width bodyTree)
  totalWidth = max childWidth (box-width rootBox)
  pad = max 0 (/ (- totalWidth childWidth) 2)
  make-subtree
    svg-concat [(translate varSvg pad (+ (box-height rootBox) 5)),(translate bodySvg (+ pad (+ (box-width varBox) 5)) (+ (box-height rootBox) 5)),(translate rootSvg (- (/ totalWidth 2) (/ (box-width rootBox) 2)) 0)]
    totalWidth
    + (+ (box-height rootBox) 5) (max (box-height varBox) (subtree-height bodyTree))
    / totalWidth 2
    / (box-height rootBox) 2

createApplySubtree f a = do
  rootBox = textBox blueStyle 'apply'
  rootSvg = box-svg rootBox
  argTree = subtreeFor a
  argSvg = subtree-svg argTree
  funcTree = subtreeFor f
  funcSvg = subtree-svg funcTree
  childWidth = + (+ (subtree-width argTree) 5) (subtree-width funcTree)
  totalWidth = max childWidth (box-width rootBox)
  pad = max 0 (/ (- totalWidth childWidth) 2)
  make-subtree
    svg-concat [(translate argSvg pad (+ (box-height rootBox) 5)), (translate funcSvg (+ pad (+ (subtree-width argTree) 5)) (+ (box-height rootBox) 5)), (translate rootSvg (- (/ totalWidth 2) (/ (box-width rootBox) 2)) 0)]
    totalWidth
    + (+ (box-height rootBox) 5) (max (subtree-height argTree) (subtree-height funcTree))
    / totalWidth 2
    / (box-height rootBox) 2

createRefSubtree ref = (textBox redStyle ref) \b w h .  make-subtree b w h (/ w 2) (/ h 2)
createLitSubtree lit = (textBox greenStyle lit) \b w h .  make-subtree b w h (/ w 2) (/ h 2)

textBox map txt = (svg-measure-text txt '') \w h . do
  box-w = + w 24
  box-h = + h 14
  make-box (svg-concat [(rect [['x'|2],['y'|2],['width'|box-w],['height'|box-h] | map]), (text txt [['text-anchor'|"middle"],['dominant-baseline'|"mathematical"],['x'|(+ 14 (/ w 2))],['y'|(+ 5 (/ h 2))]])]) box-w box-h

typeof x = getType x id false

# parseRef r tree = add-child tree (make-tree [ 'ref', (r id) ] )
# 
# parseLit l tree = add-child tree (make-tree [ 'lit', (l id) ] )
# 
# parseLambda l tree = l (\v b . add-child tree (add-child (make-tree [ 'lambda', v ]) (parseAst b nil))  )
# 
# parseApply a tree = a (\func arg . add-child tree (add-child (add-child (make-tree [ 'apply', '' ]) (parseAst func nil)) (parseAst arg nil)) )
# 
# 
# parseAst a tree = do
#   t = typeof a
#   (eq t 'ref')
#     parseRef a tree
#     (eq t 'lit')
#       parseLit a tree
#       (eq t 'lambda')
#         parseLambda a tree
#         parseApply a tree
# 
# 
# make-error err = make-tree [ 'error', (err id) ]
# 
# parseTree s = (parse s) (\x. parseAst x nil) make-error
# 
# #ex: printAst (parse 'cons (\x.x) 2' id id)
# 
# 
# build-svg-node n = (rect nil)
# 
# build-svg-children t = ''
# 
# build-tree c = if (null? c) ''
#   concat [ build-svg-node (data c), build-svg-children (first-child c) ]
# 
# build-svg tree = traverse-infix tree build-tree
# 
# tst = (build-svg (parseTree '1'))

