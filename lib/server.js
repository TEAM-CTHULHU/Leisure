// Generated by CoffeeScript 1.7.1
(function() {
  var URI, attemptCollab, createNamespace, createServer, diff, dir, fs, getFile, handler, hashes, io, newTrunk, ns, root, sha, storeVersion, trunks, util, _;

  root = module.exports = require('./base');

  global.Utf8 = require('utf8');

  URI = require('./uri');

  _ = require('./lazy');

  sha = require('./sha256');

  diff = require('./diff');

  fs = require('fs');

  util = require('util');

  dir = null;

  ns = {};

  io = null;

  hashes = {};

  trunks = {};

  console.log("HASH 'hello' = " + (sha.hash('hello')));

  handler = function(req, res) {
    var m, uri;
    uri = new URI(req.url);
    console.log("PATH: " + uri.path);
    if (m = uri.path.match(/^file\/(.*)$/)) {
      return getFile(uri, req, res, m);
    } else if (m = uri.path.match(/^collab\/(.*)$/)) {
      return attemptCollab(uri, req, res, m);
    } else {
      console.log("BAD REQUEST: " + uri.path);
      res.writeHead(404);
      return res.end("Unknown uri: " + uri.path);
    }
  };

  getFile = function(uri, req, res, m) {
    var fileName;
    fileName = m[1];
    if (trunks[fileName]) {
      console.log("retrieving working copy: " + fileName);
      res.writeHead(200);
      res.end(hashes[trunks[fileName]]);
    }
    return fs.readFile("" + dir + "/" + fileName, function(err, data) {
      if (err) {
        console.log("ERROR READING FILE: " + fileName);
        res.writeHead(500);
        return res.end('Error loading index.html');
      } else {
        console.log("SENDING FILE: " + fileName);
        res.writeHead(200);
        return res.end(data);
      }
    });
  };

  attemptCollab = function(uri, req, res, m) {
    var file, fileName;
    fileName = m[1];
    if (!trunks[fileName]) {
      file = "" + dir + "/" + fileName;
      if (!(fs.existsSync(file))) {
        res.writeHead(404);
        return res.end("No file: " + file);
      } else {
        return fs.readFile("" + dir + "/" + fileName, {
          encoding: 'utf8'
        }, function(err, data) {
          if (err) {
            res.writeHead(404);
            return res.end("No file: " + file);
          } else {
            ns[fileName] = true;
            createNamespace(fileName);
            newTrunk(fileName, data);
            console.log("COLLABORATE: " + fileName + " (NEW NAMESPACE)");
            res.writeHead(200);
            return res.end("true");
          }
        });
      }
    } else {
      console.log("COLLABORATE: " + fileName);
      res.writeHead(200);
      return res.end("true");
    }
  };

  newTrunk = function(fileName, data) {
    var hash;
    console.log("encode type: " + (typeof data));
    hash = sha.hash(data);
    trunks[fileName] = hash;
    return hashes[hash] = data;
  };

  createNamespace = function(file) {
    console.log("CREATED NAMESPACE: " + file);
    ns = io.of("/" + file);
    return ns.on('connection', function(socket) {
      console.log("CONNECTION TO NAMESPACE: " + file);
      socket.file = file;
      socket.on('init', function(data) {
        console.log("INIT: " + data);
        return socket.hash = data;
      });
      return socket.on('store', function(_arg) {
        var hash, keepPrivate, mergeHash, parent, patch;
        hash = _arg.hash, parent = _arg.parent, patch = _arg.patch, keepPrivate = _arg.keepPrivate, mergeHash = _arg.mergeHash;
        return storeVersion(socket, hash, parent, patch, keepPrivate, mergeHash);
      });
    });
  };

  storeVersion = function(socket, hash, parent, patch, keepPrivate, mergeHash) {
    var d, sock, _i, _len, _ref, _results;
    console.log("STORE hash: " + hash + ", parent: " + parent + ", patch length: " + patch.length);
    d = hashes[hash] = diff.patch(hashes[parent], patch).join('');
    if (sha.hash(hashes[hash]) !== hash) {
      console.log("WARNING, bad data for hash: " + hash + "...\n" + d);
    } else {
      console.log("STORED: " + d);
    }
    trunks[socket.file] = hash;
    socket.hash = hash;
    if (!keepPrivate) {
      _ref = socket.nsp.sockets;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        sock = _ref[_i];
        if (sock.hash && sock.hash !== hash) {
          sock.emit('patch', {
            hash: sock.hash,
            patch: diff.diff_patch(hashes[sock.hash], d)
          });
          _results.push(sock.hash = hash);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    }
  };

  createServer = function(opts) {
    var app;
    dir = opts.dir;
    app = require('http').createServer(handler);
    io = require('socket.io').listen(app);
    app.listen(80);
    return io.sockets.on('connection', function(socket) {
      return console.log("GLOBAL CONNECTION");
    });
  };

  root.createServer = createServer;

}).call(this);

//# sourceMappingURL=server.map
