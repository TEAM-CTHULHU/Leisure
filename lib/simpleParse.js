require('source-map-support').install();
runMonad(resolve(L_define)(function(){return "true"})(function(){return 0})(function(){return "true = \\a b . a"})((function(){var $m; return function(){return $m || ($m = setDataType(setType(function(L_a){return function(L_b){return resolve(L_a)}}, 'true'), 'true'))}})()));
runMonad(resolve(L_define)(function(){return "false"})(function(){return 0})(function(){return "false = \\a b . b"})((function(){var $m; return function(){return $m || ($m = setDataType(setType(function(L_a){return function(L_b){return resolve(L_b)}}, 'false'), 'false'))}})()));
runMonad(resolve(L_define)(function(){return "not"})(function(){return 1})(function(){return "not b = b false true"})((function(){var $m; return function(){return $m || ($m = function(L_b){return resolve(L_b)(L_false)(L_true)})}})()));
runMonad(resolve(L_define)(function(){return "and"})(function(){return 2})(function(){return "and a b = a b false"})((function(){var $m; return function(){return $m || ($m = function(L_a){return function(L_b){return resolve(L_a)(L_b)(L_false)}})}})()));
runMonad(resolve(L_define)(function(){return "or"})(function(){return 2})(function(){return "or a b = a true b"})((function(){var $m; return function(){return $m || ($m = function(L_a){return function(L_b){return resolve(L_a)(L_true)(L_b)}})}})()));
runMonad(resolve(L_define)(function(){return "some"})(function(){return 1})(function(){return "some x = \\someCase noneCase . someCase x"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_x){return setType(function(L_someCase){return function(L_noneCase){return resolve(L_someCase)(L_x)}}, 'some')}, 'some'))}})()));
runMonad(resolve(L_define)(function(){return "some2"})(function(){return 2})(function(){return "some2 a b = \\someCase noneCase . someCase a b"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_a){return function(L_b){return setType(function(L_someCase){return function(L_noneCase){return resolve(L_someCase)(L_a)(L_b)}}, 'some2')}}, 'some2'))}})()));
runMonad(resolve(L_define)(function(){return "none"})(function(){return 0})(function(){return "none = \\someCase noneCase . noneCase"})((function(){var $m; return function(){return $m || ($m = setDataType(setType(function(L_someCase){return function(L_noneCase){return resolve(L_noneCase)}}, 'none'), 'none'))}})()));
runMonad(resolve(L_define)(function(){return "isNone"})(function(){return 1})(function(){return "isNone obj = hasType obj none"})((function(){var $m; return function(){return $m || ($m = function(L_obj){return resolve(L_hasType)(L_obj)(L_none)})}})()));
runMonad(resolve(L_define)(function(){return "isSome"})(function(){return 1})(function(){return "isSome obj = hasType obj some"})((function(){var $m; return function(){return $m || ($m = function(L_obj){return resolve(L_hasType)(L_obj)(L_some)})}})()));
runMonad(resolve(L_define)(function(){return "isSome2"})(function(){return 1})(function(){return "isSome2 obj = hasType obj some2"})((function(){var $m; return function(){return $m || ($m = function(L_obj){return resolve(L_hasType)(L_obj)(L_some2)})}})()));
runMonad(resolve(L_define)(function(){return "neq"})(function(){return 2})(function(){return "neq a b = not (eq a b)"})((function(){var $m; return function(){return $m || ($m = function(L_a){return function(L_b){return resolve(L_not)((function(){var $m; return function(){return $m || ($m = resolve(L_eq)(L_a)(L_b))}})())}})}})()));
runMonad(resolve(L_define)(function(){return "left"})(function(){return 1})(function(){return "left x = \\lCase rCase . lCase x"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_x){return setType(function(L_lCase){return function(L_rCase){return resolve(L_lCase)(L_x)}}, 'left')}, 'left'))}})()));
runMonad(resolve(L_define)(function(){return "right"})(function(){return 1})(function(){return "right x = \\lCase rCase . rCase x"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_x){return setType(function(L_lCase){return function(L_rCase){return resolve(L_rCase)(L_x)}}, 'right')}, 'right'))}})()));
runMonad(resolve(L_define)(function(){return "strAsc"})(function(){return 1})(function(){return "strAsc string = _strAsc (assertType 'strAsc string' '*string' string)"})((function(){var $m; return function(){return $m || ($m = function(L_string){return resolve(L__strAsc)((function(){var $m; return function(){return $m || ($m = resolve(L_assertType)(function(){return "strAsc string"})(function(){return "*string"})(L_string))}})())})}})()));
runMonad(resolve(L_define)(function(){return "strChr"})(function(){return 1})(function(){return "strChr ascii = _strChr (assertType 'strChr string' '*number' ascii)"})((function(){var $m; return function(){return $m || ($m = function(L_ascii){return resolve(L__strChr)((function(){var $m; return function(){return $m || ($m = resolve(L_assertType)(function(){return "strChr string"})(function(){return "*number"})(L_ascii))}})())})}})()));
runMonad(resolve(L_define)(function(){return "strAt"})(function(){return 2})(function(){return "strAt string index = _strAt\n  assertType 'strAt string' '*string' string\n  assertType 'strAt index' '*number' index"})((function(){var $m; return function(){return $m || ($m = function(L_string){return function(L_index){return resolve(L__strAt)((function(){var $m; return function(){return $m || ($m = resolve(L_assertType)(function(){return "strAt string"})(function(){return "*string"})(L_string))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_assertType)(function(){return "strAt index"})(function(){return "*number"})(L_index))}})())}})}})()));
runMonad(resolve(L_define)(function(){return "strStartsWith"})(function(){return 2})(function(){return "strStartsWith string prefix = _strStartsWith\n  assertType 'strStartsWith string' '*string' string\n  assertType 'strStartsWith prefix' '*string' prefix"})((function(){var $m; return function(){return $m || ($m = function(L_string){return function(L_prefix){return resolve(L__strStartsWith)((function(){var $m; return function(){return $m || ($m = resolve(L_assertType)(function(){return "strStartsWith string"})(function(){return "*string"})(L_string))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_assertType)(function(){return "strStartsWith prefix"})(function(){return "*string"})(L_prefix))}})())}})}})()));
runMonad(resolve(L_define)(function(){return "strLen"})(function(){return 1})(function(){return "strLen string = _strLen (assertType 'strLen string' '*string' string)"})((function(){var $m; return function(){return $m || ($m = function(L_string){return resolve(L__strLen)((function(){var $m; return function(){return $m || ($m = resolve(L_assertType)(function(){return "strLen string"})(function(){return "*string"})(L_string))}})())})}})()));
runMonad(resolve(L_define)(function(){return "strToLowerCase"})(function(){return 1})(function(){return "strToLowerCase string = _strToLowerCase (assertType 'strToLowerCase string' '*string' string)"})((function(){var $m; return function(){return $m || ($m = function(L_string){return resolve(L__strToLowerCase)((function(){var $m; return function(){return $m || ($m = resolve(L_assertType)(function(){return "strToLowerCase string"})(function(){return "*string"})(L_string))}})())})}})()));
runMonad(resolve(L_define)(function(){return "strToUpperCase"})(function(){return 1})(function(){return "strToUpperCase string = _strToUpperCase (assertType 'strToUpperCase string' '*string' string)"})((function(){var $m; return function(){return $m || ($m = function(L_string){return resolve(L__strToUpperCase)((function(){var $m; return function(){return $m || ($m = resolve(L_assertType)(function(){return "strToUpperCase string"})(function(){return "*string"})(L_string))}})())})}})()));
runMonad(resolve(L_define)(function(){return "strReplace"})(function(){return 3})(function(){return "strReplace string pat repl = _strReplace\n  assertType 'strReplace string' '*string' string\n  assert (or (hasType pat '*string') (hasType pat '*RegExp')) (strCat (cons 'strStartsWith pat should be type string or RegExp but it is type ' (cons (getType pat) (cons ': ' (cons (show pat) nil))))) pat\n  assertType 'strReplace repl' '*string' repl"})((function(){var $m; return function(){return $m || ($m = function(L_string){return function(L_pat){return function(L_repl){return resolve(L__strReplace)((function(){var $m; return function(){return $m || ($m = resolve(L_assertType)(function(){return "strReplace string"})(function(){return "*string"})(L_string))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_assert)((function(){var $m; return function(){return $m || ($m = resolve(L_or)((function(){var $m; return function(){return $m || ($m = resolve(L_hasType)(L_pat)(function(){return "*string"}))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_hasType)(L_pat)(function(){return "*RegExp"}))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_strCat)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(function(){return "strStartsWith pat should be type string or RegExp but it is type "})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_getType)(L_pat))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(function(){return ": "})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_show)(L_pat))}})())(L_nil))}})()))}})()))}})()))}})()))}})())(L_pat))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_assertType)(function(){return "strReplace repl"})(function(){return "*string"})(L_repl))}})())}}})}})()));
runMonad(resolve(L_define)(function(){return "strSubstring"})(function(){return 3})(function(){return "strSubstring str start end = _strSubstring\n  assertType 'strSubstring str' '*string' str\n  assertType 'strSubstring start' '*number' start\n  assertType 'strSubstring end' '*number' end"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_start){return function(L_end){return resolve(L__strSubstring)((function(){var $m; return function(){return $m || ($m = resolve(L_assertType)(function(){return "strSubstring str"})(function(){return "*string"})(L_str))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_assertType)(function(){return "strSubstring start"})(function(){return "*number"})(L_start))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_assertType)(function(){return "strSubstring end"})(function(){return "*number"})(L_end))}})())}}})}})()));
runMonad(resolve(L_define)(function(){return "strSplit"})(function(){return 2})(function(){return "strSplit str pat = _strSplit\n  assertType 'strSplit str' '*string' str\n  assert (or (hasType pat '*string') (hasType pat '*RegExp')) (strCat (cons 'strSplit pat should be type string or RegExp but it is type ' (cons (getType pat) (cons ': ' (cons (show pat) nil))))) pat"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pat){return resolve(L__strSplit)((function(){var $m; return function(){return $m || ($m = resolve(L_assertType)(function(){return "strSplit str"})(function(){return "*string"})(L_str))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_assert)((function(){var $m; return function(){return $m || ($m = resolve(L_or)((function(){var $m; return function(){return $m || ($m = resolve(L_hasType)(L_pat)(function(){return "*string"}))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_hasType)(L_pat)(function(){return "*RegExp"}))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_strCat)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(function(){return "strSplit pat should be type string or RegExp but it is type "})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_getType)(L_pat))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(function(){return ": "})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_show)(L_pat))}})())(L_nil))}})()))}})()))}})()))}})()))}})())(L_pat))}})())}})}})()));
runMonad(resolve(L_define)(function(){return "strCat"})(function(){return 1})(function(){return "strCat list = _strCat\n  assert (isList list) (strCat (cons 'strCat list should be type cons or nil but it is type ' (cons (getType list) (cons ': ' (cons list))))) list"})((function(){var $m; return function(){return $m || ($m = function(L_list){return resolve(L__strCat)((function(){var $m; return function(){return $m || ($m = resolve(L_assert)((function(){var $m; return function(){return $m || ($m = resolve(L_isList)(L_list))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_strCat)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(function(){return "strCat list should be type cons or nil but it is type "})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_getType)(L_list))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(function(){return ": "})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_list))}})()))}})()))}})()))}})()))}})())(L_list))}})())})}})()));
runMonad(resolve(L_define)(function(){return "strAdd"})(function(){return 2})(function(){return "strAdd str1 str2 = _strAdd (assertType 'strAdd str1' '*string' str1) (assertType 'strAdd str2' '*string' str2)"})((function(){var $m; return function(){return $m || ($m = function(L_str1){return function(L_str2){return resolve(L__strAdd)((function(){var $m; return function(){return $m || ($m = resolve(L_assertType)(function(){return "strAdd str1"})(function(){return "*string"})(L_str1))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_assertType)(function(){return "strAdd str2"})(function(){return "*string"})(L_str2))}})())}})}})()));
runMonad(resolve(L_define)(function(){return "strMatch"})(function(){return 2})(function(){return "strMatch str pat = _strMatch\n  assertType 'strMatch str' '*string' str\n  assert (or (hasType pat '*string') (hasType pat '*RegExp')) (strCat (cons 'strMatch pat should be type string or RegExp but it is type ' (cons (getType pat) (cons ': ' (cons (show pat) nil))))) pat"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pat){return resolve(L__strMatch)((function(){var $m; return function(){return $m || ($m = resolve(L_assertType)(function(){return "strMatch str"})(function(){return "*string"})(L_str))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_assert)((function(){var $m; return function(){return $m || ($m = resolve(L_or)((function(){var $m; return function(){return $m || ($m = resolve(L_hasType)(L_pat)(function(){return "*string"}))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_hasType)(L_pat)(function(){return "*RegExp"}))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_strCat)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(function(){return "strMatch pat should be type string or RegExp but it is type "})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_getType)(L_pat))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(function(){return ": "})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_show)(L_pat))}})())(L_nil))}})()))}})()))}})()))}})()))}})())(L_pat))}})())}})}})()));
runMonad(resolve(L_define)(function(){return "strToList"})(function(){return 1})(function(){return "strToList str = _strToList (assertType 'strToList str' '*string' str)"})((function(){var $m; return function(){return $m || ($m = function(L_str){return resolve(L__strToList)((function(){var $m; return function(){return $m || ($m = resolve(L_assertType)(function(){return "strToList str"})(function(){return "*string"})(L_str))}})())})}})()));
runMonad(resolve(L_define)(function(){return "strFromList"})(function(){return 1})(function(){return "strFromList list = _strFromList\n  assert (isList list) (strCat (cons 'strFromList list should be type cons or nil but it is type ' (cons (getType list) (cons ': ' (cons list))))) list"})((function(){var $m; return function(){return $m || ($m = function(L_list){return resolve(L__strFromList)((function(){var $m; return function(){return $m || ($m = resolve(L_assert)((function(){var $m; return function(){return $m || ($m = resolve(L_isList)(L_list))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_strCat)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(function(){return "strFromList list should be type cons or nil but it is type "})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_getType)(L_list))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(function(){return ": "})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_list))}})()))}})()))}})()))}})()))}})())(L_list))}})())})}})()));
runMonad(resolve(L_define)(function(){return "regexp"})(function(){return 1})(function(){return "regexp str = _regexp (assertType 'regexp str' '*string' str)"})((function(){var $m; return function(){return $m || ($m = function(L_str){return resolve(L__regexp)((function(){var $m; return function(){return $m || ($m = resolve(L_assertType)(function(){return "regexp str"})(function(){return "*string"})(L_str))}})())})}})()));
runMonad(resolve(L_define)(function(){return "regexpFlags"})(function(){return 2})(function(){return "regexpFlags str flags = _regexpFlags\n  assertType 'regexp str' '*string' str\n  assertType 'regexp flags' '*string' flags"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_flags){return resolve(L__regexpFlags)((function(){var $m; return function(){return $m || ($m = resolve(L_assertType)(function(){return "regexp str"})(function(){return "*string"})(L_str))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_assertType)(function(){return "regexp flags"})(function(){return "*string"})(L_flags))}})())}})}})()));
runMonad(resolve(L_define)(function(){return "jsonParse"})(function(){return 3})(function(){return "jsonParse str failure success = _jsonParse\n  assertType 'jsonParse str' '*string' str\n  failure\n  success"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_failure){return function(L_success){return resolve(L__jsonParse)((function(){var $m; return function(){return $m || ($m = resolve(L_assertType)(function(){return "jsonParse str"})(function(){return "*string"})(L_str))}})())(L_failure)(L_success)}}})}})()));
runMonad(resolve(L_define)(function(){return "show"})(function(){return 1})(function(){return "show x = _show x"})((function(){var $m; return function(){return $m || ($m = function(L_x){return resolve(L__show)(L_x)})}})()));
runMonad(resolve(L_define)(function(){return "id"})(function(){return 1})(function(){return "id x = x"})((function(){var $m; return function(){return $m || ($m = function(L_x){return resolve(L_x)})}})()));
runMonad(resolve(L_define)(function(){return "compose"})(function(){return 2})(function(){return "compose f g = \\x . f (g x)"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_f){return function(L_g){return setType(function(L_x){return resolve(L_f)((function(){var $m; return function(){return $m || ($m = resolve(L_g)(L_x))}})())}, 'compose')}}, 'compose'))}})()));
runMonad(resolve(L_define)(function(){return "flip"})(function(){return 1})(function(){return "flip func = \\x y . func y x"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_func){return setType(function(L_x){return function(L_y){return resolve(L_func)(L_y)(L_x)}}, 'flip')}, 'flip'))}})()));
runMonad(resolve(L_define)(function(){return "cons"})(function(){return 2})(function(){return "cons a b = \\f . f a b"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_a){return function(L_b){return setType(function(L_f){return resolve(L_f)(L_a)(L_b)}, 'cons')}}, 'cons'))}})()));
runMonad(resolve(L_define)(function(){return "isCons"})(function(){return 1})(function(){return "isCons c = hasType c cons"})((function(){var $m; return function(){return $m || ($m = function(L_c){return resolve(L_hasType)(L_c)(L_cons)})}})()));
runMonad(resolve(L_define)(function(){return "isList"})(function(){return 1})(function(){return "isList l = or (hasType l cons) (hasType l nil)"})((function(){var $m; return function(){return $m || ($m = function(L_l){return resolve(L_or)((function(){var $m; return function(){return $m || ($m = resolve(L_hasType)(L_l)(L_cons))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_hasType)(L_l)(L_nil))}})())})}})()));
runMonad(resolve(L_define)(function(){return "assertType"})(function(){return 3})(function(){return "assertType msg type value = assert (hasType value type) (strCat (cons msg (cons ' should be type ' (cons (getDataType type) (cons ', but its type is ' (cons (getType value) (cons ': ' (cons (show value) nil)))))))) value"})((function(){var $m; return function(){return $m || ($m = function(L_msg){return function(L_type){return function(L_value){return resolve(L_assert)((function(){var $m; return function(){return $m || ($m = resolve(L_hasType)(L_value)(L_type))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_strCat)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_msg)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(function(){return " should be type "})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_getDataType)(L_type))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(function(){return ", but its type is "})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_getType)(L_value))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(function(){return ": "})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_show)(L_value))}})())(L_nil))}})()))}})()))}})()))}})()))}})()))}})()))}})()))}})())(L_value)}}})}})()));
runMonad(resolve(L_define)(function(){return "nil"})(function(){return 0})(function(){return "nil = \\a b . b"})((function(){var $m; return function(){return $m || ($m = setDataType(setType(function(L_a){return function(L_b){return resolve(L_b)}}, 'nil'), 'nil'))}})()));
runMonad(resolve(L_define)(function(){return "isNil"})(function(){return 1})(function(){return "isNil n = hasType n nil"})((function(){var $m; return function(){return $m || ($m = function(L_n){return resolve(L_hasType)(L_n)(L_nil)})}})()));
runMonad(resolve(L_define)(function(){return "head"})(function(){return 1})(function(){return "head l = l \\h t . h"})((function(){var $m; return function(){return $m || ($m = function(L_l){return resolve(L_l)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return resolve(L_h)}})}})())})}})()));
runMonad(resolve(L_define)(function(){return "tail"})(function(){return 1})(function(){return "tail l = l \\h t . t"})((function(){var $m; return function(){return $m || ($m = function(L_l){return resolve(L_l)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return resolve(L_t)}})}})())})}})()));
runMonad(resolve(L_define)(function(){return "last"})(function(){return 1})(function(){return "last l = isNil (tail l)\n  head l\n  last (tail l)"})((function(){var $m; return function(){return $m || ($m = function(L_l){return resolve(L_isNil)((function(){var $m; return function(){return $m || ($m = resolve(L_tail)(L_l))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_head)(L_l))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_last)((function(){var $m; return function(){return $m || ($m = resolve(L_tail)(L_l))}})()))}})())})}})()));
runMonad(resolve(L_define)(function(){return "removeLast"})(function(){return 1})(function(){return "removeLast l = isNil (tail l)\n  nil\n  cons (head l) (removeLast (tail l))"})((function(){var $m; return function(){return $m || ($m = function(L_l){return resolve(L_isNil)((function(){var $m; return function(){return $m || ($m = resolve(L_tail)(L_l))}})())(L_nil)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_head)(L_l))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_removeLast)((function(){var $m; return function(){return $m || ($m = resolve(L_tail)(L_l))}})()))}})()))}})())})}})()));
runMonad(resolve(L_define)(function(){return "length"})(function(){return 1})(function(){return "length list = isCons list\n  + 1 (length (tail list))\n  0"})((function(){var $m; return function(){return $m || ($m = function(L_list){return resolve(L_isCons)(L_list)((function(){var $m; return function(){return $m || ($m = resolve(L_$o)(function(){return 1})((function(){var $m; return function(){return $m || ($m = resolve(L_length)((function(){var $m; return function(){return $m || ($m = resolve(L_tail)(L_list))}})()))}})()))}})())(function(){return 0})})}})()));
runMonad(resolve(L_define)(function(){return "append"})(function(){return 2})(function(){return "append a b = isNil a\n  b\n  cons (head a) (append (tail a) b)"})((function(){var $m; return function(){return $m || ($m = function(L_a){return function(L_b){return resolve(L_isNil)(L_a)(L_b)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_head)(L_a))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_append)((function(){var $m; return function(){return $m || ($m = resolve(L_tail)(L_a))}})())(L_b))}})()))}})())}})}})()));
runMonad(resolve(L_define)(function(){return "flatten"})(function(){return 1})(function(){return "flatten list = isCons list\n  subflatten list nil\n  list"})((function(){var $m; return function(){return $m || ($m = function(L_list){return resolve(L_isCons)(L_list)((function(){var $m; return function(){return $m || ($m = resolve(L_subflatten)(L_list)(L_nil))}})())(L_list)})}})()));
runMonad(resolve(L_define)(function(){return "subflatten"})(function(){return 2})(function(){return "subflatten list result = isNil list\n  result\n  isCons list\n    subflatten (head list) (subflatten (tail list) result)\n    cons list result"})((function(){var $m; return function(){return $m || ($m = function(L_list){return function(L_result){return resolve(L_isNil)(L_list)(L_result)((function(){var $m; return function(){return $m || ($m = resolve(L_isCons)(L_list)((function(){var $m; return function(){return $m || ($m = resolve(L_subflatten)((function(){var $m; return function(){return $m || ($m = resolve(L_head)(L_list))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_subflatten)((function(){var $m; return function(){return $m || ($m = resolve(L_tail)(L_list))}})())(L_result))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_list)(L_result))}})()))}})())}})}})()));
runMonad(resolve(L_define)(function(){return "reverse"})(function(){return 1})(function(){return "reverse l = rev l nil"})((function(){var $m; return function(){return $m || ($m = function(L_l){return resolve(L_rev)(L_l)(L_nil)})}})()));
runMonad(resolve(L_define)(function(){return "rev"})(function(){return 2})(function(){return "rev l result = isNil l\n  result\n  rev (tail l) (cons (head l) result)"})((function(){var $m; return function(){return $m || ($m = function(L_l){return function(L_result){return resolve(L_isNil)(L_l)(L_result)((function(){var $m; return function(){return $m || ($m = resolve(L_rev)((function(){var $m; return function(){return $m || ($m = resolve(L_tail)(L_l))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_head)(L_l))}})())(L_result))}})()))}})())}})}})()));
runMonad(resolve(L_define)(function(){return "filter"})(function(){return 2})(function(){return "filter func list = isNil list\n  nil\n  func (head list) (cons (head list)) id (filter func (tail list))"})((function(){var $m; return function(){return $m || ($m = function(L_func){return function(L_list){return resolve(L_isNil)(L_list)(L_nil)((function(){var $m; return function(){return $m || ($m = resolve(L_func)((function(){var $m; return function(){return $m || ($m = resolve(L_head)(L_list))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_head)(L_list))}})()))}})())(L_id)((function(){var $m; return function(){return $m || ($m = resolve(L_filter)(L_func)((function(){var $m; return function(){return $m || ($m = resolve(L_tail)(L_list))}})()))}})()))}})())}})}})()));
runMonad(resolve(L_define)(function(){return "find"})(function(){return 2})(function(){return "find predicate list = isNil list\n  none\n  predicate (head list) (some (head list)) (find predicate (tail list))"})((function(){var $m; return function(){return $m || ($m = function(L_predicate){return function(L_list){return resolve(L_isNil)(L_list)(L_none)((function(){var $m; return function(){return $m || ($m = resolve(L_predicate)((function(){var $m; return function(){return $m || ($m = resolve(L_head)(L_list))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_some)((function(){var $m; return function(){return $m || ($m = resolve(L_head)(L_list))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_find)(L_predicate)((function(){var $m; return function(){return $m || ($m = resolve(L_tail)(L_list))}})()))}})()))}})())}})}})()));
runMonad(resolve(L_define)(function(){return "contains"})(function(){return 2})(function(){return "contains list item = find (\\el . eq el item) list (\\x . true) false"})((function(){var $m; return function(){return $m || ($m = function(L_list){return function(L_item){return resolve(L_find)((function(){var $m; return function(){return $m || ($m = function(L_el){return resolve(L_eq)(L_el)(L_item)})}})())(L_list)((function(){var $m; return function(){return $m || ($m = function(L_x){return resolve(L_true)})}})())(L_false)}})}})()));
runMonad(resolve(L_define)(function(){return "map"})(function(){return 2})(function(){return "map func l = isNil l\n  nil\n  cons (func (head l)) (map func (tail l))"})((function(){var $m; return function(){return $m || ($m = function(L_func){return function(L_l){return resolve(L_isNil)(L_l)(L_nil)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_func)((function(){var $m; return function(){return $m || ($m = resolve(L_head)(L_l))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_map)(L_func)((function(){var $m; return function(){return $m || ($m = resolve(L_tail)(L_l))}})()))}})()))}})())}})}})()));
runMonad(resolve(L_define)(function(){return "mapSave"})(function(){return 2})(function(){return "mapSave func l = isNil l\n  nil\n  \\\\\n    newH = func (head l)\n    newT = mapSave func (tail l)\n    .\n    and (eq newH (head l)) (eq newT (tail l))\n      l\n      cons newH newT"})((function(){var $m; return function(){return $m || ($m = function(L_func){return function(L_l){return resolve(L_isNil)(L_l)(L_nil)(function(){
var L_newT, L_newH;

L_newT = (function(){var $m; return function(){return $m || ($m = resolve(L_mapSave)(L_func)((function(){var $m; return function(){return $m || ($m = resolve(L_tail)(L_l))}})()))}})();

L_newH = (function(){var $m; return function(){return $m || ($m = resolve(L_func)((function(){var $m; return function(){return $m || ($m = resolve(L_head)(L_l))}})()))}})();
return resolve(L_and)((function(){var $m; return function(){return $m || ($m = resolve(L_eq)(L_newH)((function(){var $m; return function(){return $m || ($m = resolve(L_head)(L_l))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_eq)(L_newT)((function(){var $m; return function(){return $m || ($m = resolve(L_tail)(L_l))}})()))}})())(L_l)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_newH)(L_newT))}})())})}})}})()));
runMonad(resolve(L_define)(function(){return "foldl"})(function(){return 3})(function(){return "foldl func initialValue l = l (\\h t D . foldl func (func initialValue h) t) initialValue"})((function(){var $m; return function(){return $m || ($m = function(L_func){return function(L_initialValue){return function(L_l){return resolve(L_l)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return resolve(L_foldl)(L_func)((function(){var $m; return function(){return $m || ($m = resolve(L_func)(L_initialValue)(L_h))}})())(L_t)}}})}})())(L_initialValue)}}})}})()));
runMonad(resolve(L_define)(function(){return "foldl1"})(function(){return 2})(function(){return "foldl1 func l = l \\h t . foldl func h t"})((function(){var $m; return function(){return $m || ($m = function(L_func){return function(L_l){return resolve(L_l)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return resolve(L_foldl)(L_func)(L_h)(L_t)}})}})())}})}})()));
runMonad(resolve(L_define)(function(){return "foldr"})(function(){return 3})(function(){return "foldr func initialValue list = list\n  \\h t D . func h (foldr func initialValue t)\n  initialValue"})((function(){var $m; return function(){return $m || ($m = function(L_func){return function(L_initialValue){return function(L_list){return resolve(L_list)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return resolve(L_func)(L_h)((function(){var $m; return function(){return $m || ($m = resolve(L_foldr)(L_func)(L_initialValue)(L_t))}})())}}})}})())(L_initialValue)}}})}})()));
runMonad(resolve(L_define)(function(){return "foldr1"})(function(){return 2})(function(){return "foldr1 func list = list \\h t . isNil t\n  h\n  func h (foldr1 func t)"})((function(){var $m; return function(){return $m || ($m = function(L_func){return function(L_list){return resolve(L_list)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return resolve(L_isNil)(L_t)(L_h)((function(){var $m; return function(){return $m || ($m = resolve(L_func)(L_h)((function(){var $m; return function(){return $m || ($m = resolve(L_foldr1)(L_func)(L_t))}})()))}})())}})}})())}})}})()));
runMonad(resolve(L_define)(function(){return "intersperse"})(function(){return 2})(function(){return "intersperse list element = list (\\h t D .\n  isNil t\n    list\n    cons h (cons element (intersperse t element))) nil"})((function(){var $m; return function(){return $m || ($m = function(L_list){return function(L_element){return resolve(L_list)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return resolve(L_isNil)(L_t)(L_list)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_h)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_element)((function(){var $m; return function(){return $m || ($m = resolve(L_intersperse)(L_t)(L_element))}})()))}})()))}})())}}})}})())(L_nil)}})}})()));
runMonad(resolve(L_define)(function(){return "join"})(function(){return 2})(function(){return "join list el = strCat (intersperse list el)"})((function(){var $m; return function(){return $m || ($m = function(L_list){return function(L_el){return resolve(L_strCat)((function(){var $m; return function(){return $m || ($m = resolve(L_intersperse)(L_list)(L_el))}})())}})}})()));
runMonad(resolve(L_define)(function(){return "findIndex"})(function(){return 2})(function(){return "findIndex func list = idx list func 0"})((function(){var $m; return function(){return $m || ($m = function(L_func){return function(L_list){return resolve(L_idx)(L_list)(L_func)(function(){return 0})}})}})()));
runMonad(resolve(L_define)(function(){return "idx"})(function(){return 3})(function(){return "idx list func pos = list\n  \\h t D . func h\n    pos\n    idx t func (+ 1 pos)\n  -1"})((function(){var $m; return function(){return $m || ($m = function(L_list){return function(L_func){return function(L_pos){return resolve(L_list)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return resolve(L_func)(L_h)(L_pos)((function(){var $m; return function(){return $m || ($m = resolve(L_idx)(L_t)(L_func)((function(){var $m; return function(){return $m || ($m = resolve(L_$o)(function(){return 1})(L_pos))}})()))}})())}}})}})())(function(){return -1})}}})}})()));
runMonad(resolve(L_define)(function(){return "index"})(function(){return 2})(function(){return "index list el = find (\\item . == el item) list"})((function(){var $m; return function(){return $m || ($m = function(L_list){return function(L_el){return resolve(L_find)((function(){var $m; return function(){return $m || ($m = function(L_item){return resolve(L_$p$p)(L_el)(L_item)})}})())(L_list)}})}})()));
runMonad(resolve(L_define)(function(){return "assertAlist"})(function(){return 3})(function(){return "assertAlist msg value result = assert (isAlist value) (strCat (cons msg (cons ' should be a association list, but it is not; its type is ' (cons (getType value) (cons ': ' (cons (show value) nil)))))) result"})((function(){var $m; return function(){return $m || ($m = function(L_msg){return function(L_value){return function(L_result){return resolve(L_assert)((function(){var $m; return function(){return $m || ($m = resolve(L_isAlist)(L_value))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_strCat)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_msg)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(function(){return " should be a association list, but it is not; its type is "})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_getType)(L_value))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(function(){return ": "})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_show)(L_value))}})())(L_nil))}})()))}})()))}})()))}})()))}})()))}})())(L_result)}}})}})()));
runMonad(resolve(L_define)(function(){return "acons"})(function(){return 3})(function(){return "acons k v alist = assertAlist \"acons alist\" alist (\\@ type cons . \\f . \\@ assoc true . f (cons k v) alist)"})((function(){var $m; return function(){return $m || ($m = function(L_k){return function(L_v){return function(L_alist){return resolve(L_assertAlist)(function(){return "acons alist"})(L_alist)((function(){var $m; return function(){return $m || ($m = setType(setLambdaProperties(function(L_f){return resolve(L_f)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_k)(L_v))}})())(L_alist)}, {"assoc":"true"}), 'cons'))}})())}}})}})()));
runMonad(resolve(L_define)(function(){return "assoc"})(function(){return 2})(function(){return "assoc k alist  = find (\\el . eq k (head el)) alist (\\cell . cell \\head tail . some tail) none"})((function(){var $m; return function(){return $m || ($m = function(L_k){return function(L_alist){return resolve(L_find)((function(){var $m; return function(){return $m || ($m = function(L_el){return resolve(L_eq)(L_k)((function(){var $m; return function(){return $m || ($m = resolve(L_head)(L_el))}})())})}})())(L_alist)((function(){var $m; return function(){return $m || ($m = function(L_cell){return resolve(L_cell)((function(){var $m; return function(){return $m || ($m = function(L_head){return function(L_tail){return resolve(L_some)(L_tail)}})}})())})}})())(L_none)}})}})()));
runMonad(resolve(L_define)(function(){return "rassoc"})(function(){return 2})(function(){return "rassoc v alist = find (\\el . eq v (tail el)) alist (\\cell . cell \\head tail . some head) none"})((function(){var $m; return function(){return $m || ($m = function(L_v){return function(L_alist){return resolve(L_find)((function(){var $m; return function(){return $m || ($m = function(L_el){return resolve(L_eq)(L_v)((function(){var $m; return function(){return $m || ($m = resolve(L_tail)(L_el))}})())})}})())(L_alist)((function(){var $m; return function(){return $m || ($m = function(L_cell){return resolve(L_cell)((function(){var $m; return function(){return $m || ($m = function(L_head){return function(L_tail){return resolve(L_some)(L_head)}})}})())})}})())(L_none)}})}})()));
runMonad(resolve(L_define)(function(){return "isAlist"})(function(){return 1})(function(){return "isAlist obj = or (isNil obj) (hasProperty obj 'assoc')"})((function(){var $m; return function(){return $m || ($m = function(L_obj){return resolve(L_or)((function(){var $m; return function(){return $m || ($m = resolve(L_isNil)(L_obj))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_hasProperty)(L_obj)(function(){return "assoc"}))}})())})}})()));
runMonad(resolve(L_define)(function(){return "aconsPair"})(function(){return 2})(function(){return "aconsPair keyValue list = \\@ type cons . \\f . \\@ assoc true . f keyValue list"})((function(){var $m; return function(){return $m || ($m = function(L_keyValue){return function(L_list){return setType(setLambdaProperties(function(L_f){return resolve(L_f)(L_keyValue)(L_list)}, {"assoc":"true"}), 'cons')}})}})()));
runMonad(resolve(L_define)(function(){return "appendAlist"})(function(){return 2})(function(){return "appendAlist a b = isNil a\n  b\n  aconsPair (head a) (appendAlist (tail a) b)"})((function(){var $m; return function(){return $m || ($m = function(L_a){return function(L_b){return resolve(L_isNil)(L_a)(L_b)((function(){var $m; return function(){return $m || ($m = resolve(L_aconsPair)((function(){var $m; return function(){return $m || ($m = resolve(L_head)(L_a))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_appendAlist)((function(){var $m; return function(){return $m || ($m = resolve(L_tail)(L_a))}})())(L_b))}})()))}})())}})}})()));
runMonad(resolve(L_define)(function(){return "keys"})(function(){return 1})(function(){return "keys list = map (\\l . head l) list"})((function(){var $m; return function(){return $m || ($m = function(L_list){return resolve(L_map)((function(){var $m; return function(){return $m || ($m = function(L_l){return resolve(L_head)(L_l)})}})())(L_list)})}})()));
runMonad(resolve(L_define)(function(){return "getProperty"})(function(){return 2})(function(){return "getProperty func prop = getProperties func\n  \\props . assoc prop props\n  none"})((function(){var $m; return function(){return $m || ($m = function(L_func){return function(L_prop){return resolve(L_getProperties)(L_func)((function(){var $m; return function(){return $m || ($m = function(L_props){return resolve(L_assoc)(L_prop)(L_props)})}})())(L_none)}})}})()));
runMonad(resolve(L_define)(function(){return "hasProperty"})(function(){return 2})(function(){return "hasProperty func prop = getProperty func prop\n  \\_ . true\n  false"})((function(){var $m; return function(){return $m || ($m = function(L_func){return function(L_prop){return resolve(L_getProperty)(L_func)(L_prop)((function(){var $m; return function(){return $m || ($m = function(L__){return resolve(L_true)})}})())(L_false)}})}})()));
runMonad(resolve(L_define)(function(){return "quicksort"})(function(){return 2})(function(){return "quicksort less list = (qs less list) nil"})((function(){var $m; return function(){return $m || ($m = function(L_less){return function(L_list){return resolve(L_qs)(L_less)(L_list)(L_nil)}})}})()));
runMonad(resolve(L_define)(function(){return "qs"})(function(){return 2})(function(){return "qs sortedFunc list = list\n  \\h t D . \\\\\n    greater = filter (sortedFunc h) t\n    lesser = filter (compose not (sortedFunc h)) t\n    .\n    \\rest . (qs sortedFunc lesser) (cons h ((qs sortedFunc greater) rest))\n  id"})((function(){var $m; return function(){return $m || ($m = function(L_sortedFunc){return function(L_list){return resolve(L_list)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return (function(){

var L_lesser, L_greater;

L_lesser = (function(){var $m; return function(){return $m || ($m = resolve(L_filter)((function(){var $m; return function(){return $m || ($m = resolve(L_compose)(L_not)((function(){var $m; return function(){return $m || ($m = resolve(L_sortedFunc)(L_h))}})()))}})())(L_t))}})();

L_greater = (function(){var $m; return function(){return $m || ($m = resolve(L_filter)((function(){var $m; return function(){return $m || ($m = resolve(L_sortedFunc)(L_h))}})())(L_t))}})();
return function(L_rest){return resolve(L_qs)(L_sortedFunc)(L_lesser)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_h)((function(){var $m; return function(){return $m || ($m = resolve(L_qs)(L_sortedFunc)(L_greater)(L_rest))}})()))}})())}})()}}})}})())(L_id)}})}})()));
runMonad(resolve(L_define)(function(){return "insertSorted"})(function(){return 3})(function(){return "insertSorted sortFunc item list = list\n  \\h t D . sortFunc item h (cons item list) (cons h (insertSorted sortFunc item t))\n  cons item nil"})((function(){var $m; return function(){return $m || ($m = function(L_sortFunc){return function(L_item){return function(L_list){return resolve(L_list)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return resolve(L_sortFunc)(L_item)(L_h)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_item)(L_list))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_h)((function(){var $m; return function(){return $m || ($m = resolve(L_insertSorted)(L_sortFunc)(L_item)(L_t))}})()))}})())}}})}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_item)(L_nil))}})())}}})}})()));
runMonad(resolve(L_define)(function(){return "token"})(function(){return 2})(function(){return "token txt pos = \\f . f txt pos"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_txt){return function(L_pos){return setType(function(L_f){return resolve(L_f)(L_txt)(L_pos)}, 'token')}}, 'token'))}})()));
runMonad(resolve(L_define)(function(){return "tokenString"})(function(){return 1})(function(){return "tokenString tok = tok \\t p . t"})((function(){var $m; return function(){return $m || ($m = function(L_tok){return resolve(L_tok)((function(){var $m; return function(){return $m || ($m = function(L_t){return function(L_p){return resolve(L_t)}})}})())})}})()));
runMonad(resolve(L_define)(function(){return "tokenPos"})(function(){return 1})(function(){return "tokenPos tok = tok \\t p . p"})((function(){var $m; return function(){return $m || ($m = function(L_tok){return resolve(L_tok)((function(){var $m; return function(){return $m || ($m = function(L_t){return function(L_p){return resolve(L_p)}})}})())})}})()));
runMonad(resolve(L_define)(function(){return "isToken"})(function(){return 1})(function(){return "isToken t = hasType t token"})((function(){var $m; return function(){return $m || ($m = function(L_t){return resolve(L_hasType)(L_t)(L_token)})}})()));
runMonad(resolve(L_define)(function(){return "parens"})(function(){return 3})(function(){return "parens start end content = \\f . f start end content"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_start){return function(L_end){return function(L_content){return setType(function(L_f){return resolve(L_f)(L_start)(L_end)(L_content)}, 'parens')}}}, 'parens'))}})()));
runMonad(resolve(L_define)(function(){return "parensStart"})(function(){return 1})(function(){return "parensStart p = p \\s e c . s"})((function(){var $m; return function(){return $m || ($m = function(L_p){return resolve(L_p)((function(){var $m; return function(){return $m || ($m = function(L_s){return function(L_e){return function(L_c){return resolve(L_s)}}})}})())})}})()));
runMonad(resolve(L_define)(function(){return "parensEnd"})(function(){return 1})(function(){return "parensEnd p = p \\s e c . e"})((function(){var $m; return function(){return $m || ($m = function(L_p){return resolve(L_p)((function(){var $m; return function(){return $m || ($m = function(L_s){return function(L_e){return function(L_c){return resolve(L_e)}}})}})())})}})()));
runMonad(resolve(L_define)(function(){return "parensContent"})(function(){return 1})(function(){return "parensContent p = p \\s e c . c"})((function(){var $m; return function(){return $m || ($m = function(L_p){return resolve(L_p)((function(){var $m; return function(){return $m || ($m = function(L_s){return function(L_e){return function(L_c){return resolve(L_c)}}})}})())})}})()));
runMonad(resolve(L_define)(function(){return "isParens"})(function(){return 1})(function(){return "isParens p = hasType p parens"})((function(){var $m; return function(){return $m || ($m = function(L_p){return resolve(L_hasType)(L_p)(L_parens)})}})()));
runMonad(resolve(L_define)(function(){return "makeParens"})(function(){return 3})(function(){return "makeParens start end content =\n  and (isCons content) (isNil (tail content))\n    makeParens start end (head content)\n    or (isToken content) (isParens content)\n      content\n      parens start end content"})((function(){var $m; return function(){return $m || ($m = function(L_start){return function(L_end){return function(L_content){return resolve(L_and)((function(){var $m; return function(){return $m || ($m = resolve(L_isCons)(L_content))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_isNil)((function(){var $m; return function(){return $m || ($m = resolve(L_tail)(L_content))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_makeParens)(L_start)(L_end)((function(){var $m; return function(){return $m || ($m = resolve(L_head)(L_content))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_or)((function(){var $m; return function(){return $m || ($m = resolve(L_isToken)(L_content))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_isParens)(L_content))}})())(L_content)((function(){var $m; return function(){return $m || ($m = resolve(L_parens)(L_start)(L_end)(L_content))}})()))}})())}}})}})()));
runMonad(resolve(L_define)(function(){return "parensFromToks"})(function(){return 3})(function(){return "parensFromToks left right content = \\\\\n  start = tokenPos left\n  end = + (tokenPos right) (strLen (tokenString right))\n  .\n  parens start end content"})((function(){var $m; return function(){return $m || ($m = function(L_left){return function(L_right){return function(L_content){return (function(){

var L_end, L_start;

L_end = (function(){var $m; return function(){return $m || ($m = resolve(L_$o)((function(){var $m; return function(){return $m || ($m = resolve(L_tokenPos)(L_right))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_strLen)((function(){var $m; return function(){return $m || ($m = resolve(L_tokenString)(L_right))}})()))}})()))}})();

L_start = (function(){var $m; return function(){return $m || ($m = resolve(L_tokenPos)(L_left))}})();
return resolve(L_parens)(L_start)(L_end)(L_content)})()}}})}})()));
runMonad(resolve(L_define)(function(){return "stripParens"})(function(){return 1})(function(){return "stripParens p = isParens p (parensContent p) p"})((function(){var $m; return function(){return $m || ($m = function(L_p){return resolve(L_isParens)(L_p)((function(){var $m; return function(){return $m || ($m = resolve(L_parensContent)(L_p))}})())(L_p)})}})()));
runMonad(resolve(L_define)(function(){return "parseErr"})(function(){return 2})(function(){return "parseErr msg1 msg2 = \\f . f (strCat (cons msg1 (cons msg2 nil)))"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_msg1){return function(L_msg2){return setType(function(L_f){return resolve(L_f)((function(){var $m; return function(){return $m || ($m = resolve(L_strCat)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_msg1)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_msg2)(L_nil))}})()))}})()))}})())}, 'parseErr')}}, 'parseErr'))}})()));
runMonad(resolve(L_define)(function(){return "parseErrMsg"})(function(){return 1})(function(){return "parseErrMsg err = err \\m . m"})((function(){var $m; return function(){return $m || ($m = function(L_err){return resolve(L_err)((function(){var $m; return function(){return $m || ($m = function(L_m){return resolve(L_m)})}})())})}})()));
runMonad(resolve(L_define)(function(){return "isParseErr"})(function(){return 1})(function(){return "isParseErr thing = hasType thing parseErr"})((function(){var $m; return function(){return $m || ($m = function(L_thing){return resolve(L_hasType)(L_thing)(L_parseErr)})}})()));
runMonad(resolve(L_define)(function(){return "emptyToken"})(function(){return 0})(function(){return "emptyToken = regexp '^\\\\n[ \\\\i]*(#|$)'"})((function(){var $m; return function(){return $m || ($m = resolve(L_regexp)(function(){return "^\\n[ \\i]*(#|$)"}))}})()));
runMonad(resolve(L_define)(function(){return "makeTokens"})(function(){return 2})(function(){return "makeTokens strings start = strings (\\h t D . makeMoreTokens h t start) nil"})((function(){var $m; return function(){return $m || ($m = function(L_strings){return function(L_start){return resolve(L_strings)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return resolve(L_makeMoreTokens)(L_h)(L_t)(L_start)}}})}})())(L_nil)}})}})()));
runMonad(resolve(L_define)(function(){return "makeMoreTokens"})(function(){return 3})(function(){return "makeMoreTokens h t start = \\\\\n  next = makeTokens t (+ start (strLen h))\n  .\n  and (strMatches h emptyToken) (or (isNil t) (strStartsWith (head t) '\\n'))\n    makeTokens t (+ start (strLen h))\n    or (strStartsWith h ' ') (strStartsWith h '#')\n      next\n      and (strStartsWith h '\\n') (strStartsWith (head t) '#')\n        makeTokens (tail t) (+ start (+ (strLen h) (strLen (head t))))\n        cons (token h start) next"})((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_start){return (function(){

var L_next;

L_next = (function(){var $m; return function(){return $m || ($m = resolve(L_makeTokens)(L_t)((function(){var $m; return function(){return $m || ($m = resolve(L_$o)(L_start)((function(){var $m; return function(){return $m || ($m = resolve(L_strLen)(L_h))}})()))}})()))}})();
return resolve(L_and)((function(){var $m; return function(){return $m || ($m = resolve(L_strMatches)(L_h)(L_emptyToken))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_or)((function(){var $m; return function(){return $m || ($m = resolve(L_isNil)(L_t))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_strStartsWith)((function(){var $m; return function(){return $m || ($m = resolve(L_head)(L_t))}})())(function(){return "\n"}))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_makeTokens)(L_t)((function(){var $m; return function(){return $m || ($m = resolve(L_$o)(L_start)((function(){var $m; return function(){return $m || ($m = resolve(L_strLen)(L_h))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_or)((function(){var $m; return function(){return $m || ($m = resolve(L_strStartsWith)(L_h)(function(){return " "}))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_strStartsWith)(L_h)(function(){return "#"}))}})())(L_next)((function(){var $m; return function(){return $m || ($m = resolve(L_and)((function(){var $m; return function(){return $m || ($m = resolve(L_strStartsWith)(L_h)(function(){return "\n"}))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_strStartsWith)((function(){var $m; return function(){return $m || ($m = resolve(L_head)(L_t))}})())(function(){return "#"}))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_makeTokens)((function(){var $m; return function(){return $m || ($m = resolve(L_tail)(L_t))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_$o)(L_start)((function(){var $m; return function(){return $m || ($m = resolve(L_$o)((function(){var $m; return function(){return $m || ($m = resolve(L_strLen)(L_h))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_strLen)((function(){var $m; return function(){return $m || ($m = resolve(L_head)(L_t))}})()))}})()))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_token)(L_h)(L_start))}})())(L_next))}})()))}})()))}})())})()}}})}})()));
runMonad(resolve(L_define)(function(){return "splitTokens"})(function(){return 2})(function(){return "splitTokens str pat = filter (\\s . not (eq s '')) (basicSplitTokens str pat true)"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pat){return resolve(L_filter)((function(){var $m; return function(){return $m || ($m = function(L_s){return resolve(L_not)((function(){var $m; return function(){return $m || ($m = resolve(L_eq)(L_s)(function(){return ""}))}})())})}})())((function(){var $m; return function(){return $m || ($m = resolve(L_basicSplitTokens)(L_str)(L_pat)(L_true))}})())}})}})()));
runMonad(resolve(L_define)(function(){return "numberPat"})(function(){return 0})(function(){return "numberPat = regexp '-?([0-9]+(\\\\.[0-9]+)?|\\\\.[0-9]+)'"})((function(){var $m; return function(){return $m || ($m = resolve(L_regexp)(function(){return "-?([0-9]+(\\.[0-9]+)?|\\.[0-9]+)"}))}})()));
runMonad(resolve(L_define)(function(){return "matchOffset"})(function(){return 2})(function(){return "matchOffset str match = isNil match\n  strLen str\n  head (tail (tail match))"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_match){return resolve(L_isNil)(L_match)((function(){var $m; return function(){return $m || ($m = resolve(L_strLen)(L_str))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_head)((function(){var $m; return function(){return $m || ($m = resolve(L_tail)((function(){var $m; return function(){return $m || ($m = resolve(L_tail)(L_match))}})()))}})()))}})())}})}})()));
runMonad(resolve(L_define)(function(){return "basicSplitTokens"})(function(){return 3})(function(){return "basicSplitTokens str pat prevIsDel = == str ''\n  nil\n  \\\\\n    num = strMatch str numberPat\n    del = strMatch str pat\n    numOffset = matchOffset str num\n    delOffset = matchOffset str del\n    select = and (== numOffset 0) prevIsDel\n      \\del num first . num\n      == delOffset 0\n        \\del num first . del\n        \\del num first . first\n    first = select (head del) (head num) (strSubstring str 0 delOffset)\n    .\n    cons\n      first\n      basicSplitTokens\n        strSubstring str (strLen first) 0\n        pat\n        select true false false"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pat){return function(L_prevIsDel){return resolve(L_$p$p)(L_str)(function(){return ""})(L_nil)(function(){
var L_first, L_select, L_delOffset, L_numOffset, L_del, L_num;

L_first = (function(){var $m; return function(){return $m || ($m = resolve(L_select)((function(){var $m; return function(){return $m || ($m = resolve(L_head)(L_del))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_head)(L_num))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_strSubstring)(L_str)(function(){return 0})(L_delOffset))}})()))}})();

L_select = (function(){var $m; return function(){return $m || ($m = resolve(L_and)((function(){var $m; return function(){return $m || ($m = resolve(L_$p$p)(L_numOffset)(function(){return 0}))}})())(L_prevIsDel)((function(){var $m; return function(){return $m || ($m = function(L_del_0){return function(L_num_1){return function(L_first){return resolve(L_num_1)}}})}})())((function(){var $m; return function(){return $m || ($m = resolve(L_$p$p)(L_delOffset)(function(){return 0})((function(){var $m; return function(){return $m || ($m = function(L_del_0){return function(L_num_1){return function(L_first){return resolve(L_del_0)}}})}})())((function(){var $m; return function(){return $m || ($m = function(L_del_0){return function(L_num_1){return function(L_first){return resolve(L_first)}}})}})()))}})()))}})();

L_delOffset = (function(){var $m; return function(){return $m || ($m = resolve(L_matchOffset)(L_str)(L_del))}})();

L_numOffset = (function(){var $m; return function(){return $m || ($m = resolve(L_matchOffset)(L_str)(L_num))}})();

L_del = (function(){var $m; return function(){return $m || ($m = resolve(L_strMatch)(L_str)(L_pat))}})();

L_num = (function(){var $m; return function(){return $m || ($m = resolve(L_strMatch)(L_str)(L_numberPat))}})();
return resolve(L_cons)(L_first)((function(){var $m; return function(){return $m || ($m = resolve(L_basicSplitTokens)((function(){var $m; return function(){return $m || ($m = resolve(L_strSubstring)(L_str)((function(){var $m; return function(){return $m || ($m = resolve(L_strLen)(L_first))}})())(function(){return 0}))}})())(L_pat)((function(){var $m; return function(){return $m || ($m = resolve(L_select)(L_true)(L_false)(L_false))}})()))}})())})}}})}})()));
runMonad(resolve(L_define)(function(){return "tokens"})(function(){return 2})(function(){return "tokens str pat = makeTokens (splitTokens str pat) 0"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pat){return resolve(L_makeTokens)((function(){var $m; return function(){return $m || ($m = resolve(L_splitTokens)(L_str)(L_pat))}})())(function(){return 0})}})}})()));
runMonad(resolve(L_define)(function(){return "isString"})(function(){return 1})(function(){return "isString s = == (getType s) '*string'"})((function(){var $m; return function(){return $m || ($m = function(L_s){return resolve(L_$p$p)((function(){var $m; return function(){return $m || ($m = resolve(L_getType)(L_s))}})())(function(){return "*string"})})}})()));
runMonad(resolve(L_define)(function(){return "isNumber"})(function(){return 1})(function(){return "isNumber s = == (getType s) '*number'"})((function(){var $m; return function(){return $m || ($m = function(L_s){return resolve(L_$p$p)((function(){var $m; return function(){return $m || ($m = resolve(L_getType)(L_s))}})())(function(){return "*number"})})}})()));
runMonad(resolve(L_define)(function(){return "isTokenString"})(function(){return 2})(function(){return "isTokenString tok str = or\n  and (isToken tok) (eq (tokenString tok) str)\n  and (isString tok) (eq tok str)"})((function(){var $m; return function(){return $m || ($m = function(L_tok){return function(L_str){return resolve(L_or)((function(){var $m; return function(){return $m || ($m = resolve(L_and)((function(){var $m; return function(){return $m || ($m = resolve(L_isToken)(L_tok))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_eq)((function(){var $m; return function(){return $m || ($m = resolve(L_tokenString)(L_tok))}})())(L_str))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_and)((function(){var $m; return function(){return $m || ($m = resolve(L_isString)(L_tok))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_eq)(L_tok)(L_str))}})()))}})())}})}})()));
runMonad(resolve(L_define)(function(){return "isTokenStart"})(function(){return 2})(function(){return "isTokenStart tok str = or\n  and (isToken tok) (strStartsWith (tokenString tok) str)\n  and (isString tok) (strStartsWith tok str)"})((function(){var $m; return function(){return $m || ($m = function(L_tok){return function(L_str){return resolve(L_or)((function(){var $m; return function(){return $m || ($m = resolve(L_and)((function(){var $m; return function(){return $m || ($m = resolve(L_isToken)(L_tok))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_strStartsWith)((function(){var $m; return function(){return $m || ($m = resolve(L_tokenString)(L_tok))}})())(L_str))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_and)((function(){var $m; return function(){return $m || ($m = resolve(L_isString)(L_tok))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_strStartsWith)(L_tok)(L_str))}})()))}})())}})}})()));
runMonad(resolve(L_define)(function(){return "strTokenString"})(function(){return 1})(function(){return "strTokenString tok = withToken tok nil \\str pos . str"})((function(){var $m; return function(){return $m || ($m = function(L_tok){return resolve(L_withToken)(L_tok)(L_nil)((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pos){return resolve(L_str)}})}})())})}})()));
runMonad(resolve(L_define)(function(){return "withToken"})(function(){return 3})(function(){return "withToken tok nonTokCase tokCase = isToken tok\n  tok tokCase\n  isString tok\n    tokCase tok -1\n    nonTokCase"})((function(){var $m; return function(){return $m || ($m = function(L_tok){return function(L_nonTokCase){return function(L_tokCase){return resolve(L_isToken)(L_tok)((function(){var $m; return function(){return $m || ($m = resolve(L_tok)(L_tokCase))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_isString)(L_tok)((function(){var $m; return function(){return $m || ($m = resolve(L_tokCase)(L_tok)(function(){return -1}))}})())(L_nonTokCase))}})())}}})}})()));
runMonad(resolve(L_define)(function(){return "withCons"})(function(){return 3})(function(){return "withCons l nilCase cont = isCons l (l (\\h t D . cont h t) nilCase) nilCase"})((function(){var $m; return function(){return $m || ($m = function(L_l){return function(L_nilCase){return function(L_cont){return resolve(L_isCons)(L_l)((function(){var $m; return function(){return $m || ($m = resolve(L_l)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return resolve(L_cont)(L_h)(L_t)}}})}})())(L_nilCase))}})())(L_nilCase)}}})}})()));
runMonad(resolve(L_define)(function(){return "ifNotErr"})(function(){return 2})(function(){return "ifNotErr thing cont = hasType thing parseErr thing (cont thing)"})((function(){var $m; return function(){return $m || ($m = function(L_thing){return function(L_cont){return resolve(L_hasType)(L_thing)(L_parseErr)(L_thing)((function(){var $m; return function(){return $m || ($m = resolve(L_cont)(L_thing))}})())}})}})()));
runMonad(resolve(L_define)(function(){return "parseToks"})(function(){return 2})(function(){return "parseToks toks groups =\n  isNil toks nil\n    ifNotErr (parseTok toks groups) \\list . list \\h t .\n      ifNotErr (parseToks t groups) \\res .\n        cons h\n          and (isCons res) (isBlockStart (head res))\n            cons res nil\n            res"})((function(){var $m; return function(){return $m || ($m = function(L_toks){return function(L_groups){return resolve(L_isNil)(L_toks)(L_nil)((function(){var $m; return function(){return $m || ($m = resolve(L_ifNotErr)((function(){var $m; return function(){return $m || ($m = resolve(L_parseTok)(L_toks)(L_groups))}})())((function(){var $m; return function(){return $m || ($m = function(L_list){return resolve(L_list)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return resolve(L_ifNotErr)((function(){var $m; return function(){return $m || ($m = resolve(L_parseToks)(L_t)(L_groups))}})())((function(){var $m; return function(){return $m || ($m = function(L_res){return resolve(L_cons)(L_h)((function(){var $m; return function(){return $m || ($m = resolve(L_and)((function(){var $m; return function(){return $m || ($m = resolve(L_isCons)(L_res))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_isBlockStart)((function(){var $m; return function(){return $m || ($m = resolve(L_head)(L_res))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_res)(L_nil))}})())(L_res))}})())})}})())}})}})())})}})()))}})())}})}})()));
runMonad(resolve(L_define)(function(){return "parseTok"})(function(){return 2})(function(){return "parseTok toks groups = withCons toks nil \\h t .\n  withToken h toks \\txt pos .\n    assoc txt groups\n      \\close . parseGroup h t nil close groups\n      isTokenStart h '\\n' (parseIndent h t nil groups)\n        toks"})((function(){var $m; return function(){return $m || ($m = function(L_toks){return function(L_groups){return resolve(L_withCons)(L_toks)(L_nil)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return resolve(L_withToken)(L_h)(L_toks)((function(){var $m; return function(){return $m || ($m = function(L_txt){return function(L_pos){return resolve(L_assoc)(L_txt)(L_groups)((function(){var $m; return function(){return $m || ($m = function(L_close){return resolve(L_parseGroup)(L_h)(L_t)(L_nil)(L_close)(L_groups)})}})())((function(){var $m; return function(){return $m || ($m = resolve(L_isTokenStart)(L_h)(function(){return "\n"})((function(){var $m; return function(){return $m || ($m = resolve(L_parseIndent)(L_h)(L_t)(L_nil)(L_groups))}})())(L_toks))}})())}})}})())}})}})())}})}})()));
runMonad(resolve(L_define)(function(){return "parseGroup"})(function(){return 5})(function(){return "parseGroup left toks gr close groups = withCons toks (parseErr 'Unterminated group starting ' (loc left))\n  \\h t . isTokenString h close\n    eq close ')'\n      cons (parensFromToks left h (reverse gr)) t\n      cons (cons left (cons (reverse gr) (cons h nil))) t\n    withToken h\n      ifNotErr (parseTok toks groups) \\list . list \\restH restT .\n        parseGroup left restT (cons restH gr) close groups\n      \\txt pos .\n        rassoc txt groups\n          \\open . parseErr (strCat (cons 'Mismatched group: ' (cons (tokenString left) (cons txt (cons ' ' nil))))) (loc left)\n          ifNotErr (parseTok toks groups) \\list . list \\restH restT . parseGroup left restT (cons restH gr) close groups"})((function(){var $m; return function(){return $m || ($m = function(L_left){return function(L_toks){return function(L_gr){return function(L_close){return function(L_groups){return resolve(L_withCons)(L_toks)((function(){var $m; return function(){return $m || ($m = resolve(L_parseErr)(function(){return "Unterminated group starting "})((function(){var $m; return function(){return $m || ($m = resolve(L_loc)(L_left))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return resolve(L_isTokenString)(L_h)(L_close)((function(){var $m; return function(){return $m || ($m = resolve(L_eq)(L_close)(function(){return ")"})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_parensFromToks)(L_left)(L_h)((function(){var $m; return function(){return $m || ($m = resolve(L_reverse)(L_gr))}})()))}})())(L_t))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_left)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_reverse)(L_gr))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_h)(L_nil))}})()))}})()))}})())(L_t))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_withToken)(L_h)((function(){var $m; return function(){return $m || ($m = resolve(L_ifNotErr)((function(){var $m; return function(){return $m || ($m = resolve(L_parseTok)(L_toks)(L_groups))}})())((function(){var $m; return function(){return $m || ($m = function(L_list){return resolve(L_list)((function(){var $m; return function(){return $m || ($m = function(L_restH){return function(L_restT){return resolve(L_parseGroup)(L_left)(L_restT)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_restH)(L_gr))}})())(L_close)(L_groups)}})}})())})}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_txt){return function(L_pos){return resolve(L_rassoc)(L_txt)(L_groups)((function(){var $m; return function(){return $m || ($m = function(L_open){return resolve(L_parseErr)((function(){var $m; return function(){return $m || ($m = resolve(L_strCat)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(function(){return "Mismatched group: "})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_tokenString)(L_left))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_txt)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(function(){return " "})(L_nil))}})()))}})()))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_loc)(L_left))}})())})}})())((function(){var $m; return function(){return $m || ($m = resolve(L_ifNotErr)((function(){var $m; return function(){return $m || ($m = resolve(L_parseTok)(L_toks)(L_groups))}})())((function(){var $m; return function(){return $m || ($m = function(L_list){return resolve(L_list)((function(){var $m; return function(){return $m || ($m = function(L_restH){return function(L_restT){return resolve(L_parseGroup)(L_left)(L_restT)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_restH)(L_gr))}})())(L_close)(L_groups)}})}})())})}})()))}})())}})}})()))}})())}})}})())}}}}})}})()));
runMonad(resolve(L_define)(function(){return "parseIndent"})(function(){return 4})(function(){return "parseIndent indent toks gr groups =\n  withCons toks (cons (makeParens (tokenPos indent) (lexEnd (head gr)) (reverse gr)) nil)\n    \\h t . or (withToken h false (\\txt pos . rassoc txt groups (\\open . true) false))\n      and (isTokenStart h '\\n') (<= (strLen (tokenString h)) (strLen (tokenString indent)))\n      cons (makeParens (tokenPos indent) (tokenPos h) (reverse gr)) toks\n      ifNotErr (parseTok toks groups) \\list . list \\restH restT . parseIndent indent restT (cons restH gr) groups"})((function(){var $m; return function(){return $m || ($m = function(L_indent){return function(L_toks){return function(L_gr){return function(L_groups){return resolve(L_withCons)(L_toks)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_makeParens)((function(){var $m; return function(){return $m || ($m = resolve(L_tokenPos)(L_indent))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_lexEnd)((function(){var $m; return function(){return $m || ($m = resolve(L_head)(L_gr))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_reverse)(L_gr))}})()))}})())(L_nil))}})())((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return resolve(L_or)((function(){var $m; return function(){return $m || ($m = resolve(L_withToken)(L_h)(L_false)((function(){var $m; return function(){return $m || ($m = function(L_txt){return function(L_pos){return resolve(L_rassoc)(L_txt)(L_groups)((function(){var $m; return function(){return $m || ($m = function(L_open){return resolve(L_true)})}})())(L_false)}})}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_and)((function(){var $m; return function(){return $m || ($m = resolve(L_isTokenStart)(L_h)(function(){return "\n"}))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_$y$p)((function(){var $m; return function(){return $m || ($m = resolve(L_strLen)((function(){var $m; return function(){return $m || ($m = resolve(L_tokenString)(L_h))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_strLen)((function(){var $m; return function(){return $m || ($m = resolve(L_tokenString)(L_indent))}})()))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_makeParens)((function(){var $m; return function(){return $m || ($m = resolve(L_tokenPos)(L_indent))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_tokenPos)(L_h))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_reverse)(L_gr))}})()))}})())(L_toks))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_ifNotErr)((function(){var $m; return function(){return $m || ($m = resolve(L_parseTok)(L_toks)(L_groups))}})())((function(){var $m; return function(){return $m || ($m = function(L_list){return resolve(L_list)((function(){var $m; return function(){return $m || ($m = function(L_restH){return function(L_restT){return resolve(L_parseIndent)(L_indent)(L_restT)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_restH)(L_gr))}})())(L_groups)}})}})())})}})()))}})())}})}})())}}}})}})()));
runMonad(resolve(L_define)(function(){return "lit"})(function(){return 1})(function(){return "lit value = \\f . f value"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_value){return setType(function(L_f){return resolve(L_f)(L_value)}, 'lit')}, 'lit'))}})()));
runMonad(resolve(L_define)(function(){return "ref"})(function(){return 1})(function(){return "ref name = \\f . f name"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_name){return setType(function(L_f){return resolve(L_f)(L_name)}, 'ref')}, 'ref'))}})()));
runMonad(resolve(L_define)(function(){return "lambda"})(function(){return 2})(function(){return "lambda name body = \\f . f name body"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_name){return function(L_body){return setType(function(L_f){return resolve(L_f)(L_name)(L_body)}, 'lambda')}}, 'lambda'))}})()));
runMonad(resolve(L_define)(function(){return "apply"})(function(){return 2})(function(){return "apply func arg = \\f . f func arg"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_func){return function(L_arg){return setType(function(L_f){return resolve(L_f)(L_func)(L_arg)}, 'apply')}}, 'apply'))}})()));
runMonad(resolve(L_define)(function(){return "let"})(function(){return 3})(function(){return "let name value body = \\f . f name value body"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_name){return function(L_value){return function(L_body){return setType(function(L_f){return resolve(L_f)(L_name)(L_value)(L_body)}, 'let')}}}, 'let'))}})()));
runMonad(resolve(L_define)(function(){return "anno"})(function(){return 3})(function(){return "anno name data body = \\f . f name data body"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_name){return function(L_data){return function(L_body){return setType(function(L_f){return resolve(L_f)(L_name)(L_data)(L_body)}, 'anno')}}}, 'anno'))}})()));
runMonad(resolve(L_define)(function(){return "withParens"})(function(){return 3})(function(){return "withParens p err cont = isParens p (p cont) err"})((function(){var $m; return function(){return $m || ($m = function(L_p){return function(L_err){return function(L_cont){return resolve(L_isParens)(L_p)((function(){var $m; return function(){return $m || ($m = resolve(L_p)(L_cont))}})())(L_err)}}})}})()));
runMonad(resolve(L_define)(function(){return "setParens"})(function(){return 2})(function(){return "setParens p func = isParens p\n  p \\start end content . parens start end (func content)\n  func p"})((function(){var $m; return function(){return $m || ($m = function(L_p){return function(L_func){return resolve(L_isParens)(L_p)((function(){var $m; return function(){return $m || ($m = resolve(L_p)((function(){var $m; return function(){return $m || ($m = function(L_start){return function(L_end){return function(L_content){return resolve(L_parens)(L_start)(L_end)((function(){var $m; return function(){return $m || ($m = resolve(L_func)(L_content))}})())}}})}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_func)(L_p))}})())}})}})()));
runMonad(resolve(L_define)(function(){return "withStripped"})(function(){return 2})(function(){return "withStripped list cont = withParens list (cont list) \\start end content . withStripped content cont"})((function(){var $m; return function(){return $m || ($m = function(L_list){return function(L_cont){return resolve(L_withParens)(L_list)((function(){var $m; return function(){return $m || ($m = resolve(L_cont)(L_list))}})())((function(){var $m; return function(){return $m || ($m = function(L_start){return function(L_end){return function(L_content){return resolve(L_withStripped)(L_content)(L_cont)}}})}})())}})}})()));
runMonad(resolve(L_define)(function(){return "position"})(function(){return 1})(function(){return "position thing = isToken thing (tokenPos thing)\n  isParens thing (parensStart thing)\n    isCons thing (position (head thing))\n      -1"})((function(){var $m; return function(){return $m || ($m = function(L_thing){return resolve(L_isToken)(L_thing)((function(){var $m; return function(){return $m || ($m = resolve(L_tokenPos)(L_thing))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_isParens)(L_thing)((function(){var $m; return function(){return $m || ($m = resolve(L_parensStart)(L_thing))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_isCons)(L_thing)((function(){var $m; return function(){return $m || ($m = resolve(L_position)((function(){var $m; return function(){return $m || ($m = resolve(L_head)(L_thing))}})()))}})())(function(){return -1}))}})()))}})())})}})()));
runMonad(resolve(L_define)(function(){return "lexEnd"})(function(){return 1})(function(){return "lexEnd thing = isToken thing (+ (tokenPos thing) (strLen (tokenString thing)))\n  isParens thing (parensEnd thing)\n    isCons thing (lexEnd (last thing))\n      -1"})((function(){var $m; return function(){return $m || ($m = function(L_thing){return resolve(L_isToken)(L_thing)((function(){var $m; return function(){return $m || ($m = resolve(L_$o)((function(){var $m; return function(){return $m || ($m = resolve(L_tokenPos)(L_thing))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_strLen)((function(){var $m; return function(){return $m || ($m = resolve(L_tokenString)(L_thing))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_isParens)(L_thing)((function(){var $m; return function(){return $m || ($m = resolve(L_parensEnd)(L_thing))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_isCons)(L_thing)((function(){var $m; return function(){return $m || ($m = resolve(L_lexEnd)((function(){var $m; return function(){return $m || ($m = resolve(L_last)(L_thing))}})()))}})())(function(){return -1}))}})()))}})())})}})()));
runMonad(resolve(L_define)(function(){return "loc"})(function(){return 1})(function(){return "loc thing = \\\\\n  p = position thing\n  l = eq p -1 'an unknown location' p\n  .\n  strCat (cons 'at ' (cons l nil))"})((function(){var $m; return function(){return $m || ($m = function(L_thing){return (function(){

var L_l, L_p;

L_l = (function(){var $m; return function(){return $m || ($m = resolve(L_eq)(L_p)(function(){return -1})(function(){return "an unknown location"})(L_p))}})();

L_p = (function(){var $m; return function(){return $m || ($m = resolve(L_position)(L_thing))}})();
return resolve(L_strCat)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(function(){return "at "})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_l)(L_nil))}})()))}})())})()})}})()));
runMonad(resolve(L_define)(function(){return "scrub"})(function(){return 1})(function(){return "scrub str = strFromList (scrubList (strToList str))"})((function(){var $m; return function(){return $m || ($m = function(L_str){return resolve(L_strFromList)((function(){var $m; return function(){return $m || ($m = resolve(L_scrubList)((function(){var $m; return function(){return $m || ($m = resolve(L_strToList)(L_str))}})()))}})())})}})()));
runMonad(resolve(L_define)(function(){return "scrubList"})(function(){return 1})(function(){return "scrubList list = list\n  \\h t D . \\\\\n    next = scrubList t\n    .\n    eq h '\\\\' (cons h (cons (head t) (scrubList (tail t))))\n      eq h '\\\"' (cons '\\\\' (cons '\\\"' next))\n        cons h next\n  nil"})((function(){var $m; return function(){return $m || ($m = function(L_list){return resolve(L_list)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return (function(){

var L_next;

L_next = (function(){var $m; return function(){return $m || ($m = resolve(L_scrubList)(L_t))}})();
return resolve(L_eq)(L_h)(function(){return "\\"})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_h)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_head)(L_t))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_scrubList)((function(){var $m; return function(){return $m || ($m = resolve(L_tail)(L_t))}})()))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_eq)(L_h)(function(){return "\""})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(function(){return "\\"})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(function(){return "\""})(L_next))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_h)(L_next))}})()))}})())})()}}})}})())(L_nil)})}})()));
runMonad(resolve(L_define)(function(){return "createAst"})(function(){return 2})(function(){return "createAst inList names = withStripped inList \\list .\n  isToken list (createLitOrRef (tokenString list) names)\n    list\n      \\h t D .\n        isTokenString h '\\\\\\\\' (createLet h t names)\n          isTokenString h '\\\\@' (createAnno h t names)\n            isTokenString h '\\\\' (createLambda h t names)\n              createApply list names\n      nil"})((function(){var $m; return function(){return $m || ($m = function(L_inList){return function(L_names){return resolve(L_withStripped)(L_inList)((function(){var $m; return function(){return $m || ($m = function(L_list){return resolve(L_isToken)(L_list)((function(){var $m; return function(){return $m || ($m = resolve(L_createLitOrRef)((function(){var $m; return function(){return $m || ($m = resolve(L_tokenString)(L_list))}})())(L_names))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_list)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return resolve(L_isTokenString)(L_h)(function(){return "\\\\"})((function(){var $m; return function(){return $m || ($m = resolve(L_createLet)(L_h)(L_t)(L_names))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_isTokenString)(L_h)(function(){return "\\@"})((function(){var $m; return function(){return $m || ($m = resolve(L_createAnno)(L_h)(L_t)(L_names))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_isTokenString)(L_h)(function(){return "\\"})((function(){var $m; return function(){return $m || ($m = resolve(L_createLambda)(L_h)(L_t)(L_names))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_createApply)(L_list)(L_names))}})()))}})()))}})())}}})}})())(L_nil))}})())})}})())}})}})()));
runMonad(resolve(L_define)(function(){return "strMatches"})(function(){return 2})(function(){return "strMatches str pat = isCons (strMatch str pat)"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pat){return resolve(L_isCons)((function(){var $m; return function(){return $m || ($m = resolve(L_strMatch)(L_str)(L_pat))}})())}})}})()));
runMonad(resolve(L_define)(function(){return "digit"})(function(){return 0})(function(){return "digit = regexp '^[0-9]+$'"})((function(){var $m; return function(){return $m || ($m = resolve(L_regexp)(function(){return "^[0-9]+$"}))}})()));
runMonad(resolve(L_define)(function(){return "backslashCodes"})(function(){return 0})(function(){return "backslashCodes = 'bfnrt'"})(function(){return "bfnrt"}));
runMonad(resolve(L_define)(function(){return "backslashValues"})(function(){return 0})(function(){return "backslashValues = '\\b\\f\\n\\r\\t'"})(function(){return "\b\f\n\r\t"}));
runMonad(resolve(L_define)(function(){return "convertStringEscape"})(function(){return 3})(function(){return "convertStringEscape char codes values =\n  eq codes ''\n    char\n    eq char (strAt codes 0)\n      strAt values 0\n      convertStringEscape char (strSubstring codes 1 0) (strSubstring values 1 0)"})((function(){var $m; return function(){return $m || ($m = function(L_char){return function(L_codes){return function(L_values){return resolve(L_eq)(L_codes)(function(){return ""})(L_char)((function(){var $m; return function(){return $m || ($m = resolve(L_eq)(L_char)((function(){var $m; return function(){return $m || ($m = resolve(L_strAt)(L_codes)(function(){return 0}))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_strAt)(L_values)(function(){return 0}))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_convertStringEscape)(L_char)((function(){var $m; return function(){return $m || ($m = resolve(L_strSubstring)(L_codes)(function(){return 1})(function(){return 0}))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_strSubstring)(L_values)(function(){return 1})(function(){return 0}))}})()))}})()))}})())}}})}})()));
runMonad(resolve(L_define)(function(){return "convertStringEscapes"})(function(){return 3})(function(){return "convertStringEscapes orig str cont =\n  eq str ''\n    cont str\n    eq (strAt str 0) '\\\\'\n      eq (strLen str) 1 (parseErr \"Error, backslash without character in string: \" orig)\n        convertStringEscapes orig (strSubstring str 2 0) \\rest . cont\n          strAdd\n            convertStringEscape (strAt str 1) backslashCodes backslashValues\n            rest\n      convertStringEscapes orig (strSubstring str 1 0) \\rest . cont\n        strAdd\n          strAt str 0\n          rest"})((function(){var $m; return function(){return $m || ($m = function(L_orig){return function(L_str){return function(L_cont){return resolve(L_eq)(L_str)(function(){return ""})((function(){var $m; return function(){return $m || ($m = resolve(L_cont)(L_str))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_eq)((function(){var $m; return function(){return $m || ($m = resolve(L_strAt)(L_str)(function(){return 0}))}})())(function(){return "\\"})((function(){var $m; return function(){return $m || ($m = resolve(L_eq)((function(){var $m; return function(){return $m || ($m = resolve(L_strLen)(L_str))}})())(function(){return 1})((function(){var $m; return function(){return $m || ($m = resolve(L_parseErr)(function(){return "Error, backslash without character in string: "})(L_orig))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_convertStringEscapes)(L_orig)((function(){var $m; return function(){return $m || ($m = resolve(L_strSubstring)(L_str)(function(){return 2})(function(){return 0}))}})())((function(){var $m; return function(){return $m || ($m = function(L_rest){return resolve(L_cont)((function(){var $m; return function(){return $m || ($m = resolve(L_strAdd)((function(){var $m; return function(){return $m || ($m = resolve(L_convertStringEscape)((function(){var $m; return function(){return $m || ($m = resolve(L_strAt)(L_str)(function(){return 1}))}})())(L_backslashCodes)(L_backslashValues))}})())(L_rest))}})())})}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_convertStringEscapes)(L_orig)((function(){var $m; return function(){return $m || ($m = resolve(L_strSubstring)(L_str)(function(){return 1})(function(){return 0}))}})())((function(){var $m; return function(){return $m || ($m = function(L_rest){return resolve(L_cont)((function(){var $m; return function(){return $m || ($m = resolve(L_strAdd)((function(){var $m; return function(){return $m || ($m = resolve(L_strAt)(L_str)(function(){return 0}))}})())(L_rest))}})())})}})()))}})()))}})())}}})}})()));
runMonad(resolve(L_define)(function(){return "parseString"})(function(){return 2})(function(){return "parseString str cont =\n  neq (strAt str 0) (strAt str -1) (parseErr \"Badly terminated string: \" str)\n    convertStringEscapes str (strSubstring str 1 -1) cont"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_cont){return resolve(L_neq)((function(){var $m; return function(){return $m || ($m = resolve(L_strAt)(L_str)(function(){return 0}))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_strAt)(L_str)(function(){return -1}))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_parseErr)(function(){return "Badly terminated string: "})(L_str))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_convertStringEscapes)(L_str)((function(){var $m; return function(){return $m || ($m = resolve(L_strSubstring)(L_str)(function(){return 1})(function(){return -1}))}})())(L_cont))}})())}})}})()));
runMonad(resolve(L_define)(function(){return "createLitOrRef"})(function(){return 2})(function(){return "createLitOrRef tok names =\n  contains names tok\n    ref tok\n    or (strStartsWith tok '\\\"') (strStartsWith tok \"'\")\n      parseString tok \\str . lit str\n      strStartsWith tok '.'\n        jsonParse (strCat (cons '0' (cons tok nil))) (\\err . ref tok) (\\item . lit item)\n        or (and (>= (strAt tok 0) '0') (<= (strAt tok 0) '9')) (strStartsWith tok '-')\n          jsonParse tok (\\err . ref tok) (\\item . lit item)\n          ref tok"})((function(){var $m; return function(){return $m || ($m = function(L_tok){return function(L_names){return resolve(L_contains)(L_names)(L_tok)((function(){var $m; return function(){return $m || ($m = resolve(L_ref)(L_tok))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_or)((function(){var $m; return function(){return $m || ($m = resolve(L_strStartsWith)(L_tok)(function(){return "\""}))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_strStartsWith)(L_tok)(function(){return "'"}))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_parseString)(L_tok)((function(){var $m; return function(){return $m || ($m = function(L_str){return resolve(L_lit)(L_str)})}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_strStartsWith)(L_tok)(function(){return "."})((function(){var $m; return function(){return $m || ($m = resolve(L_jsonParse)((function(){var $m; return function(){return $m || ($m = resolve(L_strCat)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(function(){return "0"})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_tok)(L_nil))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_err){return resolve(L_ref)(L_tok)})}})())((function(){var $m; return function(){return $m || ($m = function(L_item){return resolve(L_lit)(L_item)})}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_or)((function(){var $m; return function(){return $m || ($m = resolve(L_and)((function(){var $m; return function(){return $m || ($m = resolve(L_$z$p)((function(){var $m; return function(){return $m || ($m = resolve(L_strAt)(L_tok)(function(){return 0}))}})())(function(){return "0"}))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_$y$p)((function(){var $m; return function(){return $m || ($m = resolve(L_strAt)(L_tok)(function(){return 0}))}})())(function(){return "9"}))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_strStartsWith)(L_tok)(function(){return "-"}))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_jsonParse)(L_tok)((function(){var $m; return function(){return $m || ($m = function(L_err){return resolve(L_ref)(L_tok)})}})())((function(){var $m; return function(){return $m || ($m = function(L_item){return resolve(L_lit)(L_item)})}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_ref)(L_tok))}})()))}})()))}})()))}})())}})}})()));
runMonad(resolve(L_define)(function(){return "createLambda"})(function(){return 3})(function(){return "createLambda start list names = \\\\\n  err = parseErr \"Lambda needs a variable name, a dot, and a body \" (loc start)\n  .\n  withCons list err \\name rest .\n    withToken name err \\n p .\n      withCons rest err \\dot body .\n        # are these partial applications too hard to read?\n        isTokenString dot '.'\n          ifNotErr (createAst body (cons n names)) \\bodyAst . lambda n bodyAst\n          ifNotErr (createLambda start rest (cons n names)) \\bodyAst . lambda n bodyAst"})((function(){var $m; return function(){return $m || ($m = function(L_start){return function(L_list){return function(L_names){return (function(){

var L_err;

L_err = (function(){var $m; return function(){return $m || ($m = resolve(L_parseErr)(function(){return "Lambda needs a variable name, a dot, and a body "})((function(){var $m; return function(){return $m || ($m = resolve(L_loc)(L_start))}})()))}})();
return resolve(L_withCons)(L_list)(L_err)((function(){var $m; return function(){return $m || ($m = function(L_name){return function(L_rest){return resolve(L_withToken)(L_name)(L_err)((function(){var $m; return function(){return $m || ($m = function(L_n){return function(L_p){return resolve(L_withCons)(L_rest)(L_err)((function(){var $m; return function(){return $m || ($m = function(L_dot){return function(L_body){return resolve(L_isTokenString)(L_dot)(function(){return "."})((function(){var $m; return function(){return $m || ($m = resolve(L_ifNotErr)((function(){var $m; return function(){return $m || ($m = resolve(L_createAst)(L_body)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_n)(L_names))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_bodyAst){return resolve(L_lambda)(L_n)(L_bodyAst)})}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_ifNotErr)((function(){var $m; return function(){return $m || ($m = resolve(L_createLambda)(L_start)(L_rest)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_n)(L_names))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_bodyAst){return resolve(L_lambda)(L_n)(L_bodyAst)})}})()))}})())}})}})())}})}})())}})}})())})()}}})}})()));
runMonad(resolve(L_define)(function(){return "createAnno"})(function(){return 3})(function(){return "createAnno start list names =\n  withCons list (parseErr \"No annotation name or data in annotation \" (loc start)) \\name rest .\n    withCons rest (parseErr \"No data for annotation \" (loc start)) \\data rest . \\\\\n      finish data body = ifNotErr (createAst body names) \\bodyAst .\n        cleanTokens start name \\name .\n          cleanTokens start data \\data .\n            anno name data bodyAst\n      .\n      isTokenString data '.'\n        finish nil rest\n        withStripped data \\data .\n          withCons rest (parseErr \"No body for annotation \" (loc start)) \\dot body .\n            isTokenString dot '.'\n              finish data body\n              parseErr \"Annotation expects dot after name and data \" (loc start)"})((function(){var $m; return function(){return $m || ($m = function(L_start){return function(L_list){return function(L_names){return resolve(L_withCons)(L_list)((function(){var $m; return function(){return $m || ($m = resolve(L_parseErr)(function(){return "No annotation name or data in annotation "})((function(){var $m; return function(){return $m || ($m = resolve(L_loc)(L_start))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_name){return function(L_rest){return resolve(L_withCons)(L_rest)((function(){var $m; return function(){return $m || ($m = resolve(L_parseErr)(function(){return "No data for annotation "})((function(){var $m; return function(){return $m || ($m = resolve(L_loc)(L_start))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_data){return function(L_rest_0){return (function(){

var L_finish;

L_finish = (function(){var $m; return function(){return $m || ($m = function(L_data_1){return function(L_body){return resolve(L_ifNotErr)((function(){var $m; return function(){return $m || ($m = resolve(L_createAst)(L_body)(L_names))}})())((function(){var $m; return function(){return $m || ($m = function(L_bodyAst){return resolve(L_cleanTokens)(L_start)(L_name)((function(){var $m; return function(){return $m || ($m = function(L_name_2){return resolve(L_cleanTokens)(L_start)(L_data_1)((function(){var $m; return function(){return $m || ($m = function(L_data_3){return resolve(L_anno)(L_name_2)(L_data_3)(L_bodyAst)})}})())})}})())})}})())}})}})();
return resolve(L_isTokenString)(L_data)(function(){return "."})((function(){var $m; return function(){return $m || ($m = resolve(L_finish)(L_nil)(L_rest_0))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_withStripped)(L_data)((function(){var $m; return function(){return $m || ($m = function(L_data_1){return resolve(L_withCons)(L_rest_0)((function(){var $m; return function(){return $m || ($m = resolve(L_parseErr)(function(){return "No body for annotation "})((function(){var $m; return function(){return $m || ($m = resolve(L_loc)(L_start))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_dot){return function(L_body){return resolve(L_isTokenString)(L_dot)(function(){return "."})((function(){var $m; return function(){return $m || ($m = resolve(L_finish)(L_data_1)(L_body))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_parseErr)(function(){return "Annotation expects dot after name and data "})((function(){var $m; return function(){return $m || ($m = resolve(L_loc)(L_start))}})()))}})())}})}})())})}})()))}})())})()}})}})())}})}})())}}})}})()));
runMonad(resolve(L_define)(function(){return "bodyStructPat"})(function(){return 0})(function(){return "bodyStructPat = regexp '\\\\|\\\\\\\\|\\\\@'"})((function(){var $m; return function(){return $m || ($m = resolve(L_regexp)(function(){return "\\|\\\\|\\@"}))}})()));
runMonad(resolve(L_define)(function(){return "createApply"})(function(){return 2})(function(){return "createApply inList names = withStripped inList \\list .\n  withCons list (parseErr \"Funcion apply expecting a non-empty list \" (loc inList)) \\h t .\n    ifNotErr (createAst h names) \\func . chainApply func t names"})((function(){var $m; return function(){return $m || ($m = function(L_inList){return function(L_names){return resolve(L_withStripped)(L_inList)((function(){var $m; return function(){return $m || ($m = function(L_list){return resolve(L_withCons)(L_list)((function(){var $m; return function(){return $m || ($m = resolve(L_parseErr)(function(){return "Funcion apply expecting a non-empty list "})((function(){var $m; return function(){return $m || ($m = resolve(L_loc)(L_inList))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return resolve(L_ifNotErr)((function(){var $m; return function(){return $m || ($m = resolve(L_createAst)(L_h)(L_names))}})())((function(){var $m; return function(){return $m || ($m = function(L_func){return resolve(L_chainApply)(L_func)(L_t)(L_names)})}})())}})}})())})}})())}})}})()));
runMonad(resolve(L_define)(function(){return "blockStarts"})(function(){return 0})(function(){return "blockStarts = cons '\\\\' (cons '\\\\\\\\' (cons '\\\\@' nil))"})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(function(){return "\\"})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(function(){return "\\\\"})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(function(){return "\\@"})(L_nil))}})()))}})()))}})()));
runMonad(resolve(L_define)(function(){return "chainApply"})(function(){return 3})(function(){return "chainApply func list names = withCons list func \\argItem rest .\n  and (isToken argItem) (contains blockStarts (tokenString argItem))\n    ifNotErr (createAst list names) \\arg . apply func arg\n    ifNotErr (createAst argItem names) \\arg . chainApply (apply func arg) rest names"})((function(){var $m; return function(){return $m || ($m = function(L_func){return function(L_list){return function(L_names){return resolve(L_withCons)(L_list)(L_func)((function(){var $m; return function(){return $m || ($m = function(L_argItem){return function(L_rest){return resolve(L_and)((function(){var $m; return function(){return $m || ($m = resolve(L_isToken)(L_argItem))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_contains)(L_blockStarts)((function(){var $m; return function(){return $m || ($m = resolve(L_tokenString)(L_argItem))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_ifNotErr)((function(){var $m; return function(){return $m || ($m = resolve(L_createAst)(L_list)(L_names))}})())((function(){var $m; return function(){return $m || ($m = function(L_arg){return resolve(L_apply)(L_func)(L_arg)})}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_ifNotErr)((function(){var $m; return function(){return $m || ($m = resolve(L_createAst)(L_argItem)(L_names))}})())((function(){var $m; return function(){return $m || ($m = function(L_arg){return resolve(L_chainApply)((function(){var $m; return function(){return $m || ($m = resolve(L_apply)(L_func)(L_arg))}})())(L_rest)(L_names)})}})()))}})())}})}})())}}})}})()));
runMonad(resolve(L_define)(function(){return "cleanTokens"})(function(){return 3})(function(){return "cleanTokens start toks cont = isToken toks\n  cont (tokenString toks)\n  withCons toks (cont toks) \\head tail .\n    cleanTokens start head \\head .\n      cleanTokens start tail \\tail .\n        cont (cons head tail)"})((function(){var $m; return function(){return $m || ($m = function(L_start){return function(L_toks){return function(L_cont){return resolve(L_isToken)(L_toks)((function(){var $m; return function(){return $m || ($m = resolve(L_cont)((function(){var $m; return function(){return $m || ($m = resolve(L_tokenString)(L_toks))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_withCons)(L_toks)((function(){var $m; return function(){return $m || ($m = resolve(L_cont)(L_toks))}})())((function(){var $m; return function(){return $m || ($m = function(L_head){return function(L_tail){return resolve(L_cleanTokens)(L_start)(L_head)((function(){var $m; return function(){return $m || ($m = function(L_head_0){return resolve(L_cleanTokens)(L_start)(L_tail)((function(){var $m; return function(){return $m || ($m = function(L_tail_1){return resolve(L_cont)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_head_0)(L_tail_1))}})())})}})())})}})())}})}})()))}})())}}})}})()));
runMonad(resolve(L_define)(function(){return "createLet"})(function(){return 3})(function(){return "createLet start list names = withCons list\n  parseErr \"No variable or body for let \" (loc start)\n  \\binding body . eq body nil (createAst binding name)\n    getLetNames start list names \\newNames .\n      createSublets start binding body newNames id"})((function(){var $m; return function(){return $m || ($m = function(L_start){return function(L_list){return function(L_names){return resolve(L_withCons)(L_list)((function(){var $m; return function(){return $m || ($m = resolve(L_parseErr)(function(){return "No variable or body for let "})((function(){var $m; return function(){return $m || ($m = resolve(L_loc)(L_start))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_binding){return function(L_body){return resolve(L_eq)(L_body)(L_nil)((function(){var $m; return function(){return $m || ($m = resolve(L_createAst)(L_binding)(L_name))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_getLetNames)(L_start)(L_list)(L_names)((function(){var $m; return function(){return $m || ($m = function(L_newNames){return resolve(L_createSublets)(L_start)(L_binding)(L_body)(L_newNames)(L_id)})}})()))}})())}})}})())}}})}})()));
runMonad(resolve(L_define)(function(){return "getLetNames"})(function(){return 4})(function(){return "getLetNames start list names cont = \\\\\n  err = parseErr \"Let expected binding \" (loc start)\n  .\n  withCons list (cont names) \\binding body .\n    isTokenString binding '.' (cont names)\n      withParens binding err \\start end def .\n        withCons def err \\name rest .\n          withToken name err \\str pos .\n            getLetNames start body (cons str names) cont"})((function(){var $m; return function(){return $m || ($m = function(L_start){return function(L_list){return function(L_names){return function(L_cont){return (function(){

var L_err;

L_err = (function(){var $m; return function(){return $m || ($m = resolve(L_parseErr)(function(){return "Let expected binding "})((function(){var $m; return function(){return $m || ($m = resolve(L_loc)(L_start))}})()))}})();
return resolve(L_withCons)(L_list)((function(){var $m; return function(){return $m || ($m = resolve(L_cont)(L_names))}})())((function(){var $m; return function(){return $m || ($m = function(L_binding){return function(L_body){return resolve(L_isTokenString)(L_binding)(function(){return "."})((function(){var $m; return function(){return $m || ($m = resolve(L_cont)(L_names))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_withParens)(L_binding)(L_err)((function(){var $m; return function(){return $m || ($m = function(L_start_0){return function(L_end){return function(L_def){return resolve(L_withCons)(L_def)(L_err)((function(){var $m; return function(){return $m || ($m = function(L_name){return function(L_rest){return resolve(L_withToken)(L_name)(L_err)((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pos){return resolve(L_getLetNames)(L_start_0)(L_body)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_str)(L_names))}})())(L_cont)}})}})())}})}})())}}})}})()))}})())}})}})())})()}}}})}})()));
runMonad(resolve(L_define)(function(){return "createSublets"})(function(){return 5})(function(){return "createSublets start binding body names cont =\n  isTokenString binding '.' (ifNotErr (createAst body names) cont)\n    withCons body (parseErr \"Let expected a body \" (loc start)) \\bodyH bodyT .\n      getNameAndDef (parensStart binding) (parensContent binding) names \\name def .\n        createSublets start bodyH bodyT names \\bodyAst .\n          cont (let (tokenString name) def bodyAst)"})((function(){var $m; return function(){return $m || ($m = function(L_start){return function(L_binding){return function(L_body){return function(L_names){return function(L_cont){return resolve(L_isTokenString)(L_binding)(function(){return "."})((function(){var $m; return function(){return $m || ($m = resolve(L_ifNotErr)((function(){var $m; return function(){return $m || ($m = resolve(L_createAst)(L_body)(L_names))}})())(L_cont))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_withCons)(L_body)((function(){var $m; return function(){return $m || ($m = resolve(L_parseErr)(function(){return "Let expected a body "})((function(){var $m; return function(){return $m || ($m = resolve(L_loc)(L_start))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_bodyH){return function(L_bodyT){return resolve(L_getNameAndDef)((function(){var $m; return function(){return $m || ($m = resolve(L_parensStart)(L_binding))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_parensContent)(L_binding))}})())(L_names)((function(){var $m; return function(){return $m || ($m = function(L_name){return function(L_def){return resolve(L_createSublets)(L_start)(L_bodyH)(L_bodyT)(L_names)((function(){var $m; return function(){return $m || ($m = function(L_bodyAst){return resolve(L_cont)((function(){var $m; return function(){return $m || ($m = resolve(L_let)((function(){var $m; return function(){return $m || ($m = resolve(L_tokenString)(L_name))}})())(L_def)(L_bodyAst))}})())})}})())}})}})())}})}})()))}})())}}}}})}})()));
runMonad(resolve(L_define)(function(){return "getNameAndDef"})(function(){return 4})(function(){return "getNameAndDef pos binding names cont =\n  withCons (tail binding) (parseErr \"Let expected binding at \" pos) \\snd sndT .\n    isTokenString snd '=' (ifNotErr (createAst sndT names) \\def . cont (head binding) def)\n      getLetLambda pos (tail binding) nil names \\lamb . cont (head binding) lamb"})((function(){var $m; return function(){return $m || ($m = function(L_pos){return function(L_binding){return function(L_names){return function(L_cont){return resolve(L_withCons)((function(){var $m; return function(){return $m || ($m = resolve(L_tail)(L_binding))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_parseErr)(function(){return "Let expected binding at "})(L_pos))}})())((function(){var $m; return function(){return $m || ($m = function(L_snd){return function(L_sndT){return resolve(L_isTokenString)(L_snd)(function(){return "="})((function(){var $m; return function(){return $m || ($m = resolve(L_ifNotErr)((function(){var $m; return function(){return $m || ($m = resolve(L_createAst)(L_sndT)(L_names))}})())((function(){var $m; return function(){return $m || ($m = function(L_def){return resolve(L_cont)((function(){var $m; return function(){return $m || ($m = resolve(L_head)(L_binding))}})())(L_def)})}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_getLetLambda)(L_pos)((function(){var $m; return function(){return $m || ($m = resolve(L_tail)(L_binding))}})())(L_nil)(L_names)((function(){var $m; return function(){return $m || ($m = function(L_lamb){return resolve(L_cont)((function(){var $m; return function(){return $m || ($m = resolve(L_head)(L_binding))}})())(L_lamb)})}})()))}})())}})}})())}}}})}})()));
runMonad(resolve(L_define)(function(){return "getLetLambda"})(function(){return 5})(function(){return "getLetLambda pos def args names cont =\n  withCons def (parseErr \"Let expected binding at \" pos) \\arg rest .\n    not (isToken arg) (parseErr \"Let expected binding at \" pos)\n      isTokenString arg '='\n        ifNotErr (createAst (cons (token '\\\\' pos) (append (reverse args) (cons (token '.' (position arg)) rest))) names) cont\n        getLetLambda pos rest (cons arg args) names cont"})((function(){var $m; return function(){return $m || ($m = function(L_pos){return function(L_def){return function(L_args){return function(L_names){return function(L_cont){return resolve(L_withCons)(L_def)((function(){var $m; return function(){return $m || ($m = resolve(L_parseErr)(function(){return "Let expected binding at "})(L_pos))}})())((function(){var $m; return function(){return $m || ($m = function(L_arg){return function(L_rest){return resolve(L_not)((function(){var $m; return function(){return $m || ($m = resolve(L_isToken)(L_arg))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_parseErr)(function(){return "Let expected binding at "})(L_pos))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_isTokenString)(L_arg)(function(){return "="})((function(){var $m; return function(){return $m || ($m = resolve(L_ifNotErr)((function(){var $m; return function(){return $m || ($m = resolve(L_createAst)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_token)(function(){return "\\"})(L_pos))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_append)((function(){var $m; return function(){return $m || ($m = resolve(L_reverse)(L_args))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_token)(function(){return "."})((function(){var $m; return function(){return $m || ($m = resolve(L_position)(L_arg))}})()))}})())(L_rest))}})()))}})()))}})())(L_names))}})())(L_cont))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_getLetLambda)(L_pos)(L_rest)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_arg)(L_args))}})())(L_names)(L_cont))}})()))}})())}})}})())}}}}})}})()));
runMonad(resolve(L_define)(function(){return "scanLineG"})(function(){return 5})(function(){return "scanLineG str pat groups onDef onExpr = \\\\\n  toks = tokens str pat\n  groupToks = foldr (\\el value . el \\h t . cons h (cons t value)) (cons '=' blockStarts) groups\n  .\n  # check if it's a definition\n  find (\\tok . or (contains groupToks (tokenString tok)) (isCons (strMatch (tokenString tok) '^\\n'))) toks (\\item . isTokenString item '=') false\n    toks \\name rest . \\\\\n      parseIt func = \\\\\n        parsed = parseToks (checkSetDataType func rest name) groups\n        .\n        onDef (ifNotErr parsed \\list . createDef list name (arity rest 0) str)\n      .\n      isTokenString (head rest) '='\n        isTokenString (head (tail rest)) '\\\\'\n          parseIt (setTypeAnno (tail rest) (tokenString name))\n          parseIt (tail rest)\n        transformDef name rest \\def .\n          parseIt (cons (token '\\\\' (- (position (head rest)) 1)) def)\n    ifNotErr (parseToks toks groups) \\list . onExpr list"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pat){return function(L_groups){return function(L_onDef){return function(L_onExpr){return (function(){

var L_groupToks, L_toks;

L_groupToks = (function(){var $m; return function(){return $m || ($m = resolve(L_foldr)((function(){var $m; return function(){return $m || ($m = function(L_el){return function(L_value){return resolve(L_el)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return resolve(L_cons)(L_h)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_t)(L_value))}})())}})}})())}})}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(function(){return "="})(L_blockStarts))}})())(L_groups))}})();

L_toks = (function(){var $m; return function(){return $m || ($m = resolve(L_tokens)(L_str)(L_pat))}})();
return resolve(L_find)((function(){var $m; return function(){return $m || ($m = function(L_tok){return resolve(L_or)((function(){var $m; return function(){return $m || ($m = resolve(L_contains)(L_groupToks)((function(){var $m; return function(){return $m || ($m = resolve(L_tokenString)(L_tok))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_isCons)((function(){var $m; return function(){return $m || ($m = resolve(L_strMatch)((function(){var $m; return function(){return $m || ($m = resolve(L_tokenString)(L_tok))}})())(function(){return "^\n"}))}})()))}})())})}})())(L_toks)((function(){var $m; return function(){return $m || ($m = function(L_item){return resolve(L_isTokenString)(L_item)(function(){return "="})})}})())(L_false)((function(){var $m; return function(){return $m || ($m = resolve(L_toks)((function(){var $m; return function(){return $m || ($m = function(L_name){return function(L_rest){return (function(){

var L_parseIt;

L_parseIt = (function(){var $m; return function(){return $m || ($m = function(L_func){return (function(){

var L_parsed;

L_parsed = (function(){var $m; return function(){return $m || ($m = resolve(L_parseToks)((function(){var $m; return function(){return $m || ($m = resolve(L_checkSetDataType)(L_func)(L_rest)(L_name))}})())(L_groups))}})();
return resolve(L_onDef)((function(){var $m; return function(){return $m || ($m = resolve(L_ifNotErr)(L_parsed)((function(){var $m; return function(){return $m || ($m = function(L_list){return resolve(L_createDef)(L_list)(L_name)((function(){var $m; return function(){return $m || ($m = resolve(L_arity)(L_rest)(function(){return 0}))}})())(L_str)})}})()))}})())})()})}})();
return resolve(L_isTokenString)((function(){var $m; return function(){return $m || ($m = resolve(L_head)(L_rest))}})())(function(){return "="})((function(){var $m; return function(){return $m || ($m = resolve(L_isTokenString)((function(){var $m; return function(){return $m || ($m = resolve(L_head)((function(){var $m; return function(){return $m || ($m = resolve(L_tail)(L_rest))}})()))}})())(function(){return "\\"})((function(){var $m; return function(){return $m || ($m = resolve(L_parseIt)((function(){var $m; return function(){return $m || ($m = resolve(L_setTypeAnno)((function(){var $m; return function(){return $m || ($m = resolve(L_tail)(L_rest))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_tokenString)(L_name))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_parseIt)((function(){var $m; return function(){return $m || ($m = resolve(L_tail)(L_rest))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_transformDef)(L_name)(L_rest)((function(){var $m; return function(){return $m || ($m = function(L_def){return resolve(L_parseIt)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_token)(function(){return "\\"})((function(){var $m; return function(){return $m || ($m = resolve(L_$_)((function(){var $m; return function(){return $m || ($m = resolve(L_position)((function(){var $m; return function(){return $m || ($m = resolve(L_head)(L_rest))}})()))}})())(function(){return 1}))}})()))}})())(L_def))}})())})}})()))}})())})()}})}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_ifNotErr)((function(){var $m; return function(){return $m || ($m = resolve(L_parseToks)(L_toks)(L_groups))}})())((function(){var $m; return function(){return $m || ($m = function(L_list){return resolve(L_onExpr)(L_list)})}})()))}})())})()}}}}})}})()));
runMonad(resolve(L_define)(function(){return "parseLineG"})(function(){return 6})(function(){return "parseLineG str pat names groups onDef onExpr = \\\\\n  astCallback cb = \\list . ifNotErr (createAst list names) \\ast . cb ast\n  .\n  scanLineG str pat groups (astCallback onDef) (astCallback onExpr)"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pat){return function(L_names){return function(L_groups){return function(L_onDef){return function(L_onExpr){return (function(){

var L_astCallback;

L_astCallback = (function(){var $m; return function(){return $m || ($m = function(L_cb){return function(L_list){return resolve(L_ifNotErr)((function(){var $m; return function(){return $m || ($m = resolve(L_createAst)(L_list)(L_names))}})())((function(){var $m; return function(){return $m || ($m = function(L_ast){return resolve(L_cb)(L_ast)})}})())}})}})();
return resolve(L_scanLineG)(L_str)(L_pat)(L_groups)((function(){var $m; return function(){return $m || ($m = resolve(L_astCallback)(L_onDef))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_astCallback)(L_onExpr))}})())})()}}}}}})}})()));
runMonad(resolve(L_define)(function(){return "transformDef"})(function(){return 3})(function(){return "transformDef name toks cont = withCons toks (parseErr \"Bad definition, expecting tokens\" (loc name)) \\h t .\n  isTokenString h '='\n    isTokenString (head t) '\\\\'\n      cont (cons (token '.' (position h)) (setTypeAnno t (tokenString name)))\n      cont (cons (token '.' (position h)) t)\n    transformDef name t \\list . cont (cons h list)"})((function(){var $m; return function(){return $m || ($m = function(L_name){return function(L_toks){return function(L_cont){return resolve(L_withCons)(L_toks)((function(){var $m; return function(){return $m || ($m = resolve(L_parseErr)(function(){return "Bad definition, expecting tokens"})((function(){var $m; return function(){return $m || ($m = resolve(L_loc)(L_name))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return resolve(L_isTokenString)(L_h)(function(){return "="})((function(){var $m; return function(){return $m || ($m = resolve(L_isTokenString)((function(){var $m; return function(){return $m || ($m = resolve(L_head)(L_t))}})())(function(){return "\\"})((function(){var $m; return function(){return $m || ($m = resolve(L_cont)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_token)(function(){return "."})((function(){var $m; return function(){return $m || ($m = resolve(L_position)(L_h))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_setTypeAnno)(L_t)((function(){var $m; return function(){return $m || ($m = resolve(L_tokenString)(L_name))}})()))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cont)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_token)(function(){return "."})((function(){var $m; return function(){return $m || ($m = resolve(L_position)(L_h))}})()))}})())(L_t))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_transformDef)(L_name)(L_t)((function(){var $m; return function(){return $m || ($m = function(L_list){return resolve(L_cont)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_h)(L_list))}})())})}})()))}})())}})}})())}}})}})()));
runMonad(resolve(L_define)(function(){return "setTypeAnno"})(function(){return 2})(function(){return "setTypeAnno toks name = \\\\\n  tok = \\str . token str (position toks)\n  .\n  cons (tok '\\\\@') (cons (tok 'type') (cons (tok name) (cons (tok '.') toks)))"})((function(){var $m; return function(){return $m || ($m = function(L_toks){return function(L_name){return (function(){

var L_tok;

L_tok = (function(){var $m; return function(){return $m || ($m = function(L_str){return resolve(L_token)(L_str)((function(){var $m; return function(){return $m || ($m = resolve(L_position)(L_toks))}})())})}})();
return resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_tok)(function(){return "\\@"}))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_tok)(function(){return "type"}))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_tok)(L_name))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_tok)(function(){return "."}))}})())(L_toks))}})()))}})()))}})())})()}})}})()));
runMonad(resolve(L_define)(function(){return "setDataTypeAnno"})(function(){return 2})(function(){return "setDataTypeAnno toks name = \\\\\n  tok = \\str . token str (position toks)\n  .\n  cons (tok '\\\\@') (cons (tok 'dataType') (cons (tok (tokenString name)) (cons (tok '.') toks)))"})((function(){var $m; return function(){return $m || ($m = function(L_toks){return function(L_name){return (function(){

var L_tok;

L_tok = (function(){var $m; return function(){return $m || ($m = function(L_str){return resolve(L_token)(L_str)((function(){var $m; return function(){return $m || ($m = resolve(L_position)(L_toks))}})())})}})();
return resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_tok)(function(){return "\\@"}))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_tok)(function(){return "dataType"}))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_tok)((function(){var $m; return function(){return $m || ($m = resolve(L_tokenString)(L_name))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_tok)(function(){return "."}))}})())(L_toks))}})()))}})()))}})())})()}})}})()));
runMonad(resolve(L_define)(function(){return "createDef"})(function(){return 4})(function(){return "createDef def name arity src = \\\\\n  tok str = token str (position def)\n  .\n  jsonStringify (tokenString name) (\\err . parseErr (strCat (cons \"Bad function name \" (cons (loc name) nil))) err) \\nameStr .\n    jsonStringify src (\\err . parseErr (strCat (cons \"Bad source \" (cons (loc name) nil))) err) \\srcStr .\n      #cons (tok 'define') (cons (tok nameStr) (cons (tok (strString arity)) (cons (tok srcStr) (cons def nil))))\n      cons (tok '\\\\@') (cons (cons (tok 'definition') (cons (tok name) nil)) (cons (tok '.') (cons (tok 'define') (cons (tok nameStr) (cons (tok (strString arity)) (cons (tok srcStr) (cons def nil)))))))"})((function(){var $m; return function(){return $m || ($m = function(L_def){return function(L_name){return function(L_arity){return function(L_src){return (function(){

var L_tok;

L_tok = (function(){var $m; return function(){return $m || ($m = function(L_str){return resolve(L_token)(L_str)((function(){var $m; return function(){return $m || ($m = resolve(L_position)(L_def))}})())})}})();
return resolve(L_jsonStringify)((function(){var $m; return function(){return $m || ($m = resolve(L_tokenString)(L_name))}})())((function(){var $m; return function(){return $m || ($m = function(L_err){return resolve(L_parseErr)((function(){var $m; return function(){return $m || ($m = resolve(L_strCat)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(function(){return "Bad function name "})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_loc)(L_name))}})())(L_nil))}})()))}})()))}})())(L_err)})}})())((function(){var $m; return function(){return $m || ($m = function(L_nameStr){return resolve(L_jsonStringify)(L_src)((function(){var $m; return function(){return $m || ($m = function(L_err){return resolve(L_parseErr)((function(){var $m; return function(){return $m || ($m = resolve(L_strCat)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(function(){return "Bad source "})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_loc)(L_name))}})())(L_nil))}})()))}})()))}})())(L_err)})}})())((function(){var $m; return function(){return $m || ($m = function(L_srcStr){return resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_tok)(function(){return "\\@"}))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_tok)(function(){return "definition"}))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_tok)(L_name))}})())(L_nil))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_tok)(function(){return "."}))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_tok)(function(){return "define"}))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_tok)(L_nameStr))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_tok)((function(){var $m; return function(){return $m || ($m = resolve(L_strString)(L_arity))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_tok)(L_srcStr))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_def)(L_nil))}})()))}})()))}})()))}})()))}})()))}})()))}})())})}})())})}})())})()}}}})}})()));
runMonad(resolve(L_define)(function(){return "checkSetDataType"})(function(){return 3})(function(){return "checkSetDataType toks curToks name = withCons curToks toks \\h t .\n  isTokenString h '='\n    isTokenString (head t) '\\\\'\n      setDataTypeAnno toks name\n      toks\n    checkSetDataType toks t name"})((function(){var $m; return function(){return $m || ($m = function(L_toks){return function(L_curToks){return function(L_name){return resolve(L_withCons)(L_curToks)(L_toks)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return resolve(L_isTokenString)(L_h)(function(){return "="})((function(){var $m; return function(){return $m || ($m = resolve(L_isTokenString)((function(){var $m; return function(){return $m || ($m = resolve(L_head)(L_t))}})())(function(){return "\\"})((function(){var $m; return function(){return $m || ($m = resolve(L_setDataTypeAnno)(L_toks)(L_name))}})())(L_toks))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_checkSetDataType)(L_toks)(L_t)(L_name))}})())}})}})())}}})}})()));
runMonad(resolve(L_define)(function(){return "arity"})(function(){return 2})(function(){return "arity toks n = isTokenString (head toks) '=' n (arity (tail toks) (+ n 1))"})((function(){var $m; return function(){return $m || ($m = function(L_toks){return function(L_n){return resolve(L_isTokenString)((function(){var $m; return function(){return $m || ($m = resolve(L_head)(L_toks))}})())(function(){return "="})(L_n)((function(){var $m; return function(){return $m || ($m = resolve(L_arity)((function(){var $m; return function(){return $m || ($m = resolve(L_tail)(L_toks))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_$o)(L_n)(function(){return 1}))}})()))}})())}})}})()));
runMonad(resolve(L_define)(function(){return "tokListStr"})(function(){return 1})(function(){return "tokListStr toks = jsonStringify (join (map (\\t . tokenString t) toks) ' ')"})((function(){var $m; return function(){return $m || ($m = function(L_toks){return resolve(L_jsonStringify)((function(){var $m; return function(){return $m || ($m = resolve(L_join)((function(){var $m; return function(){return $m || ($m = resolve(L_map)((function(){var $m; return function(){return $m || ($m = function(L_t){return resolve(L_tokenString)(L_t)})}})())(L_toks))}})())(function(){return " "}))}})())})}})()));
runMonad(resolve(L_define)(function(){return "linePat"})(function(){return 0})(function(){return "linePat = regexp '\\\\r?\\\\n(?=[^ ]|$)'"})((function(){var $m; return function(){return $m || ($m = resolve(L_regexp)(function(){return "\\r?\\n(?=[^ ]|$)"}))}})()));
runMonad(resolve(L_define)(function(){return "emptyLinePat"})(function(){return 0})(function(){return "emptyLinePat = regexp '(^[ \\\\i]*\\\\#.*|^[ \\\\i]*$|^\\\\r?\\\\n[ \\\\i]*$)'"})((function(){var $m; return function(){return $m || ($m = resolve(L_regexp)(function(){return "(^[ \\i]*\\#.*|^[ \\i]*$|^\\r?\\n[ \\i]*$)"}))}})()));
runMonad(resolve(L_define)(function(){return "lineScrub"})(function(){return 0})(function(){return "lineScrub = regexpFlags '\\\\r\\\\n' 'g'"})((function(){var $m; return function(){return $m || ($m = resolve(L_regexpFlags)(function(){return "\\r\\n"})(function(){return "g"}))}})()));
runMonad(resolve(L_define)(function(){return "linesForFile"})(function(){return 1})(function(){return "linesForFile text = filter\n  \\line . isNil (strMatch line emptyLinePat)\n  strSplit (strReplace text lineScrub '\\n') linePat"})((function(){var $m; return function(){return $m || ($m = function(L_text){return resolve(L_filter)((function(){var $m; return function(){return $m || ($m = function(L_line){return resolve(L_isNil)((function(){var $m; return function(){return $m || ($m = resolve(L_strMatch)(L_line)(L_emptyLinePat))}})())})}})())((function(){var $m; return function(){return $m || ($m = resolve(L_strSplit)((function(){var $m; return function(){return $m || ($m = resolve(L_strReplace)(L_text)(L_lineScrub)(function(){return "\n"}))}})())(L_linePat))}})())})}})()));
runMonad(resolve(L_define)(function(){return "defPat"})(function(){return 0})(function(){return "defPat = regexp '^[^ =]+.* =( |$)'"})((function(){var $m; return function(){return $m || ($m = resolve(L_regexp)(function(){return "^[^ =]+.* =( |$)"}))}})()));
runMonad(resolve(L_define)(function(){return "unanchoredDefPat"})(function(){return 0})(function(){return "unanchoredDefPat = regexp '^((?:\\\\s*\\\\n|#[^\\\\n]*\\\\n)*)([^=\\\\n]*)(=\\\\([^=]+=|=)?'"})((function(){var $m; return function(){return $m || ($m = resolve(L_regexp)(function(){return "^((?:\\s*\\n|#[^\\n]*\\n)*)([^=\\n]*)(=\\([^=]+=|=)?"}))}})()));
runMonad(resolve(L_define)(function(){return "namesForLines"})(function(){return 1})(function(){return "namesForLines lines = foldl\n  \\result line . \\\\\n    m = strMatch line defPat\n    .\n    isNil m result (cons (head (tail m)) result)\n  nil\n  lines"})((function(){var $m; return function(){return $m || ($m = function(L_lines){return resolve(L_foldl)((function(){var $m; return function(){return $m || ($m = function(L_result){return function(L_line){return (function(){

var L_m;

L_m = (function(){var $m; return function(){return $m || ($m = resolve(L_strMatch)(L_line)(L_defPat))}})();
return resolve(L_isNil)(L_m)(L_result)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_head)((function(){var $m; return function(){return $m || ($m = resolve(L_tail)(L_m))}})()))}})())(L_result))}})())})()}})}})())(L_nil)(L_lines)})}})()));
runMonad(resolve(L_define)(function(){return "runParseFilters"})(function(){return 2})(function(){return "runParseFilters filters line = filters\n  \\h t D . bind (h line) \\filtered . runParseFilters t filtered\n  line"})((function(){var $m; return function(){return $m || ($m = function(L_filters){return function(L_line){return resolve(L_filters)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_h)(L_line))}})())((function(){var $m; return function(){return $m || ($m = function(L_filtered){return resolve(L_runParseFilters)(L_t)(L_filtered)})}})())}}})}})())(L_line)}})}})()));
runMonad(resolve(L_define)(function(){return "isBlockStart"})(function(){return 1})(function(){return "isBlockStart tok = and\n  or (isToken tok) (isString tok)\n  contains blockStarts (strTokenString tok)"})((function(){var $m; return function(){return $m || ($m = function(L_tok){return resolve(L_and)((function(){var $m; return function(){return $m || ($m = resolve(L_or)((function(){var $m; return function(){return $m || ($m = resolve(L_isToken)(L_tok))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_isString)(L_tok))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_contains)(L_blockStarts)((function(){var $m; return function(){return $m || ($m = resolve(L_strTokenString)(L_tok))}})()))}})())})}})()));
runMonad(resolve(L_define)(function(){return "macroSub"})(function(){return 2})(function(){return "macroSub macs expr = postProcessMacro -1 -1 (baseMacroSub macs expr)"})((function(){var $m; return function(){return $m || ($m = function(L_macs){return function(L_expr){return resolve(L_postProcessMacro)(function(){return -1})(function(){return -1})((function(){var $m; return function(){return $m || ($m = resolve(L_baseMacroSub)(L_macs)(L_expr))}})())}})}})()));
runMonad(resolve(L_define)(function(){return "consifyMacroValue"})(function(){return 1})(function(){return "consifyMacroValue value = isCons value value (cons value nil)"})((function(){var $m; return function(){return $m || ($m = function(L_value){return resolve(L_isCons)(L_value)(L_value)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_value)(L_nil))}})())})}})()));
runMonad(resolve(L_define)(function(){return "baseMacroSub"})(function(){return 2})(function(){return "baseMacroSub macs expr = isToken expr\n  expr\n  isParens expr\n    expr \\start end content . \\\\\n      result = baseMacroSub macs content\n      .\n      isToken result result (parens start end result)\n    withCons expr expr \\h t .\n      isBlockStart h\n        cons h\n          isTokenString h '\\\\\\\\'\n            macroSubLet macs t\n            macroSubBody '.' macs t\n        withToken h\n          \\\\\n            subH = baseMacroSub macs h\n            .\n            withToken subH\n              cons subH (map (baseMacroSub macs) t)\n              \\tok pos . baseMacroSub macs (cons subH t)\n          \\tok pos . assoc tok macs\n            \\def . baseMacroSub macs (def t)\n            cons h (map (baseMacroSub macs) t)"})((function(){var $m; return function(){return $m || ($m = function(L_macs){return function(L_expr){return resolve(L_isToken)(L_expr)(L_expr)((function(){var $m; return function(){return $m || ($m = resolve(L_isParens)(L_expr)((function(){var $m; return function(){return $m || ($m = resolve(L_expr)((function(){var $m; return function(){return $m || ($m = function(L_start){return function(L_end){return function(L_content){return (function(){

var L_result;

L_result = (function(){var $m; return function(){return $m || ($m = resolve(L_baseMacroSub)(L_macs)(L_content))}})();
return resolve(L_isToken)(L_result)(L_result)((function(){var $m; return function(){return $m || ($m = resolve(L_parens)(L_start)(L_end)(L_result))}})())})()}}})}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_withCons)(L_expr)(L_expr)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return resolve(L_isBlockStart)(L_h)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_h)((function(){var $m; return function(){return $m || ($m = resolve(L_isTokenString)(L_h)(function(){return "\\\\"})((function(){var $m; return function(){return $m || ($m = resolve(L_macroSubLet)(L_macs)(L_t))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_macroSubBody)(function(){return "."})(L_macs)(L_t))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_withToken)(L_h)(function(){
var L_subH;

L_subH = (function(){var $m; return function(){return $m || ($m = resolve(L_baseMacroSub)(L_macs)(L_h))}})();
return resolve(L_withToken)(L_subH)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_subH)((function(){var $m; return function(){return $m || ($m = resolve(L_map)((function(){var $m; return function(){return $m || ($m = resolve(L_baseMacroSub)(L_macs))}})())(L_t))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_tok){return function(L_pos){return resolve(L_baseMacroSub)(L_macs)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_subH)(L_t))}})())}})}})())})((function(){var $m; return function(){return $m || ($m = function(L_tok){return function(L_pos){return resolve(L_assoc)(L_tok)(L_macs)((function(){var $m; return function(){return $m || ($m = function(L_def){return resolve(L_baseMacroSub)(L_macs)((function(){var $m; return function(){return $m || ($m = resolve(L_def)(L_t))}})())})}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_h)((function(){var $m; return function(){return $m || ($m = resolve(L_map)((function(){var $m; return function(){return $m || ($m = resolve(L_baseMacroSub)(L_macs))}})())(L_t))}})()))}})())}})}})()))}})())}})}})()))}})()))}})())}})}})()));
runMonad(resolve(L_define)(function(){return "macroSubLet"})(function(){return 2})(function(){return "macroSubLet macs list = list\n  \\h t D . isTokenString h '.'\n    cons h (baseMacroSub macs t)\n    cons (setParens h \\content . macroSubBody '=' macs content) (macroSubLet macs t)\n  # Don't bother with parse errors at this point -- ast generator will detect them\n  nil"})((function(){var $m; return function(){return $m || ($m = function(L_macs){return function(L_list){return resolve(L_list)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return resolve(L_isTokenString)(L_h)(function(){return "."})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_h)((function(){var $m; return function(){return $m || ($m = resolve(L_baseMacroSub)(L_macs)(L_t))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_setParens)(L_h)((function(){var $m; return function(){return $m || ($m = function(L_content){return resolve(L_macroSubBody)(function(){return "="})(L_macs)(L_content)})}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_macroSubLet)(L_macs)(L_t))}})()))}})())}}})}})())(L_nil)}})}})()));
runMonad(resolve(L_define)(function(){return "macroSubBody"})(function(){return 3})(function(){return "macroSubBody char macs list = list\n  \\h t D . cons h\n    isTokenString h char baseMacroSub (macroSubBody char)\n      macs\n      t\n  nil"})((function(){var $m; return function(){return $m || ($m = function(L_char){return function(L_macs){return function(L_list){return resolve(L_list)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return resolve(L_cons)(L_h)((function(){var $m; return function(){return $m || ($m = resolve(L_isTokenString)(L_h)(L_char)(L_baseMacroSub)((function(){var $m; return function(){return $m || ($m = resolve(L_macroSubBody)(L_char))}})())(L_macs)(L_t))}})())}}})}})())(L_nil)}}})}})()));
runMonad(resolve(L_define)(function(){return "postProcessMacro"})(function(){return 3})(function(){return "postProcessMacro before after expr = isString expr\n  token expr (eq after -1 before after)\n  isParens expr\n    expr \\start end contents . parens start end (postProcessMacro start end contents)\n    isCons expr\n      expr \\h t .\n        isToken h\n          cons h (postProcessMacro (+ 1 (+ (tokenPos h) (strLen (tokenString h)))) -1 t)\n          \\\\\n            posStart = position h\n            posEnd = position t\n            t2 = postProcessMacro -1 after t\n            h2 = postProcessMacro before -1 h\n            .\n            eq posStart -1\n              cons (postProcessMacro before (position t2) h) t2\n              cons h2 (postProcessMacro (+ 1 (lexEnd h2)) after t)\n      isNumber expr\n        token (strString expr) (eq after -1 before after)\n        expr"})((function(){var $m; return function(){return $m || ($m = function(L_before){return function(L_after){return function(L_expr){return resolve(L_isString)(L_expr)((function(){var $m; return function(){return $m || ($m = resolve(L_token)(L_expr)((function(){var $m; return function(){return $m || ($m = resolve(L_eq)(L_after)(function(){return -1})(L_before)(L_after))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_isParens)(L_expr)((function(){var $m; return function(){return $m || ($m = resolve(L_expr)((function(){var $m; return function(){return $m || ($m = function(L_start){return function(L_end){return function(L_contents){return resolve(L_parens)(L_start)(L_end)((function(){var $m; return function(){return $m || ($m = resolve(L_postProcessMacro)(L_start)(L_end)(L_contents))}})())}}})}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_isCons)(L_expr)((function(){var $m; return function(){return $m || ($m = resolve(L_expr)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return resolve(L_isToken)(L_h)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_h)((function(){var $m; return function(){return $m || ($m = resolve(L_postProcessMacro)((function(){var $m; return function(){return $m || ($m = resolve(L_$o)(function(){return 1})((function(){var $m; return function(){return $m || ($m = resolve(L_$o)((function(){var $m; return function(){return $m || ($m = resolve(L_tokenPos)(L_h))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_strLen)((function(){var $m; return function(){return $m || ($m = resolve(L_tokenString)(L_h))}})()))}})()))}})()))}})())(function(){return -1})(L_t))}})()))}})())(function(){
var L_h2, L_t2, L_posEnd, L_posStart;

L_h2 = (function(){var $m; return function(){return $m || ($m = resolve(L_postProcessMacro)(L_before)(function(){return -1})(L_h))}})();

L_t2 = (function(){var $m; return function(){return $m || ($m = resolve(L_postProcessMacro)(function(){return -1})(L_after)(L_t))}})();

L_posEnd = (function(){var $m; return function(){return $m || ($m = resolve(L_position)(L_t))}})();

L_posStart = (function(){var $m; return function(){return $m || ($m = resolve(L_position)(L_h))}})();
return resolve(L_eq)(L_posStart)(function(){return -1})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_postProcessMacro)(L_before)((function(){var $m; return function(){return $m || ($m = resolve(L_position)(L_t2))}})())(L_h))}})())(L_t2))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_h2)((function(){var $m; return function(){return $m || ($m = resolve(L_postProcessMacro)((function(){var $m; return function(){return $m || ($m = resolve(L_$o)(function(){return 1})((function(){var $m; return function(){return $m || ($m = resolve(L_lexEnd)(L_h2))}})()))}})())(L_after)(L_t))}})()))}})())})}})}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_isNumber)(L_expr)((function(){var $m; return function(){return $m || ($m = resolve(L_token)((function(){var $m; return function(){return $m || ($m = resolve(L_strString)(L_expr))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_eq)(L_after)(function(){return -1})(L_before)(L_after))}})()))}})())(L_expr))}})()))}})()))}})())}}})}})()));
runMonad(resolve(L_define)(function(){return "defMacro"})(function(){return 2})(function(){return "defMacro name def = bind (getValue 'macroDefs') \\macs . setValue 'macroDefs' (acons name def macs)"})((function(){var $m; return function(){return $m || ($m = function(L_name){return function(L_def){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_getValue)(function(){return "macroDefs"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_macs){return resolve(L_setValue)(function(){return "macroDefs"})((function(){var $m; return function(){return $m || ($m = resolve(L_acons)(L_name)(L_def)(L_macs))}})())})}})())}})}})()));
runMonad(resolve(L_define)(function(){return "delimiterListPrefix"})(function(){return 0})(function(){return "delimiterListPrefix = \"\\\"(?:\\\\\\\\.|[^\\\"])*\\\"|'(?:\\\\\\\\.|[^'])*'|\\\\n *|#.*| +\""})(function(){return "\"(?:\\\\.|[^\"])*\"|'(?:\\\\.|[^'])*'|\\n *|#.*| +"}));
runMonad(resolve(L_define)(function(){return "regexpEscapePat"})(function(){return 0})(function(){return "regexpEscapePat = regexpFlags '[\\\\-\\\\[\\\\]/\\\\{\\\\}\\\\(\\\\)\\\\*\\\\+\\\\?\\\\.\\\\\\\\\\\\^\\\\$\\\\|]' 'g'"})((function(){var $m; return function(){return $m || ($m = resolve(L_regexpFlags)(function(){return "[\\-\\[\\]/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]"})(function(){return "g"}))}})()));
runMonad(resolve(L_define)(function(){return "addToken"})(function(){return 1})(function(){return "addToken del = bind (getValue 'tokenList')\n  \\dels . contains dels del\n    false\n    \\\\\n      newDels = insertSorted (\\a b . > (strLen a) (strLen b)) del dels\n      .\n      bind (setValue 'tokenList' newDels)\n        \\_ . computeTokenPat newDels"})((function(){var $m; return function(){return $m || ($m = function(L_del){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_getValue)(function(){return "tokenList"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_dels){return resolve(L_contains)(L_dels)(L_del)(L_false)(function(){
var L_newDels;

L_newDels = (function(){var $m; return function(){return $m || ($m = resolve(L_insertSorted)((function(){var $m; return function(){return $m || ($m = function(L_a){return function(L_b){return resolve(L_$z)((function(){var $m; return function(){return $m || ($m = resolve(L_strLen)(L_a))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_strLen)(L_b))}})())}})}})())(L_del)(L_dels))}})();
return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_setValue)(function(){return "tokenList"})(L_newDels))}})())((function(){var $m; return function(){return $m || ($m = function(L__){return resolve(L_computeTokenPat)(L_newDels)})}})())})})}})())})}})()));
runMonad(resolve(L_define)(function(){return "computeTokenPat"})(function(){return 1})(function(){return "computeTokenPat dels = \\\\\n  delPats = map (\\item . strReplace item regexpEscapePat \"\\\\$&\") dels\n  newPat = strCat (cons '(' (cons (join (cons delimiterListPrefix delPats) '|') (cons ')' nil)))\n  .\n  setValue 'tokenPat' newPat"})((function(){var $m; return function(){return $m || ($m = function(L_dels){return (function(){

var L_newPat, L_delPats;

L_newPat = (function(){var $m; return function(){return $m || ($m = resolve(L_strCat)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(function(){return "("})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_join)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_delimiterListPrefix)(L_delPats))}})())(function(){return "|"}))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(function(){return ")"})(L_nil))}})()))}})()))}})()))}})();

L_delPats = (function(){var $m; return function(){return $m || ($m = resolve(L_map)((function(){var $m; return function(){return $m || ($m = function(L_item){return resolve(L_strReplace)(L_item)(L_regexpEscapePat)(function(){return "\\$&"})})}})())(L_dels))}})();
return resolve(L_setValue)(function(){return "tokenPat"})(L_newPat)})()})}})()));
runMonad(resolve(L_define)(function(){return "addTokenGroup"})(function(){return 2})(function(){return "addTokenGroup open close = bind (addToken open)\n  \\_ . bind (addToken close)\n    \\_ . bind (getValue 'tokenGroups')\n      \\gr . setValue 'tokenGroups' (acons open close gr)"})((function(){var $m; return function(){return $m || ($m = function(L_open){return function(L_close){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_addToken)(L_open))}})())((function(){var $m; return function(){return $m || ($m = function(L__){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_addToken)(L_close))}})())((function(){var $m; return function(){return $m || ($m = function(L___0){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_getValue)(function(){return "tokenGroups"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_gr){return resolve(L_setValue)(function(){return "tokenGroups"})((function(){var $m; return function(){return $m || ($m = resolve(L_acons)(L_open)(L_close)(L_gr))}})())})}})())})}})())})}})())}})}})()));
runMonad(resolve(L_define)(function(){return "parenGroups"})(function(){return 0})(function(){return "parenGroups = acons '(' ')' nil"})((function(){var $m; return function(){return $m || ($m = resolve(L_acons)(function(){return "("})(function(){return ")"})(L_nil))}})()));
runMonad(resolve(L_define)(function(){return "parse"})(function(){return 2})(function(){return "parse str pat = ifNotErr (parseIndent (token '\\n' 0) (tokens str pat) nil parenGroups) \\list . list \\h t . stripParens h"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pat){return resolve(L_ifNotErr)((function(){var $m; return function(){return $m || ($m = resolve(L_parseIndent)((function(){var $m; return function(){return $m || ($m = resolve(L_token)(function(){return "\n"})(function(){return 0}))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_tokens)(L_str)(L_pat))}})())(L_nil)(L_parenGroups))}})())((function(){var $m; return function(){return $m || ($m = function(L_list){return resolve(L_list)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return resolve(L_stripParens)(L_h)}})}})())})}})())}})}})()));
runMonad(resolve(L_define)(function(){return "parseG"})(function(){return 3})(function(){return "parseG str pat groups = ifNotErr (parseIndent (token '\\n' 0) (tokens str pat) nil groups) \\list . list \\h t . stripParens h"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pat){return function(L_groups){return resolve(L_ifNotErr)((function(){var $m; return function(){return $m || ($m = resolve(L_parseIndent)((function(){var $m; return function(){return $m || ($m = resolve(L_token)(function(){return "\n"})(function(){return 0}))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_tokens)(L_str)(L_pat))}})())(L_nil)(L_groups))}})())((function(){var $m; return function(){return $m || ($m = function(L_list){return resolve(L_list)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return resolve(L_stripParens)(L_h)}})}})())})}})())}}})}})()));
runMonad(resolve(L_define)(function(){return "parseToAst"})(function(){return 2})(function(){return "parseToAst str pat = createAst (parse str pat) nil"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pat){return resolve(L_createAst)((function(){var $m; return function(){return $m || ($m = resolve(L_parse)(L_str)(L_pat))}})())(L_nil)}})}})()));
runMonad(resolve(L_define)(function(){return "parseM"})(function(){return 1})(function(){return "parseM str =\n  bind (getValue 'tokenPat')\n    \\tokPat . bind (getValue 'tokenGroups')\n      \\groups . parseG str tokPat groups"})((function(){var $m; return function(){return $m || ($m = function(L_str){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_getValue)(function(){return "tokenPat"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_tokPat){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_getValue)(function(){return "tokenGroups"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_groups){return resolve(L_parseG)(L_str)(L_tokPat)(L_groups)})}})())})}})())})}})()));
runMonad(resolve(L_define)(function(){return "scanLine"})(function(){return 4})(function(){return "scanLine str pat onDef onExpr = scanLineG str pat parenGroups onDef onExpr"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pat){return function(L_onDef){return function(L_onExpr){return resolve(L_scanLineG)(L_str)(L_pat)(L_parenGroups)(L_onDef)(L_onExpr)}}}})}})()));
runMonad(resolve(L_define)(function(){return "parseLine"})(function(){return 5})(function(){return "parseLine str pat names onDef onExpr = parseLineG str pat names parenGroups onDef onExpr"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pat){return function(L_names){return function(L_onDef){return function(L_onExpr){return resolve(L_parseLineG)(L_str)(L_pat)(L_names)(L_parenGroups)(L_onDef)(L_onExpr)}}}}})}})()));
runMonad(resolve(L_define)(function(){return "parseLineM"})(function(){return 1})(function(){return "parseLineM str = bind (getValue 'tokenPat')\n  \\tokPat . bind (getValue 'tokenGroups')\n    \\groups . parseLineG str tokPat nil groups id id"})((function(){var $m; return function(){return $m || ($m = function(L_str){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_getValue)(function(){return "tokenPat"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_tokPat){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_getValue)(function(){return "tokenGroups"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_groups){return resolve(L_parseLineG)(L_str)(L_tokPat)(L_nil)(L_groups)(L_id)(L_id)})}})())})}})())})}})()));
runMonad(resolve(L_define)(function(){return "macroSubM"})(function(){return 1})(function(){return "macroSubM expr =\n  bind (getValue 'macroDefs')\n    \\macs . macroSub macs expr"})((function(){var $m; return function(){return $m || ($m = function(L_expr){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_getValue)(function(){return "macroDefs"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_macs){return resolve(L_macroSub)(L_macs)(L_expr)})}})())})}})()));
runMonad(resolve(L_define)(function(){return "macroParse"})(function(){return 1})(function(){return "macroParse str =\n  bind (parseM str)\n    \\ex . macroSubM ex"})((function(){var $m; return function(){return $m || ($m = function(L_str){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_parseM)(L_str))}})())((function(){var $m; return function(){return $m || ($m = function(L_ex){return resolve(L_macroSubM)(L_ex)})}})())})}})()));
runMonad(resolve(L_define)(function(){return "tokensM"})(function(){return 1})(function(){return "tokensM str =\n  bind (getValue 'tokenPat')\n    \\delimiterPat . tokens str delimiterPat"})((function(){var $m; return function(){return $m || ($m = function(L_str){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_getValue)(function(){return "tokenPat"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_delimiterPat){return resolve(L_tokens)(L_str)(L_delimiterPat)})}})())})}})()));
runMonad(resolve(L_define)(function(){return "parseLines"})(function(){return 2})(function(){return "parseLines lines result = lines\n  \\h t D . bind (parseLineM h)\n    \\ast . parseLines t (cons ast result)\n  reverse result"})((function(){var $m; return function(){return $m || ($m = function(L_lines){return function(L_result){return resolve(L_lines)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_parseLineM)(L_h))}})())((function(){var $m; return function(){return $m || ($m = function(L_ast){return resolve(L_parseLines)(L_t)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_ast)(L_result))}})())})}})())}}})}})())((function(){var $m; return function(){return $m || ($m = resolve(L_reverse)(L_result))}})())}})}})()));
runMonad(resolve(L_define)(function(){return "parseFile"})(function(){return 1})(function(){return "parseFile text = parseLines (linesForFile text) nil"})((function(){var $m; return function(){return $m || ($m = function(L_text){return resolve(L_parseLines)((function(){var $m; return function(){return $m || ($m = resolve(L_linesForFile)(L_text))}})())(L_nil)})}})()));
runMonad(resolve(L_define)(function(){return "simpleScanLine"})(function(){return 1})(function(){return "simpleScanLine line = bind (getValue 'tokenPat')\n  \\tokenPat . bind (getValue 'tokenGroups')\n    \\groups . scanLineG line tokenPat groups id id"})((function(){var $m; return function(){return $m || ($m = function(L_line){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_getValue)(function(){return "tokenPat"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_tokenPat){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_getValue)(function(){return "tokenGroups"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_groups){return resolve(L_scanLineG)(L_line)(L_tokenPat)(L_groups)(L_id)(L_id)})}})())})}})())})}})()));
runMonad(resolve(L_define)(function(){return "scanLineM"})(function(){return 1})(function(){return "scanLineM line = bind (getValue 'tokenPat')\n  \\tokenPat . bind (getValue 'tokenGroups')\n    \\groups . bind (getValue 'parseFilters')\n      \\filters . bind (getValue 'macroDefs')\n        \\macros . bind (runParseFilters filters (scanLineG line tokenPat groups id id))\n          \\scanned . macroSub macros scanned"})((function(){var $m; return function(){return $m || ($m = function(L_line){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_getValue)(function(){return "tokenPat"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_tokenPat){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_getValue)(function(){return "tokenGroups"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_groups){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_getValue)(function(){return "parseFilters"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_filters){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_getValue)(function(){return "macroDefs"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_macros){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_runParseFilters)(L_filters)((function(){var $m; return function(){return $m || ($m = resolve(L_scanLineG)(L_line)(L_tokenPat)(L_groups)(L_id)(L_id))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_scanned){return resolve(L_macroSub)(L_macros)(L_scanned)})}})())})}})())})}})())})}})())})}})())})}})()));
runMonad(resolve(L_define)(function(){return "newParseLine"})(function(){return 2})(function(){return "newParseLine names line = bind (scanLineM line)\n  \\scanned . ifNotErr (createAst scanned names) \\ast . ast"})((function(){var $m; return function(){return $m || ($m = function(L_names){return function(L_line){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_scanLineM)(L_line))}})())((function(){var $m; return function(){return $m || ($m = function(L_scanned){return resolve(L_ifNotErr)((function(){var $m; return function(){return $m || ($m = resolve(L_createAst)(L_scanned)(L_names))}})())((function(){var $m; return function(){return $m || ($m = function(L_ast){return resolve(L_ast)})}})())})}})())}})}})()));
runMonad(resolve(L_define)(function(){return "runLine"})(function(){return 2})(function(){return "runLine names line = bind (newParseLine names line)\n  \\ast . bind (runAst ast)\n    \\result . cons\n      ast\n      isParseErr result\n        left (parseErrMsg result)\n        right result"})((function(){var $m; return function(){return $m || ($m = function(L_names){return function(L_line){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_newParseLine)(L_names)(L_line))}})())((function(){var $m; return function(){return $m || ($m = function(L_ast){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_runAst)(L_ast))}})())((function(){var $m; return function(){return $m || ($m = function(L_result){return resolve(L_cons)(L_ast)((function(){var $m; return function(){return $m || ($m = resolve(L_isParseErr)(L_result)((function(){var $m; return function(){return $m || ($m = resolve(L_left)((function(){var $m; return function(){return $m || ($m = resolve(L_parseErrMsg)(L_result))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_right)(L_result))}})()))}})())})}})())})}})())}})}})()));
runMonad(resolve(L_define)(function(){return "runLines"})(function(){return 2})(function(){return "runLines names lines = lines\n  \\h t D . bind (runLine names h)\n    \\line . bind (runLines names t)\n      \\rest . cons line rest\n  nil"})((function(){var $m; return function(){return $m || ($m = function(L_names){return function(L_lines){return resolve(L_lines)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_runLine)(L_names)(L_h))}})())((function(){var $m; return function(){return $m || ($m = function(L_line){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_runLines)(L_names)(L_t))}})())((function(){var $m; return function(){return $m || ($m = function(L_rest){return resolve(L_cons)(L_line)(L_rest)})}})())})}})())}}})}})())(L_nil)}})}})()));
runMonad(resolve(L_define)(function(){return "runFile"})(function(){return 1})(function(){return "runFile text = \\\\\n  lines = linesForFile text\n  names = namesForLines lines\n  .\n  runLines names lines"})((function(){var $m; return function(){return $m || ($m = function(L_text){return (function(){

var L_names, L_lines;

L_names = (function(){var $m; return function(){return $m || ($m = resolve(L_namesForLines)(L_lines))}})();

L_lines = (function(){var $m; return function(){return $m || ($m = resolve(L_linesForFile)(L_text))}})();
return resolve(L_runLines)(L_names)(L_lines)})()})}})()));
runMonad(resolve(L_define)(function(){return "baseLoad"})(function(){return 1})(function(){return "baseLoad file = bind (readFile file)\n  \\result . result\n    \\err . err\n    \\contents . bind (getValue 'activeTokenPacks')\n      \\activePacks . bind resetStdTokenPacks\n        \\_ . bind (runFile contents)\n          \\result . isNil activePacks\n            bind resetStdTokenPacks\n              \\_ . result\n            bind (resetTokenPacks activePacks)\n                \\_ . result"})((function(){var $m; return function(){return $m || ($m = function(L_file){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_readFile)(L_file))}})())((function(){var $m; return function(){return $m || ($m = function(L_result){return resolve(L_result)((function(){var $m; return function(){return $m || ($m = function(L_err){return resolve(L_err)})}})())((function(){var $m; return function(){return $m || ($m = function(L_contents){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_getValue)(function(){return "activeTokenPacks"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_activePacks){return resolve(L_bind)(L_resetStdTokenPacks)((function(){var $m; return function(){return $m || ($m = function(L__){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_runFile)(L_contents))}})())((function(){var $m; return function(){return $m || ($m = function(L_result_0){return resolve(L_isNil)(L_activePacks)((function(){var $m; return function(){return $m || ($m = resolve(L_bind)(L_resetStdTokenPacks)((function(){var $m; return function(){return $m || ($m = function(L___1){return resolve(L_result_0)})}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_resetTokenPacks)(L_activePacks))}})())((function(){var $m; return function(){return $m || ($m = function(L___1){return resolve(L_result_0)})}})()))}})())})}})())})}})())})}})())})}})())})}})())})}})()));
runMonad(resolve(L_define)(function(){return "load"})(function(){return 1})(function(){return "load file = bind (baseLoad file)\n  \\result . \\\\\n    errs = foldr (\\line results . tail line (\\er . cons er results) (\\x . results)) nil result\n    .\n    isNil errs\n      right true\n      left errs"})((function(){var $m; return function(){return $m || ($m = function(L_file){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_baseLoad)(L_file))}})())((function(){var $m; return function(){return $m || ($m = function(L_result){return (function(){

var L_errs;

L_errs = (function(){var $m; return function(){return $m || ($m = resolve(L_foldr)((function(){var $m; return function(){return $m || ($m = function(L_line){return function(L_results){return resolve(L_tail)(L_line)((function(){var $m; return function(){return $m || ($m = function(L_er){return resolve(L_cons)(L_er)(L_results)})}})())((function(){var $m; return function(){return $m || ($m = function(L_x){return resolve(L_results)})}})())}})}})())(L_nil)(L_result))}})();
return resolve(L_isNil)(L_errs)((function(){var $m; return function(){return $m || ($m = resolve(L_right)(L_true))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_left)(L_errs))}})())})()})}})())})}})()));
runMonad(resolve(L_define)(function(){return "require"})(function(){return 1})(function(){return "require file = bind (getValue 'requiredFiles')\n  \\files . contains files file\n    false\n    bind (load file)\n      \\result . result\n        \\x . left x\n        \\_ . bind (setValue 'requiredFiles' (cons file files))\n          \\_ . right true"})((function(){var $m; return function(){return $m || ($m = function(L_file){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_getValue)(function(){return "requiredFiles"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_files){return resolve(L_contains)(L_files)(L_file)(L_false)((function(){var $m; return function(){return $m || ($m = resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_load)(L_file))}})())((function(){var $m; return function(){return $m || ($m = function(L_result){return resolve(L_result)((function(){var $m; return function(){return $m || ($m = function(L_x){return resolve(L_left)(L_x)})}})())((function(){var $m; return function(){return $m || ($m = function(L__){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_setValue)(function(){return "requiredFiles"})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_file)(L_files))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L___0){return resolve(L_right)(L_true)})}})())})}})())})}})()))}})())})}})())})}})()));
runMonad(resolve(L_define)(function(){return "defTokenPack"})(function(){return 2})(function(){return "defTokenPack name pack = bind (getValue 'tokenPacks')\n  \\packs . setValue 'tokenPacks' (acons name pack packs)"})((function(){var $m; return function(){return $m || ($m = function(L_name){return function(L_pack){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_getValue)(function(){return "tokenPacks"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_packs){return resolve(L_setValue)(function(){return "tokenPacks"})((function(){var $m; return function(){return $m || ($m = resolve(L_acons)(L_name)(L_pack)(L_packs))}})())})}})())}})}})()));
runMonad(resolve(L_define)(function(){return "useTokenPack"})(function(){return 1})(function(){return "useTokenPack name = bind (getValue 'tokenPacks')\n  \\packs . bind (getValue 'tokenGroups')\n    \\groups . bind (getValue 'tokenList')\n      \\tokens . bind (getValue 'activeTokenPacks')\n        \\activePacks . bind (getValue 'parseFilters')\n          \\filters . assoc name packs\n            \\pack . \\\\\n              groupToks = foldl (\\value el . el \\h t . cons h (cons t value)) nil (head (tail pack))\n              newToks = quicksort (\\a b . > (strLen a) (strLen b)) (append (head pack) (append groupToks tokens))\n              .\n              bind (setValue 'tokenList' newToks)\n                \\_ . bind (setValue 'tokenGroups' (appendAlist (head (tail pack)) groups))\n                  \\_ . bind (setValue 'parseFilters' (append filters (head (tail (tail pack)))))\n                    \\_ . bind (computeTokenPat newToks)\n                      \\_ . setValue 'activeTokenPacks' (cons name activePacks)\n            nil"})((function(){var $m; return function(){return $m || ($m = function(L_name){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_getValue)(function(){return "tokenPacks"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_packs){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_getValue)(function(){return "tokenGroups"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_groups){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_getValue)(function(){return "tokenList"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_tokens){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_getValue)(function(){return "activeTokenPacks"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_activePacks){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_getValue)(function(){return "parseFilters"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_filters){return resolve(L_assoc)(L_name)(L_packs)((function(){var $m; return function(){return $m || ($m = function(L_pack){return (function(){

var L_newToks, L_groupToks;

L_newToks = (function(){var $m; return function(){return $m || ($m = resolve(L_quicksort)((function(){var $m; return function(){return $m || ($m = function(L_a){return function(L_b){return resolve(L_$z)((function(){var $m; return function(){return $m || ($m = resolve(L_strLen)(L_a))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_strLen)(L_b))}})())}})}})())((function(){var $m; return function(){return $m || ($m = resolve(L_append)((function(){var $m; return function(){return $m || ($m = resolve(L_head)(L_pack))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_append)(L_groupToks)(L_tokens))}})()))}})()))}})();

L_groupToks = (function(){var $m; return function(){return $m || ($m = resolve(L_foldl)((function(){var $m; return function(){return $m || ($m = function(L_value){return function(L_el){return resolve(L_el)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return resolve(L_cons)(L_h)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_t)(L_value))}})())}})}})())}})}})())(L_nil)((function(){var $m; return function(){return $m || ($m = resolve(L_head)((function(){var $m; return function(){return $m || ($m = resolve(L_tail)(L_pack))}})()))}})()))}})();
return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_setValue)(function(){return "tokenList"})(L_newToks))}})())((function(){var $m; return function(){return $m || ($m = function(L__){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_setValue)(function(){return "tokenGroups"})((function(){var $m; return function(){return $m || ($m = resolve(L_appendAlist)((function(){var $m; return function(){return $m || ($m = resolve(L_head)((function(){var $m; return function(){return $m || ($m = resolve(L_tail)(L_pack))}})()))}})())(L_groups))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L___0){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_setValue)(function(){return "parseFilters"})((function(){var $m; return function(){return $m || ($m = resolve(L_append)(L_filters)((function(){var $m; return function(){return $m || ($m = resolve(L_head)((function(){var $m; return function(){return $m || ($m = resolve(L_tail)((function(){var $m; return function(){return $m || ($m = resolve(L_tail)(L_pack))}})()))}})()))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L___1){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_computeTokenPat)(L_newToks))}})())((function(){var $m; return function(){return $m || ($m = function(L___2){return resolve(L_setValue)(function(){return "activeTokenPacks"})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_name)(L_activePacks))}})())})}})())})}})())})}})())})}})())})()})}})())(L_nil)})}})())})}})())})}})())})}})())})}})())})}})()));
runMonad(resolve(L_define)(function(){return "resetTokenPacks"})(function(){return 1})(function(){return "resetTokenPacks packs = bind (setValue 'tokenGroups' nil)\n  \\_ . bind (setValue 'tokenList' nil)\n    \\_ . bind (setValue 'activeTokenPacks' nil)\n      \\_ . bind (setValue 'parseFilters' nil)\n        \\_ . foldr1\n          \\packCmd result . bind packCmd \\_ . result\n          map useTokenPack packs"})((function(){var $m; return function(){return $m || ($m = function(L_packs){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_setValue)(function(){return "tokenGroups"})(L_nil))}})())((function(){var $m; return function(){return $m || ($m = function(L__){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_setValue)(function(){return "tokenList"})(L_nil))}})())((function(){var $m; return function(){return $m || ($m = function(L___0){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_setValue)(function(){return "activeTokenPacks"})(L_nil))}})())((function(){var $m; return function(){return $m || ($m = function(L___1){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_setValue)(function(){return "parseFilters"})(L_nil))}})())((function(){var $m; return function(){return $m || ($m = function(L___2){return resolve(L_foldr1)((function(){var $m; return function(){return $m || ($m = function(L_packCmd){return function(L_result){return resolve(L_bind)(L_packCmd)((function(){var $m; return function(){return $m || ($m = function(L___3){return resolve(L_result)})}})())}})}})())((function(){var $m; return function(){return $m || ($m = resolve(L_map)(L_useTokenPack)(L_packs))}})())})}})())})}})())})}})())})}})())})}})()));
runMonad(resolve(L_define)(function(){return "resetStdTokenPacks"})(function(){return 0})(function(){return "resetStdTokenPacks = bind (getValue 'stdTokenPacks')\n  \\stds . bind (resetTokenPacks stds)\n    \\_ . setValue 'activeTokenPacks' nil"})((function(){var $m; return function(){return $m || ($m = resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_getValue)(function(){return "stdTokenPacks"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_stds){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_resetTokenPacks)(L_stds))}})())((function(){var $m; return function(){return $m || ($m = function(L__){return resolve(L_setValue)(function(){return "activeTokenPacks"})(L_nil)})}})())})}})()))}})()));
runMonad(resolve(L_define)(function(){return "addStdTokenPacks"})(function(){return 1})(function(){return "addStdTokenPacks morePacks = bind (getValue 'stdTokenPacks')\n  \\stds . setValue 'stdTokenPacks' (append stds morePacks)"})((function(){var $m; return function(){return $m || ($m = function(L_morePacks){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_getValue)(function(){return "stdTokenPacks"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_stds){return resolve(L_setValue)(function(){return "stdTokenPacks"})((function(){var $m; return function(){return $m || ($m = resolve(L_append)(L_stds)(L_morePacks))}})())})}})())})}})()));
runMonad(resolve(L_define)(function(){return "addParseFilter"})(function(){return 1})(function(){return "addParseFilter filt = bind (getValue 'parseFilters')\n  \\filters . setValue 'parseFilters' (append filters (cons filt nil))"})((function(){var $m; return function(){return $m || ($m = function(L_filt){return resolve(L_bind)((function(){var $m; return function(){return $m || ($m = resolve(L_getValue)(function(){return "parseFilters"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_filters){return resolve(L_setValue)(function(){return "parseFilters"})((function(){var $m; return function(){return $m || ($m = resolve(L_append)(L_filters)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_filt)(L_nil))}})()))}})())})}})())})}})()));
runMonad(resolve(L_define)(function(){return "d"})(function(){return 3})(function(){return "d label value expr = log (strCat (cons label (cons value nil))) expr"})((function(){var $m; return function(){return $m || ($m = function(L_label){return function(L_value){return function(L_expr){return resolve(L_log)((function(){var $m; return function(){return $m || ($m = resolve(L_strCat)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_label)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_value)(L_nil))}})()))}})()))}})())(L_expr)}}})}})()));
runMonad(resolve(L_define)(function(){return "dd"})(function(){return 2})(function(){return "dd label arg = d label arg arg"})((function(){var $m; return function(){return $m || ($m = function(L_label){return function(L_arg){return resolve(L_d)(L_label)(L_arg)(L_arg)}})}})()));
runMonad(resolve(L_setValue)(function(){return "macroDefs"})(L_nil));
runMonad(resolve(L_setValue)(function(){return "requiredFiles"})(L_nil));
runMonad(resolve(L_setValue)(function(){return "tokenPacks"})(L_nil));
runMonad(resolve(L_setValue)(function(){return "activeTokenPacks"})(L_nil));
runMonad(resolve(L_setValue)(function(){return "stdTokenPacks"})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(function(){return "std"})(L_nil))}})()));
runMonad(resolve(L_defTokenPack)(function(){return "std"})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(function(){return "."})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(function(){return "\\"})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(function(){return "\\\\"})((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(function(){return "\\@"})(L_nil))}})()))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)((function(){var $m; return function(){return $m || ($m = resolve(L_acons)(function(){return "("})(function(){return ")"})(L_nil))}})())((function(){var $m; return function(){return $m || ($m = resolve(L_cons)(L_nil)(L_nil))}})()))}})()))}})()));
runMonad(resolve(L_resetStdTokenPacks));

//@ sourceURL=core/simpleParse.lsr
