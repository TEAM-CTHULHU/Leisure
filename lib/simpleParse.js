require('source-map-support').install();
runMonad(L_define()(function(){return "true"})(function(){return 0})(function(){return "true = \\a b . a"})((function(){var $m; return function(){return $m || ($m = setDataType(setType(function(L_a){return function(L_b){return L_a()}}, 'true'), 'true'))}})()));
runMonad(L_define()(function(){return "false"})(function(){return 0})(function(){return "false = \\a b . b"})((function(){var $m; return function(){return $m || ($m = setDataType(setType(function(L_a){return function(L_b){return L_b()}}, 'false'), 'false'))}})()));
runMonad(L_define()(function(){return "not"})(function(){return 1})(function(){return "not b = b false true"})((function(){var $m; return function(){return $m || ($m = function(L_b){return L_b()(L_false)(L_true)})}})()));
runMonad(L_define()(function(){return "and"})(function(){return 2})(function(){return "and a b = a b false"})((function(){var $m; return function(){return $m || ($m = function(L_a){return function(L_b){return L_a()(L_b)(L_false)}})}})()));
runMonad(L_define()(function(){return "or"})(function(){return 2})(function(){return "or a b = a true b"})((function(){var $m; return function(){return $m || ($m = function(L_a){return function(L_b){return L_a()(L_true)(L_b)}})}})()));
runMonad(L_define()(function(){return "some"})(function(){return 1})(function(){return "some x = \\someCase noneCase . someCase x"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_x){return setType(function(L_someCase){return function(L_noneCase){return L_someCase()(L_x)}}, 'some')}, 'some'))}})()));
runMonad(L_define()(function(){return "some2"})(function(){return 2})(function(){return "some2 a b = \\someCase noneCase . someCase a b"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_a){return function(L_b){return setType(function(L_someCase){return function(L_noneCase){return L_someCase()(L_a)(L_b)}}, 'some2')}}, 'some2'))}})()));
runMonad(L_define()(function(){return "none"})(function(){return 0})(function(){return "none = \\someCase noneCase . noneCase"})((function(){var $m; return function(){return $m || ($m = setDataType(setType(function(L_someCase){return function(L_noneCase){return L_noneCase()}}, 'none'), 'none'))}})()));
runMonad(L_define()(function(){return "neq"})(function(){return 2})(function(){return "neq a b = not (eq a b)"})((function(){var $m; return function(){return $m || ($m = function(L_a){return function(L_b){return L_not()((function(){var $m; return function(){return $m || ($m = L_eq()(L_a)(L_b))}})())}})}})()));
runMonad(L_define()(function(){return "left"})(function(){return 1})(function(){return "left x = \\lCase rCase . lCase x"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_x){return setType(function(L_lCase){return function(L_rCase){return L_lCase()(L_x)}}, 'left')}, 'left'))}})()));
runMonad(L_define()(function(){return "right"})(function(){return 1})(function(){return "right x = \\lCase rCase . rCase x"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_x){return setType(function(L_lCase){return function(L_rCase){return L_rCase()(L_x)}}, 'right')}, 'right'))}})()));
runMonad(L_define()(function(){return "id"})(function(){return 1})(function(){return "id x = x"})((function(){var $m; return function(){return $m || ($m = function(L_x){return L_x()})}})()));
runMonad(L_define()(function(){return "compose"})(function(){return 2})(function(){return "compose f g = \\x . f (g x)"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_f){return function(L_g){return setType(function(L_x){return L_f()((function(){var $m; return function(){return $m || ($m = L_g()(L_x))}})())}, 'compose')}}, 'compose'))}})()));
runMonad(L_define()(function(){return "flip"})(function(){return 1})(function(){return "flip func = \\x y . func y x"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_func){return setType(function(L_x){return function(L_y){return L_func()(L_y)(L_x)}}, 'flip')}, 'flip'))}})()));
runMonad(L_define()(function(){return "cons"})(function(){return 2})(function(){return "cons a b = \\f . f a b"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_a){return function(L_b){return setType(function(L_f){return L_f()(L_a)(L_b)}, 'cons')}}, 'cons'))}})()));
runMonad(L_define()(function(){return "isCons"})(function(){return 1})(function(){return "isCons c = hasType c cons"})((function(){var $m; return function(){return $m || ($m = function(L_c){return L_hasType()(L_c)(L_cons)})}})()));
runMonad(L_define()(function(){return "nil"})(function(){return 0})(function(){return "nil = \\a b . b"})((function(){var $m; return function(){return $m || ($m = setDataType(setType(function(L_a){return function(L_b){return L_b()}}, 'nil'), 'nil'))}})()));
runMonad(L_define()(function(){return "isNil"})(function(){return 1})(function(){return "isNil n = hasType n nil"})((function(){var $m; return function(){return $m || ($m = function(L_n){return L_hasType()(L_n)(L_nil)})}})()));
runMonad(L_define()(function(){return "head"})(function(){return 1})(function(){return "head l = l \\h t . h"})((function(){var $m; return function(){return $m || ($m = function(L_l){return L_l()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_h()}})}})())})}})()));
runMonad(L_define()(function(){return "tail"})(function(){return 1})(function(){return "tail l = l \\h t . t"})((function(){var $m; return function(){return $m || ($m = function(L_l){return L_l()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_t()}})}})())})}})()));
runMonad(L_define()(function(){return "last"})(function(){return 1})(function(){return "last l = isCons l\n  l \\h t . isCons t (last t) h\n  nil"})((function(){var $m; return function(){return $m || ($m = function(L_l){return L_isCons()(L_l)((function(){var $m; return function(){return $m || ($m = L_l()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_isCons()(L_t)((function(){var $m; return function(){return $m || ($m = L_last()(L_t))}})())(L_h)}})}})()))}})())(L_nil)})}})()));
runMonad(L_define()(function(){return "removeLast"})(function(){return 1})(function(){return "removeLast l = isCons l\n  l \\h t . isCons t (cons h (removeLast t)) nil\n  nil"})((function(){var $m; return function(){return $m || ($m = function(L_l){return L_isCons()(L_l)((function(){var $m; return function(){return $m || ($m = L_l()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_isCons()(L_t)((function(){var $m; return function(){return $m || ($m = L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_removeLast()(L_t))}})()))}})())(L_nil)}})}})()))}})())(L_nil)})}})()));
runMonad(L_define()(function(){return "length"})(function(){return 1})(function(){return "length list = list\n  \\h t D . + 1 (length t)\n  0"})((function(){var $m; return function(){return $m || ($m = function(L_list){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_$o()(function(){return 1})((function(){var $m; return function(){return $m || ($m = L_length()(L_t))}})())}}})}})())(function(){return 0})})}})()));
runMonad(L_define()(function(){return "append"})(function(){return 2})(function(){return "append a b = a (\\h t D . cons h (append t b)) b"})((function(){var $m; return function(){return $m || ($m = function(L_a){return function(L_b){return L_a()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_append()(L_t)(L_b))}})())}}})}})())(L_b)}})}})()));
runMonad(L_define()(function(){return "flatten"})(function(){return 1})(function(){return "flatten list = isCons list\n  subflatten list nil\n  list"})((function(){var $m; return function(){return $m || ($m = function(L_list){return L_isCons()(L_list)((function(){var $m; return function(){return $m || ($m = L_subflatten()(L_list)(L_nil))}})())(L_list)})}})()));
runMonad(L_define()(function(){return "subflatten"})(function(){return 2})(function(){return "subflatten list result = isNil list\n  result\n  isCons list\n    list \\h t . subflatten h (subflatten t result)\n    cons list result"})((function(){var $m; return function(){return $m || ($m = function(L_list){return function(L_result){return L_isNil()(L_list)(L_result)((function(){var $m; return function(){return $m || ($m = L_isCons()(L_list)((function(){var $m; return function(){return $m || ($m = L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_subflatten()(L_h)((function(){var $m; return function(){return $m || ($m = L_subflatten()(L_t)(L_result))}})())}})}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cons()(L_list)(L_result))}})()))}})())}})}})()));
runMonad(L_define()(function(){return "reverse"})(function(){return 1})(function(){return "reverse l = rev l nil"})((function(){var $m; return function(){return $m || ($m = function(L_l){return L_rev()(L_l)(L_nil)})}})()));
runMonad(L_define()(function(){return "rev"})(function(){return 2})(function(){return "rev l result = l (\\h t D . rev t (cons h result)) result"})((function(){var $m; return function(){return $m || ($m = function(L_l){return function(L_result){return L_l()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_rev()(L_t)((function(){var $m; return function(){return $m || ($m = L_cons()(L_h)(L_result))}})())}}})}})())(L_result)}})}})()));
runMonad(L_define()(function(){return "filter"})(function(){return 2})(function(){return "filter func list = list (\\h t D . func h (cons h) id (filter func t)) nil"})((function(){var $m; return function(){return $m || ($m = function(L_func){return function(L_list){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_func()(L_h)((function(){var $m; return function(){return $m || ($m = L_cons()(L_h))}})())(L_id)((function(){var $m; return function(){return $m || ($m = L_filter()(L_func)(L_t))}})())}}})}})())(L_nil)}})}})()));
runMonad(L_define()(function(){return "find"})(function(){return 2})(function(){return "find predicate list = list (\\h t D . predicate h (some h) (find predicate t)) none"})((function(){var $m; return function(){return $m || ($m = function(L_predicate){return function(L_list){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_predicate()(L_h)((function(){var $m; return function(){return $m || ($m = L_some()(L_h))}})())((function(){var $m; return function(){return $m || ($m = L_find()(L_predicate)(L_t))}})())}}})}})())(L_none)}})}})()));
runMonad(L_define()(function(){return "contains"})(function(){return 2})(function(){return "contains list item = find (\\el . eq el item) list (\\x . true) false"})((function(){var $m; return function(){return $m || ($m = function(L_list){return function(L_item){return L_find()((function(){var $m; return function(){return $m || ($m = function(L_el){return L_eq()(L_el)(L_item)})}})())(L_list)((function(){var $m; return function(){return $m || ($m = function(L_x){return L_true()})}})())(L_false)}})}})()));
runMonad(L_define()(function(){return "map"})(function(){return 2})(function(){return "map func l = l (\\h t D . cons (func h) (map func t)) nil"})((function(){var $m; return function(){return $m || ($m = function(L_func){return function(L_l){return L_l()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_cons()((function(){var $m; return function(){return $m || ($m = L_func()(L_h))}})())((function(){var $m; return function(){return $m || ($m = L_map()(L_func)(L_t))}})())}}})}})())(L_nil)}})}})()));
runMonad(L_define()(function(){return "mapSave"})(function(){return 2})(function(){return "mapSave func l = l\n  \\h t D . \\\\\n    newH = func h\n    newT = mapSave func t\n    .\n    and (eq newH h) (eq newT t)\n      l\n      cons newH newT\n  nil"})((function(){var $m; return function(){return $m || ($m = function(L_func){return function(L_l){return L_l()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return (function(){

var L_newT, L_newH;

L_newT = (function(){var $m; return function(){return $m || ($m = L_mapSave()(L_func)(L_t))}})();

L_newH = (function(){var $m; return function(){return $m || ($m = L_func()(L_h))}})();
return L_and()((function(){var $m; return function(){return $m || ($m = L_eq()(L_newH)(L_h))}})())((function(){var $m; return function(){return $m || ($m = L_eq()(L_newT)(L_t))}})())(L_l)((function(){var $m; return function(){return $m || ($m = L_cons()(L_newH)(L_newT))}})())})()}}})}})())(L_nil)}})}})()));
runMonad(L_define()(function(){return "foldl"})(function(){return 3})(function(){return "foldl func initialValue l = l (\\h t D . foldl func (func initialValue h) t) initialValue"})((function(){var $m; return function(){return $m || ($m = function(L_func){return function(L_initialValue){return function(L_l){return L_l()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_foldl()(L_func)((function(){var $m; return function(){return $m || ($m = L_func()(L_initialValue)(L_h))}})())(L_t)}}})}})())(L_initialValue)}}})}})()));
runMonad(L_define()(function(){return "foldl1"})(function(){return 2})(function(){return "foldl1 func l = l \\h t . foldl func h t"})((function(){var $m; return function(){return $m || ($m = function(L_func){return function(L_l){return L_l()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_foldl()(L_func)(L_h)(L_t)}})}})())}})}})()));
runMonad(L_define()(function(){return "foldr"})(function(){return 3})(function(){return "foldr func initialValue list = list\n  \\h t D . func h (foldr func initialValue t)\n  initialValue"})((function(){var $m; return function(){return $m || ($m = function(L_func){return function(L_initialValue){return function(L_list){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_func()(L_h)((function(){var $m; return function(){return $m || ($m = L_foldr()(L_func)(L_initialValue)(L_t))}})())}}})}})())(L_initialValue)}}})}})()));
runMonad(L_define()(function(){return "foldr1"})(function(){return 2})(function(){return "foldr1 func list = list \\h t . isNil t\n  h\n  func h (foldr1 func t)"})((function(){var $m; return function(){return $m || ($m = function(L_func){return function(L_list){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_isNil()(L_t)(L_h)((function(){var $m; return function(){return $m || ($m = L_func()(L_h)((function(){var $m; return function(){return $m || ($m = L_foldr1()(L_func)(L_t))}})()))}})())}})}})())}})}})()));
runMonad(L_define()(function(){return "intersperse"})(function(){return 2})(function(){return "intersperse list element = list (\\h t D .\n  isNil t\n    list\n    cons h (cons element (intersperse t element))) nil"})((function(){var $m; return function(){return $m || ($m = function(L_list){return function(L_element){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_isNil()(L_t)(L_list)((function(){var $m; return function(){return $m || ($m = L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_cons()(L_element)((function(){var $m; return function(){return $m || ($m = L_intersperse()(L_t)(L_element))}})()))}})()))}})())}}})}})())(L_nil)}})}})()));
runMonad(L_define()(function(){return "join"})(function(){return 2})(function(){return "join list el = strCat (intersperse list el)"})((function(){var $m; return function(){return $m || ($m = function(L_list){return function(L_el){return L_strCat()((function(){var $m; return function(){return $m || ($m = L_intersperse()(L_list)(L_el))}})())}})}})()));
runMonad(L_define()(function(){return "findIndex"})(function(){return 2})(function(){return "findIndex func list = idx list func 0"})((function(){var $m; return function(){return $m || ($m = function(L_func){return function(L_list){return L_idx()(L_list)(L_func)(function(){return 0})}})}})()));
runMonad(L_define()(function(){return "idx"})(function(){return 3})(function(){return "idx list func pos = list\n  \\h t D . func h\n    pos\n    idx t func (+ 1 pos)\n  -1"})((function(){var $m; return function(){return $m || ($m = function(L_list){return function(L_func){return function(L_pos){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_func()(L_h)(L_pos)((function(){var $m; return function(){return $m || ($m = L_idx()(L_t)(L_func)((function(){var $m; return function(){return $m || ($m = L_$o()(function(){return 1})(L_pos))}})()))}})())}}})}})())(function(){return -1})}}})}})()));
runMonad(L_define()(function(){return "index"})(function(){return 2})(function(){return "index list el = find (\\item . == el item) list"})((function(){var $m; return function(){return $m || ($m = function(L_list){return function(L_el){return L_find()((function(){var $m; return function(){return $m || ($m = function(L_item){return L_$p$p()(L_el)(L_item)})}})())(L_list)}})}})()));
runMonad(L_define()(function(){return "acons"})(function(){return 3})(function(){return "acons k v alist = cons (cons k v) alist"})((function(){var $m; return function(){return $m || ($m = function(L_k){return function(L_v){return function(L_alist){return L_cons()((function(){var $m; return function(){return $m || ($m = L_cons()(L_k)(L_v))}})())(L_alist)}}})}})()));
runMonad(L_define()(function(){return "assoc"})(function(){return 2})(function(){return "assoc k alist  = find (\\el . eq k (head el)) alist (\\cell . cell \\head tail . some tail) none"})((function(){var $m; return function(){return $m || ($m = function(L_k){return function(L_alist){return L_find()((function(){var $m; return function(){return $m || ($m = function(L_el){return L_eq()(L_k)((function(){var $m; return function(){return $m || ($m = L_head()(L_el))}})())})}})())(L_alist)((function(){var $m; return function(){return $m || ($m = function(L_cell){return L_cell()((function(){var $m; return function(){return $m || ($m = function(L_head){return function(L_tail){return L_some()(L_tail)}})}})())})}})())(L_none)}})}})()));
runMonad(L_define()(function(){return "rassoc"})(function(){return 2})(function(){return "rassoc v alist = find (\\el . eq v (tail el)) alist (\\cell . cell \\head tail . some head) none"})((function(){var $m; return function(){return $m || ($m = function(L_v){return function(L_alist){return L_find()((function(){var $m; return function(){return $m || ($m = function(L_el){return L_eq()(L_v)((function(){var $m; return function(){return $m || ($m = L_tail()(L_el))}})())})}})())(L_alist)((function(){var $m; return function(){return $m || ($m = function(L_cell){return L_cell()((function(){var $m; return function(){return $m || ($m = function(L_head){return function(L_tail){return L_some()(L_head)}})}})())})}})())(L_none)}})}})()));
runMonad(L_define()(function(){return "quicksort"})(function(){return 2})(function(){return "quicksort less list = (qs less list) nil"})((function(){var $m; return function(){return $m || ($m = function(L_less){return function(L_list){return L_qs()(L_less)(L_list)(L_nil)}})}})()));
runMonad(L_define()(function(){return "qs"})(function(){return 2})(function(){return "qs sortedFunc list = list\n  \\h t D . \\\\\n    greater = filter (sortedFunc h) t\n    lesser = filter (compose not (sortedFunc h)) t\n    .\n    \\rest . (qs sortedFunc lesser) (cons h ((qs sortedFunc greater) rest))\n  id"})((function(){var $m; return function(){return $m || ($m = function(L_sortedFunc){return function(L_list){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return (function(){

var L_lesser, L_greater;

L_lesser = (function(){var $m; return function(){return $m || ($m = L_filter()((function(){var $m; return function(){return $m || ($m = L_compose()(L_not)((function(){var $m; return function(){return $m || ($m = L_sortedFunc()(L_h))}})()))}})())(L_t))}})();

L_greater = (function(){var $m; return function(){return $m || ($m = L_filter()((function(){var $m; return function(){return $m || ($m = L_sortedFunc()(L_h))}})())(L_t))}})();
return function(L_rest){return L_qs()(L_sortedFunc)(L_lesser)((function(){var $m; return function(){return $m || ($m = L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_qs()(L_sortedFunc)(L_greater)(L_rest))}})()))}})())}})()}}})}})())(L_id)}})}})()));
runMonad(L_define()(function(){return "insertSorted"})(function(){return 3})(function(){return "insertSorted sortFunc item list = list\n  \\h t D . sortFunc item h (cons item list) (cons h (insertSorted sortFunc item t))\n  cons item nil"})((function(){var $m; return function(){return $m || ($m = function(L_sortFunc){return function(L_item){return function(L_list){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_sortFunc()(L_item)(L_h)((function(){var $m; return function(){return $m || ($m = L_cons()(L_item)(L_list))}})())((function(){var $m; return function(){return $m || ($m = L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_insertSorted()(L_sortFunc)(L_item)(L_t))}})()))}})())}}})}})())((function(){var $m; return function(){return $m || ($m = L_cons()(L_item)(L_nil))}})())}}})}})()));
runMonad(L_define()(function(){return "token"})(function(){return 2})(function(){return "token txt pos = \\f . f txt pos"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_txt){return function(L_pos){return setType(function(L_f){return L_f()(L_txt)(L_pos)}, 'token')}}, 'token'))}})()));
runMonad(L_define()(function(){return "tokenString"})(function(){return 1})(function(){return "tokenString tok = tok \\t p . t"})((function(){var $m; return function(){return $m || ($m = function(L_tok){return L_tok()((function(){var $m; return function(){return $m || ($m = function(L_t){return function(L_p){return L_t()}})}})())})}})()));
runMonad(L_define()(function(){return "tokenPos"})(function(){return 1})(function(){return "tokenPos tok = tok \\t p . p"})((function(){var $m; return function(){return $m || ($m = function(L_tok){return L_tok()((function(){var $m; return function(){return $m || ($m = function(L_t){return function(L_p){return L_p()}})}})())})}})()));
runMonad(L_define()(function(){return "isToken"})(function(){return 1})(function(){return "isToken t = hasType t token"})((function(){var $m; return function(){return $m || ($m = function(L_t){return L_hasType()(L_t)(L_token)})}})()));
runMonad(L_define()(function(){return "parens"})(function(){return 3})(function(){return "parens start end content = \\f . f start end content"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_start){return function(L_end){return function(L_content){return setType(function(L_f){return L_f()(L_start)(L_end)(L_content)}, 'parens')}}}, 'parens'))}})()));
runMonad(L_define()(function(){return "parensStart"})(function(){return 1})(function(){return "parensStart p = p \\s e c . s"})((function(){var $m; return function(){return $m || ($m = function(L_p){return L_p()((function(){var $m; return function(){return $m || ($m = function(L_s){return function(L_e){return function(L_c){return L_s()}}})}})())})}})()));
runMonad(L_define()(function(){return "parensEnd"})(function(){return 1})(function(){return "parensEnd p = p \\s e c . e"})((function(){var $m; return function(){return $m || ($m = function(L_p){return L_p()((function(){var $m; return function(){return $m || ($m = function(L_s){return function(L_e){return function(L_c){return L_e()}}})}})())})}})()));
runMonad(L_define()(function(){return "parensContent"})(function(){return 1})(function(){return "parensContent p = p \\s e c . c"})((function(){var $m; return function(){return $m || ($m = function(L_p){return L_p()((function(){var $m; return function(){return $m || ($m = function(L_s){return function(L_e){return function(L_c){return L_c()}}})}})())})}})()));
runMonad(L_define()(function(){return "isParens"})(function(){return 1})(function(){return "isParens p = hasType p parens"})((function(){var $m; return function(){return $m || ($m = function(L_p){return L_hasType()(L_p)(L_parens)})}})()));
runMonad(L_define()(function(){return "makeParens"})(function(){return 3})(function(){return "makeParens start end content =\n  and (isCons content) (isNil (tail content))\n    makeParens start end (head content)\n    or (isToken content) (isParens content)\n      content\n      parens start end content"})((function(){var $m; return function(){return $m || ($m = function(L_start){return function(L_end){return function(L_content){return L_and()((function(){var $m; return function(){return $m || ($m = L_isCons()(L_content))}})())((function(){var $m; return function(){return $m || ($m = L_isNil()((function(){var $m; return function(){return $m || ($m = L_tail()(L_content))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_makeParens()(L_start)(L_end)((function(){var $m; return function(){return $m || ($m = L_head()(L_content))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_or()((function(){var $m; return function(){return $m || ($m = L_isToken()(L_content))}})())((function(){var $m; return function(){return $m || ($m = L_isParens()(L_content))}})())(L_content)((function(){var $m; return function(){return $m || ($m = L_parens()(L_start)(L_end)(L_content))}})()))}})())}}})}})()));
runMonad(L_define()(function(){return "parensFromToks"})(function(){return 3})(function(){return "parensFromToks left right content = \\\\\n  start = tokenPos left\n  end = + (tokenPos right) (strLen (tokenString right))\n  .\n  parens start end content"})((function(){var $m; return function(){return $m || ($m = function(L_left){return function(L_right){return function(L_content){return (function(){

var L_end, L_start;

L_end = (function(){var $m; return function(){return $m || ($m = L_$o()((function(){var $m; return function(){return $m || ($m = L_tokenPos()(L_right))}})())((function(){var $m; return function(){return $m || ($m = L_strLen()((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_right))}})()))}})()))}})();

L_start = (function(){var $m; return function(){return $m || ($m = L_tokenPos()(L_left))}})();
return L_parens()(L_start)(L_end)(L_content)})()}}})}})()));
runMonad(L_define()(function(){return "stripParens"})(function(){return 1})(function(){return "stripParens p = isParens p (parensContent p) p"})((function(){var $m; return function(){return $m || ($m = function(L_p){return L_isParens()(L_p)((function(){var $m; return function(){return $m || ($m = L_parensContent()(L_p))}})())(L_p)})}})()));
runMonad(L_define()(function(){return "parseErr"})(function(){return 2})(function(){return "parseErr msg1 msg2 = \\f . f (strCat (cons msg1 (cons msg2 nil)))"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_msg1){return function(L_msg2){return setType(function(L_f){return L_f()((function(){var $m; return function(){return $m || ($m = L_strCat()((function(){var $m; return function(){return $m || ($m = L_cons()(L_msg1)((function(){var $m; return function(){return $m || ($m = L_cons()(L_msg2)(L_nil))}})()))}})()))}})())}, 'parseErr')}}, 'parseErr'))}})()));
runMonad(L_define()(function(){return "parseErrMsg"})(function(){return 1})(function(){return "parseErrMsg err = err \\m . m"})((function(){var $m; return function(){return $m || ($m = function(L_err){return L_err()((function(){var $m; return function(){return $m || ($m = function(L_m){return L_m()})}})())})}})()));
runMonad(L_define()(function(){return "makeTokens"})(function(){return 2})(function(){return "makeTokens strings start = strings (\\h t D . makeMoreTokens h t start) nil"})((function(){var $m; return function(){return $m || ($m = function(L_strings){return function(L_start){return L_strings()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_makeMoreTokens()(L_h)(L_t)(L_start)}}})}})())(L_nil)}})}})()));
runMonad(L_define()(function(){return "makeMoreTokens"})(function(){return 3})(function(){return "makeMoreTokens h t start = \\\\\n  next = makeTokens t (+ start (strLen h))\n  .\n  or (strStartsWith h ' ') (strStartsWith h '#')\n    next\n    and (strStartsWith h '\\n') (strStartsWith (head t) '#')\n      makeTokens (tail t) (+ start (+ (strLen h) (strLen (head t))))\n      cons (token h start) next"})((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_start){return (function(){

var L_next;

L_next = (function(){var $m; return function(){return $m || ($m = L_makeTokens()(L_t)((function(){var $m; return function(){return $m || ($m = L_$o()(L_start)((function(){var $m; return function(){return $m || ($m = L_strLen()(L_h))}})()))}})()))}})();
return L_or()((function(){var $m; return function(){return $m || ($m = L_strStartsWith()(L_h)(function(){return " "}))}})())((function(){var $m; return function(){return $m || ($m = L_strStartsWith()(L_h)(function(){return "#"}))}})())(L_next)((function(){var $m; return function(){return $m || ($m = L_and()((function(){var $m; return function(){return $m || ($m = L_strStartsWith()(L_h)(function(){return "\n"}))}})())((function(){var $m; return function(){return $m || ($m = L_strStartsWith()((function(){var $m; return function(){return $m || ($m = L_head()(L_t))}})())(function(){return "#"}))}})())((function(){var $m; return function(){return $m || ($m = L_makeTokens()((function(){var $m; return function(){return $m || ($m = L_tail()(L_t))}})())((function(){var $m; return function(){return $m || ($m = L_$o()(L_start)((function(){var $m; return function(){return $m || ($m = L_$o()((function(){var $m; return function(){return $m || ($m = L_strLen()(L_h))}})())((function(){var $m; return function(){return $m || ($m = L_strLen()((function(){var $m; return function(){return $m || ($m = L_head()(L_t))}})()))}})()))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_token()(L_h)(L_start))}})())(L_next))}})()))}})())})()}}})}})()));
runMonad(L_define()(function(){return "splitTokens"})(function(){return 2})(function(){return "splitTokens str pat = filter (\\s . not (eq s '')) (strSplit str pat)"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pat){return L_filter()((function(){var $m; return function(){return $m || ($m = function(L_s){return L_not()((function(){var $m; return function(){return $m || ($m = L_eq()(L_s)(function(){return ""}))}})())})}})())((function(){var $m; return function(){return $m || ($m = L_strSplit()(L_str)(L_pat))}})())}})}})()));
runMonad(L_define()(function(){return "tokens"})(function(){return 2})(function(){return "tokens str pat = makeTokens (splitTokens str pat) 0"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pat){return L_makeTokens()((function(){var $m; return function(){return $m || ($m = L_splitTokens()(L_str)(L_pat))}})())(function(){return 0})}})}})()));
runMonad(L_define()(function(){return "isString"})(function(){return 1})(function(){return "isString s = == (getType s) '*string'"})((function(){var $m; return function(){return $m || ($m = function(L_s){return L_$p$p()((function(){var $m; return function(){return $m || ($m = L_getType()(L_s))}})())(function(){return "*string"})})}})()));
runMonad(L_define()(function(){return "isTokenString"})(function(){return 2})(function(){return "isTokenString tok str = or\n  and (isToken tok) (eq (tokenString tok) str)\n  and (isString tok) (eq tok str)"})((function(){var $m; return function(){return $m || ($m = function(L_tok){return function(L_str){return L_or()((function(){var $m; return function(){return $m || ($m = L_and()((function(){var $m; return function(){return $m || ($m = L_isToken()(L_tok))}})())((function(){var $m; return function(){return $m || ($m = L_eq()((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_tok))}})())(L_str))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_and()((function(){var $m; return function(){return $m || ($m = L_isString()(L_tok))}})())((function(){var $m; return function(){return $m || ($m = L_eq()(L_tok)(L_str))}})()))}})())}})}})()));
runMonad(L_define()(function(){return "isTokenStart"})(function(){return 2})(function(){return "isTokenStart tok str = or\n  and (isToken tok) (strStartsWith (tokenString tok) str)\n  and (isString tok) (strStartsWith tok str)"})((function(){var $m; return function(){return $m || ($m = function(L_tok){return function(L_str){return L_or()((function(){var $m; return function(){return $m || ($m = L_and()((function(){var $m; return function(){return $m || ($m = L_isToken()(L_tok))}})())((function(){var $m; return function(){return $m || ($m = L_strStartsWith()((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_tok))}})())(L_str))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_and()((function(){var $m; return function(){return $m || ($m = L_isString()(L_tok))}})())((function(){var $m; return function(){return $m || ($m = L_strStartsWith()(L_tok)(L_str))}})()))}})())}})}})()));
runMonad(L_define()(function(){return "strTokenString"})(function(){return 1})(function(){return "strTokenString tok = withToken tok nil \\str pos . str"})((function(){var $m; return function(){return $m || ($m = function(L_tok){return L_withToken()(L_tok)(L_nil)((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pos){return L_str()}})}})())})}})()));
runMonad(L_define()(function(){return "withToken"})(function(){return 3})(function(){return "withToken tok nonTokCase tokCase = isToken tok\n  tok tokCase\n  isString tok\n    tokCase tok -1\n    nonTokCase"})((function(){var $m; return function(){return $m || ($m = function(L_tok){return function(L_nonTokCase){return function(L_tokCase){return L_isToken()(L_tok)((function(){var $m; return function(){return $m || ($m = L_tok()(L_tokCase))}})())((function(){var $m; return function(){return $m || ($m = L_isString()(L_tok)((function(){var $m; return function(){return $m || ($m = L_tokCase()(L_tok)(function(){return -1}))}})())(L_nonTokCase))}})())}}})}})()));
runMonad(L_define()(function(){return "withCons"})(function(){return 3})(function(){return "withCons l nilCase cont = isCons l (l (\\h t D . cont h t) nilCase) nilCase"})((function(){var $m; return function(){return $m || ($m = function(L_l){return function(L_nilCase){return function(L_cont){return L_isCons()(L_l)((function(){var $m; return function(){return $m || ($m = L_l()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_cont()(L_h)(L_t)}}})}})())(L_nilCase))}})())(L_nilCase)}}})}})()));
runMonad(L_define()(function(){return "parseToks"})(function(){return 3})(function(){return "parseToks toks groups cont =\n  isNil toks (cont nil)\n    parseTok toks groups \\h t .\n      parseToks t groups \\res .\n        cont (cons h\n          and (isCons res) (isBlockStart (head res))\n            cons res nil\n            res)"})((function(){var $m; return function(){return $m || ($m = function(L_toks){return function(L_groups){return function(L_cont){return L_isNil()(L_toks)((function(){var $m; return function(){return $m || ($m = L_cont()(L_nil))}})())((function(){var $m; return function(){return $m || ($m = L_parseTok()(L_toks)(L_groups)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_parseToks()(L_t)(L_groups)((function(){var $m; return function(){return $m || ($m = function(L_res){return L_cont()((function(){var $m; return function(){return $m || ($m = L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_and()((function(){var $m; return function(){return $m || ($m = L_isCons()(L_res))}})())((function(){var $m; return function(){return $m || ($m = L_isBlockStart()((function(){var $m; return function(){return $m || ($m = L_head()(L_res))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cons()(L_res)(L_nil))}})())(L_res))}})()))}})())})}})())}})}})()))}})())}}})}})()));
runMonad(L_define()(function(){return "parseTok"})(function(){return 3})(function(){return "parseTok toks groups cont = withCons toks nil \\h t .\n  withToken h (cont h t) \\txt pos .\n    assoc txt groups\n      \\close . parseGroup h t nil close groups cont\n      isTokenStart h '\\n' (parseIndent h t nil groups cont)\n        cont h t"})((function(){var $m; return function(){return $m || ($m = function(L_toks){return function(L_groups){return function(L_cont){return L_withCons()(L_toks)(L_nil)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_withToken()(L_h)((function(){var $m; return function(){return $m || ($m = L_cont()(L_h)(L_t))}})())((function(){var $m; return function(){return $m || ($m = function(L_txt){return function(L_pos){return L_assoc()(L_txt)(L_groups)((function(){var $m; return function(){return $m || ($m = function(L_close){return L_parseGroup()(L_h)(L_t)(L_nil)(L_close)(L_groups)(L_cont)})}})())((function(){var $m; return function(){return $m || ($m = L_isTokenStart()(L_h)(function(){return "\n"})((function(){var $m; return function(){return $m || ($m = L_parseIndent()(L_h)(L_t)(L_nil)(L_groups)(L_cont))}})())((function(){var $m; return function(){return $m || ($m = L_cont()(L_h)(L_t))}})()))}})())}})}})())}})}})())}}})}})()));
runMonad(L_define()(function(){return "parseGroup"})(function(){return 6})(function(){return "parseGroup left toks gr close groups cont = withCons toks (parseErr 'Unterminated group starting ' (loc left))\n  \\h t . isTokenString h close\n    eq close ')'\n      cont (parensFromToks left h (reverse gr)) t\n      cont (cons left (cons (reverse gr) (cons h nil))) t\n    withToken h\n      parseTok toks groups \\restH restT . parseGroup left restT (cons restH gr) close groups cont\n      \\txt pos .\n        rassoc txt groups\n          \\open . parseErr (strCat (cons 'Mismatched group: ' (cons (tokenString left) (cons txt (cons ' ' nil))))) (loc left)\n          parseTok toks groups \\restH restT . parseGroup left restT (cons restH gr) close groups cont"})((function(){var $m; return function(){return $m || ($m = function(L_left){return function(L_toks){return function(L_gr){return function(L_close){return function(L_groups){return function(L_cont){return L_withCons()(L_toks)((function(){var $m; return function(){return $m || ($m = L_parseErr()(function(){return "Unterminated group starting "})((function(){var $m; return function(){return $m || ($m = L_loc()(L_left))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_isTokenString()(L_h)(L_close)((function(){var $m; return function(){return $m || ($m = L_eq()(L_close)(function(){return ")"})((function(){var $m; return function(){return $m || ($m = L_cont()((function(){var $m; return function(){return $m || ($m = L_parensFromToks()(L_left)(L_h)((function(){var $m; return function(){return $m || ($m = L_reverse()(L_gr))}})()))}})())(L_t))}})())((function(){var $m; return function(){return $m || ($m = L_cont()((function(){var $m; return function(){return $m || ($m = L_cons()(L_left)((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_reverse()(L_gr))}})())((function(){var $m; return function(){return $m || ($m = L_cons()(L_h)(L_nil))}})()))}})()))}})())(L_t))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_withToken()(L_h)((function(){var $m; return function(){return $m || ($m = L_parseTok()(L_toks)(L_groups)((function(){var $m; return function(){return $m || ($m = function(L_restH){return function(L_restT){return L_parseGroup()(L_left)(L_restT)((function(){var $m; return function(){return $m || ($m = L_cons()(L_restH)(L_gr))}})())(L_close)(L_groups)(L_cont)}})}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_txt){return function(L_pos){return L_rassoc()(L_txt)(L_groups)((function(){var $m; return function(){return $m || ($m = function(L_open){return L_parseErr()((function(){var $m; return function(){return $m || ($m = L_strCat()((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "Mismatched group: "})((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_left))}})())((function(){var $m; return function(){return $m || ($m = L_cons()(L_txt)((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return " "})(L_nil))}})()))}})()))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_loc()(L_left))}})())})}})())((function(){var $m; return function(){return $m || ($m = L_parseTok()(L_toks)(L_groups)((function(){var $m; return function(){return $m || ($m = function(L_restH){return function(L_restT){return L_parseGroup()(L_left)(L_restT)((function(){var $m; return function(){return $m || ($m = L_cons()(L_restH)(L_gr))}})())(L_close)(L_groups)(L_cont)}})}})()))}})())}})}})()))}})())}})}})())}}}}}})}})()));
runMonad(L_define()(function(){return "parseIndent"})(function(){return 5})(function(){return "parseIndent indent toks gr groups cont =\n  withCons toks (cont (makeParens (tokenPos indent) (lexEnd (head gr)) (reverse gr)) nil) \\h t .\n    or (withToken h false (\\txt pos . rassoc txt groups (\\open . true) false))\n      and (isTokenStart h '\\n') (<= (strLen (tokenString h)) (strLen (tokenString indent)))\n      cont (makeParens (tokenPos indent) (tokenPos h) (reverse gr)) toks\n      parseTok toks groups \\restH restT . parseIndent indent restT (cons restH gr) groups cont"})((function(){var $m; return function(){return $m || ($m = function(L_indent){return function(L_toks){return function(L_gr){return function(L_groups){return function(L_cont){return L_withCons()(L_toks)((function(){var $m; return function(){return $m || ($m = L_cont()((function(){var $m; return function(){return $m || ($m = L_makeParens()((function(){var $m; return function(){return $m || ($m = L_tokenPos()(L_indent))}})())((function(){var $m; return function(){return $m || ($m = L_lexEnd()((function(){var $m; return function(){return $m || ($m = L_head()(L_gr))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_reverse()(L_gr))}})()))}})())(L_nil))}})())((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_or()((function(){var $m; return function(){return $m || ($m = L_withToken()(L_h)(L_false)((function(){var $m; return function(){return $m || ($m = function(L_txt){return function(L_pos){return L_rassoc()(L_txt)(L_groups)((function(){var $m; return function(){return $m || ($m = function(L_open){return L_true()})}})())(L_false)}})}})()))}})())((function(){var $m; return function(){return $m || ($m = L_and()((function(){var $m; return function(){return $m || ($m = L_isTokenStart()(L_h)(function(){return "\n"}))}})())((function(){var $m; return function(){return $m || ($m = L_$y$p()((function(){var $m; return function(){return $m || ($m = L_strLen()((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_h))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_strLen()((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_indent))}})()))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cont()((function(){var $m; return function(){return $m || ($m = L_makeParens()((function(){var $m; return function(){return $m || ($m = L_tokenPos()(L_indent))}})())((function(){var $m; return function(){return $m || ($m = L_tokenPos()(L_h))}})())((function(){var $m; return function(){return $m || ($m = L_reverse()(L_gr))}})()))}})())(L_toks))}})())((function(){var $m; return function(){return $m || ($m = L_parseTok()(L_toks)(L_groups)((function(){var $m; return function(){return $m || ($m = function(L_restH){return function(L_restT){return L_parseIndent()(L_indent)(L_restT)((function(){var $m; return function(){return $m || ($m = L_cons()(L_restH)(L_gr))}})())(L_groups)(L_cont)}})}})()))}})())}})}})())}}}}})}})()));
runMonad(L_define()(function(){return "id"})(function(){return 1})(function(){return "id x = x"})((function(){var $m; return function(){return $m || ($m = function(L_x){return L_x()})}})()));
runMonad(L_define()(function(){return "lit"})(function(){return 1})(function(){return "lit value = \\f . f value"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_value){return setType(function(L_f){return L_f()(L_value)}, 'lit')}, 'lit'))}})()));
runMonad(L_define()(function(){return "ref"})(function(){return 1})(function(){return "ref name = \\f . f name"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_name){return setType(function(L_f){return L_f()(L_name)}, 'ref')}, 'ref'))}})()));
runMonad(L_define()(function(){return "lambda"})(function(){return 2})(function(){return "lambda name body = \\f . f name body"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_name){return function(L_body){return setType(function(L_f){return L_f()(L_name)(L_body)}, 'lambda')}}, 'lambda'))}})()));
runMonad(L_define()(function(){return "apply"})(function(){return 2})(function(){return "apply func arg = \\f . f func arg"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_func){return function(L_arg){return setType(function(L_f){return L_f()(L_func)(L_arg)}, 'apply')}}, 'apply'))}})()));
runMonad(L_define()(function(){return "let"})(function(){return 3})(function(){return "let name value body = \\f . f name value body"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_name){return function(L_value){return function(L_body){return setType(function(L_f){return L_f()(L_name)(L_value)(L_body)}, 'let')}}}, 'let'))}})()));
runMonad(L_define()(function(){return "anno"})(function(){return 3})(function(){return "anno name data body = \\f . f name data body"})((function(){var $m; return function(){return $m || ($m = setDataType(function(L_name){return function(L_data){return function(L_body){return setType(function(L_f){return L_f()(L_name)(L_data)(L_body)}, 'anno')}}}, 'anno'))}})()));
runMonad(L_define()(function(){return "withParens"})(function(){return 3})(function(){return "withParens p err cont = isParens p (p cont) err"})((function(){var $m; return function(){return $m || ($m = function(L_p){return function(L_err){return function(L_cont){return L_isParens()(L_p)((function(){var $m; return function(){return $m || ($m = L_p()(L_cont))}})())(L_err)}}})}})()));
runMonad(L_define()(function(){return "setParens"})(function(){return 2})(function(){return "setParens p func = isParens p\n  p \\start end content . parens start end (func content)\n  func p"})((function(){var $m; return function(){return $m || ($m = function(L_p){return function(L_func){return L_isParens()(L_p)((function(){var $m; return function(){return $m || ($m = L_p()((function(){var $m; return function(){return $m || ($m = function(L_start){return function(L_end){return function(L_content){return L_parens()(L_start)(L_end)((function(){var $m; return function(){return $m || ($m = L_func()(L_content))}})())}}})}})()))}})())((function(){var $m; return function(){return $m || ($m = L_func()(L_p))}})())}})}})()));
runMonad(L_define()(function(){return "withStripped"})(function(){return 2})(function(){return "withStripped list cont = withParens list (cont list) \\start end content . withStripped content cont"})((function(){var $m; return function(){return $m || ($m = function(L_list){return function(L_cont){return L_withParens()(L_list)((function(){var $m; return function(){return $m || ($m = L_cont()(L_list))}})())((function(){var $m; return function(){return $m || ($m = function(L_start){return function(L_end){return function(L_content){return L_withStripped()(L_content)(L_cont)}}})}})())}})}})()));
runMonad(L_define()(function(){return "position"})(function(){return 1})(function(){return "position thing = isToken thing (tokenPos thing)\n  isParens thing (parensStart thing)\n    isCons thing (position (head thing))\n      -1"})((function(){var $m; return function(){return $m || ($m = function(L_thing){return L_isToken()(L_thing)((function(){var $m; return function(){return $m || ($m = L_tokenPos()(L_thing))}})())((function(){var $m; return function(){return $m || ($m = L_isParens()(L_thing)((function(){var $m; return function(){return $m || ($m = L_parensStart()(L_thing))}})())((function(){var $m; return function(){return $m || ($m = L_isCons()(L_thing)((function(){var $m; return function(){return $m || ($m = L_position()((function(){var $m; return function(){return $m || ($m = L_head()(L_thing))}})()))}})())(function(){return -1}))}})()))}})())})}})()));
runMonad(L_define()(function(){return "lexEnd"})(function(){return 1})(function(){return "lexEnd thing = isToken thing (+ (tokenPos thing) (strLen (tokenString thing)))\n  isParens thing (parensEnd thing)\n    isCons thing (lexEnd (last thing))\n      -1"})((function(){var $m; return function(){return $m || ($m = function(L_thing){return L_isToken()(L_thing)((function(){var $m; return function(){return $m || ($m = L_$o()((function(){var $m; return function(){return $m || ($m = L_tokenPos()(L_thing))}})())((function(){var $m; return function(){return $m || ($m = L_strLen()((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_thing))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_isParens()(L_thing)((function(){var $m; return function(){return $m || ($m = L_parensEnd()(L_thing))}})())((function(){var $m; return function(){return $m || ($m = L_isCons()(L_thing)((function(){var $m; return function(){return $m || ($m = L_lexEnd()((function(){var $m; return function(){return $m || ($m = L_last()(L_thing))}})()))}})())(function(){return -1}))}})()))}})())})}})()));
runMonad(L_define()(function(){return "loc"})(function(){return 1})(function(){return "loc thing = \\\\\n  p = position thing\n  l = eq p -1 'an unknown location' p\n  .\n  strCat (cons 'at ' (cons l nil))"})((function(){var $m; return function(){return $m || ($m = function(L_thing){return (function(){

var L_l, L_p;

L_l = (function(){var $m; return function(){return $m || ($m = L_eq()(L_p)(function(){return -1})(function(){return "an unknown location"})(L_p))}})();

L_p = (function(){var $m; return function(){return $m || ($m = L_position()(L_thing))}})();
return L_strCat()((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "at "})((function(){var $m; return function(){return $m || ($m = L_cons()(L_l)(L_nil))}})()))}})())})()})}})()));
runMonad(L_define()(function(){return "scrub"})(function(){return 1})(function(){return "scrub str = strFromList (scrubList (strToList str))"})((function(){var $m; return function(){return $m || ($m = function(L_str){return L_strFromList()((function(){var $m; return function(){return $m || ($m = L_scrubList()((function(){var $m; return function(){return $m || ($m = L_strToList()(L_str))}})()))}})())})}})()));
runMonad(L_define()(function(){return "scrubList"})(function(){return 1})(function(){return "scrubList list = list\n  \\h t D . \\\\\n    next = scrubList t\n    .\n    eq h '\\\\' (cons h (cons (head t) (scrubList (tail t))))\n      eq h '\\\"' (cons '\\\\' (cons '\\\"' next))\n        cons h next\n  nil"})((function(){var $m; return function(){return $m || ($m = function(L_list){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return (function(){

var L_next;

L_next = (function(){var $m; return function(){return $m || ($m = L_scrubList()(L_t))}})();
return L_eq()(L_h)(function(){return "\\"})((function(){var $m; return function(){return $m || ($m = L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_head()(L_t))}})())((function(){var $m; return function(){return $m || ($m = L_scrubList()((function(){var $m; return function(){return $m || ($m = L_tail()(L_t))}})()))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_eq()(L_h)(function(){return "\""})((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "\\"})((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "\""})(L_next))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cons()(L_h)(L_next))}})()))}})())})()}}})}})())(L_nil)})}})()));
runMonad(L_define()(function(){return "createAst"})(function(){return 3})(function(){return "createAst inList names cont = withStripped inList \\list .\n  isToken list (createLitOrRef (tokenString list) names cont)\n    list\n      \\h t D .\n        isTokenString h '\\\\\\\\' (createLet h t names cont)\n          isTokenString h '\\\\@' (createAnno h t names cont)\n            isTokenString h '\\\\' (createLambda h t names cont)\n              createApply list names cont\n      cont nil"})((function(){var $m; return function(){return $m || ($m = function(L_inList){return function(L_names){return function(L_cont){return L_withStripped()(L_inList)((function(){var $m; return function(){return $m || ($m = function(L_list){return L_isToken()(L_list)((function(){var $m; return function(){return $m || ($m = L_createLitOrRef()((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_list))}})())(L_names)(L_cont))}})())((function(){var $m; return function(){return $m || ($m = L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_isTokenString()(L_h)(function(){return "\\\\"})((function(){var $m; return function(){return $m || ($m = L_createLet()(L_h)(L_t)(L_names)(L_cont))}})())((function(){var $m; return function(){return $m || ($m = L_isTokenString()(L_h)(function(){return "\\@"})((function(){var $m; return function(){return $m || ($m = L_createAnno()(L_h)(L_t)(L_names)(L_cont))}})())((function(){var $m; return function(){return $m || ($m = L_isTokenString()(L_h)(function(){return "\\"})((function(){var $m; return function(){return $m || ($m = L_createLambda()(L_h)(L_t)(L_names)(L_cont))}})())((function(){var $m; return function(){return $m || ($m = L_createApply()(L_list)(L_names)(L_cont))}})()))}})()))}})())}}})}})())((function(){var $m; return function(){return $m || ($m = L_cont()(L_nil))}})()))}})())})}})())}}})}})()));
runMonad(L_define()(function(){return "strMatches"})(function(){return 2})(function(){return "strMatches str pat = isCons (strMatch str pat)"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pat){return L_isCons()((function(){var $m; return function(){return $m || ($m = L_strMatch()(L_str)(L_pat))}})())}})}})()));
runMonad(L_define()(function(){return "digit"})(function(){return 0})(function(){return "digit = regexp '^[0-9]+$'"})((function(){var $m; return function(){return $m || ($m = L_regexp()(function(){return "^[0-9]+$"}))}})()));
runMonad(L_define()(function(){return "backslashCodes"})(function(){return 0})(function(){return "backslashCodes = 'bfnrt'"})(function(){return "bfnrt"}));
runMonad(L_define()(function(){return "backslashValues"})(function(){return 0})(function(){return "backslashValues = '\\b\\f\\n\\r\\t'"})(function(){return "\b\f\n\r\t"}));
runMonad(L_define()(function(){return "convertStringEscape"})(function(){return 3})(function(){return "convertStringEscape char codes values =\n  eq codes ''\n    char\n    eq char (strAt codes 0)\n      strAt values 0\n      convertStringEscape char (strSubstring codes 1 0) (strSubstring values 1 0)"})((function(){var $m; return function(){return $m || ($m = function(L_char){return function(L_codes){return function(L_values){return L_eq()(L_codes)(function(){return ""})(L_char)((function(){var $m; return function(){return $m || ($m = L_eq()(L_char)((function(){var $m; return function(){return $m || ($m = L_strAt()(L_codes)(function(){return 0}))}})())((function(){var $m; return function(){return $m || ($m = L_strAt()(L_values)(function(){return 0}))}})())((function(){var $m; return function(){return $m || ($m = L_convertStringEscape()(L_char)((function(){var $m; return function(){return $m || ($m = L_strSubstring()(L_codes)(function(){return 1})(function(){return 0}))}})())((function(){var $m; return function(){return $m || ($m = L_strSubstring()(L_values)(function(){return 1})(function(){return 0}))}})()))}})()))}})())}}})}})()));
runMonad(L_define()(function(){return "convertStringEscapes"})(function(){return 3})(function(){return "convertStringEscapes orig str cont =\n  eq str ''\n    cont str\n    eq (strAt str 0) '\\\\'\n      eq (strLen str) 1 (parseErr \"Error, backslash without character in string: \" orig)\n        convertStringEscapes orig (strSubstring str 2 0) \\rest . cont\n          strAdd\n            convertStringEscape (strAt str 1) backslashCodes backslashValues\n            rest\n      convertStringEscapes orig (strSubstring str 1 0) \\rest . cont\n        strAdd\n          strAt str 0\n          rest"})((function(){var $m; return function(){return $m || ($m = function(L_orig){return function(L_str){return function(L_cont){return L_eq()(L_str)(function(){return ""})((function(){var $m; return function(){return $m || ($m = L_cont()(L_str))}})())((function(){var $m; return function(){return $m || ($m = L_eq()((function(){var $m; return function(){return $m || ($m = L_strAt()(L_str)(function(){return 0}))}})())(function(){return "\\"})((function(){var $m; return function(){return $m || ($m = L_eq()((function(){var $m; return function(){return $m || ($m = L_strLen()(L_str))}})())(function(){return 1})((function(){var $m; return function(){return $m || ($m = L_parseErr()(function(){return "Error, backslash without character in string: "})(L_orig))}})())((function(){var $m; return function(){return $m || ($m = L_convertStringEscapes()(L_orig)((function(){var $m; return function(){return $m || ($m = L_strSubstring()(L_str)(function(){return 2})(function(){return 0}))}})())((function(){var $m; return function(){return $m || ($m = function(L_rest){return L_cont()((function(){var $m; return function(){return $m || ($m = L_strAdd()((function(){var $m; return function(){return $m || ($m = L_convertStringEscape()((function(){var $m; return function(){return $m || ($m = L_strAt()(L_str)(function(){return 1}))}})())(L_backslashCodes)(L_backslashValues))}})())(L_rest))}})())})}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_convertStringEscapes()(L_orig)((function(){var $m; return function(){return $m || ($m = L_strSubstring()(L_str)(function(){return 1})(function(){return 0}))}})())((function(){var $m; return function(){return $m || ($m = function(L_rest){return L_cont()((function(){var $m; return function(){return $m || ($m = L_strAdd()((function(){var $m; return function(){return $m || ($m = L_strAt()(L_str)(function(){return 0}))}})())(L_rest))}})())})}})()))}})()))}})())}}})}})()));
runMonad(L_define()(function(){return "parseString"})(function(){return 2})(function(){return "parseString str cont =\n  neq (strAt str 0) (strAt str -1) (parseErr \"Badly terminated string: \" str)\n    convertStringEscapes str (strSubstring str 1 -1) cont"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_cont){return L_neq()((function(){var $m; return function(){return $m || ($m = L_strAt()(L_str)(function(){return 0}))}})())((function(){var $m; return function(){return $m || ($m = L_strAt()(L_str)(function(){return -1}))}})())((function(){var $m; return function(){return $m || ($m = L_parseErr()(function(){return "Badly terminated string: "})(L_str))}})())((function(){var $m; return function(){return $m || ($m = L_convertStringEscapes()(L_str)((function(){var $m; return function(){return $m || ($m = L_strSubstring()(L_str)(function(){return 1})(function(){return -1}))}})())(L_cont))}})())}})}})()));
runMonad(L_define()(function(){return "createLitOrRef"})(function(){return 3})(function(){return "createLitOrRef tok names cont =\n  contains names tok\n    cont (ref tok)\n    or (strStartsWith tok '\\\"') (strStartsWith tok \"'\")\n      parseString tok \\str . cont (lit str)\n      or (and (>= (strAt tok 0) '0') (<= (strAt tok 0) '9')) (strStartsWith tok '-')\n        jsonParse tok (\\err . cont (ref tok)) (\\item . cont (lit item))\n        cont (ref tok)"})((function(){var $m; return function(){return $m || ($m = function(L_tok){return function(L_names){return function(L_cont){return L_contains()(L_names)(L_tok)((function(){var $m; return function(){return $m || ($m = L_cont()((function(){var $m; return function(){return $m || ($m = L_ref()(L_tok))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_or()((function(){var $m; return function(){return $m || ($m = L_strStartsWith()(L_tok)(function(){return "\""}))}})())((function(){var $m; return function(){return $m || ($m = L_strStartsWith()(L_tok)(function(){return "'"}))}})())((function(){var $m; return function(){return $m || ($m = L_parseString()(L_tok)((function(){var $m; return function(){return $m || ($m = function(L_str){return L_cont()((function(){var $m; return function(){return $m || ($m = L_lit()(L_str))}})())})}})()))}})())((function(){var $m; return function(){return $m || ($m = L_or()((function(){var $m; return function(){return $m || ($m = L_and()((function(){var $m; return function(){return $m || ($m = L_$z$p()((function(){var $m; return function(){return $m || ($m = L_strAt()(L_tok)(function(){return 0}))}})())(function(){return "0"}))}})())((function(){var $m; return function(){return $m || ($m = L_$y$p()((function(){var $m; return function(){return $m || ($m = L_strAt()(L_tok)(function(){return 0}))}})())(function(){return "9"}))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_strStartsWith()(L_tok)(function(){return "-"}))}})())((function(){var $m; return function(){return $m || ($m = L_jsonParse()(L_tok)((function(){var $m; return function(){return $m || ($m = function(L_err){return L_cont()((function(){var $m; return function(){return $m || ($m = L_ref()(L_tok))}})())})}})())((function(){var $m; return function(){return $m || ($m = function(L_item){return L_cont()((function(){var $m; return function(){return $m || ($m = L_lit()(L_item))}})())})}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cont()((function(){var $m; return function(){return $m || ($m = L_ref()(L_tok))}})()))}})()))}})()))}})())}}})}})()));
runMonad(L_define()(function(){return "createLambda"})(function(){return 4})(function(){return "createLambda start list names cont = \\\\\n  err = parseErr \"Lambda needs a variable name, a dot, and a body \" (loc start)\n  .\n  withCons list err \\name rest .\n    withToken name err \\n p .\n      withCons rest err \\dot body .\n        # are these partial applications too hard to read?\n        isTokenString dot '.' (createAst body) (createLambda start rest)\n          cons n names\n          \\bodyAst . cont (lambda n bodyAst)"})((function(){var $m; return function(){return $m || ($m = function(L_start){return function(L_list){return function(L_names){return function(L_cont){return (function(){

var L_err;

L_err = (function(){var $m; return function(){return $m || ($m = L_parseErr()(function(){return "Lambda needs a variable name, a dot, and a body "})((function(){var $m; return function(){return $m || ($m = L_loc()(L_start))}})()))}})();
return L_withCons()(L_list)(L_err)((function(){var $m; return function(){return $m || ($m = function(L_name){return function(L_rest){return L_withToken()(L_name)(L_err)((function(){var $m; return function(){return $m || ($m = function(L_n){return function(L_p){return L_withCons()(L_rest)(L_err)((function(){var $m; return function(){return $m || ($m = function(L_dot){return function(L_body){return L_isTokenString()(L_dot)(function(){return "."})((function(){var $m; return function(){return $m || ($m = L_createAst()(L_body))}})())((function(){var $m; return function(){return $m || ($m = L_createLambda()(L_start)(L_rest))}})())((function(){var $m; return function(){return $m || ($m = L_cons()(L_n)(L_names))}})())((function(){var $m; return function(){return $m || ($m = function(L_bodyAst){return L_cont()((function(){var $m; return function(){return $m || ($m = L_lambda()(L_n)(L_bodyAst))}})())})}})())}})}})())}})}})())}})}})())})()}}}})}})()));
runMonad(L_define()(function(){return "createAnno"})(function(){return 4})(function(){return "createAnno start list names cont =\n  withCons list (parseErr \"No annotation name or data in annotation \" (loc start)) \\name rest .\n    withCons rest (parseErr \"No data for annotation \" (loc start)) \\data rest . \\\\\n      finish data body = createAst body names \\bodyAst .\n        cleanTokens start name \\name .\n          cleanTokens start data \\data .\n            cont (anno name data bodyAst)\n      .\n      isTokenString data '.'\n        finish nil rest\n        withStripped data \\data .\n          withCons rest (parseErr \"No body for annotation \" (loc start)) \\dot body .\n            isTokenString dot '.'\n              finish data body\n              parseErr \"Annotation expects dot after name and data \" (loc start)"})((function(){var $m; return function(){return $m || ($m = function(L_start){return function(L_list){return function(L_names){return function(L_cont){return L_withCons()(L_list)((function(){var $m; return function(){return $m || ($m = L_parseErr()(function(){return "No annotation name or data in annotation "})((function(){var $m; return function(){return $m || ($m = L_loc()(L_start))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_name){return function(L_rest){return L_withCons()(L_rest)((function(){var $m; return function(){return $m || ($m = L_parseErr()(function(){return "No data for annotation "})((function(){var $m; return function(){return $m || ($m = L_loc()(L_start))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_data){return function(L_rest_0){return (function(){

var L_finish;

L_finish = (function(){var $m; return function(){return $m || ($m = function(L_data_1){return function(L_body){return L_createAst()(L_body)(L_names)((function(){var $m; return function(){return $m || ($m = function(L_bodyAst){return L_cleanTokens()(L_start)(L_name)((function(){var $m; return function(){return $m || ($m = function(L_name_2){return L_cleanTokens()(L_start)(L_data_1)((function(){var $m; return function(){return $m || ($m = function(L_data_3){return L_cont()((function(){var $m; return function(){return $m || ($m = L_anno()(L_name_2)(L_data_3)(L_bodyAst))}})())})}})())})}})())})}})())}})}})();
return L_isTokenString()(L_data)(function(){return "."})((function(){var $m; return function(){return $m || ($m = L_finish()(L_nil)(L_rest_0))}})())((function(){var $m; return function(){return $m || ($m = L_withStripped()(L_data)((function(){var $m; return function(){return $m || ($m = function(L_data_1){return L_withCons()(L_rest_0)((function(){var $m; return function(){return $m || ($m = L_parseErr()(function(){return "No body for annotation "})((function(){var $m; return function(){return $m || ($m = L_loc()(L_start))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_dot){return function(L_body){return L_isTokenString()(L_dot)(function(){return "."})((function(){var $m; return function(){return $m || ($m = L_finish()(L_data_1)(L_body))}})())((function(){var $m; return function(){return $m || ($m = L_parseErr()(function(){return "Annotation expects dot after name and data "})((function(){var $m; return function(){return $m || ($m = L_loc()(L_start))}})()))}})())}})}})())})}})()))}})())})()}})}})())}})}})())}}}})}})()));
runMonad(L_define()(function(){return "bodyStructPat"})(function(){return 0})(function(){return "bodyStructPat = regexp '\\\\|\\\\\\\\|\\\\@'"})((function(){var $m; return function(){return $m || ($m = L_regexp()(function(){return "\\|\\\\|\\@"}))}})()));
runMonad(L_define()(function(){return "createApply"})(function(){return 3})(function(){return "createApply inList names cont = withStripped inList \\list .\n  withCons list (parseErr \"Funcion apply expecting a non-empty list \" (loc inList)) \\h t .\n    createAst h names \\func . chainApply func t names cont"})((function(){var $m; return function(){return $m || ($m = function(L_inList){return function(L_names){return function(L_cont){return L_withStripped()(L_inList)((function(){var $m; return function(){return $m || ($m = function(L_list){return L_withCons()(L_list)((function(){var $m; return function(){return $m || ($m = L_parseErr()(function(){return "Funcion apply expecting a non-empty list "})((function(){var $m; return function(){return $m || ($m = L_loc()(L_inList))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_createAst()(L_h)(L_names)((function(){var $m; return function(){return $m || ($m = function(L_func){return L_chainApply()(L_func)(L_t)(L_names)(L_cont)})}})())}})}})())})}})())}}})}})()));
runMonad(L_define()(function(){return "blockStarts"})(function(){return 0})(function(){return "blockStarts = cons '\\\\' (cons '\\\\\\\\' (cons '\\\\@' nil))"})((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "\\"})((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "\\\\"})((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "\\@"})(L_nil))}})()))}})()))}})()));
runMonad(L_define()(function(){return "chainApply"})(function(){return 4})(function(){return "chainApply func list names cont = withCons list (cont func) \\argItem rest .\n  and (isToken argItem) (contains blockStarts (tokenString argItem))\n    createAst list names \\arg . cont (apply func arg)\n    createAst argItem names \\arg . chainApply (apply func arg) rest names cont"})((function(){var $m; return function(){return $m || ($m = function(L_func){return function(L_list){return function(L_names){return function(L_cont){return L_withCons()(L_list)((function(){var $m; return function(){return $m || ($m = L_cont()(L_func))}})())((function(){var $m; return function(){return $m || ($m = function(L_argItem){return function(L_rest){return L_and()((function(){var $m; return function(){return $m || ($m = L_isToken()(L_argItem))}})())((function(){var $m; return function(){return $m || ($m = L_contains()(L_blockStarts)((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_argItem))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_createAst()(L_list)(L_names)((function(){var $m; return function(){return $m || ($m = function(L_arg){return L_cont()((function(){var $m; return function(){return $m || ($m = L_apply()(L_func)(L_arg))}})())})}})()))}})())((function(){var $m; return function(){return $m || ($m = L_createAst()(L_argItem)(L_names)((function(){var $m; return function(){return $m || ($m = function(L_arg){return L_chainApply()((function(){var $m; return function(){return $m || ($m = L_apply()(L_func)(L_arg))}})())(L_rest)(L_names)(L_cont)})}})()))}})())}})}})())}}}})}})()));
runMonad(L_define()(function(){return "cleanTokens"})(function(){return 3})(function(){return "cleanTokens start toks cont = isToken toks\n  cont (tokenString toks)\n  withCons toks (cont toks) \\head tail .\n    cleanTokens start head \\head .\n      cleanTokens start tail \\tail .\n        cont (cons head tail)"})((function(){var $m; return function(){return $m || ($m = function(L_start){return function(L_toks){return function(L_cont){return L_isToken()(L_toks)((function(){var $m; return function(){return $m || ($m = L_cont()((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_toks))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_withCons()(L_toks)((function(){var $m; return function(){return $m || ($m = L_cont()(L_toks))}})())((function(){var $m; return function(){return $m || ($m = function(L_head){return function(L_tail){return L_cleanTokens()(L_start)(L_head)((function(){var $m; return function(){return $m || ($m = function(L_head_0){return L_cleanTokens()(L_start)(L_tail)((function(){var $m; return function(){return $m || ($m = function(L_tail_1){return L_cont()((function(){var $m; return function(){return $m || ($m = L_cons()(L_head_0)(L_tail_1))}})())})}})())})}})())}})}})()))}})())}}})}})()));
runMonad(L_define()(function(){return "createLet"})(function(){return 4})(function(){return "createLet start list names cont = withCons list\n  parseErr \"No variable or body for let \" (loc start)\n  \\binding body . eq body nil (createAst binding name cont)\n    getLetNames start list names \\newNames .\n      createSublets start binding body newNames cont"})((function(){var $m; return function(){return $m || ($m = function(L_start){return function(L_list){return function(L_names){return function(L_cont){return L_withCons()(L_list)((function(){var $m; return function(){return $m || ($m = L_parseErr()(function(){return "No variable or body for let "})((function(){var $m; return function(){return $m || ($m = L_loc()(L_start))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_binding){return function(L_body){return L_eq()(L_body)(L_nil)((function(){var $m; return function(){return $m || ($m = L_createAst()(L_binding)(L_name)(L_cont))}})())((function(){var $m; return function(){return $m || ($m = L_getLetNames()(L_start)(L_list)(L_names)((function(){var $m; return function(){return $m || ($m = function(L_newNames){return L_createSublets()(L_start)(L_binding)(L_body)(L_newNames)(L_cont)})}})()))}})())}})}})())}}}})}})()));
runMonad(L_define()(function(){return "getLetNames"})(function(){return 4})(function(){return "getLetNames start list names cont = \\\\\n  err = parseErr \"Let expected binding \" (loc start)\n  .\n  withCons list (cont names) \\binding body .\n    isTokenString binding '.' (cont names)\n      withParens binding err \\start end def .\n        withCons def err \\name rest .\n          withToken name err \\str pos .\n            getLetNames start body (cons str names) cont"})((function(){var $m; return function(){return $m || ($m = function(L_start){return function(L_list){return function(L_names){return function(L_cont){return (function(){

var L_err;

L_err = (function(){var $m; return function(){return $m || ($m = L_parseErr()(function(){return "Let expected binding "})((function(){var $m; return function(){return $m || ($m = L_loc()(L_start))}})()))}})();
return L_withCons()(L_list)((function(){var $m; return function(){return $m || ($m = L_cont()(L_names))}})())((function(){var $m; return function(){return $m || ($m = function(L_binding){return function(L_body){return L_isTokenString()(L_binding)(function(){return "."})((function(){var $m; return function(){return $m || ($m = L_cont()(L_names))}})())((function(){var $m; return function(){return $m || ($m = L_withParens()(L_binding)(L_err)((function(){var $m; return function(){return $m || ($m = function(L_start_0){return function(L_end){return function(L_def){return L_withCons()(L_def)(L_err)((function(){var $m; return function(){return $m || ($m = function(L_name){return function(L_rest){return L_withToken()(L_name)(L_err)((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pos){return L_getLetNames()(L_start_0)(L_body)((function(){var $m; return function(){return $m || ($m = L_cons()(L_str)(L_names))}})())(L_cont)}})}})())}})}})())}}})}})()))}})())}})}})())})()}}}})}})()));
runMonad(L_define()(function(){return "createSublets"})(function(){return 5})(function(){return "createSublets start binding body names cont =\n  isTokenString binding '.' (createAst body names cont)\n    withCons body (parseErr \"Let expected a body \" (loc start)) \\bodyH bodyT .\n      getNameAndDef (parensStart binding) (parensContent binding) names \\name def .\n        createSublets start bodyH bodyT names \\bodyAst .\n          cont (let (tokenString name) def bodyAst)"})((function(){var $m; return function(){return $m || ($m = function(L_start){return function(L_binding){return function(L_body){return function(L_names){return function(L_cont){return L_isTokenString()(L_binding)(function(){return "."})((function(){var $m; return function(){return $m || ($m = L_createAst()(L_body)(L_names)(L_cont))}})())((function(){var $m; return function(){return $m || ($m = L_withCons()(L_body)((function(){var $m; return function(){return $m || ($m = L_parseErr()(function(){return "Let expected a body "})((function(){var $m; return function(){return $m || ($m = L_loc()(L_start))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_bodyH){return function(L_bodyT){return L_getNameAndDef()((function(){var $m; return function(){return $m || ($m = L_parensStart()(L_binding))}})())((function(){var $m; return function(){return $m || ($m = L_parensContent()(L_binding))}})())(L_names)((function(){var $m; return function(){return $m || ($m = function(L_name){return function(L_def){return L_createSublets()(L_start)(L_bodyH)(L_bodyT)(L_names)((function(){var $m; return function(){return $m || ($m = function(L_bodyAst){return L_cont()((function(){var $m; return function(){return $m || ($m = L_let()((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_name))}})())(L_def)(L_bodyAst))}})())})}})())}})}})())}})}})()))}})())}}}}})}})()));
runMonad(L_define()(function(){return "getNameAndDef"})(function(){return 4})(function(){return "getNameAndDef pos binding names cont =\n  withCons (tail binding) (parseErr \"Let expected binding at \" pos) \\snd sndT .\n    isTokenString snd '=' (createAst sndT names \\def . cont (head binding) def)\n      getLetLambda pos (tail binding) nil names \\lamb . cont (head binding) lamb"})((function(){var $m; return function(){return $m || ($m = function(L_pos){return function(L_binding){return function(L_names){return function(L_cont){return L_withCons()((function(){var $m; return function(){return $m || ($m = L_tail()(L_binding))}})())((function(){var $m; return function(){return $m || ($m = L_parseErr()(function(){return "Let expected binding at "})(L_pos))}})())((function(){var $m; return function(){return $m || ($m = function(L_snd){return function(L_sndT){return L_isTokenString()(L_snd)(function(){return "="})((function(){var $m; return function(){return $m || ($m = L_createAst()(L_sndT)(L_names)((function(){var $m; return function(){return $m || ($m = function(L_def){return L_cont()((function(){var $m; return function(){return $m || ($m = L_head()(L_binding))}})())(L_def)})}})()))}})())((function(){var $m; return function(){return $m || ($m = L_getLetLambda()(L_pos)((function(){var $m; return function(){return $m || ($m = L_tail()(L_binding))}})())(L_nil)(L_names)((function(){var $m; return function(){return $m || ($m = function(L_lamb){return L_cont()((function(){var $m; return function(){return $m || ($m = L_head()(L_binding))}})())(L_lamb)})}})()))}})())}})}})())}}}})}})()));
runMonad(L_define()(function(){return "getLetLambda"})(function(){return 5})(function(){return "getLetLambda pos def args names cont =\n  withCons def (parseErr \"Let expected binding at \" pos) \\arg rest .\n    not (isToken arg) (parseErr \"Let expected binding at \" pos)\n      isTokenString arg '='\n        createAst (cons (token '\\\\' pos) (append (reverse args) (cons (token '.' (position arg)) rest))) names cont\n        getLetLambda pos rest (cons arg args) names cont"})((function(){var $m; return function(){return $m || ($m = function(L_pos){return function(L_def){return function(L_args){return function(L_names){return function(L_cont){return L_withCons()(L_def)((function(){var $m; return function(){return $m || ($m = L_parseErr()(function(){return "Let expected binding at "})(L_pos))}})())((function(){var $m; return function(){return $m || ($m = function(L_arg){return function(L_rest){return L_not()((function(){var $m; return function(){return $m || ($m = L_isToken()(L_arg))}})())((function(){var $m; return function(){return $m || ($m = L_parseErr()(function(){return "Let expected binding at "})(L_pos))}})())((function(){var $m; return function(){return $m || ($m = L_isTokenString()(L_arg)(function(){return "="})((function(){var $m; return function(){return $m || ($m = L_createAst()((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_token()(function(){return "\\"})(L_pos))}})())((function(){var $m; return function(){return $m || ($m = L_append()((function(){var $m; return function(){return $m || ($m = L_reverse()(L_args))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_token()(function(){return "."})((function(){var $m; return function(){return $m || ($m = L_position()(L_arg))}})()))}})())(L_rest))}})()))}})()))}})())(L_names)(L_cont))}})())((function(){var $m; return function(){return $m || ($m = L_getLetLambda()(L_pos)(L_rest)((function(){var $m; return function(){return $m || ($m = L_cons()(L_arg)(L_args))}})())(L_names)(L_cont))}})()))}})())}})}})())}}}}})}})()));
runMonad(L_define()(function(){return "parenGroups"})(function(){return 0})(function(){return "parenGroups = cons (cons '(' ')') nil"})((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "("})(function(){return ")"}))}})())(L_nil))}})()));
runMonad(L_define()(function(){return "scanLineG"})(function(){return 5})(function(){return "scanLineG str pat groups onDef onExpr = \\\\\n  toks = tokens str pat\n  groupToks = foldr (\\el value . el \\h t . cons h (cons t value)) (cons '=' blockStarts) groups\n  .\n  # check if it's a definition\n  find (\\tok . or (contains groupToks (tokenString tok)) (isCons (strMatch (tokenString tok) '^\\n'))) toks (\\item . isTokenString item '=') false\n    toks \\name rest . \\\\\n      parseIt func = parseToks (checkSetDataType func rest name) groups \\list .\n        onDef (createDef list name (arity rest 0) str)\n      .\n      isTokenString (head rest) '='\n        isTokenString (head (tail rest)) '\\\\'\n          parseIt (setTypeAnno (tail rest) (tokenString name))\n          parseIt (tail rest)\n        transformDef name rest \\def .\n          parseIt (cons (token '\\\\' (- (position (head rest)) 1)) def)\n    parseToks toks groups \\list . onExpr list"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pat){return function(L_groups){return function(L_onDef){return function(L_onExpr){return (function(){

var L_groupToks, L_toks;

L_groupToks = (function(){var $m; return function(){return $m || ($m = L_foldr()((function(){var $m; return function(){return $m || ($m = function(L_el){return function(L_value){return L_el()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_cons()(L_t)(L_value))}})())}})}})())}})}})())((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "="})(L_blockStarts))}})())(L_groups))}})();

L_toks = (function(){var $m; return function(){return $m || ($m = L_tokens()(L_str)(L_pat))}})();
return L_find()((function(){var $m; return function(){return $m || ($m = function(L_tok){return L_or()((function(){var $m; return function(){return $m || ($m = L_contains()(L_groupToks)((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_tok))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_isCons()((function(){var $m; return function(){return $m || ($m = L_strMatch()((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_tok))}})())(function(){return "^\n"}))}})()))}})())})}})())(L_toks)((function(){var $m; return function(){return $m || ($m = function(L_item){return L_isTokenString()(L_item)(function(){return "="})})}})())(L_false)((function(){var $m; return function(){return $m || ($m = L_toks()((function(){var $m; return function(){return $m || ($m = function(L_name){return function(L_rest){return (function(){

var L_parseIt;

L_parseIt = (function(){var $m; return function(){return $m || ($m = function(L_func){return L_parseToks()((function(){var $m; return function(){return $m || ($m = L_checkSetDataType()(L_func)(L_rest)(L_name))}})())(L_groups)((function(){var $m; return function(){return $m || ($m = function(L_list){return L_onDef()((function(){var $m; return function(){return $m || ($m = L_createDef()(L_list)(L_name)((function(){var $m; return function(){return $m || ($m = L_arity()(L_rest)(function(){return 0}))}})())(L_str))}})())})}})())})}})();
return L_isTokenString()((function(){var $m; return function(){return $m || ($m = L_head()(L_rest))}})())(function(){return "="})((function(){var $m; return function(){return $m || ($m = L_isTokenString()((function(){var $m; return function(){return $m || ($m = L_head()((function(){var $m; return function(){return $m || ($m = L_tail()(L_rest))}})()))}})())(function(){return "\\"})((function(){var $m; return function(){return $m || ($m = L_parseIt()((function(){var $m; return function(){return $m || ($m = L_setTypeAnno()((function(){var $m; return function(){return $m || ($m = L_tail()(L_rest))}})())((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_name))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_parseIt()((function(){var $m; return function(){return $m || ($m = L_tail()(L_rest))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_transformDef()(L_name)(L_rest)((function(){var $m; return function(){return $m || ($m = function(L_def){return L_parseIt()((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_token()(function(){return "\\"})((function(){var $m; return function(){return $m || ($m = L_$_()((function(){var $m; return function(){return $m || ($m = L_position()((function(){var $m; return function(){return $m || ($m = L_head()(L_rest))}})()))}})())(function(){return 1}))}})()))}})())(L_def))}})())})}})()))}})())})()}})}})()))}})())((function(){var $m; return function(){return $m || ($m = L_parseToks()(L_toks)(L_groups)((function(){var $m; return function(){return $m || ($m = function(L_list){return L_onExpr()(L_list)})}})()))}})())})()}}}}})}})()));
runMonad(L_define()(function(){return "parseLineG"})(function(){return 6})(function(){return "parseLineG str pat names groups onDef onExpr = \\\\\n  astCallback cb = \\list . createAst list names \\ast . cb ast\n  .\n  scanLineG str pat groups (astCallback onDef) (astCallback onExpr)"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pat){return function(L_names){return function(L_groups){return function(L_onDef){return function(L_onExpr){return (function(){

var L_astCallback;

L_astCallback = (function(){var $m; return function(){return $m || ($m = function(L_cb){return function(L_list){return L_createAst()(L_list)(L_names)((function(){var $m; return function(){return $m || ($m = function(L_ast){return L_cb()(L_ast)})}})())}})}})();
return L_scanLineG()(L_str)(L_pat)(L_groups)((function(){var $m; return function(){return $m || ($m = L_astCallback()(L_onDef))}})())((function(){var $m; return function(){return $m || ($m = L_astCallback()(L_onExpr))}})())})()}}}}}})}})()));
runMonad(L_define()(function(){return "transformDef"})(function(){return 3})(function(){return "transformDef name toks cont = withCons toks (parseErr \"Bad definition, expecting tokens\" (loc name)) \\h t .\n  isTokenString h '='\n    isTokenString (head t) '\\\\'\n      cont (cons (token '.' (position h)) (setTypeAnno t (tokenString name)))\n      cont (cons (token '.' (position h)) t)\n    transformDef name t \\list . cont (cons h list)"})((function(){var $m; return function(){return $m || ($m = function(L_name){return function(L_toks){return function(L_cont){return L_withCons()(L_toks)((function(){var $m; return function(){return $m || ($m = L_parseErr()(function(){return "Bad definition, expecting tokens"})((function(){var $m; return function(){return $m || ($m = L_loc()(L_name))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_isTokenString()(L_h)(function(){return "="})((function(){var $m; return function(){return $m || ($m = L_isTokenString()((function(){var $m; return function(){return $m || ($m = L_head()(L_t))}})())(function(){return "\\"})((function(){var $m; return function(){return $m || ($m = L_cont()((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_token()(function(){return "."})((function(){var $m; return function(){return $m || ($m = L_position()(L_h))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_setTypeAnno()(L_t)((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_name))}})()))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cont()((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_token()(function(){return "."})((function(){var $m; return function(){return $m || ($m = L_position()(L_h))}})()))}})())(L_t))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_transformDef()(L_name)(L_t)((function(){var $m; return function(){return $m || ($m = function(L_list){return L_cont()((function(){var $m; return function(){return $m || ($m = L_cons()(L_h)(L_list))}})())})}})()))}})())}})}})())}}})}})()));
runMonad(L_define()(function(){return "setTypeAnno"})(function(){return 2})(function(){return "setTypeAnno toks name = \\\\\n  tok = \\str . token str (position toks)\n  .\n  cons (tok '\\\\@') (cons (tok 'type') (cons (tok name) (cons (tok '.') toks)))"})((function(){var $m; return function(){return $m || ($m = function(L_toks){return function(L_name){return (function(){

var L_tok;

L_tok = (function(){var $m; return function(){return $m || ($m = function(L_str){return L_token()(L_str)((function(){var $m; return function(){return $m || ($m = L_position()(L_toks))}})())})}})();
return L_cons()((function(){var $m; return function(){return $m || ($m = L_tok()(function(){return "\\@"}))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_tok()(function(){return "type"}))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_tok()(L_name))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_tok()(function(){return "."}))}})())(L_toks))}})()))}})()))}})())})()}})}})()));
runMonad(L_define()(function(){return "setDataTypeAnno"})(function(){return 2})(function(){return "setDataTypeAnno toks name = \\\\\n  tok = \\str . token str (position toks)\n  .\n  cons (tok '\\\\@') (cons (tok 'dataType') (cons (tok (tokenString name)) (cons (tok '.') toks)))"})((function(){var $m; return function(){return $m || ($m = function(L_toks){return function(L_name){return (function(){

var L_tok;

L_tok = (function(){var $m; return function(){return $m || ($m = function(L_str){return L_token()(L_str)((function(){var $m; return function(){return $m || ($m = L_position()(L_toks))}})())})}})();
return L_cons()((function(){var $m; return function(){return $m || ($m = L_tok()(function(){return "\\@"}))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_tok()(function(){return "dataType"}))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_tok()((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_name))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_tok()(function(){return "."}))}})())(L_toks))}})()))}})()))}})())})()}})}})()));
runMonad(L_define()(function(){return "createDef"})(function(){return 4})(function(){return "createDef def name arity src = \\\\\n  tok str = token str (position def)\n  .\n  jsonStringify (tokenString name) (\\err . parseErr (strCat (cons \"Bad function name \" (cons (loc name) nil))) err) \\nameStr .\n    jsonStringify src (\\err . parseErr (strCat (cons \"Bad source \" (cons (loc name) nil))) err) \\srcStr .\n      cons (tok 'define') (cons (tok nameStr) (cons (tok (strString arity)) (cons (tok srcStr) (cons def nil))))"})((function(){var $m; return function(){return $m || ($m = function(L_def){return function(L_name){return function(L_arity){return function(L_src){return (function(){

var L_tok;

L_tok = (function(){var $m; return function(){return $m || ($m = function(L_str){return L_token()(L_str)((function(){var $m; return function(){return $m || ($m = L_position()(L_def))}})())})}})();
return L_jsonStringify()((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_name))}})())((function(){var $m; return function(){return $m || ($m = function(L_err){return L_parseErr()((function(){var $m; return function(){return $m || ($m = L_strCat()((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "Bad function name "})((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_loc()(L_name))}})())(L_nil))}})()))}})()))}})())(L_err)})}})())((function(){var $m; return function(){return $m || ($m = function(L_nameStr){return L_jsonStringify()(L_src)((function(){var $m; return function(){return $m || ($m = function(L_err){return L_parseErr()((function(){var $m; return function(){return $m || ($m = L_strCat()((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "Bad source "})((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_loc()(L_name))}})())(L_nil))}})()))}})()))}})())(L_err)})}})())((function(){var $m; return function(){return $m || ($m = function(L_srcStr){return L_cons()((function(){var $m; return function(){return $m || ($m = L_tok()(function(){return "define"}))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_tok()(L_nameStr))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_tok()((function(){var $m; return function(){return $m || ($m = L_strString()(L_arity))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_tok()(L_srcStr))}})())((function(){var $m; return function(){return $m || ($m = L_cons()(L_def)(L_nil))}})()))}})()))}})()))}})())})}})())})}})())})()}}}})}})()));
runMonad(L_define()(function(){return "checkSetDataType"})(function(){return 3})(function(){return "checkSetDataType toks curToks name = withCons curToks toks \\h t .\n  isTokenString h '='\n    isTokenString (head t) '\\\\'\n      setDataTypeAnno toks name\n      toks\n    checkSetDataType toks t name"})((function(){var $m; return function(){return $m || ($m = function(L_toks){return function(L_curToks){return function(L_name){return L_withCons()(L_curToks)(L_toks)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_isTokenString()(L_h)(function(){return "="})((function(){var $m; return function(){return $m || ($m = L_isTokenString()((function(){var $m; return function(){return $m || ($m = L_head()(L_t))}})())(function(){return "\\"})((function(){var $m; return function(){return $m || ($m = L_setDataTypeAnno()(L_toks)(L_name))}})())(L_toks))}})())((function(){var $m; return function(){return $m || ($m = L_checkSetDataType()(L_toks)(L_t)(L_name))}})())}})}})())}}})}})()));
runMonad(L_define()(function(){return "arity"})(function(){return 2})(function(){return "arity toks n = isTokenString (head toks) '=' n (arity (tail toks) (+ n 1))"})((function(){var $m; return function(){return $m || ($m = function(L_toks){return function(L_n){return L_isTokenString()((function(){var $m; return function(){return $m || ($m = L_head()(L_toks))}})())(function(){return "="})(L_n)((function(){var $m; return function(){return $m || ($m = L_arity()((function(){var $m; return function(){return $m || ($m = L_tail()(L_toks))}})())((function(){var $m; return function(){return $m || ($m = L_$o()(L_n)(function(){return 1}))}})()))}})())}})}})()));
runMonad(L_define()(function(){return "tokListStr"})(function(){return 1})(function(){return "tokListStr toks = jsonStringify (join (map (\\t . tokenString t) toks) ' ')"})((function(){var $m; return function(){return $m || ($m = function(L_toks){return L_jsonStringify()((function(){var $m; return function(){return $m || ($m = L_join()((function(){var $m; return function(){return $m || ($m = L_map()((function(){var $m; return function(){return $m || ($m = function(L_t){return L_tokenString()(L_t)})}})())(L_toks))}})())(function(){return " "}))}})())})}})()));
runMonad(L_define()(function(){return "linePat"})(function(){return 0})(function(){return "linePat = regexp '\\\\r?\\\\n(?=[^ ]|$)'"})((function(){var $m; return function(){return $m || ($m = L_regexp()(function(){return "\\r?\\n(?=[^ ]|$)"}))}})()));
runMonad(L_define()(function(){return "emptyLinePat"})(function(){return 0})(function(){return "emptyLinePat = regexp '^[ \\\\i]*\\\\#.*|^[ \\\\i]*$|^\\\\r?\\\\n[ \\\\i]*$'"})((function(){var $m; return function(){return $m || ($m = L_regexp()(function(){return "^[ \\i]*\\#.*|^[ \\i]*$|^\\r?\\n[ \\i]*$"}))}})()));
runMonad(L_define()(function(){return "lineScrub"})(function(){return 0})(function(){return "lineScrub = regexpFlags '\\\\r\\\\n' 'g'"})((function(){var $m; return function(){return $m || ($m = L_regexpFlags()(function(){return "\\r\\n"})(function(){return "g"}))}})()));
runMonad(L_define()(function(){return "linesForFile"})(function(){return 1})(function(){return "linesForFile text = filter\n  \\line . isNil (strMatch line emptyLinePat)\n  strSplit (strReplace text lineScrub '\\n') linePat"})((function(){var $m; return function(){return $m || ($m = function(L_text){return L_filter()((function(){var $m; return function(){return $m || ($m = function(L_line){return L_isNil()((function(){var $m; return function(){return $m || ($m = L_strMatch()(L_line)(L_emptyLinePat))}})())})}})())((function(){var $m; return function(){return $m || ($m = L_strSplit()((function(){var $m; return function(){return $m || ($m = L_strReplace()(L_text)(L_lineScrub)(function(){return "\n"}))}})())(L_linePat))}})())})}})()));
runMonad(L_define()(function(){return "defPat"})(function(){return 0})(function(){return "defPat = regexp '^[^ =]+.* =( |$)'"})((function(){var $m; return function(){return $m || ($m = L_regexp()(function(){return "^[^ =]+.* =( |$)"}))}})()));
runMonad(L_define()(function(){return "namesForLines"})(function(){return 1})(function(){return "namesForLines lines = foldl\n  \\result line . \\\\\n    m = strMatch line defPat\n    .\n    isNil m result (cons (head (tail m)) result)\n  nil\n  lines"})((function(){var $m; return function(){return $m || ($m = function(L_lines){return L_foldl()((function(){var $m; return function(){return $m || ($m = function(L_result){return function(L_line){return (function(){

var L_m;

L_m = (function(){var $m; return function(){return $m || ($m = L_strMatch()(L_line)(L_defPat))}})();
return L_isNil()(L_m)(L_result)((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_head()((function(){var $m; return function(){return $m || ($m = L_tail()(L_m))}})()))}})())(L_result))}})())})()}})}})())(L_nil)(L_lines)})}})()));
runMonad(L_define()(function(){return "runParseFilters"})(function(){return 2})(function(){return "runParseFilters filters line = filters\n  \\h t D . bind (h line) \\filtered . runParseFilters t filtered\n  line"})((function(){var $m; return function(){return $m || ($m = function(L_filters){return function(L_line){return L_filters()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_bind()((function(){var $m; return function(){return $m || ($m = L_h()(L_line))}})())((function(){var $m; return function(){return $m || ($m = function(L_filtered){return L_runParseFilters()(L_t)(L_filtered)})}})())}}})}})())(L_line)}})}})()));
runMonad(L_define()(function(){return "isBlockStart"})(function(){return 1})(function(){return "isBlockStart tok = and\n  isToken tok\n  contains blockStarts (tokenString tok)"})((function(){var $m; return function(){return $m || ($m = function(L_tok){return L_and()((function(){var $m; return function(){return $m || ($m = L_isToken()(L_tok))}})())((function(){var $m; return function(){return $m || ($m = L_contains()(L_blockStarts)((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_tok))}})()))}})())})}})()));
runMonad(L_define()(function(){return "macroSub"})(function(){return 2})(function(){return "macroSub macs expr = postProcessMacro -1 -1 (baseMacroSub macs expr)"})((function(){var $m; return function(){return $m || ($m = function(L_macs){return function(L_expr){return L_postProcessMacro()(function(){return -1})(function(){return -1})((function(){var $m; return function(){return $m || ($m = L_baseMacroSub()(L_macs)(L_expr))}})())}})}})()));
runMonad(L_define()(function(){return "consifyMacroValue"})(function(){return 1})(function(){return "consifyMacroValue value = isCons value value (cons value nil)"})((function(){var $m; return function(){return $m || ($m = function(L_value){return L_isCons()(L_value)(L_value)((function(){var $m; return function(){return $m || ($m = L_cons()(L_value)(L_nil))}})())})}})()));
runMonad(L_define()(function(){return "baseMacroSub"})(function(){return 2})(function(){return "baseMacroSub macs expr = isToken expr\n  expr\n  isParens expr\n    expr \\start end content . \\\\\n      result = baseMacroSub macs content\n      .\n      isToken result result (parens start end result)\n    withCons expr expr \\h t .\n      isBlockStart h\n        cons h\n          isTokenString h '\\\\\\\\'\n            macroSubLet macs t\n            macroSubBody '.' macs t\n        withToken h\n          \\\\\n            subH = baseMacroSub macs h\n            .\n            withToken subH\n              cons subH (map (baseMacroSub macs) t)\n              \\tok pos . baseMacroSub macs (cons subH t)\n          #d \"TOK: \" h (\\tok pos . assoc tok macs\n          \\tok pos . assoc tok macs\n            \\def . baseMacroSub macs (def t)\n            cons h (map (baseMacroSub macs) t)"})((function(){var $m; return function(){return $m || ($m = function(L_macs){return function(L_expr){return L_isToken()(L_expr)(L_expr)((function(){var $m; return function(){return $m || ($m = L_isParens()(L_expr)((function(){var $m; return function(){return $m || ($m = L_expr()((function(){var $m; return function(){return $m || ($m = function(L_start){return function(L_end){return function(L_content){return (function(){

var L_result;

L_result = (function(){var $m; return function(){return $m || ($m = L_baseMacroSub()(L_macs)(L_content))}})();
return L_isToken()(L_result)(L_result)((function(){var $m; return function(){return $m || ($m = L_parens()(L_start)(L_end)(L_result))}})())})()}}})}})()))}})())((function(){var $m; return function(){return $m || ($m = L_withCons()(L_expr)(L_expr)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_isBlockStart()(L_h)((function(){var $m; return function(){return $m || ($m = L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_isTokenString()(L_h)(function(){return "\\\\"})((function(){var $m; return function(){return $m || ($m = L_macroSubLet()(L_macs)(L_t))}})())((function(){var $m; return function(){return $m || ($m = L_macroSubBody()(function(){return "."})(L_macs)(L_t))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_withToken()(L_h)(function(){
var L_subH;

L_subH = (function(){var $m; return function(){return $m || ($m = L_baseMacroSub()(L_macs)(L_h))}})();
return L_withToken()(L_subH)((function(){var $m; return function(){return $m || ($m = L_cons()(L_subH)((function(){var $m; return function(){return $m || ($m = L_map()((function(){var $m; return function(){return $m || ($m = L_baseMacroSub()(L_macs))}})())(L_t))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_tok){return function(L_pos){return L_baseMacroSub()(L_macs)((function(){var $m; return function(){return $m || ($m = L_cons()(L_subH)(L_t))}})())}})}})())})((function(){var $m; return function(){return $m || ($m = function(L_tok){return function(L_pos){return L_assoc()(L_tok)(L_macs)((function(){var $m; return function(){return $m || ($m = function(L_def){return L_baseMacroSub()(L_macs)((function(){var $m; return function(){return $m || ($m = L_def()(L_t))}})())})}})())((function(){var $m; return function(){return $m || ($m = L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_map()((function(){var $m; return function(){return $m || ($m = L_baseMacroSub()(L_macs))}})())(L_t))}})()))}})())}})}})()))}})())}})}})()))}})()))}})())}})}})()));
runMonad(L_define()(function(){return "macroSubLet"})(function(){return 2})(function(){return "macroSubLet macs list = list\n  \\h t D . isTokenString h '.'\n    cons h (baseMacroSub macs t)\n    cons (setParens h \\content . macroSubBody '=' macs content) (macroSubLet macs t)\n  # Don't bother with parse errors at this point -- ast generator will detect them\n  nil"})((function(){var $m; return function(){return $m || ($m = function(L_macs){return function(L_list){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_isTokenString()(L_h)(function(){return "."})((function(){var $m; return function(){return $m || ($m = L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_baseMacroSub()(L_macs)(L_t))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_setParens()(L_h)((function(){var $m; return function(){return $m || ($m = function(L_content){return L_macroSubBody()(function(){return "="})(L_macs)(L_content)})}})()))}})())((function(){var $m; return function(){return $m || ($m = L_macroSubLet()(L_macs)(L_t))}})()))}})())}}})}})())(L_nil)}})}})()));
runMonad(L_define()(function(){return "macroSubBody"})(function(){return 3})(function(){return "macroSubBody char macs list = list\n  \\h t D . cons h\n    isTokenString h char baseMacroSub (macroSubBody char)\n      macs\n      t\n  nil"})((function(){var $m; return function(){return $m || ($m = function(L_char){return function(L_macs){return function(L_list){return L_list()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_isTokenString()(L_h)(L_char)(L_baseMacroSub)((function(){var $m; return function(){return $m || ($m = L_macroSubBody()(L_char))}})())(L_macs)(L_t))}})())}}})}})())(L_nil)}}})}})()));
runMonad(L_define()(function(){return "postProcessMacro"})(function(){return 3})(function(){return "postProcessMacro before after expr = isString expr\n  token expr (eq after -1 before after)\n  isParens expr\n    expr \\start end contents . parens start end (postProcessMacro start end contents)\n    isCons expr\n      expr \\h t .\n        isToken h\n          cons h (postProcessMacro (+ 1 (+ (tokenPos h) (strLen (tokenString h)))) -1 t)\n          \\\\\n            posStart = position h\n            posEnd = position t\n            t2 = postProcessMacro -1 after t\n            h2 = postProcessMacro before -1 h\n            .\n            eq posStart -1\n              cons (postProcessMacro before (position t2) h) t2\n              cons h2 (postProcessMacro (+ 1 (lexEnd h2)) after t)\n      expr"})((function(){var $m; return function(){return $m || ($m = function(L_before){return function(L_after){return function(L_expr){return L_isString()(L_expr)((function(){var $m; return function(){return $m || ($m = L_token()(L_expr)((function(){var $m; return function(){return $m || ($m = L_eq()(L_after)(function(){return -1})(L_before)(L_after))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_isParens()(L_expr)((function(){var $m; return function(){return $m || ($m = L_expr()((function(){var $m; return function(){return $m || ($m = function(L_start){return function(L_end){return function(L_contents){return L_parens()(L_start)(L_end)((function(){var $m; return function(){return $m || ($m = L_postProcessMacro()(L_start)(L_end)(L_contents))}})())}}})}})()))}})())((function(){var $m; return function(){return $m || ($m = L_isCons()(L_expr)((function(){var $m; return function(){return $m || ($m = L_expr()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_isToken()(L_h)((function(){var $m; return function(){return $m || ($m = L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_postProcessMacro()((function(){var $m; return function(){return $m || ($m = L_$o()(function(){return 1})((function(){var $m; return function(){return $m || ($m = L_$o()((function(){var $m; return function(){return $m || ($m = L_tokenPos()(L_h))}})())((function(){var $m; return function(){return $m || ($m = L_strLen()((function(){var $m; return function(){return $m || ($m = L_tokenString()(L_h))}})()))}})()))}})()))}})())(function(){return -1})(L_t))}})()))}})())(function(){
var L_h2, L_t2, L_posEnd, L_posStart;

L_h2 = (function(){var $m; return function(){return $m || ($m = L_postProcessMacro()(L_before)(function(){return -1})(L_h))}})();

L_t2 = (function(){var $m; return function(){return $m || ($m = L_postProcessMacro()(function(){return -1})(L_after)(L_t))}})();

L_posEnd = (function(){var $m; return function(){return $m || ($m = L_position()(L_t))}})();

L_posStart = (function(){var $m; return function(){return $m || ($m = L_position()(L_h))}})();
return L_eq()(L_posStart)(function(){return -1})((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_postProcessMacro()(L_before)((function(){var $m; return function(){return $m || ($m = L_position()(L_t2))}})())(L_h))}})())(L_t2))}})())((function(){var $m; return function(){return $m || ($m = L_cons()(L_h2)((function(){var $m; return function(){return $m || ($m = L_postProcessMacro()((function(){var $m; return function(){return $m || ($m = L_$o()(function(){return 1})((function(){var $m; return function(){return $m || ($m = L_lexEnd()(L_h2))}})()))}})())(L_after)(L_t))}})()))}})())})}})}})()))}})())(L_expr))}})()))}})())}}})}})()));
runMonad(L_define()(function(){return "defMacro"})(function(){return 2})(function(){return "defMacro name def = bind (getValue 'macroDefs') \\macs . setValue 'macroDefs' (acons name def macs)"})((function(){var $m; return function(){return $m || ($m = function(L_name){return function(L_def){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "macroDefs"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_macs){return L_setValue()(function(){return "macroDefs"})((function(){var $m; return function(){return $m || ($m = L_acons()(L_name)(L_def)(L_macs))}})())})}})())}})}})()));
runMonad(L_define()(function(){return "delimiterListPrefix"})(function(){return 0})(function(){return "delimiterListPrefix = \"\\\"(?:\\\\\\\\.|[^\\\"])*\\\"|'(?:\\\\\\\\.|[^'])*'|\\\\n *|#.*| +\""})(function(){return "\"(?:\\\\.|[^\"])*\"|'(?:\\\\.|[^'])*'|\\n *|#.*| +"}));
runMonad(L_define()(function(){return "regexpEscapePat"})(function(){return 0})(function(){return "regexpEscapePat = regexpFlags '[\\\\-\\\\[\\\\]/\\\\{\\\\}\\\\(\\\\)\\\\*\\\\+\\\\?\\\\.\\\\\\\\\\\\^\\\\$\\\\|]' 'g'"})((function(){var $m; return function(){return $m || ($m = L_regexpFlags()(function(){return "[\\-\\[\\]/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]"})(function(){return "g"}))}})()));
runMonad(L_define()(function(){return "addToken"})(function(){return 1})(function(){return "addToken del = bind (getValue 'tokenList')\n  \\dels . contains dels del\n    false\n    \\\\\n      newDels = insertSorted (\\a b . > (strLen a) (strLen b)) del dels\n      .\n      bind (setValue 'tokenList' newDels)\n        \\_ . computeTokenPat newDels"})((function(){var $m; return function(){return $m || ($m = function(L_del){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "tokenList"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_dels){return L_contains()(L_dels)(L_del)(L_false)(function(){
var L_newDels;

L_newDels = (function(){var $m; return function(){return $m || ($m = L_insertSorted()((function(){var $m; return function(){return $m || ($m = function(L_a){return function(L_b){return L_$z()((function(){var $m; return function(){return $m || ($m = L_strLen()(L_a))}})())((function(){var $m; return function(){return $m || ($m = L_strLen()(L_b))}})())}})}})())(L_del)(L_dels))}})();
return L_bind()((function(){var $m; return function(){return $m || ($m = L_setValue()(function(){return "tokenList"})(L_newDels))}})())((function(){var $m; return function(){return $m || ($m = function(L__){return L_computeTokenPat()(L_newDels)})}})())})})}})())})}})()));
runMonad(L_define()(function(){return "computeTokenPat"})(function(){return 1})(function(){return "computeTokenPat dels = \\\\\n  delPats = map (\\item . strReplace item regexpEscapePat \"\\\\$&\") dels\n  newPat = strCat (cons '(' (cons (join (cons delimiterListPrefix delPats) '|') (cons ')' nil)))\n  .\n  setValue 'tokenPat' newPat"})((function(){var $m; return function(){return $m || ($m = function(L_dels){return (function(){

var L_newPat, L_delPats;

L_newPat = (function(){var $m; return function(){return $m || ($m = L_strCat()((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "("})((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_join()((function(){var $m; return function(){return $m || ($m = L_cons()(L_delimiterListPrefix)(L_delPats))}})())(function(){return "|"}))}})())((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return ")"})(L_nil))}})()))}})()))}})()))}})();

L_delPats = (function(){var $m; return function(){return $m || ($m = L_map()((function(){var $m; return function(){return $m || ($m = function(L_item){return L_strReplace()(L_item)(L_regexpEscapePat)(function(){return "\\$&"})})}})())(L_dels))}})();
return L_setValue()(function(){return "tokenPat"})(L_newPat)})()})}})()));
runMonad(L_define()(function(){return "addTokenGroup"})(function(){return 2})(function(){return "addTokenGroup open close = bind (addToken open)\n  \\_ . bind (addToken close)\n    \\_ . bind (getValue 'tokenGroups')\n      \\gr . setValue 'tokenGroups' (acons open close gr)"})((function(){var $m; return function(){return $m || ($m = function(L_open){return function(L_close){return L_bind()((function(){var $m; return function(){return $m || ($m = L_addToken()(L_open))}})())((function(){var $m; return function(){return $m || ($m = function(L__){return L_bind()((function(){var $m; return function(){return $m || ($m = L_addToken()(L_close))}})())((function(){var $m; return function(){return $m || ($m = function(L___0){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "tokenGroups"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_gr){return L_setValue()(function(){return "tokenGroups"})((function(){var $m; return function(){return $m || ($m = L_acons()(L_open)(L_close)(L_gr))}})())})}})())})}})())})}})())}})}})()));
runMonad(L_define()(function(){return "parse"})(function(){return 2})(function(){return "parse str pat = parseIndent (token '\\n' 0) (tokens str pat) nil parenGroups \\h t . stripParens h"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pat){return L_parseIndent()((function(){var $m; return function(){return $m || ($m = L_token()(function(){return "\n"})(function(){return 0}))}})())((function(){var $m; return function(){return $m || ($m = L_tokens()(L_str)(L_pat))}})())(L_nil)(L_parenGroups)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_stripParens()(L_h)}})}})())}})}})()));
runMonad(L_define()(function(){return "parseG"})(function(){return 3})(function(){return "parseG str pat groups = parseIndent (token '\\n' 0) (tokens str pat) nil groups \\h t . stripParens h"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pat){return function(L_groups){return L_parseIndent()((function(){var $m; return function(){return $m || ($m = L_token()(function(){return "\n"})(function(){return 0}))}})())((function(){var $m; return function(){return $m || ($m = L_tokens()(L_str)(L_pat))}})())(L_nil)(L_groups)((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_stripParens()(L_h)}})}})())}}})}})()));
runMonad(L_define()(function(){return "parseToAst"})(function(){return 2})(function(){return "parseToAst str pat = createAst (parse str pat) nil id"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pat){return L_createAst()((function(){var $m; return function(){return $m || ($m = L_parse()(L_str)(L_pat))}})())(L_nil)(L_id)}})}})()));
runMonad(L_define()(function(){return "parseM"})(function(){return 1})(function(){return "parseM str =\n  bind (getValue 'tokenPat')\n    \\tokPat . bind (getValue 'tokenGroups')\n      \\groups . parseG str tokPat groups"})((function(){var $m; return function(){return $m || ($m = function(L_str){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "tokenPat"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_tokPat){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "tokenGroups"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_groups){return L_parseG()(L_str)(L_tokPat)(L_groups)})}})())})}})())})}})()));
runMonad(L_define()(function(){return "scanLine"})(function(){return 4})(function(){return "scanLine str pat onDef onExpr = scanLineG str pat parenGroups onDef onExpr"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pat){return function(L_onDef){return function(L_onExpr){return L_scanLineG()(L_str)(L_pat)(L_parenGroups)(L_onDef)(L_onExpr)}}}})}})()));
runMonad(L_define()(function(){return "parseLine"})(function(){return 5})(function(){return "parseLine str pat names onDef onExpr = parseLineG str pat names parenGroups onDef onExpr"})((function(){var $m; return function(){return $m || ($m = function(L_str){return function(L_pat){return function(L_names){return function(L_onDef){return function(L_onExpr){return L_parseLineG()(L_str)(L_pat)(L_names)(L_parenGroups)(L_onDef)(L_onExpr)}}}}})}})()));
runMonad(L_define()(function(){return "parseLineM"})(function(){return 1})(function(){return "parseLineM str = bind (getValue 'tokenPat')\n  \\tokPat . bind (getValue 'tokenGroups')\n    \\groups . parseLineG str tokPat nil groups id id"})((function(){var $m; return function(){return $m || ($m = function(L_str){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "tokenPat"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_tokPat){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "tokenGroups"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_groups){return L_parseLineG()(L_str)(L_tokPat)(L_nil)(L_groups)(L_id)(L_id)})}})())})}})())})}})()));
runMonad(L_define()(function(){return "macroSubM"})(function(){return 1})(function(){return "macroSubM expr =\n  bind (getValue 'macroDefs')\n    \\macs . macroSub macs expr"})((function(){var $m; return function(){return $m || ($m = function(L_expr){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "macroDefs"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_macs){return L_macroSub()(L_macs)(L_expr)})}})())})}})()));
runMonad(L_define()(function(){return "macroParse"})(function(){return 1})(function(){return "macroParse str =\n  bind (parseM str)\n    \\ex . macroSubM ex"})((function(){var $m; return function(){return $m || ($m = function(L_str){return L_bind()((function(){var $m; return function(){return $m || ($m = L_parseM()(L_str))}})())((function(){var $m; return function(){return $m || ($m = function(L_ex){return L_macroSubM()(L_ex)})}})())})}})()));
runMonad(L_define()(function(){return "tokensM"})(function(){return 1})(function(){return "tokensM str =\n  bind (getValue 'tokenPat')\n    \\delimiterPat . tokens str delimiterPat"})((function(){var $m; return function(){return $m || ($m = function(L_str){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "tokenPat"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_delimiterPat){return L_tokens()(L_str)(L_delimiterPat)})}})())})}})()));
runMonad(L_define()(function(){return "parseLines"})(function(){return 2})(function(){return "parseLines lines result = lines\n  \\h t D . bind (parseLineM h)\n    \\ast . parseLines t (cons ast result)\n  reverse result"})((function(){var $m; return function(){return $m || ($m = function(L_lines){return function(L_result){return L_lines()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_bind()((function(){var $m; return function(){return $m || ($m = L_parseLineM()(L_h))}})())((function(){var $m; return function(){return $m || ($m = function(L_ast){return L_parseLines()(L_t)((function(){var $m; return function(){return $m || ($m = L_cons()(L_ast)(L_result))}})())})}})())}}})}})())((function(){var $m; return function(){return $m || ($m = L_reverse()(L_result))}})())}})}})()));
runMonad(L_define()(function(){return "parseFile"})(function(){return 1})(function(){return "parseFile text = parseLines (linesForFile text) nil"})((function(){var $m; return function(){return $m || ($m = function(L_text){return L_parseLines()((function(){var $m; return function(){return $m || ($m = L_linesForFile()(L_text))}})())(L_nil)})}})()));
runMonad(L_define()(function(){return "simpleScanLine"})(function(){return 1})(function(){return "simpleScanLine line = bind (getValue 'tokenPat')\n  \\tokenPat . bind (getValue 'tokenGroups')\n    \\groups . scanLineG line tokenPat groups id id"})((function(){var $m; return function(){return $m || ($m = function(L_line){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "tokenPat"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_tokenPat){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "tokenGroups"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_groups){return L_scanLineG()(L_line)(L_tokenPat)(L_groups)(L_id)(L_id)})}})())})}})())})}})()));
runMonad(L_define()(function(){return "scanLineM"})(function(){return 1})(function(){return "scanLineM line = bind (getValue 'tokenPat')\n  \\tokenPat . bind (getValue 'tokenGroups')\n    \\groups . bind (getValue 'parseFilters')\n      \\filters . bind (getValue 'macroDefs')\n        \\macros . bind (runParseFilters filters (scanLineG line tokenPat groups id id))\n          \\scanned . macroSub macros scanned"})((function(){var $m; return function(){return $m || ($m = function(L_line){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "tokenPat"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_tokenPat){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "tokenGroups"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_groups){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "parseFilters"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_filters){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "macroDefs"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_macros){return L_bind()((function(){var $m; return function(){return $m || ($m = L_runParseFilters()(L_filters)((function(){var $m; return function(){return $m || ($m = L_scanLineG()(L_line)(L_tokenPat)(L_groups)(L_id)(L_id))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L_scanned){return L_macroSub()(L_macros)(L_scanned)})}})())})}})())})}})())})}})())})}})())})}})()));
runMonad(L_define()(function(){return "newParseLine"})(function(){return 2})(function(){return "newParseLine names line = bind (scanLineM line)\n  \\scanned . createAst scanned names \\ast . ast"})((function(){var $m; return function(){return $m || ($m = function(L_names){return function(L_line){return L_bind()((function(){var $m; return function(){return $m || ($m = L_scanLineM()(L_line))}})())((function(){var $m; return function(){return $m || ($m = function(L_scanned){return L_createAst()(L_scanned)(L_names)((function(){var $m; return function(){return $m || ($m = function(L_ast){return L_ast()})}})())})}})())}})}})()));
runMonad(L_define()(function(){return "runLine"})(function(){return 2})(function(){return "runLine names line = bind (newParseLine names line)\n  \\ast . bind (runAst ast)\n    \\result . cons ast result"})((function(){var $m; return function(){return $m || ($m = function(L_names){return function(L_line){return L_bind()((function(){var $m; return function(){return $m || ($m = L_newParseLine()(L_names)(L_line))}})())((function(){var $m; return function(){return $m || ($m = function(L_ast){return L_bind()((function(){var $m; return function(){return $m || ($m = L_runAst()(L_ast))}})())((function(){var $m; return function(){return $m || ($m = function(L_result){return L_cons()(L_ast)(L_result)})}})())})}})())}})}})()));
runMonad(L_define()(function(){return "runLines"})(function(){return 2})(function(){return "runLines names lines = lines\n  \\h t D . bind (runLine names h)\n    \\line . bind (runLines names t)\n      \\rest . cons line rest\n  nil"})((function(){var $m; return function(){return $m || ($m = function(L_names){return function(L_lines){return L_lines()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return function(L_D){return L_bind()((function(){var $m; return function(){return $m || ($m = L_runLine()(L_names)(L_h))}})())((function(){var $m; return function(){return $m || ($m = function(L_line){return L_bind()((function(){var $m; return function(){return $m || ($m = L_runLines()(L_names)(L_t))}})())((function(){var $m; return function(){return $m || ($m = function(L_rest){return L_cons()(L_line)(L_rest)})}})())})}})())}}})}})())(L_nil)}})}})()));
runMonad(L_define()(function(){return "runFile"})(function(){return 1})(function(){return "runFile text = \\\\\n  lines = linesForFile text\n  names = namesForLines lines\n  .\n  runLines names lines"})((function(){var $m; return function(){return $m || ($m = function(L_text){return (function(){

var L_names, L_lines;

L_names = (function(){var $m; return function(){return $m || ($m = L_namesForLines()(L_lines))}})();

L_lines = (function(){var $m; return function(){return $m || ($m = L_linesForFile()(L_text))}})();
return L_runLines()(L_names)(L_lines)})()})}})()));
runMonad(L_define()(function(){return "load"})(function(){return 1})(function(){return "load file = bind (readFile file)\n  \\result . result\n    \\err . err\n    \\contents . bind (getValue 'stdTokenPacks')\n      \\stds . bind (getValue 'activeTokenPacks')\n        \\activePacks . bind (resetTokenPacks stds)\n          \\_ . bind (runFile contents)\n            \\_ . isNil activePacks\n              bind (getValue 'stdTokenPacks')\n                \\stds . resetTokenPacks stds\n              resetTokenPacks activePacks"})((function(){var $m; return function(){return $m || ($m = function(L_file){return L_bind()((function(){var $m; return function(){return $m || ($m = L_readFile()(L_file))}})())((function(){var $m; return function(){return $m || ($m = function(L_result){return L_result()((function(){var $m; return function(){return $m || ($m = function(L_err){return L_err()})}})())((function(){var $m; return function(){return $m || ($m = function(L_contents){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "stdTokenPacks"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_stds){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "activeTokenPacks"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_activePacks){return L_bind()((function(){var $m; return function(){return $m || ($m = L_resetTokenPacks()(L_stds))}})())((function(){var $m; return function(){return $m || ($m = function(L__){return L_bind()((function(){var $m; return function(){return $m || ($m = L_runFile()(L_contents))}})())((function(){var $m; return function(){return $m || ($m = function(L___0){return L_isNil()(L_activePacks)((function(){var $m; return function(){return $m || ($m = L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "stdTokenPacks"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_stds_1){return L_resetTokenPacks()(L_stds_1)})}})()))}})())((function(){var $m; return function(){return $m || ($m = L_resetTokenPacks()(L_activePacks))}})())})}})())})}})())})}})())})}})())})}})())})}})())})}})()));
runMonad(L_define()(function(){return "require"})(function(){return 1})(function(){return "require file = bind (getValue 'requiredFiles')\n  \\files . contains files file nil\n    bind (load file)\n      \\_ . bind (setValue 'requiredFiles' (cons file files))\n        \\_ . nil"})((function(){var $m; return function(){return $m || ($m = function(L_file){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "requiredFiles"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_files){return L_contains()(L_files)(L_file)(L_nil)((function(){var $m; return function(){return $m || ($m = L_bind()((function(){var $m; return function(){return $m || ($m = L_load()(L_file))}})())((function(){var $m; return function(){return $m || ($m = function(L__){return L_bind()((function(){var $m; return function(){return $m || ($m = L_setValue()(function(){return "requiredFiles"})((function(){var $m; return function(){return $m || ($m = L_cons()(L_file)(L_files))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L___0){return L_nil()})}})())})}})()))}})())})}})())})}})()));
runMonad(L_define()(function(){return "defTokenPack"})(function(){return 2})(function(){return "defTokenPack name pack = bind (getValue 'tokenPacks')\n  \\packs . setValue 'tokenPacks' (acons name pack packs)"})((function(){var $m; return function(){return $m || ($m = function(L_name){return function(L_pack){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "tokenPacks"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_packs){return L_setValue()(function(){return "tokenPacks"})((function(){var $m; return function(){return $m || ($m = L_acons()(L_name)(L_pack)(L_packs))}})())})}})())}})}})()));
runMonad(L_define()(function(){return "useTokenPack"})(function(){return 1})(function(){return "useTokenPack name = bind (getValue 'tokenPacks')\n  \\packs . bind (getValue 'tokenGroups')\n    \\groups . bind (getValue 'tokenList')\n      \\tokens . bind (getValue 'activeTokenPacks')\n        \\activePacks . bind (getValue 'parseFilters')\n          \\filters . assoc name packs\n            \\pack . \\\\\n              groupToks = foldl (\\value el . el \\h t . cons h (cons t value)) nil (head (tail pack))\n              newToks = quicksort (\\a b . > (strLen a) (strLen b)) (append (head pack) (append groupToks tokens))\n              .\n              bind (setValue 'tokenList' newToks)\n                \\_ . bind (setValue 'tokenGroups' (append (head (tail pack)) groups))\n                  \\_ . bind (setValue 'parseFilters' (append filters (head (tail (tail pack)))))\n                    \\_ . bind (computeTokenPat newToks)\n                      \\_ . setValue 'activeTokenPacks' (cons name activePacks)\n            nil"})((function(){var $m; return function(){return $m || ($m = function(L_name){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "tokenPacks"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_packs){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "tokenGroups"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_groups){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "tokenList"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_tokens){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "activeTokenPacks"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_activePacks){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "parseFilters"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_filters){return L_assoc()(L_name)(L_packs)((function(){var $m; return function(){return $m || ($m = function(L_pack){return (function(){

var L_newToks, L_groupToks;

L_newToks = (function(){var $m; return function(){return $m || ($m = L_quicksort()((function(){var $m; return function(){return $m || ($m = function(L_a){return function(L_b){return L_$z()((function(){var $m; return function(){return $m || ($m = L_strLen()(L_a))}})())((function(){var $m; return function(){return $m || ($m = L_strLen()(L_b))}})())}})}})())((function(){var $m; return function(){return $m || ($m = L_append()((function(){var $m; return function(){return $m || ($m = L_head()(L_pack))}})())((function(){var $m; return function(){return $m || ($m = L_append()(L_groupToks)(L_tokens))}})()))}})()))}})();

L_groupToks = (function(){var $m; return function(){return $m || ($m = L_foldl()((function(){var $m; return function(){return $m || ($m = function(L_value){return function(L_el){return L_el()((function(){var $m; return function(){return $m || ($m = function(L_h){return function(L_t){return L_cons()(L_h)((function(){var $m; return function(){return $m || ($m = L_cons()(L_t)(L_value))}})())}})}})())}})}})())(L_nil)((function(){var $m; return function(){return $m || ($m = L_head()((function(){var $m; return function(){return $m || ($m = L_tail()(L_pack))}})()))}})()))}})();
return L_bind()((function(){var $m; return function(){return $m || ($m = L_setValue()(function(){return "tokenList"})(L_newToks))}})())((function(){var $m; return function(){return $m || ($m = function(L__){return L_bind()((function(){var $m; return function(){return $m || ($m = L_setValue()(function(){return "tokenGroups"})((function(){var $m; return function(){return $m || ($m = L_append()((function(){var $m; return function(){return $m || ($m = L_head()((function(){var $m; return function(){return $m || ($m = L_tail()(L_pack))}})()))}})())(L_groups))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L___0){return L_bind()((function(){var $m; return function(){return $m || ($m = L_setValue()(function(){return "parseFilters"})((function(){var $m; return function(){return $m || ($m = L_append()(L_filters)((function(){var $m; return function(){return $m || ($m = L_head()((function(){var $m; return function(){return $m || ($m = L_tail()((function(){var $m; return function(){return $m || ($m = L_tail()(L_pack))}})()))}})()))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = function(L___1){return L_bind()((function(){var $m; return function(){return $m || ($m = L_computeTokenPat()(L_newToks))}})())((function(){var $m; return function(){return $m || ($m = function(L___2){return L_setValue()(function(){return "activeTokenPacks"})((function(){var $m; return function(){return $m || ($m = L_cons()(L_name)(L_activePacks))}})())})}})())})}})())})}})())})}})())})()})}})())(L_nil)})}})())})}})())})}})())})}})())})}})())})}})()));
runMonad(L_define()(function(){return "resetTokenPacks"})(function(){return 1})(function(){return "resetTokenPacks packs = bind (setValue 'tokenGroups' nil)\n  \\_ . bind (setValue 'tokenList' nil)\n    \\_ . bind (setValue 'activeTokenPacks' nil)\n      \\_ . bind (setValue 'parseFilters' nil)\n        \\_ . foldr (\\pack result . bind (useTokenPack pack) \\_ . result) nil packs"})((function(){var $m; return function(){return $m || ($m = function(L_packs){return L_bind()((function(){var $m; return function(){return $m || ($m = L_setValue()(function(){return "tokenGroups"})(L_nil))}})())((function(){var $m; return function(){return $m || ($m = function(L__){return L_bind()((function(){var $m; return function(){return $m || ($m = L_setValue()(function(){return "tokenList"})(L_nil))}})())((function(){var $m; return function(){return $m || ($m = function(L___0){return L_bind()((function(){var $m; return function(){return $m || ($m = L_setValue()(function(){return "activeTokenPacks"})(L_nil))}})())((function(){var $m; return function(){return $m || ($m = function(L___1){return L_bind()((function(){var $m; return function(){return $m || ($m = L_setValue()(function(){return "parseFilters"})(L_nil))}})())((function(){var $m; return function(){return $m || ($m = function(L___2){return L_foldr()((function(){var $m; return function(){return $m || ($m = function(L_pack){return function(L_result){return L_bind()((function(){var $m; return function(){return $m || ($m = L_useTokenPack()(L_pack))}})())((function(){var $m; return function(){return $m || ($m = function(L___3){return L_result()})}})())}})}})())(L_nil)(L_packs)})}})())})}})())})}})())})}})())})}})()));
runMonad(L_define()(function(){return "resetStdTokenPacks"})(function(){return 0})(function(){return "resetStdTokenPacks = bind (getValue 'stdTokenPacks')\n  \\stds . bind (resetTokenPacks stds)\n    \\_ . setValue 'activeTokenPacks' nil"})((function(){var $m; return function(){return $m || ($m = L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "stdTokenPacks"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_stds){return L_bind()((function(){var $m; return function(){return $m || ($m = L_resetTokenPacks()(L_stds))}})())((function(){var $m; return function(){return $m || ($m = function(L__){return L_setValue()(function(){return "activeTokenPacks"})(L_nil)})}})())})}})()))}})()));
runMonad(L_define()(function(){return "addStdTokenPacks"})(function(){return 1})(function(){return "addStdTokenPacks morePacks = bind (getValue 'stdTokenPacks')\n  \\stds . setValue 'stdTokenPacks' (append stds morePacks)"})((function(){var $m; return function(){return $m || ($m = function(L_morePacks){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "stdTokenPacks"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_stds){return L_setValue()(function(){return "stdTokenPacks"})((function(){var $m; return function(){return $m || ($m = L_append()(L_stds)(L_morePacks))}})())})}})())})}})()));
runMonad(L_define()(function(){return "addParseFilter"})(function(){return 1})(function(){return "addParseFilter filt = bind (getValue 'parseFilters')\n  \\filters . setValue 'parseFilters' (append filters (cons filt nil))"})((function(){var $m; return function(){return $m || ($m = function(L_filt){return L_bind()((function(){var $m; return function(){return $m || ($m = L_getValue()(function(){return "parseFilters"}))}})())((function(){var $m; return function(){return $m || ($m = function(L_filters){return L_setValue()(function(){return "parseFilters"})((function(){var $m; return function(){return $m || ($m = L_append()(L_filters)((function(){var $m; return function(){return $m || ($m = L_cons()(L_filt)(L_nil))}})()))}})())})}})())})}})()));
runMonad(L_define()(function(){return "d"})(function(){return 3})(function(){return "d label value expr = log (strCat (cons label (cons value nil))) expr"})((function(){var $m; return function(){return $m || ($m = function(L_label){return function(L_value){return function(L_expr){return L_log()((function(){var $m; return function(){return $m || ($m = L_strCat()((function(){var $m; return function(){return $m || ($m = L_cons()(L_label)((function(){var $m; return function(){return $m || ($m = L_cons()(L_value)(L_nil))}})()))}})()))}})())(L_expr)}}})}})()));
runMonad(L_define()(function(){return "dd"})(function(){return 2})(function(){return "dd label arg = d label arg arg"})((function(){var $m; return function(){return $m || ($m = function(L_label){return function(L_arg){return L_d()(L_label)(L_arg)(L_arg)}})}})()));
runMonad(L_setValue()(function(){return "macroDefs"})(L_nil));
runMonad(L_setValue()(function(){return "requiredFiles"})(L_nil));
runMonad(L_setValue()(function(){return "tokenPacks"})(L_nil));
runMonad(L_setValue()(function(){return "activeTokenPacks"})(L_nil));
runMonad(L_setValue()(function(){return "stdTokenPacks"})((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "std"})(L_nil))}})()));
runMonad(L_defTokenPack()(function(){return "std"})((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "."})((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "\\"})((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "\\\\"})((function(){var $m; return function(){return $m || ($m = L_cons()(function(){return "\\@"})(L_nil))}})()))}})()))}})()))}})())((function(){var $m; return function(){return $m || ($m = L_cons()((function(){var $m; return function(){return $m || ($m = L_acons()(function(){return "("})(function(){return ")"})(L_nil))}})())((function(){var $m; return function(){return $m || ($m = L_cons()(L_nil)(L_nil))}})()))}})()))}})()));
runMonad(L_resetStdTokenPacks());

//@ sourceURL=core/simpleParse.lsr
