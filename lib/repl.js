// Generated by CoffeeScript 1.6.2
(function() {
  var action, ast2Json, compile, createAstFile, createJsFile, defaultEnv, diag, evalInput, gen, genJsFromAst, gennedAst, gennedJs, help, identity, json2Ast, loadedParser, monad, newOptions, outDir, path, primCompile, processArg, processedFiles, readFile, readline, recompiled, repl, root, run, runMonad, setDataType, setType, verbose, writeFile, _, _ref, _ref1, _ref2;

  require('source-map-support').install();

  root = module.exports = require('./base');

  _ = require('./lodash.min');

  path = require('path');

  _ref = require('./ast'), setType = _ref.setType, setDataType = _ref.setDataType, ast2Json = _ref.ast2Json, json2Ast = _ref.json2Ast;

  gen = require('./gen').gen;

  _ref1 = require('./base'), readFile = _ref1.readFile, writeFile = _ref1.writeFile;

  _ref2 = require('./runtime'), identity = _ref2.identity, runMonad = _ref2.runMonad, defaultEnv = _ref2.defaultEnv;

  diag = false;

  readline = require('readline');

  evalInput = function(text) {
    var result;

    if (text) {
      if (diag) {
        console.log("Eval: (" + (gen(monad(L_parseLineM()(function() {
          return text;
        })))) + ")");
      }
      result = eval("(" + (gen(monad(L_parseLineM()(function() {
        return text;
      })))) + ")");
      if (result.cmd) {
        return console.log(monad(result));
      } else {
        return console.log(result);
      }
    }
  };

  monad = function(m) {
    return runMonad(m, defaultEnv, function(x) {
      return x;
    });
  };

  help = function() {
    return console.log("Welcome to the Leisure REPL!\n\nHere are the commands:\n:d -- toggle diagnostics\n:{ -- start multiline input\n:} -- end multiline input\n:h -- print this message\nfuncs -- list all known functions\n* -- evaluate Leisure code");
  };

  repl = function() {
    var lines, multiline, rl;

    help();
    lines = null;
    rl = readline.createInterface(process.stdin, process.stdout);
    multiline = false;
    rl.setPrompt('Leisure> ');
    rl.prompt();
    rl.on('line', function(line) {
      switch (line.trim()) {
        case ':d':
          diag = !diag;
          console.log("Diag: " + (diag ? 'on' : 'off'));
          break;
        case ':{':
          if (multiline) {
            console.log("Already reading multiline input");
          } else {
            multiline = true;
            lines = [];
            rl.setPrompt('Leisure {> ');
          }
          break;
        case ':}':
          if (!multiline) {
            console.log("Not reading multiline input.");
          } else {
            evalInput(lines.join('\n'));
            lines = [];
            rl.setPrompt('Leisure> ');
          }
          break;
        case ':h':
          help();
          break;
        default:
          if (multiline) {
            lines.push(line);
          } else {
            evalInput(line);
          }
      }
      return rl.prompt();
    });
    return rl.on('close', function() {
      return process.exit(0);
    });
  };

  verbose = false;

  gennedAst = false;

  gennedJs = false;

  newOptions = true;

  action = null;

  outDir = null;

  recompiled = false;

  loadedParser = false;

  processedFiles = false;

  createAstFile = false;

  createJsFile = false;

  compile = function(file, cont) {
    var ext;

    ext = path.extname(file);
    return readFile(file, function(err, contents) {
      var asts, line, lines, names, outputFile, _i, _len, _ref3;

      if (!err) {
        lines = monad(L_linesForFile()(function() {
          return contents;
        }));
        names = monad(L_namesForLines()(function() {
          return lines;
        }));
        asts = [];
        _ref3 = lines.toArray();
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          line = _ref3[_i];
          asts.push(monad(L_runLine()(function() {
            return names;
          })(function() {
            return line;
          })));
        }
        if (createAstFile) {
          outputFile = (ext === file ? file : file.substring(0, file.length - ext.length)) + ".ast";
          if (outDir) {
            outputFile = path.join(outDir, path.basename(outputFile));
          }
          console.log("AST FILE: " + outputFile);
          writeFile(outputFile, "[\n  " + (_(asts).map(function(item) {
            return JSON.stringify(ast2Json(item));
          }).join(',\n  ')) + "\n]", function(err) {
            if (!err) {
              return cont(asts);
            }
          });
        }
        if (createJsFile) {
          outputFile = (ext === file ? file : file.substring(0, file.length - ext.length)) + ".js";
          if (outDir) {
            outputFile = path.join(outDir, path.basename(outputFile));
          }
          console.log("JS FILE: " + outputFile);
          return writeFile(outputFile, _(asts).map(function(item) {
            return "runMonad((" + (gen(item)) + "), defaultEnv, identity)";
          }).join(';\n  ') + ";\n", function(err) {
            if (!err) {
              return cont(asts);
            }
          });
        }
      }
    });
  };

  primCompile = function(file, cont) {
    var compileFile, ext, parseLine, _ref3;

    _ref3 = require('./simpleParseJS'), parseLine = _ref3.parseLine, compileFile = _ref3.compileFile;
    ext = path.extname(file);
    return readFile(file, function(err, contents) {
      var compiled, outputFile;

      if (!err) {
        compiled = compileFile(contents, file);
        outputFile = (ext === file ? file : file.substring(0, file.length - ext.length)) + ".js";
        if (outDir) {
          outputFile = path.join(outDir, path.basename(outputFile));
        }
        console.log("JS FILE: " + outputFile);
        return writeFile(outputFile, compiled, function(err) {
          if (!err) {
            return cont(compiled);
          }
        });
      }
    });
  };

  genJsFromAst = function(file, cont) {
    return readFile(file, function(err, contents) {
      if (!err) {
        return genJs(_(JSON.parse(contents)).map(function(json) {
          return json2Ast(json);
        }), cont);
      }
    });
  };

  processArg = function(pos) {
    var actions;

    if (pos >= process.argv.length) {
      if (processedFiles) {
        process.exit(1);
      } else {
        repl();
        return;
      }
    }
    if (process.argv[pos][0] === '-' && !newOptions) {
      actions = [];
      newOptions = true;
      gennedAst = gennedJs = false;
    }
    switch (process.argv[pos]) {
      case '-v':
        verbose = true;
        break;
      case '-a':
        action = compile;
        createAstFile = true;
        break;
      case '-c':
        action = compile;
        createAstFile = createJsFile = true;
        break;
      case '-d':
        outDir = process.argv[pos + 1];
        pos++;
        break;
      case '-p':
        action = primCompile;
        loadedParser = true;
        break;
      case '-v':
        verbose = true;
        break;
      default:
        newOptions = true;
        if (process.argv[pos][0] === '-') {
          usage();
        } else {
          processedFiles = true;
          if (!loadedParser) {
            require('./simpleParse');
          }
          action(process.argv[pos], function() {
            return processArg(pos + 1);
          });
        }
        return;
    }
    return processArg(pos + 1);
  };

  run = function() {
    global.runMonad = runMonad;
    global.setType = setType;
    global.setDataType = setDataType;
    global.defaultEnv = defaultEnv;
    global.identity = identity;
    if (process.argv.length === 2) {
      require('./simpleParse');
      return repl();
    } else {
      return processArg(2);
    }
  };

  run();

}).call(this);

/*
//@ sourceMappingURL=repl.map
*/
