// Generated by CoffeeScript 1.6.2
/*
Copyright (C) 2013, Bill Burdick, Tiny Concepts: https://github.com/zot/Leisure

(licensed with ZLIB license)

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software
in a product, an acknowledgment in the product documentation would be
appreciated but is not required.

2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.

3. This notice may not be removed or altered from any source distribution.
*/


/*
Tests for Leisure
*/


(function() {
  var LZ, Nil, T, addDelimiter, assertEq, assertEval, assertEvalPrint, assertParse, ast2Json, compileFile, compileLine, cons, consFrom, debug, defaultEnv, define, delimiterPatStr, evalAst, gen, genLine, getDelimiterInfo, getLambdaBody, getLitVal, getRefName, getValue, id, identity, ign, json2Ast, jsonForFile, lapplyXY, let3Ast, lfalseAst, lidAst, lsr, lsrComp, lsrD, lsrM, lsrParseToAst, ltrueAst, monad, parse, parseJson, parseLine, parseToAst, readFile, run, runMonad, runTests, s, scan, setDataType, setDelimiterInfo, setType, setValue, setXTo3Ast, setXTo3YTo4Ast, splitTokens, stateValues, strLsrD, text1, text2, tokenString, tokens, writeFile, _ref, _ref1, _ref2, _ref3, _ref4;

  Error.stackTraceLimit = Infinity;

  require('source-map-support').install();

  _ref = require('./node'), readFile = _ref.readFile, writeFile = _ref.writeFile;

  _ref1 = LZ = require('./ast'), define = _ref1.define, scan = _ref1.scan, cons = _ref1.cons, Nil = _ref1.Nil, json2Ast = _ref1.json2Ast, ast2Json = _ref1.ast2Json, getLitVal = _ref1.getLitVal, getRefName = _ref1.getRefName, getLambdaBody = _ref1.getLambdaBody, consFrom = _ref1.consFrom, setType = _ref1.setType, setDataType = _ref1.setDataType;

  _ref2 = T = require('./testing'), run = _ref2.run, runTests = _ref2.runTests, assertParse = _ref2.assertParse, assertEval = _ref2.assertEval, assertEvalPrint = _ref2.assertEvalPrint, assertEq = _ref2.assertEq;

  gen = require('./gen').gen;

  _ref3 = require('./runtime'), stateValues = _ref3.stateValues, runMonad = _ref3.runMonad, identity = _ref3.identity, defaultEnv = _ref3.defaultEnv, setValue = _ref3.setValue, getValue = _ref3.getValue;

  _ref4 = require('./simpleParseJS'), splitTokens = _ref4.splitTokens, tokens = _ref4.tokens, tokenString = _ref4.tokenString, parse = _ref4.parse, parseToAst = _ref4.parseToAst, parseLine = _ref4.parseLine, genLine = _ref4.genLine, compileLine = _ref4.compileLine, compileFile = _ref4.compileFile, jsonForFile = _ref4.jsonForFile, getDelimiterInfo = _ref4.getDelimiterInfo, setDelimiterInfo = _ref4.setDelimiterInfo, addDelimiter = _ref4.addDelimiter;

  console.log('Testing CoffeeScript');

  debug = false;

  parseJson = function(str) {
    return json2Ast(JSON.parse(str));
  };

  ltrueAst = json2Ast({
    _type: "lambda",
    varName: "a",
    range: {
      _type: 'cons',
      head: 'file.lsr',
      tail: {
        _type: 'cons',
        head: 1,
        tail: {
          _type: 'cons',
          head: 0,
          tail: {
            _type: 'nil'
          }
        }
      }
    },
    body: {
      _type: "lambda",
      varName: "b",
      range: {
        _type: 'cons',
        head: 'file.lsr',
        tail: {
          _type: 'cons',
          head: 1,
          tail: {
            _type: 'cons',
            head: 0,
            tail: {
              _type: 'nil'
            }
          }
        }
      },
      body: {
        _type: "ref",
        varName: "a",
        range: {
          _type: 'cons',
          head: 'file.lsr',
          tail: {
            _type: 'cons',
            head: 1,
            tail: {
              _type: 'cons',
              head: 0,
              tail: {
                _type: 'nil'
              }
            }
          }
        }
      }
    }
  });

  lfalseAst = json2Ast({
    _type: "lambda",
    varName: "a",
    range: {
      _type: 'cons',
      head: 'file.lsr',
      tail: {
        _type: 'cons',
        head: 1,
        tail: {
          _type: 'cons',
          head: 0,
          tail: {
            _type: 'nil'
          }
        }
      }
    },
    body: {
      _type: "lambda",
      varName: "b",
      range: {
        _type: 'cons',
        head: 'file.lsr',
        tail: {
          _type: 'cons',
          head: 1,
          tail: {
            _type: 'cons',
            head: 0,
            tail: {
              _type: 'nil'
            }
          }
        }
      },
      body: {
        _type: "ref",
        varName: "b",
        range: {
          _type: 'cons',
          head: 'file.lsr',
          tail: {
            _type: 'cons',
            head: 1,
            tail: {
              _type: 'cons',
              head: 0,
              tail: {
                _type: 'nil'
              }
            }
          }
        }
      }
    }
  });

  lidAst = json2Ast({
    _type: "lambda",
    varName: "x",
    range: {
      _type: 'cons',
      head: 'file.lsr',
      tail: {
        _type: 'cons',
        head: 1,
        tail: {
          _type: 'cons',
          head: 0,
          tail: {
            _type: 'nil'
          }
        }
      }
    },
    body: {
      _type: "ref",
      varName: "x",
      range: {
        _type: 'cons',
        head: 'file.lsr',
        tail: {
          _type: 'cons',
          head: 1,
          tail: {
            _type: 'cons',
            head: 0,
            tail: {
              _type: 'nil'
            }
          }
        }
      }
    }
  });

  lapplyXY = json2Ast({
    _type: "lambda",
    varName: "x",
    range: {
      _type: 'cons',
      head: 'file.lsr',
      tail: {
        _type: 'cons',
        head: 1,
        tail: {
          _type: 'cons',
          head: 0,
          tail: {
            _type: 'nil'
          }
        }
      }
    },
    body: {
      _type: "lambda",
      varName: "y",
      range: {
        _type: 'cons',
        head: 'file.lsr',
        tail: {
          _type: 'cons',
          head: 1,
          tail: {
            _type: 'cons',
            head: 0,
            tail: {
              _type: 'nil'
            }
          }
        }
      },
      body: {
        _type: "apply",
        func: {
          _type: "ref",
          varName: "x",
          range: {
            _type: 'cons',
            head: 'file.lsr',
            tail: {
              _type: 'cons',
              head: 1,
              tail: {
                _type: 'cons',
                head: 0,
                tail: {
                  _type: 'nil'
                }
              }
            }
          }
        },
        arg: {
          _type: "ref",
          varName: "y",
          range: {
            _type: 'cons',
            head: 'file.lsr',
            tail: {
              _type: 'cons',
              head: 1,
              tail: {
                _type: 'cons',
                head: 0,
                tail: {
                  _type: 'nil'
                }
              }
            }
          }
        }
      }
    }
  });

  let3Ast = json2Ast({
    _type: 'let',
    varName: 'x',
    range: {
      _type: 'cons',
      head: 'file.lsr',
      tail: {
        _type: 'cons',
        head: 1,
        tail: {
          _type: 'cons',
          head: 0,
          tail: {
            _type: 'nil'
          }
        }
      }
    },
    value: {
      _type: 'lit',
      value: 3,
      range: {
        _type: 'cons',
        head: 'file.lsr',
        tail: {
          _type: 'cons',
          head: 1,
          tail: {
            _type: 'cons',
            head: 0,
            tail: {
              _type: 'nil'
            }
          }
        }
      }
    },
    body: {
      _type: 'let',
      varName: 'y',
      range: {
        _type: 'cons',
        head: 'file.lsr',
        tail: {
          _type: 'cons',
          head: 1,
          tail: {
            _type: 'cons',
            head: 0,
            tail: {
              _type: 'nil'
            }
          }
        }
      },
      value: {
        _type: 'apply',
        func: {
          _type: 'apply',
          func: {
            _type: 'ref',
            range: {
              _type: 'cons',
              head: 'file.lsr',
              tail: {
                _type: 'cons',
                head: 1,
                tail: {
                  _type: 'cons',
                  head: 0,
                  tail: {
                    _type: 'nil'
                  }
                }
              }
            },
            varName: 'log'
          },
          arg: {
            _type: 'lit',
            value: "hello y",
            range: {
              _type: 'cons',
              head: 'file.lsr',
              tail: {
                _type: 'cons',
                head: 1,
                tail: {
                  _type: 'cons',
                  head: 0,
                  tail: {
                    _type: 'nil'
                  }
                }
              }
            }
          }
        },
        arg: {
          _type: 'lit',
          value: 4,
          range: {
            _type: 'cons',
            head: 'file.lsr',
            tail: {
              _type: 'cons',
              head: 1,
              tail: {
                _type: 'cons',
                head: 0,
                tail: {
                  _type: 'nil'
                }
              }
            }
          }
        }
      },
      body: {
        _type: 'ref',
        varName: 'x',
        range: {
          _type: 'cons',
          head: 'file.lsr',
          tail: {
            _type: 'cons',
            head: 1,
            tail: {
              _type: 'cons',
              head: 0,
              tail: {
                _type: 'nil'
              }
            }
          }
        }
      }
    }
  });

  setXTo3Ast = json2Ast({
    _type: 'apply',
    func: {
      _type: 'apply',
      func: {
        _type: 'ref',
        varName: 'setValue',
        range: {
          _type: 'cons',
          head: 'file.lsr',
          tail: {
            _type: 'cons',
            head: 1,
            tail: {
              _type: 'cons',
              head: 0,
              tail: {
                _type: 'nil'
              }
            }
          }
        }
      },
      arg: {
        _type: 'lit',
        value: 'x',
        range: {
          _type: 'cons',
          head: 'file.lsr',
          tail: {
            _type: 'cons',
            head: 1,
            tail: {
              _type: 'cons',
              head: 0,
              tail: {
                _type: 'nil'
              }
            }
          }
        }
      }
    },
    arg: {
      _type: 'lit',
      value: 3,
      range: {
        _type: 'cons',
        head: 'file.lsr',
        tail: {
          _type: 'cons',
          head: 1,
          tail: {
            _type: 'cons',
            head: 0,
            tail: {
              _type: 'nil'
            }
          }
        }
      }
    }
  });

  setXTo3YTo4Ast = json2Ast({
    _type: 'apply',
    func: {
      _type: 'apply',
      func: {
        _type: 'ref',
        varName: 'bind',
        range: {
          _type: 'cons',
          head: 'file.lsr',
          tail: {
            _type: 'cons',
            head: 1,
            tail: {
              _type: 'cons',
              head: 0,
              tail: {
                _type: 'nil'
              }
            }
          }
        }
      },
      arg: {
        _type: 'apply',
        func: {
          _type: 'apply',
          func: {
            _type: 'ref',
            varName: 'setValue',
            range: {
              _type: 'cons',
              head: 'file.lsr',
              tail: {
                _type: 'cons',
                head: 1,
                tail: {
                  _type: 'cons',
                  head: 0,
                  tail: {
                    _type: 'nil'
                  }
                }
              }
            }
          },
          arg: {
            _type: 'lit',
            value: 'x',
            range: {
              _type: 'cons',
              head: 'file.lsr',
              tail: {
                _type: 'cons',
                head: 1,
                tail: {
                  _type: 'cons',
                  head: 0,
                  tail: {
                    _type: 'nil'
                  }
                }
              }
            }
          }
        },
        arg: {
          _type: 'lit',
          value: 3,
          range: {
            _type: 'cons',
            head: 'file.lsr',
            tail: {
              _type: 'cons',
              head: 1,
              tail: {
                _type: 'cons',
                head: 0,
                tail: {
                  _type: 'nil'
                }
              }
            }
          }
        }
      }
    },
    arg: {
      _type: 'lambda',
      varName: 'bubba',
      range: {
        _type: 'cons',
        head: 'file.lsr',
        tail: {
          _type: 'cons',
          head: 1,
          tail: {
            _type: 'cons',
            head: 0,
            tail: {
              _type: 'nil'
            }
          }
        }
      },
      body: {
        _type: 'apply',
        func: {
          _type: 'apply',
          func: {
            _type: 'ref',
            varName: 'setValue',
            range: {
              _type: 'cons',
              head: 'file.lsr',
              tail: {
                _type: 'cons',
                head: 1,
                tail: {
                  _type: 'cons',
                  head: 0,
                  tail: {
                    _type: 'nil'
                  }
                }
              }
            }
          },
          arg: {
            _type: 'lit',
            value: 'y',
            range: {
              _type: 'cons',
              head: 'file.lsr',
              tail: {
                _type: 'cons',
                head: 1,
                tail: {
                  _type: 'cons',
                  head: 0,
                  tail: {
                    _type: 'nil'
                  }
                }
              }
            }
          }
        },
        arg: {
          _type: 'lit',
          value: 4,
          range: {
            _type: 'cons',
            head: 'file.lsr',
            tail: {
              _type: 'cons',
              head: 1,
              tail: {
                _type: 'cons',
                head: 0,
                tail: {
                  _type: 'nil'
                }
              }
            }
          }
        }
      }
    }
  });

  text1 = "v1 = 3\nv2 = 4\nv3 = + 3 4";

  text2 = "v4 = 5\nv5 = 6\nv6 = + 5 6";

  evalAst = function(ast) {
    return eval("(" + (gen(ast)) + ")");
  };

  lsr = function(str) {
    return eval("(" + (gen(parseToAst(str))) + ")");
  };

  lsrD = function(str) {
    return lsr("" + str + " " + delimiterPatStr);
  };

  strLsrD = function(str) {
    return String(lsrD(str));
  };

  lsrComp = function(str, diag) {
    if (diag) {
      console.log(("COMPILE: " + str + ": ") + ("parseLine " + (s(str)) + " " + (s(LZ.delimiterPat.source)) + " nil id id"));
      console.log("TOKENS: " + (lsrD("tokens " + (s(str)))));
      console.log("LIST: " + (lsrD("parse " + (s(str)))));
      console.log("AST: " + (lsr("parseLine " + (s(str)) + " " + (s(LZ.delimiterPat.source)) + " nil id id")));
      console.log("JS: (" + gen(lsr("parseLine " + (s(str)) + " " + (s(LZ.delimiterPat.source)) + " nil id id")) + ")");
      console.log("done");
    }
    return monad(eval("(" + (gen(lsr("parseLine " + (s(str)) + " " + (s(LZ.delimiterPat.source)) + " nil id id"))) + ")"));
  };

  global.runMonad = runMonad;

  lsrM = function(str) {
    return monad(eval("(" + (gen(monad(lsr("parseLineM " + (s(str)))))) + ")"));
  };

  lsrParseToAst = function(str) {
    return lsrComp("parseToAst " + (s(str)) + " " + (s(LZ.delimiterPat.source)));
  };

  monad = function(m) {
    return runMonad(m, defaultEnv, id);
  };

  id = function(x) {
    return x;
  };

  ign = function() {};

  delimiterPatStr = JSON.stringify(LZ.delimiterPat.source);

  s = function(str) {
    return JSON.stringify(str);
  };

  readFile('core/simpleParse.lsr', function(err, code) {
    if (err) {
      throw new Error(err);
    } else {
      return writeFile('/tmp/simpleParse.js', compileFile(code, "simpleParse.js"), function(err) {
        runTests('Basic', {
          basic1: function() {
            return assertEq("1", "1");
          },
          basic2: function() {
            return assertEq("" + LZ.Nil, "Cons[]");
          },
          basic3: function() {
            return assertEq("" + (cons(1, cons(2, Nil))), "Cons[1 2]");
          },
          basic4: function() {
            return assertEq("", "");
          },
          basic5: function() {
            return assertEq("" + (consFrom('1 2 3'.split(' '))), "Cons[1 2 3]");
          },
          basic6: function() {
            return assertEq("" + (consFrom('1 2 3'.split(' ')).reverse()), "Cons[3 2 1]");
          },
          basic7: function() {
            return assertEq("" + (cons(1, 2)), "Cons[1 | 2]");
          },
          basic8: function() {
            var st;

            st = json2Ast({
              _type: "lit",
              value: 3,
              range: {
                _type: 'cons',
                head: 'file.lsr',
                tail: {
                  _type: 'cons',
                  head: 1,
                  tail: {
                    _type: 'cons',
                    head: 0,
                    tail: {
                      _type: 'nil'
                    }
                  }
                }
              }
            });
            assertEq(getLitVal(st), 3);
            return assertEq(getLitVal(json2Ast(ast2Json(st))), 3);
          },
          basic9: function() {
            var st;

            st = json2Ast({
              _type: "ref",
              varName: 3,
              range: {
                _type: 'cons',
                head: 'file.lsr',
                tail: {
                  _type: 'cons',
                  head: 1,
                  tail: {
                    _type: 'cons',
                    head: 0,
                    tail: {
                      _type: 'nil'
                    }
                  }
                }
              }
            });
            assertEq(getRefName(st), 3);
            return assertEq(getRefName(json2Ast(ast2Json(st))), 3);
          },
          basic10: function() {
            assertEq(getRefName(getLambdaBody(lidAst)), 'x');
            return assertEq(getRefName(getLambdaBody(json2Ast(ast2Json(lidAst)))), 'x');
          },
          basic11: function() {
            var st;

            st = json2Ast({
              _type: "cons",
              head: 1,
              tail: {
                _type: "nil"
              }
            });
            assertEq("" + st, "Cons[1]");
            return assertEq("" + (json2Ast(ast2Json(st))), "Cons[1]");
          },
          basic12: function() {
            var st;

            st = json2Ast({
              _type: "lit",
              value: 3,
              range: {
                _type: 'cons',
                head: 'file.lsr',
                tail: {
                  _type: 'cons',
                  head: 1,
                  tail: {
                    _type: 'cons',
                    head: 0,
                    tail: {
                      _type: 'nil'
                    }
                  }
                }
              }
            });
            return assertEq(gen(st), '3');
          },
          basic13: function() {
            return assertEq(gen(lidAst), 'function(L_x){return resolve(L_x)}');
          },
          basic14: function() {
            return assertEq(gen(lapplyXY), 'function(L_x){return function(L_y){return resolve(L_x)(L_y)}}');
          },
          basic15: function() {
            return assertEq(gen(ltrueAst), 'function(L_a){return function(L_b){return resolve(L_a)}}');
          },
          basic16: function() {
            return assertEq((eval("(" + (gen(ltrueAst)) + ")"))(function() {
              return 5;
            })(function() {
              return 6;
            }), 5);
          },
          basic17: function() {
            return assertEq((eval("(" + (gen(lfalseAst)) + ")"))(function() {
              return 5;
            })(function() {
              return 6;
            }), 6);
          },
          basic18: function() {
            return assertEq(eval("(" + (gen(let3Ast)) + ")"), 3);
          },
          basic19: function() {
            stateValues.x = 2;
            runMonad(eval("(" + (gen(setXTo3Ast)) + ")"), defaultEnv, function() {});
            return assertEq(stateValues.x, 3);
          },
          basic20: function() {
            stateValues.x = 2;
            stateValues.y = 2;
            runMonad(eval("(" + (gen(setXTo3YTo4Ast)) + ")"), defaultEnv, function() {});
            assertEq(stateValues.x, 3);
            return assertEq(stateValues.y, 4);
          }
        });
        runTests('Parsing', {
          parse1: function() {
            assertEq(splitTokens('a b').toArray(), ['a', ' ', 'b']);
            assertEq(splitTokens('a b\nc').toArray(), ['a', ' ', 'b', '\n', 'c']);
            assertEq(splitTokens('a b#\nc').toArray(), ['a', ' ', 'b', '#', '\n', 'c']);
            return assertEq(splitTokens('a b#\nc\n #asdf\nd#l;kj').toArray(), ['a', ' ', 'b', '#', '\n', 'c', '\n ', '#asdf', '\n', 'd', '#l;kj']);
          },
          parse2: function() {
            return assertEq(String(tokens('a b')), 'Cons[Token("a", 0) Token("b", 2)]');
          },
          parse3: function() {
            return assertEq(String(parse('a\n b')), 'Cons[Token("a", 0) Token("b", 3)]');
          },
          parse4: function() {
            return assertEq(String(parse('a\n b c')), 'Cons[Token("a", 0) Parens(1, 6, Cons[Token("b", 3) Token("c", 5)])]');
          },
          parse5: function() {
            return assertEq(splitTokens('a b  c').toArray(), ['a', ' ', 'b', '  ', 'c']);
          },
          parse6: function() {
            return assertEq(String(tokens('a b  c')), 'Cons[Token("a", 0) Token("b", 2) Token("c", 5)]');
          },
          parse7: function() {
            return assertEq(String(parse('a b  c')), 'Cons[Token("a", 0) Token("b", 2) Token("c", 5)]');
          },
          parse8: function() {
            return assertEq(splitTokens('a (b)').toArray(), ['a', ' ', '(', 'b', ')']);
          },
          parse9: function() {
            return assertEq(String(parse('a (b)')), 'Cons[Token("a", 0) Parens(2, 5, Cons[Token("b", 3)])]');
          },
          parse10: function() {
            return assertEq(String(tokens('a ( (b  )   c) ')), 'Cons[Token("a", 0) Token("(", 2) Token("(", 4) Token("b", 5) Token(")", 8) Token("c", 12) Token(")", 13)]');
          },
          parse11: function() {
            return assertEq(String(parse('a ( (b  )   c) ')), 'Cons[Token("a", 0) Parens(2, 14, Cons[Parens(4, 9, Cons[Token("b", 5)]) Token("c", 12)])]');
          },
          parse12: function() {
            assertEq(String(parse('a.b')), 'Cons[Token("a", 0) Token(".", 1) Token("b", 2)]');
            assertEq(String(parse('a.b#blorfl')), 'Cons[Token("a", 0) Token(".", 1) Token("b", 2)]');
            assertEq(String(tokens("a (\\b . c d (e f)) g")), 'Cons[Token("a", 0) Token("(", 2) Token("\\\\", 3) Token("b", 4) Token(".", 6) Token("c", 8) Token("d", 10) Token("(", 12) Token("e", 13) Token("f", 15) Token(")", 16) Token(")", 17) Token("g", 19)]');
            assertEq(String(parse("a (\\b . c d (e f)) g")), 'Cons[Token("a", 0) Parens(2, 18, Cons[Token("\\\\", 3) Token("b", 4) Token(".", 6) Token("c", 8) Token("d", 10) Parens(12, 17, Cons[Token("e", 13) Token("f", 15)])]) Token("g", 19)]');
            assertEq(String(tokens("a (\\b .\n  c\n  d (e f)) g")), 'Cons[Token("a", 0) Token("(", 2) Token("\\\\", 3) Token("b", 4) Token(".", 6) Token("\\n  ", 7) Token("c", 10) Token("\\n  ", 11) Token("d", 14) Token("(", 16) Token("e", 17) Token("f", 19) Token(")", 20) Token(")", 21) Token("g", 23)]');
            return assertEq(String(parse("a (\\b .\n  c\n  d (e f)) g")), 'Cons[Token("a", 0) Parens(2, 22, Cons[Token("\\\\", 3) Token("b", 4) Token(".", 6) Token("c", 10) Parens(11, 21, Cons[Token("d", 14) Parens(16, 21, Cons[Token("e", 17) Token("f", 19)])])]) Token("g", 23)]');
          }
        });
        runTests('AST', {
          ast1: function() {
            return assertEq(String(parseToAst('a')), 'ref(a)');
          },
          ast2: function() {
            return assertEq(String(parseToAst('a b')), 'apply(a b)');
          },
          ast3: function() {
            return assertEq(String(parseToAst('\\a . a')), 'lambda(\\a . a)');
          },
          ast4: function() {
            return assertEq(String(parseToAst('\\a b . a')), 'lambda(\\a . \\b . a)');
          },
          ast5: function() {
            return assertEq(String(parseToAst('\\a b . a b')), 'lambda(\\a . \\b . a b)');
          },
          ast6: function() {
            return assertEq(String(parseToAst('\\\\(a = 1) . a')), 'let(\\\\(a = 1) . a)');
          },
          ast7: function() {
            return assertEq(String(parseToAst('\\\\(a b = 1) . a')), 'let(\\\\(a = \\b . 1) . a)');
          },
          ast8: function() {
            return assertEq(String(parseToAst('\\\\(a b = c) (c = 3) . a 5')), 'let(\\\\(a = \\b . c) (c = 3) . a 5)');
          },
          ast9: function() {
            return assertEq(lsr('\\x . x')(function() {
              return 7;
            }), 7);
          },
          ast10: function() {
            return assertEq(lsr('getType "hello"'), "*string");
          },
          ast11: function() {
            return assertEq(compileLine('3', Nil, (function() {}), id), 3);
          },
          ast12: function() {
            return assertEq(compileLine('\\x . x', Nil, (function() {}), id)(function() {
              return 3;
            }), 3);
          },
          ast13: function() {
            assertEq(String(parseLine('id = \\x . x', Nil, id, ign)), 'apply(define id 0 id = \\x . x \\@dataType id . \\@type id . \\x . x)');
            return assertEq(String(parseLine('id x = x', Nil, id, ign)), 'apply(define id 1 id x = x \\x . x)');
          },
          ast14: function() {
            compileLine('id = \\x . x', Nil, id, id);
            return assertEq(compileLine('id', Nil, (function() {}), id)(function() {
              return 3;
            }), 3);
          },
          ast15: function() {
            return assertEq(compileLine('\\x y . + x y', Nil, (function() {}), id)(function() {
              return 3;
            })(function() {
              return 4;
            }), 7);
          },
          ast16: function() {
            compileLine('plus x y = + x y', Nil, id, id);
            return assertEq(compileLine('plus', Nil, (function() {}), id)(function() {
              return 3;
            })(function() {
              return 4;
            }), 7);
          },
          ast17: function() {
            return assertEq(String(parseToAst('\\@ a b . c')), 'anno(\\@a b . c)');
          },
          ast18: function() {
            return assertEq(lsr('\\@ a b . 3'), 3);
          },
          ast19: function() {
            return assertEq(lsr('(\\@ a b . \\x . x) 4'), 4);
          },
          ast20: function() {
            return assertEq(String(parseToAst('(\\f . f 5) \\x . x')), 'apply((\\f . f 5) \\x . x)');
          },
          ast21: function() {
            return assertEq(lsr('(\\f . f 5) \\x . x'), 5);
          },
          ast22: function() {
            return assertEq(lsr('(\\f . f 5) \\@ a b . \\x . x'), 5);
          },
          ast23: function() {
            return assertEq(lsr('getType \\@ type fred . \\x . x'), 'fred');
          },
          ast24: function() {
            eval(compileFile(text1));
            assertEq(lsr('v1'), 3);
            assertEq(lsr('v2'), 4);
            return assertEq(lsr('v3'), 7);
          },
          ast25: function() {
            var line, _i, _len, _ref5;

            _ref5 = jsonForFile(text2).split('\n');
            for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
              line = _ref5[_i];
              runMonad(eval(gen(json2Ast(JSON.parse(line)))), defaultEnv, id);
            }
            assertEq(lsr('v4'), 5);
            assertEq(lsr('v5'), 6);
            return assertEq(lsr('v6'), 11);
          },
          ast26: function() {
            eval(compileFile(code));
            return assertEq(String(lsr('nil')), 'Cons[]');
          },
          ast27: function() {
            assertEq(lsr("strToList '\"'").toArray(), ['"']);
            assertEq(lsr("eq '1' '\\\\' 1 2"), 2);
            assertEq(lsr("eq '1' '\"' 1 2"), 2);
            return assertEq(tokenString(tokens("eq '\\\\' (eq 'b' nil) 1 2").tail().head()), "'\\\\'");
          },
          ast28: function() {
            return assertEq(lsr('"true"'), 'true');
          },
          ast29: function() {
            return assertEq(lsr("'true'"), 'true');
          },
          ast30: function() {
            return assertEq(lsr("getType 'true'"), '*string');
          },
          ast31: function() {
            return assertEq(lsr("eq 1 1 3 4"), 3);
          },
          ast32: function() {
            return assertEq(lsr("eq 1 2 3 4"), 4);
          },
          ast33: function() {
            return assertEq(lsr("eq (getType nil) 'nil' 1 2"), 1);
          },
          ast34: function() {
            return assertEq(lsr("eq (getType (cons 1 nil)) 'cons' 1 2"), 1);
          },
          ast35: function() {
            return assertEq(splitTokens("splitTokens 'a b' " + delimiterPatStr).toArray(), ['splitTokens', ' ', "'a b'", ' ', JSON.stringify(LZ.delimiterPat.source)]);
          },
          ast36: function() {
            assertEq(String(splitTokens("'^[ \\t]*#.*|^[ \\t]*$'")), 'Cons[\'^[ \\t]*#.*|^[ \\t]*$\']');
            assertEq(String(parseToAst("'^[ \\t]*#.*|^[ \\t]*$'")), 'lit(^[ \t]*#.*|^[ \t]*$)');
            assertEq(gen(parseToAst("'^[ \\t]*#.*|^[ \\t]*$'")), '\"^[ \\t]*#.*|^[ \\t]*$\"');
            return assertEq(lsr("'^[ \\t]*#.*|^[ \\t]*$'"), '^[ \t]*#.*|^[ \t]*$');
          }
        });
        runTests('Leisure parser', {
          leisureParse1: function() {
            return assertEq(lsr("strSplit 'a b' " + delimiterPatStr).toArray(), ['a', ' ', 'b']);
          },
          leisureParse2: function() {
            assertEq(lsrD("splitTokens 'a b'").toArray(), ['a', ' ', 'b']);
            assertEq(lsrD("splitTokens 'a b\nc'").toArray(), ['a', ' ', 'b', '\n', 'c']);
            assertEq(lsrD("splitTokens 'a b#\nc'").toArray(), ['a', ' ', 'b', '#', '\n', 'c']);
            return assertEq(lsrD("splitTokens 'a b#\nc\n #asdf\nd#l;kj'").toArray(), ['a', ' ', 'b', '#', '\n', 'c', '\n ', '#asdf', '\n', 'd', '#l;kj']);
          },
          leisureParse3: function() {
            return assertEq(strLsrD("tokens 'a b'"), 'Cons[Token("a", 0) Token("b", 2)]');
          },
          leisureParse4: function() {
            return assertEq(lsr('getType (cons 1 nil)'), 'cons');
          },
          leisureParse5: function() {
            return assertEq(lsr('getDataType cons'), 'cons');
          },
          leisureParse6: function() {
            return assertEq(lsr('hasType (cons 1 nil) cons 1 0'), 1);
          },
          leisureParse7: function() {
            return assertEq(strLsrD("parse 'a\n b'"), 'Cons[Token("a", 0) Token("b", 3)]');
          },
          leisureParse8: function() {
            return assertEq(strLsrD("parse 'a\n b c'"), 'Cons[Token("a", 0) Parens(1, 6, Cons[Token("b", 3) Token("c", 5)])]');
          },
          leisureParse9: function() {
            return assertEq(strLsrD("parse 'a\n b c'"), 'Cons[Token("a", 0) Parens(1, 6, Cons[Token("b", 3) Token("c", 5)])]');
          },
          leisureParse10: function() {
            return assertEq(strLsrD("parse 'a\nb'"), 'Token("a", 0)');
          },
          leisureParse11: function() {
            return assertEq(strLsrD("parse 'a\n b c\n d e'"), 'Cons[Token("a", 0) Parens(1, 6, Cons[Token("b", 3) Token("c", 5)]) Parens(6, 11, Cons[Token("d", 8) Token("e", 10)])]');
          },
          leisureParse12: function() {
            return assertEq(strLsrD("parse 'a\n b c\n d e\nf'"), 'Cons[Token("a", 0) Parens(1, 6, Cons[Token("b", 3) Token("c", 5)]) Parens(6, 11, Cons[Token("d", 8) Token("e", 10)])]');
          },
          leisureParse13: function() {
            return assertEq(strLsrD("parse 'a\n b c\n  d e'"), 'Cons[Token("a", 0) Parens(1, 12, Cons[Token("b", 3) Token("c", 5) Parens(6, 12, Cons[Token("d", 9) Token("e", 11)])])]');
          },
          leisureParse14: function() {
            return assertEq(strLsrD("parse 'a\n b c\n  d e\n f'"), 'Cons[Token("a", 0) Parens(1, 12, Cons[Token("b", 3) Token("c", 5) Parens(6, 12, Cons[Token("d", 9) Token("e", 11)])]) Token("f", 14)]');
          },
          leisureParse15: function() {
            return assertEq(lsr('\\\\(a = 1) (b x = x) . (b a)'), 1);
          },
          leisureParse16: function() {
            return assertEq(lsr("\\\\\n  a = 1\n  b x = x\n  .\n  b a"), 1);
          },
          leisureParse17: function() {
            return assertEq(lsrD("splitTokens 'a b  c'").toArray(), ['a', ' ', 'b', '  ', 'c']);
          },
          leisureParse18: function() {
            return assertEq(strLsrD("tokens 'a b  c'"), 'Cons[Token("a", 0) Token("b", 2) Token("c", 5)]');
          },
          leisureParse19: function() {
            return assertEq(lsr("'\\n'"), '\n');
          },
          leisureParse20: function() {
            return assertEq(String(lsr("reverse (cons 1 (cons 2 nil))")), 'Cons[2 1]');
          },
          leisureParse21: function() {
            return assertEq(strLsrD("parse 'a'"), 'Token("a", 0)');
          },
          leisureParse22: function() {
            return assertEq(strLsrD("parse 'a b  c'"), 'Cons[Token("a", 0) Token("b", 2) Token("c", 5)]');
          },
          leisureParse23: function() {
            return assertEq(lsrD("splitTokens 'a (b)'").toArray(), ['a', ' ', '(', 'b', ')']);
          },
          leisureParse24: function() {
            return assertEq(strLsrD("parse 'a (b)'"), 'Cons[Token("a", 0) Parens(2, 5, Cons[Token("b", 3)])]');
          },
          leisureParse25: function() {
            return assertEq(strLsrD("tokens 'a ( (b  )   c) '"), 'Cons[Token("a", 0) Token("(", 2) Token("(", 4) Token("b", 5) Token(")", 8) Token("c", 12) Token(")", 13)]');
          },
          leisureParse26: function() {
            return assertEq(strLsrD("parse 'a ( (b  )   c) '"), 'Cons[Token("a", 0) Parens(2, 14, Cons[Parens(4, 9, Cons[Token("b", 5)]) Token("c", 12)])]');
          },
          leisureParse27: function() {
            assertEq(strLsrD("parse 'a.b'"), 'Cons[Token("a", 0) Token(".", 1) Token("b", 2)]');
            assertEq(strLsrD("parse 'a.b#blorfl'"), 'Cons[Token("a", 0) Token(".", 1) Token("b", 2)]');
            assertEq(strLsrD("tokens 'a (\\\\b . c d (e f)) g'"), 'Cons[Token("a", 0) Token("(", 2) Token("\\\\", 3) Token("b", 4) Token(".", 6) Token("c", 8) Token("d", 10) Token("(", 12) Token("e", 13) Token("f", 15) Token(")", 16) Token(")", 17) Token("g", 19)]');
            assertEq(strLsrD("parse 'a (\\\\b . c d (e f)) g'"), 'Cons[Token("a", 0) Parens(2, 18, Cons[Token("\\\\", 3) Token("b", 4) Token(".", 6) Token("c", 8) Token("d", 10) Parens(12, 17, Cons[Token("e", 13) Token("f", 15)])]) Token("g", 19)]');
            assertEq(strLsrD("tokens " + (s("a (\\b .\n  c\n  d (e f)) g"))), 'Cons[Token("a", 0) Token("(", 2) Token("\\\\", 3) Token("b", 4) Token(".", 6) Token("\\n  ", 7) Token("c", 10) Token("\\n  ", 11) Token("d", 14) Token("(", 16) Token("e", 17) Token("f", 19) Token(")", 20) Token(")", 21) Token("g", 23)]');
            return assertEq(strLsrD("parse " + (s("a (\\b .\n  c\n  d (e f)) g"))), 'Cons[Token("a", 0) Parens(2, 22, Cons[Token("\\\\", 3) Token("b", 4) Token(".", 6) Token("c", 10) Parens(11, 21, Cons[Token("d", 14) Parens(16, 21, Cons[Token("e", 17) Token("f", 19)])])]) Token("g", 23)]');
          },
          leisureParse28: function() {
            return assertEq(strLsrD("parse " + (s('"a b"'))), 'Token("\\\"a b\\\"", 0)');
          }
        });
        runTests('Leisure AST', {
          leisureAst1: function() {
            return assertEq(lsr("scrub '\"'"), "\\\"");
          },
          leisureAst2: function() {
            return assertEq(strLsrD("parseToAst 'a'"), 'ref(a)');
          },
          leisureAst3: function() {
            assertEq(lsr("strMatches 'a' 'a' 1 2"), 1);
            assertEq(String(lsr("strMatch 'a' 'b'")), "Cons[]");
            assertEq(String(lsr("getType (strMatch 'a' 'b')")), "nil");
            assertEq(String(lsr("hasType (strMatch 'a' 'b') nil 1 2")), "1");
            return assertEq(lsr("strMatches 'a' 'b' 1 2"), 2);
          },
          leisureAst4: function() {
            assertEq(strLsrD("parse 'a b'"), 'Cons[Token("a", 0) Token("b", 2)]');
            return assertEq(strLsrD("parseToAst 'a b'"), 'apply(a b)');
          },
          leisureAst5: function() {
            assertEq(strLsrD("parse " + (s('\\a . a'))), 'Cons[Token("\\\\", 0) Token("a", 1) Token(".", 3) Token("a", 5)]');
            return assertEq(strLsrD("parseToAst " + (s('\\a . a'))), 'lambda(\\a . a)');
          },
          leisureAst6: function() {
            lsr("\\@define (duh 1 'duh x = x') . \\x . x");
            return assertEq(lsr("duh 3"), 3);
          },
          leisureAst7: function() {
            return assertEq(strLsrD("parseToAst " + (s('\\@ a . 1'))), 'anno(\\@a Cons[] . 1)');
          },
          leisureAst8: function() {
            return assertEq(strLsrD("parseToAst " + (s('\\@ a b . 1'))), 'anno(\\@a b . 1)');
          },
          leisureAst9: function() {
            return assertEq(lsr('\\\\ (x = 1) (x = + x 1) . x'), 2);
          },
          leisureAst10: function() {
            return assertEq(strLsrD("parseToAst " + (s('\\a b . a'))), 'lambda(\\a . \\b . a)');
          },
          leisureAst11: function() {
            return assertEq(strLsrD("parseToAst " + (s('\\a b . a b'))), 'lambda(\\a . \\b . a b)');
          },
          leisureAst12: function() {
            return assertEq(strLsrD("parseToAst " + (s('\\\\(a = 1) . a'))), 'let(\\\\(a = 1) . a)');
          },
          leisureAst13: function() {
            return assertEq(strLsrD("parseToAst " + (s('\\\\(a b = 1) . a'))), 'let(\\\\(a = \\b . 1) . a)');
          },
          leisureAst14: function() {
            return assertEq(strLsrD("parseToAst " + (s('\\\\(a b = c) (c = 3) . a'))), 'let(\\\\(a = \\b . c) (c = 3) . a)');
          },
          leisureAst15: function() {
            return assertEq(strLsrD("parseToAst " + (s('\\\\(a b = c) (c = 3) . a 5'))), 'let(\\\\(a = \\b . c) (c = 3) . a 5)');
          },
          leisureAst16: function() {
            return assertEq(strLsrD("parseToAst '3'"), 'lit(3)');
          },
          leisureAst17: function() {
            return assertEq(lsr("(\\x . x) 3"), 3);
          },
          leisureAst18: function() {
            return assertEq(evalAst(lsrD("parseToAst '3'")), 3);
          },
          leisureAst19: function() {
            return assertEq(lsrComp("(\\x . x) 3"), 3);
          },
          leisureAst20: function() {
            return assertEq(lsrComp("\\x . x")(function() {
              return 7;
            }), 7);
          },
          leisureAst21: function() {
            assertEq(lsr("\"hello\""), 'hello');
            assertEq(strLsrD("parseToAst " + (s('"hello"'))), "lit(hello)");
            return assertEq(lsrComp('"hello"'), 'hello');
          },
          leisureAst22: function() {
            return assertEq(lsrComp('getType "hello"'), "*string");
          },
          leisureAst23: function() {
            return assertEq(lsrComp('3'), 3);
          },
          leisureAst24: function() {
            return assertEq(lsrComp('\\x . x')(function() {
              return 3;
            }), 3);
          },
          leisureAst25: function() {
            assertEq(String(parseLine('id = \\x . x', Nil, id, id)), 'apply(define id 0 id = \\x . x \\@dataType id . \\@type id . \\x . x)');
            assertEq(String(lsr("parseToAst " + (s('\\x . x')) + " " + delimiterPatStr)), 'lambda(\\x . x)');
            assertEq(String(lsr("scanLine " + (s('id = \\x . x')) + " " + delimiterPatStr + " id id")), "Cons[Token(\"define\", 5) Token(\"\\\"id\\\"\", 5) Token(\"0\", 5) Token(\"\\\"id = \\\\\\\\x . x\\\"\", 5) [Token(\"\\\\@\", 5) Token(\"dataType\", 5) Token(\"id\", 5) Token(\".\", 5) [Token(\"\\\\@\", 5) Token(\"type\", 5) Token(\"id\", 5) Token(\".\", 5) [Token(\"\\\\\", 5) Token(\"x\", 6) Token(\".\", 8) Token(\"x\", 10)]]]]");
            assertEq(String(lsr("parseLine " + (s('id = \\x . x')) + " " + delimiterPatStr + " nil id id")), 'apply(define id 0 id = \\x . x \\@dataType id . \\@type id . \\x . x)');
            return assertEq(String(lsr("parseLine 'id x = x' " + delimiterPatStr + " nil id id")), 'apply(define id 1 id x = x \\x . x)');
          },
          leisureAst26: function() {
            lsrM("id2 = \\x . x");
            lsrComp("id2 = \\x . x");
            return assertEq(lsrComp('id2')(function() {
              return 3;
            }), 3);
          },
          leisureAst27: function() {
            return assertEq(lsrComp('\\x y . + x y')(function() {
              return 3;
            })(function() {
              return 4;
            }), 7);
          },
          leisureAst28: function() {
            compileLine('plus x y = + x y', Nil, id, id);
            return assertEq(compileLine('plus', Nil, (function() {}), id)(function() {
              return 3;
            })(function() {
              return 4;
            }), 7);
          },
          leisureAst29: function() {
            return assertEq(String(lsrParseToAst('\\@ a b . c')), 'anno(\\@a b . c)');
          },
          leisureAst30: function() {
            return assertEq(lsrComp('\\@ a b . 3'), 3);
          },
          leisureAst31: function() {
            return assertEq(lsrComp('(\\@ a b . \\x . x) 4'), 4);
          },
          leisureAst32: function() {
            return assertEq(String(lsrParseToAst('(\\f . f 5) \\x . x')), 'apply((\\f . f 5) \\x . x)');
          },
          leisureAst33: function() {
            return assertEq(lsrComp('(\\f . f 5) \\x . x'), 5);
          },
          leisureAst34: function() {
            return assertEq(lsrComp('(\\f . f 5) \\@ a b . \\x . x'), 5);
          },
          leisureAst35: function() {
            return assertEq(lsrComp('getType \\@ type fred . \\x . x'), 'fred');
          },
          leisureAst36: function() {
            assertEq(lsrComp('v1'), 3);
            assertEq(lsrComp('v2'), 4);
            return assertEq(lsrComp('v3'), 7);
          },
          leisureAst37: function() {
            assertEq(lsrComp('v4'), 5);
            assertEq(lsrComp('v5'), 6);
            return assertEq(lsrComp('v6'), 11);
          },
          leisureAst38: function() {
            assertEq(lsrComp("strToList " + (s('\"'))).toArray(), ['"']);
            assertEq(lsrComp("eq " + (s('1')) + " " + (s('\\\\')) + " 1 2"), 2);
            assertEq(lsrComp("eq " + (s('1')) + " " + (s('\"')) + " 1 2"), 2);
            return assertEq(lsrComp("tokenString (head (tail (tokens " + (s("eq '\\\\' (eq 'b' nil) 1 2")) + " " + delimiterPatStr + ")))"), "'\\\\'");
          },
          leisureAst39: function() {
            return assertEq(String(lsrComp('nil')), 'Cons[]');
          },
          leisureAst40: function() {
            return assertEq(lsrComp(s("true")), 'true');
          },
          leisureAst41: function() {
            return assertEq(lsrComp(s('true')), 'true');
          },
          leisureAst42: function() {
            return assertEq(lsr("getType " + (s('true'))), '*string');
          },
          leisureAst43: function() {
            return assertEq(lsrComp("eq 1 1 3 4"), 3);
          },
          leisureAst44: function() {
            return assertEq(lsrComp("eq 1 2 3 4"), 4);
          },
          leisureAst45: function() {
            return assertEq(lsrComp("eq (getType nil) " + (s('nil')) + " 1 2"), 1);
          },
          leisureAst46: function() {
            return assertEq(lsrComp("eq (getType (cons 1 nil)) " + (s('cons')) + " 1 2"), 1);
          },
          leisureAst47: function() {
            return assertEq(lsrComp("splitTokens " + (s("splitTokens 'a b' " + delimiterPatStr)) + " " + delimiterPatStr).toArray(), ['splitTokens', ' ', "'a b'", ' ', JSON.stringify(LZ.delimiterPat.source)]);
          },
          leisureAst48: function() {
            assertEq(String(lsrComp("splitTokens " + (s("'^[ \\t]*#.*|^[ \\t]*$'")) + " " + delimiterPatStr)), 'Cons[\'^[ \\t]*#.*|^[ \\t]*$\']');
            assertEq(String(lsrParseToAst(s('^[ \t]*#.*|^[ \t]*$'))), 'lit(^[ \t]*#.*|^[ \t]*$)');
            assertEq(gen(lsrParseToAst(s('^[ \t]*#.*|^[ \t]*$'))), '\"^[ \\t]*#.*|^[ \\t]*$\"');
            return assertEq(lsrComp(s('^[ \t]*#.*|^[ \t]*$')), '^[ \t]*#.*|^[ \t]*$');
          },
          leisureAst49: function() {
            var info;

            info = getDelimiterInfo();
            addDelimiter('[');
            addDelimiter(']');
            assertEq(String(lsrComp("splitTokens " + (s('[a]')) + " " + (s(LZ.delimiterPat.source)))), 'Cons[[ a ]]');
            assertEq(String(lsr("parseG " + (s('[a] [b]')) + " " + (s(LZ.delimiterPat.source)) + " (acons '[' ']' parenGroups)")), 'Cons[[Token("[", 0) [Token("a", 1)] Token("]", 2)] [Token("[", 4) [Token("b", 5)] Token("]", 6)]]');
            assertEq(String(lsr("parseG " + (s('(a]')) + " " + (s(LZ.delimiterPat.source)) + " (acons '[' ']' parenGroups)")), 'ParseErr("Mismatched group: (] at 0")');
            setDelimiterInfo(info);
            return assertEq(String(lsrComp("splitTokens " + (s('[a]')) + " " + (s(LZ.delimiterPat.source)))), 'Cons[[a]]');
          },
          leisureAst50: function() {
            var dels, gr, pat;

            dels = getValue('delimiterList');
            pat = getValue('delimiterPat');
            gr = getValue('groups');
            monad(lsr("addTokenGroup '[' ']'"));
            assertEq(String(monad(lsr("parseM 'a'"))), 'Token("a", 0)');
            assertEq(String(monad(lsr("parseM '[a]'"))), 'Cons[Token("[", 0) [Token("a", 1)] Token("]", 2)]');
            setValue('delimiterList', dels);
            setValue('delimiterPat', pat);
            return setValue('groups', gr);
          },
          leisureAst51: function() {
            var oldMacs;

            oldMacs = getValue('macros');
            monad(lsr("defMacro 'double' \\ex . withCons ex ex \\h t . cons h ex"));
            monad(lsr("defMacro 'b' \\ex . token 'b' (position ex)"));
            assertEq(String(monad(lsr("macroParse 'double a'"))), 'Cons[Token("a", 7) Token("a", 7)]');
            assertEq(String(monad(lsr("macroParse 'double a b'"))), 'Cons[Token("a", 7) Token("a", 7) Token("b", 9)]');
            assertEq(String(monad(lsr("macroParse 'b 2'"))), 'Token("b", 2)');
            assertEq(String(monad(lsr("macroParse '(b 2) 3'"))), 'Token("b", 6)');
            assertEq(String(monad(lsr("macroParse 'double (b 2) 3 4'"))), 'Token("b", 7)');
            assertEq(String(monad(lsr("macroParse 'double (double a)'"))), 'Cons[Parens(7, 17, Cons[Token("a", 15) Token("a", 15)]) Parens(7, 17, Cons[Token("a", 15) Token("a", 15)])]');
            return setValue('macros', oldMacs);
          },
          leisureAst52: function() {
            assertEq(String(lsr("postProcessMacro -1 -1 (cons (token 'hello' 15) nil)")), 'Cons[Token("hello", 15)]');
            assertEq(String(lsrComp("postProcessMacro -1 -1 (cons (token 'hello' 15) nil)")), 'Cons[Token("hello", 15)]');
            assertEq(String(lsrM("postProcessMacro -1 -1 (cons (token 'hello' 15) nil)")), 'Cons[Token("hello", 15)]');
            assertEq(String(lsr("postProcessMacro -1 -1 (cons 'hello' (cons (token 'goodbye' 15) nil))")), 'Cons[Token("hello", 15) Token("goodbye", 15)]');
            assertEq(String(lsr("postProcessMacro -1 -1 (cons (token 'hello' 15) (cons 'goodbye' nil))")), 'Cons[Token("hello", 15) Token("goodbye", 21)]');
            return assertEq(String(lsr("postProcessMacro -1 -1 (cons (cons (token 'hello' 15) nil) (cons 'goodbye' nil))")), 'Cons[[Token("hello", 15)] Token("goodbye", 21)]');
          },
          leisureAst53: function() {
            return assertEq(lsrM("true 3 4"), 3);
          },
          leisureAst54: function() {
            return assertEq(lsrM("eq true true 3 4"), 3);
          }
        });
        runTests('Leisure Utils', {
          leisureUtil1: function() {
            assertEq(String(monad(lsr("quicksort < nil"))), 'Cons[]');
            assertEq(String(monad(lsr("quicksort < (cons 1 nil)"))), 'Cons[1]');
            assertEq(String(monad(lsr("quicksort < (cons 1 (cons 2 nil))"))), 'Cons[1 2]');
            assertEq(String(monad(lsr("quicksort < (cons 2 (cons 1 nil))"))), 'Cons[1 2]');
            return assertEq(String(monad(lsr("quicksort < (cons 2 (cons 3 (cons 1 nil)))"))), 'Cons[1 2 3]');
          }
        });
        console.log('\nDone');
        return process.exit(T.totalFailures);
      });
    }
  });

}).call(this);

/*
//@ sourceMappingURL=testLeisure.map
*/
