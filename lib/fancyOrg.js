// Generated by CoffeeScript 1.6.3
(function() {
  var BS, DEL, ENTER, HL_TAGS, Headline, KW_BOILERPLATE, KW_INFO, KW_NAME, Keyword, Meat, Results, Source, TAB, atTextEnd, atTextStart, bindContent, borderRE, boundarySpan, checkCollapsed, checkEnterReparse, checkExtraNewline, checkSourceMod, checkStart, content, contentSpan, crossesHidden, curPos, currentLine, currentTextPosition, defaultEnv, defaultMarkup, displaySource, fancyOrg, followingSpan, handleMutation, headlineRE, isCollapsed, keywordRE, lastSrcOffset, lazy, lz, makeBoundary, markupGuts, markupNode, markupOrg, markupOrgWithNode, matchLine, matchLineAt, optionalBoundary, orgAttrs, orgNotebook, parseOrgMode, parseTags, resolve, root, rz, shouldCancelBS, shouldCancelDEL, shouldDeleteCharacter, srcStartRE, _ref, _ref1, _ref2, _ref3;

  _ref = root = module.exports = require('./base'), resolve = _ref.resolve, lazy = _ref.lazy, defaultEnv = _ref.defaultEnv;

  rz = resolve;

  lz = lazy;

  _ref1 = require('./browserSupport'), TAB = _ref1.TAB, ENTER = _ref1.ENTER, BS = _ref1.BS, DEL = _ref1.DEL;

  _ref2 = require('./org'), keywordRE = _ref2.keywordRE, KW_BOILERPLATE = _ref2.KW_BOILERPLATE, KW_NAME = _ref2.KW_NAME, KW_INFO = _ref2.KW_INFO, srcStartRE = _ref2.srcStartRE, parseOrgMode = _ref2.parseOrgMode, Headline = _ref2.Headline, Meat = _ref2.Meat, Keyword = _ref2.Keyword, Source = _ref2.Source, Results = _ref2.Results, headlineRE = _ref2.headlineRE, HL_TAGS = _ref2.HL_TAGS, parseTags = _ref2.parseTags, matchLine = _ref2.matchLine;

  _ref3 = require('./orgSupport'), orgNotebook = _ref3.orgNotebook, parseOrgMode = _ref3.parseOrgMode, orgAttrs = _ref3.orgAttrs, content = _ref3.content, contentSpan = _ref3.contentSpan, checkStart = _ref3.checkStart, optionalBoundary = _ref3.optionalBoundary, boundarySpan = _ref3.boundarySpan, displaySource = _ref3.displaySource, checkEnterReparse = _ref3.checkEnterReparse, checkCollapsed = _ref3.checkCollapsed, checkExtraNewline = _ref3.checkExtraNewline, followingSpan = _ref3.followingSpan, currentLine = _ref3.currentLine, checkSourceMod = _ref3.checkSourceMod, isCollapsed = _ref3.isCollapsed;

  lastSrcOffset = -1;

  curPos = -1;

  markupOrg = function(text) {
    var node, result, _ref4;
    _ref4 = markupOrgWithNode(text), node = _ref4[0], result = _ref4[1];
    return result;
  };

  markupOrgWithNode = function(text) {
    var nodes, org;
    nodes = {};
    if (text[text.length - 1] !== '\n') {
      text = text + '\n';
    }
    org = parseOrgMode(text);
    lastSrcOffset = -1;
    return [org, markupNode(org)];
  };

  defaultMarkup = function(org) {
    return "<span " + (orgAttrs(org)) + ">" + (content(org.text)) + "</span>";
  };

  borderRE = /[\n]*$/;

  makeBoundary = function(node) {
    var nls;
    nls = node.text.match(borderRE);
    if (nls) {
      return "<span class='boundary'>" + nls[0] + "</span>";
    } else {
      return "";
    }
  };

  markupNode = function(org) {
    var intertext, name, nameM, pos, src, srcContent, srcLead, srcM, srcTrail, text;
    if (org.offset <= lastSrcOffset) {
      return '';
    } else if (org instanceof Results) {
      pos = org.contentPos - org.offset - 1;
      text = org.text.substring(pos);
      return "<span " + (orgAttrs(org)) + "><span data-org-type='text'>" + (org.text.substring(0, pos)) + "</span>" + (contentSpan(text)) + "</span>" + (makeBoundary(org));
    } else if (org instanceof Keyword) {
      if (org.name.match(/name/i)) {
        intertext = '\n';
        name = org;
        src = org.next;
        while (src instanceof Meat && !(src instanceof Source)) {
          intertext += src.text;
          src = src.next;
        }
        if (src instanceof Source) {
          lastSrcOffset = src.offset;
          nameM = name.text.match(keywordRE);
          srcM = src.text.match(srcStartRE);
          srcContent = src.content;
          srcLead = src.text.substring(0, src.contentPos - src.offset);
          srcTrail = content(src.text.substring(src.contentPos - src.offset + src.content.length));
          return "<div class='codeblock'><div class='codename' " + (orgAttrs(src)) + "><span class='hidden'>" + nameM[KW_BOILERPLATE] + "</span>" + name.info + intertext + "</div><div class='hidden'>" + srcLead + "</div><div class='codecontent'>" + srcContent + "</div><span class='hidden'>" + srcTrail + "</span></div>" + (makeBoundary(org));
        } else {
          return defaultMarkup(org);
        }
      } else {
        return defaultMarkup(org);
      }
    } else if (org instanceof Headline) {
      return "<span " + (orgAttrs(org)) + ">" + (contentSpan(org.text, 'text')) + "</span>" + (makeBoundary(org)) + (markupGuts(org, checkStart(start, org.text)));
    } else if (content(org.text).length) {
      return "<span " + (orgAttrs(org)) + ">" + (content(org.text)) + "</span>" + (makeBoundary(org));
    } else {
      return "" + (makeBoundary(org));
    }
  };

  shouldCancelBS = function(parent, r) {
    return atTextStart(r) && crossesHidden(-1);
  };

  atTextStart = function(r) {
    return r.collapsed && r.startContainer.nodeType === 3 && r.startOffset === 0;
  };

  atTextEnd = function(r) {
    return r.collapsed && r.startContainer.nodeType === 3 && ((r.startOffset === r.startContainer.length && 1) || (r.startOffset === r.startContainer.length - 1 && r.startContainer.textContent[r.startOffset] === '\n' && 2));
  };

  shouldCancelDEL = function(parent, r) {
    var atEnd;
    return (atEnd = atTextEnd(r)) && crossesHidden(atEnd + 1);
  };

  shouldDeleteCharacter = function(parent, r) {
    return false;
  };

  matchLineAt = function(parent, pos) {
    var end, start, text;
    text = parent.textContent;
    start = text.substring(0, pos).lastIndexOf('\n');
    end = text.indexOf('\n', start + 1);
    if (end === -1) {
      end = text.length;
    }
    return matchLine(text.substring(start + 1, end));
  };

  markupGuts = function(org, start) {
    var c, p, prev, s;
    if (!org.children.length) {
      return '';
    } else {
      prev = start ? null : org;
      return ((function() {
        var _i, _len, _ref4, _results;
        _ref4 = org.children;
        _results = [];
        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
          c = _ref4[_i];
          s = start;
          start = false;
          p = prev;
          prev = c;
          _results.push(markupNode(c, s));
        }
        return _results;
      })()).join("");
    }
  };

  currentTextPosition = function(parent, r) {
    if (curPos > -1) {
      return curPos;
    } else {
      return curPos = getTextPosition(parent, r || getSelection().getRangeAt(0));
    }
  };

  crossesHidden = function(delta) {
    var n, r, s, _i, _len, _ref4;
    s = rangy.getSelection();
    r = s.getRangeAt(0);
    if (delta < 0) {
      r.moveStart('character', delta);
    } else {
      r.moveEnd('character', delta);
    }
    if (r.startContainer === r.endContainer) {
      return false;
    } else {
      _ref4 = r.getNodes();
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        n = _ref4[_i];
        if (r.containsNode(n) && isCollapsed(n)) {
          return true;
        }
      }
      return false;
    }
  };

  bindContent = function(div) {
    div.addEventListener('keydown', function(e) {
      var br, c, cancelled, currentMatch, el, n, p, par, r, s, t;
      curPos = -1;
      c = e.charCode || e.keyCode || e.which;
      s = getSelection();
      r = s.getRangeAt(0);
      el = r.startContainer;
      par = el.parentNode;
      if (c === ENTER) {
        e.preventDefault();
        cancelled = true;
        n = s.focusNode;
        if (!checkCollapsed(n, 1)) {
          if (n.nodeType === 3 && r.collapsed && r.startOffset === n.length && n.parentNode.getAttribute('data-org-type') === 'text') {
            br = document.createTextNode('\n');
            $(br).prependTo(followingSpan(n.parentNode));
            r.setStart(br, br.length);
            r.setEnd(br, br.length);
          } else {
            r.insertNode(br = document.createTextNode(checkExtraNewline(r, n, div)));
            br.parentNode.normalize();
          }
        }
        r.collapse();
        s.removeAllRanges();
        s.addRange(r);
        return setTimeout((function() {
          return checkEnterReparse(div, r);
        }), 1);
      } else if (c === BS || c === DEL) {
        if ((c === BS && shouldCancelBS(div, r)) || (c === DEL && shouldCancelDEL(div, r))) {
          e.preventDefault();
          return cancelled = true;
        } else if (c === DEL && shouldDeleteCharacter(div, r)) {
          e.preventDefault();
          t = div.textContent;
          p = getTextPosition(r.startContainer, r.startOffset);
          return reparse(div, t.substring(0, p) + t.substring(p + 1));
        } else {
          currentMatch = matchLine(currentLine(div));
          return setTimeout((function() {
            return checkSourceMod(div, currentMatch);
          }), 1);
        }
      } else {
        return cancelled = false;
      }
    });
    div.addEventListener('DOMCharacterDataModified', handleMutation, true);
    return div.addEventListener('DOMSubtreeModified', handleMutation, true);
  };

  handleMutation = function(evt) {
    return displaySource();
  };

  fancyOrg = {
    __proto__: orgNotebook,
    markupOrg: markupOrg,
    markupOrgWithNode: markupOrgWithNode,
    bindContent: bindContent
  };

  root.fancyOrg = fancyOrg;

}).call(this);

/*
//@ sourceMappingURL=fancyOrg.map
*/
