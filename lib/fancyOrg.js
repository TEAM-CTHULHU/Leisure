// Generated by CoffeeScript 1.6.3
(function() {
  var BS, DEL, ENTER, HL_TAGS, Headline, KW_BOILERPLATE, KW_INFO, KW_NAME, Keyword, Meat, Results, Source, TAB, addComment, addKeyPress, astButton, atTextEnd, atTextStart, baseEnv, bindContent, boundarySpan, bsWillDestroyParent, checkCollapsed, checkEnterReparse, checkExtraNewline, checkSourceMod, checkStart, commentBlock, commentButton, commentHtml, content, contentSpan, createResults, crossesHidden, curPos, currentLine, currentTextPosition, defaultBindings, defaultEnv, defaultMarkup, displaySource, escapeAttr, escapeHtml, executeDef, executeSource, executeText, fancyOrg, findKeyBinding, followingSpan, getOrgParent, getOrgType, getResultsForSource, handleMutation, headlineRE, invalidateOrgText, isCollapsed, isHtml, keyFuncs, keywordRE, lastOrgOffset, lazy, lz, markupGuts, markupHeadline, markupHtml, markupLeisure, markupNode, markupOrg, markupOrgWithNode, markupSource, matchLine, matchLineAt, modifiers, modifyingKey, newCommentBox, nextOrgId, optionalBoundary, orgAttrs, orgEnv, orgNotebook, parseOrgMode, parseTags, presentValue, processResults, propsFor, redrawAllIssues, redrawIssue, reprocessResults, resolve, root, rz, setCurKeyBinding, setShadowHtml, shouldCancelBS, shouldCancelDEL, srcStartRE, swapMarkup, toggleComment, _, _ref, _ref1, _ref2, _ref3;

  _ref = root = module.exports = require('./base'), resolve = _ref.resolve, lazy = _ref.lazy, defaultEnv = _ref.defaultEnv;

  rz = resolve;

  lz = lazy;

  _ref1 = require('./browserSupport'), TAB = _ref1.TAB, ENTER = _ref1.ENTER, BS = _ref1.BS, DEL = _ref1.DEL;

  _ref2 = require('./org'), keywordRE = _ref2.keywordRE, KW_BOILERPLATE = _ref2.KW_BOILERPLATE, KW_NAME = _ref2.KW_NAME, KW_INFO = _ref2.KW_INFO, srcStartRE = _ref2.srcStartRE, parseOrgMode = _ref2.parseOrgMode, Headline = _ref2.Headline, Meat = _ref2.Meat, Keyword = _ref2.Keyword, Source = _ref2.Source, Results = _ref2.Results, headlineRE = _ref2.headlineRE, HL_TAGS = _ref2.HL_TAGS, parseTags = _ref2.parseTags, matchLine = _ref2.matchLine;

  _ref3 = require('./orgSupport'), orgNotebook = _ref3.orgNotebook, parseOrgMode = _ref3.parseOrgMode, orgAttrs = _ref3.orgAttrs, content = _ref3.content, contentSpan = _ref3.contentSpan, checkStart = _ref3.checkStart, optionalBoundary = _ref3.optionalBoundary, boundarySpan = _ref3.boundarySpan, displaySource = _ref3.displaySource, checkEnterReparse = _ref3.checkEnterReparse, checkCollapsed = _ref3.checkCollapsed, checkExtraNewline = _ref3.checkExtraNewline, followingSpan = _ref3.followingSpan, currentLine = _ref3.currentLine, checkSourceMod = _ref3.checkSourceMod, isCollapsed = _ref3.isCollapsed, nextOrgId = _ref3.nextOrgId, modifyingKey = _ref3.modifyingKey, getOrgParent = _ref3.getOrgParent, getOrgType = _ref3.getOrgType, orgEnv = _ref3.orgEnv, executeText = _ref3.executeText, getResultsForSource = _ref3.getResultsForSource, swapMarkup = _ref3.swapMarkup, modifiers = _ref3.modifiers, keyFuncs = _ref3.keyFuncs, defaultBindings = _ref3.defaultBindings, addKeyPress = _ref3.addKeyPress, findKeyBinding = _ref3.findKeyBinding, invalidateOrgText = _ref3.invalidateOrgText, setCurKeyBinding = _ref3.setCurKeyBinding, presentValue = _ref3.presentValue, propsFor = _ref3.propsFor, escapeHtml = _ref3.escapeHtml, escapeAttr = _ref3.escapeAttr;

  redrawAllIssues = require('./storage').redrawAllIssues;

  _ = require('./lodash.min');

  lastOrgOffset = -1;

  curPos = -1;

  markupOrg = function(text) {
    var node, result, _ref4;
    _ref4 = markupOrgWithNode(text), node = _ref4[0], result = _ref4[1];
    return result;
  };

  markupOrgWithNode = function(text) {
    var nodes, org;
    nodes = {};
    if (text[text.length - 1] !== '\n') {
      text = text + '\n';
    }
    org = parseOrgMode(text);
    lastOrgOffset = -1;
    return [org, markupNode(org)];
  };

  markupNode = function(org) {
    var intertext, name, pos, src, text;
    if (org.offset <= lastOrgOffset) {
      return '';
    } else if (org instanceof Results) {
      pos = org.contentPos - org.offset;
      text = org.text.substring(pos);
      return "<span " + (orgAttrs(org)) + "><span data-org-type='text'>" + (escapeHtml(org.text.substring(0, pos))) + "</span>" + (contentSpan(text));
    } else if (org instanceof Keyword) {
      if (org.name.match(/^name$/i)) {
        intertext = '';
        name = org;
        src = org.next;
        while (src instanceof Meat && !(src instanceof Source)) {
          intertext += src.text;
          src = src.next;
        }
        if (src instanceof Source) {
          return markupSource(src, name, intertext);
        } else {
          return defaultMarkup(org);
        }
      } else if (org instanceof Source) {
        return markupSource(org);
      } else {
        return defaultMarkup(org);
      }
    } else if (org instanceof Headline) {
      return markupHeadline(org);
    } else if (content(org.text).length) {
      return defaultMarkup(org);
    } else {
      return "<div " + (orgAttrs(org)) + ">" + (escapeHtml(org.text)) + "</div>";
    }
  };

  markupHeadline = function(org) {
    return "<div " + (orgAttrs(org)) + " data-org-headline='" + (escapeAttr(org.level)) + "'><span data-org-type='text'>" + (escapeHtml(org.text)) + "</span>" + (markupGuts(org, checkStart(start, org.text))) + "</div>";
  };

  markupSource = function(org, name, intertext) {
    var lead, srcContent, trail;
    srcContent = org.content;
    lead = org.text.substring(0, org.contentPos - org.offset);
    trail = org.text.substring(org.contentPos - org.offset + org.content.length);
    return (isHtml(org) ? markupHtml : markupLeisure)(org, name, intertext, srcContent, lead, trail);
  };

  isHtml = function(org) {
    return org.info.match(/^ *html($| )/);
  };

  markupHtml = function(org, name, intertext, content, lead, trail) {
    var _ref4;
    return "<span class='hidden'>" + (escapeHtml(((_ref4 = name != null ? name.text : void 0) != null ? _ref4 : '') + (intertext != null ? intertext : '') + org.text)) + "</span><span data-org-html='true'>" + content + "</span>";
  };

  markupLeisure = function(org, name, intertext, content, lead, trail) {
    var codeBlock, html, nameM, pos, res;
    lastOrgOffset = org.offset;
    if (name) {
      nameM = name.text.match(keywordRE);
      codeBlock = " data-org-codeblock='" + (escapeAttr(name.info.trim())) + "'><div class='codename'><span class='hidden'>" + (escapeHtml(nameM[KW_BOILERPLATE])) + "</span><div><larger><b>" + (escapeHtml(name.info)) + "</b></larger></div>" + (escapeHtml(intertext)) + "</div>";
    } else {
      codeBlock = ">";
    }
    html = "<div class='codeblock' " + (orgAttrs(org)) + codeBlock + "<div class='hidden'>" + (escapeHtml(lead)) + "</div><div class='codewrapper'><div class='codecontent'>" + (escapeHtml(content)) + "<span class='hidden' data-org-type='boundary'>" + (escapeHtml(trail)) + "</span></div>";
    res = org.next;
    intertext = '';
    while (res && !(res instanceof Results) && !(res instanceof Keyword)) {
      intertext += res.text;
      res = res.next;
    }
    if (res instanceof Results) {
      lastOrgOffset = res.offset;
      pos = res.contentPos - res.offset;
      html += "" + (intertext ? "<div class='hidden' data-org-type='boundary'>" + escapeHtml(intertext) + "</div>" : '') + "<div class='results-indicator' data-org-type='boundary'><span></span></div><div class='coderesults' " + (orgAttrs(res)) + "><span class='hidden'>" + (escapeHtml(res.text.substring(0, pos))) + "</span><div>" + (reprocessResults(res.text.substring(pos))) + "</div></div>";
    }
    return html + (name ? "</div>" + (commentButton(name.info.trim())) + "</div>" + (commentBlock(name.info.trim())) : "</div></div>");
  };

  commentButton = function(name) {
    return "<button class='comment-button' onclick='Leisure.toggleComment(\"" + (escapeAttr(name)) + "\")' contenteditable='false' data-org-commentcount='0'><img src='icons/monotone_talk_chat_speech.png'><span></span></button>";
  };

  commentBlock = function(name) {
    return "<div class='comments' data-org-comments='" + (escapeAttr(name)) + "'><div></div></div>";
  };

  astButton = function(name) {
    return "<button class='ast-button' onclick='Leisure.toggleAst(\"" + (escapeAttr(name.info.trim())) + "\")' contenteditable='false'><img src='icons/monotone_groups.png'></button>";
  };

  toggleComment = function(name) {
    var block;
    block = $("[data-org-comments=" + name + "]");
    if (block.hasClass('showcomments')) {
      return block.removeClass('showcomments');
    } else {
      block.addClass('showcomments');
      return $("[data-org-codeblock='" + (escapeAttr(name)) + "'] button.comment-button").removeClass('new-comments');
    }
  };

  addComment = function(name) {
    return console.log("ADD A COMMENT FOR " + name);
  };

  defaultMarkup = function(org) {
    return "<span " + (orgAttrs(org)) + ">" + (escapeHtml(org.text)) + "</span>";
  };

  createResults = function(srcNode) {
    var created;
    while (srcNode && !srcNode.classList.contains('codeblock')) {
      srcNode = srcNode.parentNode;
    }
    if (created = srcNode && !$(srcNode).find('.coderesults').length) {
      $(srcNode).find('.codewrapper').append("<div class=\"results-indicator\" data-org-type=\"boundary\"><span></span></div><div class=\"coderesults\" data-org-type=\"results\"><span class=\"hidden\">#+RESULTS:\n</span><div>\n</div></div>");
    }
    return created;
  };

  shouldCancelBS = function(parent, r) {
    return atTextStart(r) && crossesHidden(-1);
  };

  atTextStart = function(r) {
    return r.collapsed && (r.startContainer.nodeType === 1 || (r.startContainer.nodeType === 3 && r.startOffset === 0));
  };

  atTextEnd = function(r) {
    return r.collapsed && (r.startContainer.nodeType === 1 || (r.startContainer.nodeType === 3 && ((r.startOffset === r.startContainer.length && 1) || (r.startOffset === r.startContainer.length - 1 && r.startContainer.textContent[r.startOffset] === '\n' && 2))));
  };

  shouldCancelDEL = function(parent, r) {
    var atEnd;
    return (atEnd = atTextEnd(r)) && crossesHidden(atEnd + 1);
  };

  matchLineAt = function(parent, pos) {
    var end, start, text;
    text = parent.textContent;
    start = text.substring(0, pos).lastIndexOf('\n');
    end = text.indexOf('\n', start + 1);
    if (end === -1) {
      end = text.length;
    }
    return matchLine(text.substring(start + 1, end));
  };

  markupGuts = function(org, start) {
    var c, p, prev, s;
    if (!org.children.length) {
      return '';
    } else {
      prev = start ? null : org;
      return ((function() {
        var _i, _len, _ref4, _results;
        _ref4 = org.children;
        _results = [];
        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
          c = _ref4[_i];
          s = start;
          start = false;
          p = prev;
          prev = c;
          _results.push(markupNode(c, s));
        }
        return _results;
      })()).join("");
    }
  };

  currentTextPosition = function(parent, r) {
    if (curPos > -1) {
      return curPos;
    } else {
      return curPos = getTextPosition(parent, r || getSelection().getRangeAt(0));
    }
  };

  crossesHidden = function(delta) {
    var n, r, s, _i, _len, _ref4;
    s = rangy.getSelection();
    r = s.getRangeAt(0);
    if (delta < 0) {
      r.moveStart('character', delta);
    } else {
      r.moveEnd('character', delta);
    }
    if (r.startContainer === r.endContainer) {
      return false;
    } else {
      _ref4 = r.getNodes();
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        n = _ref4[_i];
        if (r.containsNode(n) && isCollapsed(n)) {
          return true;
        }
      }
      return false;
    }
  };

  bindContent = function(div) {
    div.addEventListener('mousedown', function(e) {
      return setCurKeyBinding(null);
    });
    div.addEventListener('keydown', function(e) {
      var bound, br, c, cancelled, checkMod, currentMatch, el, n, needsReparse, par, r, s, _ref4;
      curPos = -1;
      c = e.charCode || e.keyCode || e.which;
      if (!addKeyPress(e, c)) {
        return;
      }
      s = getSelection();
      r = s.getRangeAt(0);
      _ref4 = findKeyBinding(e, div, r), bound = _ref4[0], checkMod = _ref4[1];
      if (bound) {
        cancelled = !checkMod;
      } else {
        checkMod = modifyingKey(c);
        cancelled = false;
      }
      if (!bound) {
        if (modifyingKey(c)) {
          el = r.startContainer;
          par = el.parentNode;
          n = s.focusNode;
          currentMatch = matchLine(currentLine(div));
          if (c === ENTER) {
            e.preventDefault();
            if (n.nodeType === 3 && r.collapsed && r.startOffset === n.length && n.parentNode.getAttribute('data-org-type') === 'text') {
              br = document.createTextNode('\n');
              $(br).prependTo(followingSpan(n.parentNode));
              r.setStart(br, br.length);
              r.setEnd(br, br.length);
            } else {
              r.insertNode(br = document.createTextNode(checkExtraNewline(r, n, div)));
              br.parentNode.normalize();
            }
            r.collapse();
            s.removeAllRanges();
            s.addRange(r);
            setTimeout((function() {
              return checkEnterReparse(div, r);
            }), 1);
          } else if (c === BS || c === DEL) {
            if ((c === BS && shouldCancelBS(div, r)) || (c === DEL && shouldCancelDEL(div, r))) {
              e.preventDefault();
              return;
            } else if (c === BS && bsWillDestroyParent(r)) {
              e.preventDefault();
              el.data = el.data.substring(1);
            }
          } else if (el.nodeType === 3 && el.data === '\n') {
            setTimeout((function() {
              var sel;
              if (el.data[el.data.length - 1] !== '\n') {
                el.data += '\n';
                sel = getSelection();
                r = sel.getRangeAt(0);
                r.setStart(el, 1);
                r.setEnd(el, 1);
                sel.removeAllRanges();
                sel.addRange(r);
              }
              return checkSourceMod(div, currentMatch);
            }), 1);
            return;
          }
        }
      }
      if (!cancelled && checkMod) {
        if ((getOrgType(getOrgParent(el))) === 'boundary') {
          needsReparse = true;
        }
        return setTimeout((function() {
          return checkSourceMod(div, currentMatch);
        }), 1);
      }
    });
    div.addEventListener('DOMCharacterDataModified', handleMutation, true);
    div.addEventListener('DOMSubtreeModified', handleMutation, true);
    return displaySource();
  };

  bsWillDestroyParent = function(r) {
    var r2;
    if (r.startContainer.nodeType === 3 && r.startOffset === 1 && r.startContainer.data.match(/^.\n?$/)) {
      r2 = rangy.createRangyRange();
      r2.selectNodeContents(r.startContainer.parentNode);
      return r2.text() === r.startContainer.data;
    } else {
      return false;
    }
  };

  handleMutation = function(evt) {
    invalidateOrgText();
    return displaySource();
  };

  executeSource = function(parent, node) {
    var txt, _ref4;
    while (node && !((_ref4 = node.classList) != null ? _ref4.contains('codecontent') : void 0)) {
      node = node.parentNode;
    }
    if (node) {
      createResults(node);
      txt = node.textContent;
      if (txt.trim().length) {
        return executeText(node.textContent, propsFor(node), orgEnv(parent, node));
      }
    }
  };

  executeDef = function(node) {
    while (node && !node.hasAttribute('data-org-results')) {
      node = node.parentNode;
    }
    if (node) {
      return executeText($(node).find('.codecontent')[0].firstChild.textContent, propsFor(node), baseEnv);
    }
  };

  reprocessResults = function(str) {
    return escapeHtml(str).replace(/(^|\n): /g, '$1<span class="hidden">: </span>');
  };

  processResults = function(str) {
    if (str) {
      str = String(str);
      if (str[str.length - 1] === '\n') {
        str = str.substring(0, str.length - 1);
      }
      return "<span class='hidden'>: </span>" + (str.replace(/\n/g, '\n<span class="hidden">: </span>')) + "\n";
    } else {
      return str;
    }
  };

  setShadowHtml = function(holder, html) {
    var el;
    if (!(el = holder.shadowRoot)) {
      el = holder.createShadowRoot();
      el.applyAuthorStyles = true;
    }
    return el.innerHTML = html;
  };

  redrawIssue = function(issue) {
    var button, c, count, issueName, name;
    issueName = issue.title.trim();
    if ((name = $("[data-org-comments='" + issueName + "']")).length) {
      console.log("Showing comment button for " + issueName);
      count = issue.comments.length + 1;
      button = $("[data-org-codeblock='" + issueName + "'] button.comment-button");
      if (button.attr('data-org-commentcount') !== count) {
        button.attr('data-org-commentcount', count);
        button.addClass('new-comments');
      }
      setShadowHtml(button.find('span')[0], count);
      console.log("first gravatar: " + issue.comments[0].gravatar_id);
      return setShadowHtml(name[0].firstChild, "" + (commentHtml(issue, 'main')) + (((function() {
        var _i, _len, _ref4, _results;
        _ref4 = issue.comments;
        _results = [];
        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
          c = _ref4[_i];
          _results.push(commentHtml(c, 'added'));
        }
        return _results;
      })()).join('')) + (newCommentBox(issueName)));
    }
  };

  commentHtml = function(comment, type) {
    return "<div class='commentbox'><img src='http://gravatar.com/avatar/" + comment.user.gravatar_id + "?s=48'><div class='" + type + "'>" + comment.body + "</div></div>";
  };

  newCommentBox = function(name) {
    return "<textarea pseudo='x-new-comment'></textarea><br><button onclick='Leisure.addComment(\"" + name + "\")'>Add Comment</button>";
  };

  orgEnv = function(parent, node) {
    var r;
    r = getResultsForSource(parent, node);
    if (r) {
      r.innerHTML = '';
      return {
        write: function(str) {
          return r.innerHTML += processResults(str);
        },
        presentValue: presentValue,
        __proto__: defaultEnv
      };
    } else {
      return {
        write: function(str) {
          return console.log(": " + (str.replace(/\n/g, '\n: ')) + "\n");
        },
        __proto__: defaultEnv
      };
    }
  };

  baseEnv = {
    write: function(str) {
      return console.log(processResults(str));
    },
    __proto__: defaultEnv
  };

  fancyOrg = {
    __proto__: orgNotebook,
    markupOrg: markupOrg,
    markupOrgWithNode: markupOrgWithNode,
    bindContent: bindContent,
    installOrgDOM: function(parent, orgNode, orgText) {
      var node, _i, _len, _ref4,
        _this = this;
      orgNotebook.installOrgDOM(parent, orgNode, orgText);
      _ref4 = $('[data-org-html]');
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        node = _ref4[_i];
        console.log("HTML SRC: ", node, "TEXT: " + (node.getAttribute('data-org-html')));
        setShadowHtml(node, node.innerHTML);
        node.innerHTML = '';
      }
      return setTimeout((function() {
        var _j, _k, _len1, _len2, _ref5, _ref6;
        _ref5 = $('[data-org-results]');
        for (_j = 0, _len1 = _ref5.length; _j < _len1; _j++) {
          node = _ref5[_j];
          switch ($(node).attr('data-org-results').toLowerCase()) {
            case 'dynamic':
              _this.executeSource(parent, $(node).find('.codecontent')[0].firstChild);
              break;
            case 'def':
              _this.executeDef(node);
          }
        }
        _ref6 = $('[data-org-comments]');
        for (_k = 0, _len2 = _ref6.length; _k < _len2; _k++) {
          node = _ref6[_k];
          setShadowHtml(node.firstElementChild, newCommentBox(node.getAttribute('data-org-comments')));
        }
        return redrawAllIssues();
      }), 1);
    },
    executeSource: executeSource,
    executeDef: executeDef,
    createResults: createResults,
    bindings: defaultBindings,
    redrawIssue: function(i) {
      return redrawIssue(i);
    }
  };

  root.fancyOrg = fancyOrg;

  root.toggleComment = toggleComment;

  root.addComment = addComment;

}).call(this);

/*
//@ sourceMappingURL=fancyOrg.map
*/
