// Generated by CoffeeScript 1.6.3
(function() {
  var BS, DEL, DOCUMENT_POSITION_CONTAINED_BY, Drawer, ENTER, HL_TAGS, HTML, Headline, KW_BOILERPLATE, KW_INFO, KW_NAME, Keyword, Link, ListItem, Meat, PAGEDOWN, PAGEUP, Results, SimpleMarkup, Source, TAB, addComment, addKeyPress, allowEvents, atTextEnd, atTextStart, baseEnv, bindContent, boundarySpan, bsWillDestroyParent, changeResultType, checkCollapsed, checkEnterReparse, checkExtraNewline, checkSourceMod, checkStart, checkTestResults, childIndex, clearResults, codeBlockForNode, colonify, commentBlock, commentButton, commentHtml, content, contentSpan, createComment, createResults, createTestCase, crossesHidden, curPos, currentLine, currentTextPosition, defaultBindings, defaultEnv, defaultMarkup, define, displaySource, documentTop, drawerRE, eatListItem, emptyPresenter, escapeAttr, escapeHtml, escapePresentationHtml, executeCode, executeDef, executeSource, executeText, fancyCheckSourceMod, fancyExecuteDef, fancyOrg, findDomPosition, findKeyBinding, followingSpan, getCodeContainer, getDocumentOffset, getNodeSource, getOrgParent, getOrgType, getResultsForSource, getTextPosition, getType, handleKey, handleMutation, headlineRE, hideSlider, hideSlides, hlStars, htmlForResults, imagePath, invalidateOrgText, isCollapsed, isDef, isMonad, isOrContains, keyFuncs, keywordRE, lastOrgOffset, lazy, linePat, lz, makeSyncMonad, markupGuts, markupHeadline, markupHtml, markupLink, markupListContents, markupListItem, markupNewNode, markupNode, markupOrg, markupOrgWithNode, markupSimple, markupSource, matchLine, matchLineAt, modifiers, modifyingKey, nativeRange, needsNewline, newCodeContent, newCommentBox, nextOrgId, nextSlide, nonl, oldRestorePosition, optionalBoundary, orgAttrs, orgEnv, orgNotebook, orgSrcAttrs, parseOrgMode, parseTags, presentValue, presenter, prevSlide, processResults, propsFor, psgn, recreateAstButtons, redrawAllIssues, redrawIssue, replaceCodeBlock, replacePresenter, replaceRelatedPresenter, replaceUnrelatedPresenter, reprocessResults, resolve, restorePosition, restoreSlide, resultsRE, resultsType, root, runAutotests, runMonad, runTest, rz, selectPrevious, setCurKeyBinding, setCurrentSlide, setMinMax, setShadowHtml, setSlideAt, setTheme, shouldCancelBS, shouldCancelDEL, show, showAst, showSliderButton, showSlides, slideBindings, slideMode, slideOffset, slideParent, splitLines, srcStartRE, swapMarkup, testResult, textNodeAfter, textNodeBefore, theme, toTestCaseButton, toggleComment, toggleDynamic, toggleSlides, topNode, unescapePresentationHtml, unwrap, updateChannels, _, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;

  _ref = root = module.exports = require('./base'), resolve = _ref.resolve, lazy = _ref.lazy, defaultEnv = _ref.defaultEnv;

  rz = resolve;

  lz = lazy;

  _ref1 = require('./browserSupport'), TAB = _ref1.TAB, ENTER = _ref1.ENTER, BS = _ref1.BS, DEL = _ref1.DEL;

  _ref2 = require('./ast'), getType = _ref2.getType, define = _ref2.define, makeSyncMonad = _ref2.makeSyncMonad;

  _ref3 = require('./runtime'), runMonad = _ref3.runMonad, isMonad = _ref3.isMonad, escapePresentationHtml = _ref3.escapePresentationHtml, unescapePresentationHtml = _ref3.unescapePresentationHtml;

  _ref4 = require('./org'), parseOrgMode = _ref4.parseOrgMode, Headline = _ref4.Headline, headlineRE = _ref4.headlineRE, HL_TAGS = _ref4.HL_TAGS, Meat = _ref4.Meat, Keyword = _ref4.Keyword, keywordRE = _ref4.keywordRE, KW_BOILERPLATE = _ref4.KW_BOILERPLATE, KW_NAME = _ref4.KW_NAME, KW_INFO = _ref4.KW_INFO, Source = _ref4.Source, srcStartRE = _ref4.srcStartRE, HTML = _ref4.HTML, Results = _ref4.Results, resultsRE = _ref4.resultsRE, ListItem = _ref4.ListItem, SimpleMarkup = _ref4.SimpleMarkup, Link = _ref4.Link, Drawer = _ref4.Drawer, drawerRE = _ref4.drawerRE, parseTags = _ref4.parseTags, matchLine = _ref4.matchLine;

  _ref5 = require('./orgSupport'), orgNotebook = _ref5.orgNotebook, parseOrgMode = _ref5.parseOrgMode, orgAttrs = _ref5.orgAttrs, content = _ref5.content, contentSpan = _ref5.contentSpan, checkStart = _ref5.checkStart, optionalBoundary = _ref5.optionalBoundary, boundarySpan = _ref5.boundarySpan, displaySource = _ref5.displaySource, checkEnterReparse = _ref5.checkEnterReparse, checkCollapsed = _ref5.checkCollapsed, checkExtraNewline = _ref5.checkExtraNewline, followingSpan = _ref5.followingSpan, currentLine = _ref5.currentLine, checkSourceMod = _ref5.checkSourceMod, isCollapsed = _ref5.isCollapsed, nextOrgId = _ref5.nextOrgId, modifyingKey = _ref5.modifyingKey, getOrgParent = _ref5.getOrgParent, getOrgType = _ref5.getOrgType, executeText = _ref5.executeText, executeDef = _ref5.executeDef, getResultsForSource = _ref5.getResultsForSource, swapMarkup = _ref5.swapMarkup, modifiers = _ref5.modifiers, keyFuncs = _ref5.keyFuncs, defaultBindings = _ref5.defaultBindings, addKeyPress = _ref5.addKeyPress, findKeyBinding = _ref5.findKeyBinding, invalidateOrgText = _ref5.invalidateOrgText, setCurKeyBinding = _ref5.setCurKeyBinding, presentValue = _ref5.presentValue, propsFor = _ref5.propsFor, escapeHtml = _ref5.escapeHtml, escapeAttr = _ref5.escapeAttr, restorePosition = _ref5.restorePosition, splitLines = _ref5.splitLines, orgSrcAttrs = _ref5.orgSrcAttrs, baseEnv = _ref5.baseEnv, getNodeSource = _ref5.getNodeSource, resultsType = _ref5.resultsType, isDef = _ref5.isDef, getTextPosition = _ref5.getTextPosition, findDomPosition = _ref5.findDomPosition, nativeRange = _ref5.nativeRange, textNodeAfter = _ref5.textNodeAfter, textNodeBefore = _ref5.textNodeBefore, PAGEUP = _ref5.PAGEUP, PAGEDOWN = _ref5.PAGEDOWN;

  _ref6 = require('./storage'), redrawAllIssues = _ref6.redrawAllIssues, createComment = _ref6.createComment;

  _ = require('./lodash.min');

  oldRestorePosition = restorePosition;

  fancyOrg = null;

  slideMode = false;

  lastOrgOffset = -1;

  curPos = -1;

  emptyPresenter = {
    hide: function() {},
    isRelated: function() {
      return false;
    }
  };

  presenter = emptyPresenter;

  DOCUMENT_POSITION_CONTAINED_BY = 16;

  root.restorePosition = restorePosition = function(parent, delta, block) {
    var c, container, doc, docPos, end, endContainer, endOffset, newSlide, offset, r, sel, slide, slideIndex, sta, start, _ref7, _ref8;
    if (!block) {
      block = delta;
      delta = 0;
    }
    sel = getSelection();
    slide = slideParent(sel.focusNode);
    slideIndex = slideOffset(slide);
    if ((sel != null ? sel.rangeCount : void 0) && slideIndex > -1) {
      doc = topNode(slide).parentNode;
      parent = doc.parentNode;
      docPos = childIndex(parent, doc);
      r = sel.getRangeAt(0);
      start = delta + getTextPosition(doc, r.startContainer, r.startOffset);
      if (start > -1) {
        end = delta + getTextPosition(doc, r.endContainer, r.endOffset);
        _ref7 = findDomPosition(doc, start), container = _ref7[0], sta = _ref7[1];
        if ((isCollapsed(container)) && sta === 0) {
          container = textNodeBefore(container);
        }
        offset = getDocumentOffset(nativeRange([container, sta])) - window.pageYOffset;
      }
      block();
      if (doc = parent.children[docPos]) {
        newSlide = $('[data-org-headline="1"]')[slideIndex];
        if (slideMode) {
          setCurrentSlide(newSlide);
        }
        if (start > -1 && (r = nativeRange(findDomPosition(doc, start)))) {
          if (isCollapsed(r.startContainer)) {
            c = r.startContainer;
            while (isCollapsed(c)) {
              c = textNodeBefore(c);
            }
            r.setStart(c, 0);
            r.collapse(true);
          } else {
            _ref8 = findDomPosition(doc, end), endContainer = _ref8[0], endOffset = _ref8[1];
            if (endOffset === 0) {
              endContainer = textNodeBefore(endContainer);
              endOffset = endContainer.data.length;
            }
            r.setEnd(endContainer, endOffset);
          }
          sel.removeAllRanges();
          sel.addRange(r);
          window.scrollTo(window.pageXOffset, getDocumentOffset(r) - offset);
        }
      }
      return;
    }
    return block();
  };

  getDocumentOffset = function(r) {
    var c, _ref7;
    c = (r.startOffset === 0 ? (_ref7 = textNodeBefore(r.startContainer)) != null ? _ref7 : r.startContainer : r.startContainer);
    while (isCollapsed(c)) {
      c = textNodeBefore(c);
    }
    return documentTop(c);
  };

  childIndex = function(parent, child) {
    var i, _i, _ref7;
    for (i = _i = 0, _ref7 = parent.children.length; 0 <= _ref7 ? _i < _ref7 : _i > _ref7; i = 0 <= _ref7 ? ++_i : --_i) {
      if (parent.children[i] === child) {
        return i;
      }
    }
    return -1;
  };

  topNode = function(node) {
    var top;
    top = node;
    while (node) {
      if (typeof node.hasAttribute === "function" ? node.hasAttribute('data-org-headline') : void 0) {
        top = node;
      }
      node = node.parentNode;
    }
    return top;
  };

  replaceUnrelatedPresenter = function(target, newPres) {
    var result;
    if (result = !presenter || !presenter.isRelated(target)) {
      replacePresenter(newPres);
    }
    return result;
  };

  replaceRelatedPresenter = function(target, newPres) {
    var result;
    if (result = presenter && presenter.isRelated(target)) {
      replacePresenter(newPres);
    }
    return result;
  };

  replacePresenter = function(pres) {
    if (presenter != null) {
      presenter.hide();
    }
    return presenter = pres;
  };

  markupOrg = function(text) {
    var node, result, _ref7;
    _ref7 = markupOrgWithNode(text), node = _ref7[0], result = _ref7[1];
    return result;
  };

  markupOrgWithNode = function(text) {
    var nodes, org;
    nodes = {};
    if (text[text.length - 1] !== '\n') {
      text = text + '\n';
    }
    org = parseOrgMode(text);
    return [org, markupNewNode(org)];
  };

  markupNewNode = function(org, middleOfLine, delay) {
    lastOrgOffset = -1;
    return markupNode(org, middleOfLine, delay);
  };

  markupNode = function(org, middleOfLine, delay) {
    var intertext, name, pos, src, tag, text;
    if (org.offset <= lastOrgOffset) {
      return '';
    } else if (org instanceof Results) {
      pos = org.contentPos;
      text = org.text.substring(pos);
      return "<span " + (orgAttrs(org)) + "><span data-org-type='text'>" + (escapeHtml(org.text.substring(0, pos))) + "</span>" + (contentSpan(text));
    } else if (org instanceof HTML) {
      return markupHtml(org);
    } else if (org instanceof Keyword) {
      if (org.name.match(/^name$/i)) {
        intertext = '';
        name = org;
        src = org.next;
        while (src instanceof Meat && !(src instanceof Source)) {
          intertext += src.text;
          src = src.next;
        }
        if (src instanceof Source) {
          return markupSource(src, name, intertext, delay);
        } else {
          return defaultMarkup(org);
        }
      } else if (org instanceof Source) {
        return markupSource(org, null, null, delay);
      } else {
        return defaultMarkup(org);
      }
    } else if (org instanceof Headline) {
      return markupHeadline(org, delay);
    } else if (org instanceof ListItem) {
      return markupListItem(org, delay);
    } else if (org instanceof SimpleMarkup) {
      return markupSimple(org);
    } else if (org instanceof Link) {
      return markupLink(org);
    } else if (content(org.text).length) {
      return defaultMarkup(org);
    } else {
      tag = (middleOfLine ? 'span' : 'div');
      return "<" + tag + " " + (orgAttrs(org)) + ">" + (escapeHtml(org.text)) + "</" + tag + ">";
    }
  };

  imagePath = /\.(png|jpg|gif|svg|tiff|bmp)$/i;

  markupLink = function(org) {
    var c, guts, _i, _len, _ref7;
    if (!org.children.length && org.path.match(imagePath)) {
      return "<span class='hidden'>" + org.text + "</span><img src='" + org.path + "'>";
    } else {
      guts = '';
      _ref7 = org.children;
      for (_i = 0, _len = _ref7.length; _i < _len; _i++) {
        c = _ref7[_i];
        guts += markupNode(c, true);
      }
      if (!guts) {
        return "<span class='hidden'>[[</span><a onclick='Leisure.followLink(event)' href='" + org.path + "'>" + org.path + "</a><span class='hidden'>]]</span>";
      } else {
        return "<span class='hidden'>[[" + org.path + "][</span><a onclick='Leisure.followLink(event)' href='" + org.path + "'>" + guts + "</a><span class='hidden'>]]</span>";
      }
    }
  };

  root.followLink = function(e) {
    var t;
    t = e.target;
    while (t && t.nodeName !== 'A') {
      t = t.parentNode;
    }
    if (t) {
      return document.location = t.href;
    }
  };

  markupSimple = function(org) {
    var c, guts, text, _i, _len, _ref7;
    guts = '';
    _ref7 = org.children;
    for (_i = 0, _len = _ref7.length; _i < _len; _i++) {
      c = _ref7[_i];
      guts += markupNode(c, true);
    }
    text = (function() {
      switch (org.markupType) {
        case 'bold':
          return "<b>" + guts + "</b>";
        case 'italic':
          return "<i>" + guts + "</i>";
        case 'underline':
          return "<span style='text-decoration: underline'>" + guts + "</span>";
        case 'strikethrough':
          return "<span style='text-decoration: line-through'>" + guts + "</span>";
        case 'code':
          return "<code>" + guts + "</code>";
        case 'verbatim':
          return "<code>" + guts + "</code>";
      }
    })();
    return "<span class='hidden'>" + org.text[0] + "</span>" + text + "<span class='hidden'>" + org.text[0] + "</span>";
  };

  hlStars = /^\*+ */;

  markupHeadline = function(org, delay) {
    var last, match, stars, starsM, start, tags, _ref7;
    match = org.text.match(headlineRE);
    start = ("" + (org.text.substring(0, org.text.length - ((_ref7 = match != null ? match[HL_TAGS] : void 0) != null ? _ref7 : '').length - 1))).trim();
    if (org.text[org.text.length - 1] === '\n') {
      tags = escapeHtml(org.text.substring(start.length, org.text.length));
      last = '';
    } else {
      tags = escapeHtml(org.text.substring(start.length));
      last = '';
    }
    if (starsM = start.match(hlStars)) {
      stars = start.substring(0, starsM[0].length);
      start = start.substring(stars.length);
    } else {
      stars = '';
    }
    if (org.text.trim() !== '') {
      return "<div " + (orgAttrs(org)) + "><span class='hidden'>" + stars + "</span><span data-org-type='text'><div data-org-type='text-content'><div class='textcontent'>" + (escapeHtml(start)) + "</div><div class='textborder'></div></div><span class='tags'>" + tags + "</span>" + last + "</span>" + (markupGuts(org, checkStart(start, org.text))) + "</div>";
    } else {
      return "<div " + (orgAttrs(org)) + "><span data-org-type='text'><span data-org-type='text-content'><span class='hidden'>" + org.text + "</span>" + last + "</span></span>" + (markupGuts(org, checkStart(start, org.text))) + "</div>";
    }
  };

  markupHtml = function(org) {
    return "<div " + (orgAttrs(org)) + "><span data-org-html='true'>" + ($('<div>' + org.content() + '</div>').html()) + "</span><span class='hidden'>" + (escapeHtml(org.text)) + "</span></div>";
  };

  markupSource = function(org, name, doctext, delay) {
    var channels, codeBlock, codeName, contHtml, expected, finalIntertext, fluff, intertext, lead, nameM, node, resText, result, srcContent, startHtml, testAttr, testCase, testCaseButton, testValue, top, trail, wrapper, _ref7;
    top = name != null ? name : org;
    srcContent = org.content;
    lead = org.text.substring(0, org.contentPos - org.offset);
    trail = org.text.substring(org.contentPos - org.offset + org.content.length);
    lastOrgOffset = org.offset;
    if (name) {
      codeBlock = " data-org-codeblock='" + (escapeAttr(name.info.trim())) + "'>";
    } else {
      codeBlock = ">";
    }
    codeBlock += "<div class='codeborder'></div>";
    startHtml = "<div ";
    contHtml = "class='codeblock' contenteditable='false' " + (orgAttrs(org)) + codeBlock;
    if (channels = updateChannels(org)) {
      contHtml = "data-org-update='" + channels + "' " + contHtml;
    }
    node = org.next;
    intertext = '';
    finalIntertext = '';
    resText = '';
    while (node) {
      if (node instanceof Results) {
        lastOrgOffset = node.offset;
        resText = node.text.substring(node.contentPos);
        finalIntertext = intertext;
        break;
      } else if (node instanceof Drawer) {
        if (node.name().toLowerCase() === 'expected') {
          expected = node;
          lastOrgOffset = node.offset;
          finalIntertext = intertext += escapeHtml(node.text);
        } else {
          break;
        }
      } else if (node instanceof Headline || node instanceof Keyword) {
        break;
      } else {
        intertext += escapeHtml(node.text);
      }
      node = node.next;
    }
    if (name) {
      nameM = name.text.match(keywordRE);
      codeName = "<div class='codename' contenteditable='true'><span class='hidden'>" + (escapeHtml(nameM[KW_BOILERPLATE])) + "</span><div><larger><b>" + (escapeHtml(name.info)) + "</b></larger></div>" + (escapeHtml(doctext)) + "</div>";
    } else {
      codeName = "<div class='codename' contenteditable='true'></div>";
    }
    wrapper = "<table class='codewrapper'><tr>";
    wrapper += "<td class='code-buttons'><ul>";
    if (testCaseButton = toTestCaseButton(org)) {
      wrapper += "<li>" + testCaseButton;
    }
    if (testCaseButton) {
      wrapper += "<li><button class='results-indicator' onclick='Leisure.executeCode(event)' data-org-type='boundary'><i class='fa fa-search'></i><div></div></button>";
      wrapper += "<li><button class='dyntoggle-button' onclick='Leisure.toggleDynamic(event)'><span class='dyntoggle'></span></button>";
    }
    if (name) {
      wrapper += "<li>" + (commentButton(name.info.trim()));
    }
    wrapper += "</ul></td><td class='code-content'>";
    wrapper += codeName;
    wrapper += "<div class='hidden'>" + (escapeHtml(lead)) + "</div>";
    wrapper += "<div " + (orgSrcAttrs(org)) + " contenteditable='true'>" + (escapeHtml(srcContent)) + "</div><span class='hidden' data-org-type='boundary'>" + (escapeHtml(trail)) + "</span>";
    wrapper += ("<span class='hidden'>" + finalIntertext + "</span>") + htmlForResults(resText);
    wrapper += "</td></tr></table>";
    testCase = ((_ref7 = resultsType(org)) === 'test' || _ref7 === 'autotest') && expected;
    result = contHtml + wrapper + (name ? "</div>" + (commentBlock(name.info.trim())) : "</div>");
    if (testCase) {
      testValue = testResult(expected.content(), resText);
      testAttr = "data-org-test='" + testValue + "'";
      if (delay) {
        setTimeout((function() {
          return $("#" + (escapeAttr(org.nodeId))).attr('data-org-test', testValue);
        }), 1);
      }
      return startHtml + ("onclick='Leisure.toggleTestCase(event)' " + (!delay ? testAttr : '') + " title='<div class=" + (escapeAttr("'expected-hover'")) + "><b>Expected:</b> " + (escapeAttr(expected.content())) + "</div>' data-org-expected='" + (escapeAttr(expected.content())) + "' " + result);
    } else {
      fluff = top.prev instanceof Source || top.prev instanceof Results ? "<div class='fluff' data-newline></div>" : '';
      return '<div>' + fluff + startHtml + result + '</div>';
    }
  };

  updateChannels = function(org) {
    var _ref7;
    return org instanceof Source && ((_ref7 = org.info.match(/:update *([^:]*)/)) != null ? _ref7[1] : void 0);
  };

  testResult = function(expected, actual) {
    if (actual === '') {
      return 'unknown';
    } else if (expected === actual) {
      return 'pass';
    } else {
      return 'fail';
    }
  };

  root.toggleTestCase = function(evt) {
    var node;
    node = codeBlockForNode(evt.target);
    selectPrevious(node);
    if (node) {
      return replaceCodeBlock(node, changeResultType(node.textContent, (node.getAttribute('data-org-results') === 'autotest' ? 'dynamic' : 'static')));
    }
  };

  selectPrevious = function(node) {
    var pos, r, sel, top;
    top = topNode(node);
    pos = getTextPosition(top, node, 0);
    r = nativeRange(findDomPosition(top, Math.max(0, pos - 1)));
    sel = getSelection();
    sel.removeAllRanges();
    return sel.addRange(r);
  };

  replaceCodeBlock = function(node, text) {
    var newNode;
    newNode = null;
    restorePosition(null, function() {
      var n, _i, _j, _len, _len1, _ref7, _ref8,
        _this = this;
      newNode = $(markupNewNode(parseOrgMode(text).children[0], false, true))[0];
      $(node).replaceWith(newNode);
      _ref7 = $(newNode).find('[data-org-src]');
      for (_i = 0, _len = _ref7.length; _i < _len; _i++) {
        n = _ref7[_i];
        recreateAstButtons(parent, n);
      }
      _ref8 = $(newNode).find('.resultscontent');
      for (_j = 0, _len1 = _ref8.length; _j < _len1; _j++) {
        n = _ref8[_j];
        reprocessResults(n);
      }
      return setTimeout((function() {
        var _k, _len2, _ref9;
        _ref9 = $(newNode).find('[data-org-comments]');
        for (_k = 0, _len2 = _ref9.length; _k < _len2; _k++) {
          n = _ref9[_k];
          setShadowHtml(n.firstElementChild, ("<div class='" + (typeof theme !== "undefined" && theme !== null ? theme : '') + "'>") + newCommentBox(n.getAttribute('data-org-comments') + '</div>', codeBlockForNode(n.previousElementSibling).id));
        }
        return redrawAllIssues();
      }), 1);
    });
    return newNode;
  };

  markupListItem = function(org, delay) {
    var end, next, parent, start;
    if (org.level === 0) {
      start = !org.getPreviousListItem();
      end = !org.getNextListItem();
    } else {
      start = (parent = org.getParent()) && parent === org.getPreviousListItem();
      next = org.getNextListItem();
      end = !next || next.level < org.level;
    }
    return "" + (start ? '<ul>' : '') + "<li " + (orgAttrs(org)) + " data-org-listlevel='" + org.level + "'" + (org.checked != null ? ' data-org-checked="' + org.checked + '"' : '') + "><span class='hidden'>" + (escapeHtml(org.text.substring(0, org.contentOffset))) + "</span><span>" + (markupListContents(org.children)) + "</span></li>" + (eatListItem(org)) + (end ? '</ul>' : '');
  };

  markupListContents = function(children) {
    var child;
    return ((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = children.length; _i < _len; _i++) {
        child = children[_i];
        _results.push(markupNode(child, true));
      }
      return _results;
    })()).join('');
  };

  eatListItem = function(org) {
    var item, result;
    if (org.next instanceof Meat && org.next.text[0] === '\n') {
      return '';
    } else {
      item = org;
      result = '';
      while (((org = org.next) instanceof Meat) && !(org instanceof ListItem)) {
        result += markupNode(org);
        lastOrgOffset = Math.max(lastOrgOffset, org.offset);
      }
      return result;
    }
  };

  unwrap = function(node) {
    var parent;
    parent = node.parentNode;
    if (parent) {
      while (node.firstChild != null) {
        parent.insertBefore(node.firstChild, node);
      }
      return parent.removeChild(node);
    }
  };

  recreateAstButtons = function(parent, node) {
    return restorePosition(parent, function() {
      var button, chunk, cur, curStart, div, mchunk, mid, mnum, num, numStart, numberSpan, rest, t, _i, _j, _len, _len1, _ref7, _ref8, _results;
      _ref7 = $(node).find('.ast-button');
      for (_i = 0, _len = _ref7.length; _i < _len; _i++) {
        button = _ref7[_i];
        button.remove();
      }
      _ref8 = $(node).find('.org-num');
      for (_j = 0, _len1 = _ref8.length; _j < _len1; _j++) {
        num = _ref8[_j];
        unwrap(num);
      }
      t = node.textContent;
      if (t && t[t.length - 1] !== '\n') {
        node.textContent = t += '\n';
      }
      chunk = /^[^ \n].*$/mg;
      num = /(^|[^0-9.]+)([0-9][0-9.]*|\.[0-9.]+)/mg;
      node.normalize();
      rest = t;
      mchunk = chunk.exec(t);
      mnum = num.exec(t);
      cur = node.firstChild;
      curStart = 0;
      _results = [];
      while (cur && (mchunk || mnum)) {
        if (mchunk && (!mnum || mchunk.index <= mnum.index + mnum[1].length)) {
          cur = (mchunk.index > curStart ? cur.splitText(mchunk.index - curStart) : cur);
          curStart = mchunk.index;
          div = document.createElement('div');
          div.setAttribute('class', 'ast-button');
          div.setAttribute('contenteditable', 'false');
          (function(d, offset) {
            return div.onmousedown = function(e) {
              return showAst(e, d, offset);
            };
          })(div, mchunk.index);
          if (curStart === 0) {
            div.setAttribute('style', 'top: 0');
          }
          node.insertBefore(div, cur);
          mchunk = chunk.exec(t);
          continue;
        }
        if (mnum && (!mchunk || mnum.index + mnum[1].length <= mchunk.index)) {
          numStart = mnum.index + mnum[1].length;
          mid = (numStart > curStart ? cur.splitText(numStart - curStart) : cur);
          cur = mid.splitText(mnum[2].length);
          curStart = mnum.index + mnum[0].length;
          numberSpan = document.createElement('span');
          numberSpan.appendChild(mid);
          numberSpan.classList.add('org-num');
          node.insertBefore(numberSpan, cur);
          node.normalize();
          (function(n) {
            return n.onmousedown = function(e) {
              e.stopPropagation();
              e.preventDefault();
              return showSliderButton(node, n);
            };
          })(numberSpan);
          _results.push(mnum = num.exec(t));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    });
  };

  newCodeContent = function(name, content) {
    var node, parent;
    parent = $("[data-org-codeblock='" + name + "']");
    if (node = parent.find('[data-org-src]')[0]) {
      node.innerHTML = escapeHtml(content);
      return recreateAstButtons(parent, node);
    }
  };

  define('newCodeContent', lz(function(name) {
    return $F(arguments, function(content) {
      return makeSyncMonad(function(env, cont) {
        newCodeContent(rz(name), rz(content));
        return cont(rz(L_true));
      });
    });
  }));

  isOrContains = function(parent, node) {
    var n;
    return (n = parent.compareDocumentPosition(node) & DOCUMENT_POSITION_CONTAINED_BY) || n === 0;
  };

  linePat = /\r?\n(?=[^ ]|$)/;

  showAst = function(evt, astButton, offset) {
    var m, result, text;
    evt.preventDefault();
    evt.stopPropagation();
    if (!replaceRelatedPresenter(presenter.button, emptyPresenter)) {
      if (!astButton.firstChild) {
        astButton.innerHTML = "<div></div>";
      }
      text = astButton.parentNode.textContent.substring(offset);
      text = text.substring(0, ((m = text.match(linePat)) ? m.index : text.length));
      result = rz(L_newParseLine)(lz(0))(L_nil)(lz(text));
      return runMonad(result, baseEnv, function(ast) {
        var err;
        if (getType(ast) !== 'parseErr') {
          console.log("SIMPLIFIED: " + (show(lz(runMonad(rz(L_simplify)(lz(text)))))));
          try {
            setShadowHtml(astButton.firstChild, "<div class='" + (typeof theme !== "undefined" && theme !== null ? theme : '') + " ast'>" + (rz(L_wrappedTreeFor)(lz(ast))(L_id)) + "</div>");
            return replacePresenter({
              hide: function() {
                return astButton.firstChild.remove();
              },
              isRelated: function(node) {
                return isOrContains(astButton, node);
              },
              button: astButton
            });
          } catch (_error) {
            err = _error;
            return console.log("Error showing AST: " + err.stack);
          }
        }
      });
    }
  };

  show = function(obj) {
    return rz(L_show)(lz(obj));
  };

  commentButton = function(name) {
    return "<button class='comment-button' onclick='Leisure.toggleComment(\"" + (escapeAttr(name)) + "\", event)' contenteditable='false' data-org-commentcount='0'><i class='fa fa-comment'></i><span></span><div></div></button>";
  };

  toTestCaseButton = function(org) {
    if (isDef(org)) {
      return '';
    } else {
      return "<button class='testcase-button' onclick='Leisure.createTestCase(event)' contenteditable='false' data-org-commentcount='0'><i class='fa fa-mail-reply'></i><div></div><span></span></button>";
    }
  };

  codeBlockForNode = function(node) {
    node = $(node).closest('[data-org-type="source"]');
    if (node.is('[data-org-test]')) {
      return node[0];
    } else {
      return node[0].parentNode;
    }
  };

  createTestCase = function(evt) {
    var drawer, end, match, newExpectation, node, pre, rest, results, resultsText, src, start, text;
    console.log(evt.target);
    node = codeBlockForNode(evt.target);
    selectPrevious(node);
    text = node.textContent;
    rest = text;
    while (match = rest.match(drawerRE)) {
      if (match[0].trim().toLowerCase() === ':expected:') {
        drawer = parseOrgMode(rest.substring(match.index), text.length - rest.length + match.index).children[0];
        break;
      }
      rest = rest.substring(match.index + match[0].length);
    }
    resultsText = (drawer ? text.substring(drawer.offset + drawer.text.length) : text);
    if (match = resultsRE.exec(resultsText)) {
      results = parseOrgMode(resultsText.substring(match.index), text.length - resultsText.length + match.index).children[0];
      if (results.text.substring(results.contentPos)) {
        newExpectation = ":EXPECTED:\n" + (results.text.substring(results.contentPos)) + ":END:\n";
        start = (drawer ? drawer : results).offset;
        end = (drawer ? drawer.offset + drawer.text.length : results.offset);
        src = parseOrgMode(text).children[0];
        pre = changeResultType(text.substring(0, start), (resultsType(src) === 'dynamic' ? 'autotest' : 'test'));
        return replaceCodeBlock(node, pre + newExpectation + text.substring(end));
      }
    }
    return alert('You have to have results in order to make a test case');
  };

  changeResultType = function(text, newType) {
    var end, m, pos, src, start;
    src = parseOrgMode(text).children[0];
    while (src && !(src instanceof Source)) {
      src = src.next;
    }
    if (src) {
      if (m = src.text.match(/(:results *)([\w]*)/i)) {
        start = src.offset + m.index + m[1].length;
        end = start + m[2].length;
        return text.substring(0, start) + newType + text.substring(end);
      } else {
        pos = src.offset + src.contentPos - 1;
        return text.substring(0, pos) + (" :results " + newType) + text.substring(pos);
      }
    } else {
      return text;
    }
  };

  commentBlock = function(name) {
    return "<div class='comments' data-org-comments='" + (escapeAttr(name)) + "'><div></div></div>";
  };

  toggleComment = function(name, evt) {
    var block, button;
    button = $(evt.target).closest('button')[0];
    block = $("[data-org-comments=" + name + "]");
    if (block.hasClass('showcomments')) {
      if (!replaceRelatedPresenter(button, null)) {
        return block.removeClass('showcomments');
      }
    } else {
      block.addClass('showcomments');
      $("[data-org-codeblock='" + (escapeAttr(name)) + "'] button.comment-button").removeClass('new-comments');
      return replacePresenter({
        hide: function() {
          return block.removeClass('showcomments');
        },
        isRelated: function(target) {
          return button === $(target).closest('button')[0] || $(target).closest("[data-org-comments]").is(block);
        }
      });
    }
  };

  addComment = function(name, event) {
    var box;
    box = $(event.target.parentNode.querySelector('textarea'));
    createComment(name, box.val());
    return box.val('');
  };

  defaultMarkup = function(org) {
    return "<span " + (orgAttrs(org)) + ">" + (escapeHtml(org.text)) + "</span>";
  };

  htmlForResults = function(text) {
    return "<div class='coderesults' data-org-type='results'><span class='hidden'>#+RESULTS:\n</span><div class='resultscontent'><span></span><span class='hidden'>" + (escapeHtml(text)) + "</span></div></div>";
  };

  toggleDynamic = function(event) {
    var block, newNode, resType, top;
    block = codeBlockForNode(event.target);
    resType = (!block.hasAttribute('data-org-type') ? block.firstChild : block).getAttribute('data-org-results');
    top = topNode(block);
    newNode = replaceCodeBlock(block, changeResultType(block.textContent, (resType === 'dynamic' ? 'static' : 'dynamic')));
    if (resType !== 'dynamic') {
      return executeSource(top, $(newNode).find('[data-org-type="source"]')[0]);
    }
  };

  nonl = function(txt) {
    if (txt[txt.length - 1] === '\n') {
      return txt.substring(0, txt.length - 1);
    } else {
      return txt;
    }
  };

  createResults = function(srcNode) {
    var created;
    srcNode = $(srcNode).closest('.codeblock');
    if (created = srcNode && !$(srcNode).find('.coderesults').length) {
      $(srcNode).find('.codewrapper').append(htmlForResults(''));
    }
    return created;
  };

  executeCode = function(event) {
    selectPrevious(codeBlockForNode(event.target));
    return executeSource(topNode(event.target), event.target, function() {});
  };

  shouldCancelBS = function(parent, r) {
    return atTextStart(r) && crossesHidden(-1);
  };

  atTextStart = function(r) {
    return r.collapsed && (r.startContainer.nodeType === 1 || (r.startContainer.nodeType === 3 && r.startOffset === 0));
  };

  atTextEnd = function(r) {
    return r.collapsed && (r.startContainer.nodeType === 1 || (r.startContainer.nodeType === 3 && ((r.startOffset === r.startContainer.length && 1) || (r.startOffset === r.startContainer.length - 1 && r.startContainer.textContent[r.startOffset] === '\n' && 2))));
  };

  shouldCancelDEL = function(parent, r) {
    var atEnd;
    return (atEnd = atTextEnd(r)) && crossesHidden(atEnd + 1);
  };

  matchLineAt = function(parent, pos) {
    var end, start, text;
    text = parent.textContent;
    start = text.substring(0, pos).lastIndexOf('\n');
    end = text.indexOf('\n', start + 1);
    if (end === -1) {
      end = text.length;
    }
    return matchLine(text.substring(start + 1, end));
  };

  markupGuts = function(org, start) {
    var c, p, prev, s;
    if (!org.children.length) {
      return '';
    } else {
      prev = start ? null : org;
      return ((function() {
        var _i, _len, _ref7, _results;
        _ref7 = org.children;
        _results = [];
        for (_i = 0, _len = _ref7.length; _i < _len; _i++) {
          c = _ref7[_i];
          s = start;
          start = false;
          p = prev;
          prev = c;
          _results.push(markupNode(c, s));
        }
        return _results;
      })()).join("");
    }
  };

  currentTextPosition = function(parent, r) {
    if (curPos > -1) {
      return curPos;
    } else {
      return curPos = getTextPosition(parent, r || getSelection().getRangeAt(0));
    }
  };

  crossesHidden = function(delta) {
    var r, _ref7;
    r = getSelection().getRangeAt(0);
    return !((0 <= (_ref7 = r.startOffset) && _ref7 < r.startContainer.length)) && isCollapsed((delta < 0 ? textNodeBefore : textNodeAfter)(r.startContainer));
  };

  bindContent = function(div) {
    div.addEventListener('mousedown', function(e) {
      if (replaceUnrelatedPresenter(e.target, emptyPresenter)) {
        return setCurKeyBinding(null);
      }
    });
    div.addEventListener('keydown', handleKey(div));
    div.addEventListener('DOMCharacterDataModified', handleMutation, true);
    div.addEventListener('DOMSubtreeModified', handleMutation, true);
    return displaySource();
  };

  handleKey = function(div) {
    return function(e) {
      var bound, br, c, cancelled, checkMod, currentMatch, el, n, needsReparse, par, r, s, _ref7;
      curPos = -1;
      c = e.charCode || e.keyCode || e.which;
      if (!addKeyPress(e, c)) {
        return;
      }
      s = getSelection();
      r = (s.rangeCount > 0 ? s.getRangeAt(0) : null);
      _ref7 = findKeyBinding(e, div, r), bound = _ref7[0], checkMod = _ref7[1];
      if (bound) {
        cancelled = !checkMod;
      } else {
        checkMod = modifyingKey(c);
        cancelled = false;
      }
      if (String.fromCharCode(c) === 'C' && e.altKey) {
        root.orgApi.executeSource(div, getSelection().focusNode);
      } else if (!bound) {
        if (modifyingKey(c)) {
          n = s.focusNode;
          el = r.startContainer;
          par = el.parentNode;
          currentMatch = matchLine(currentLine(div));
          if (c === ENTER) {
            e.preventDefault();
            if (n.nodeType === 3 && r.collapsed && r.startOffset === n.length && n.parentNode.getAttribute('data-org-type') === 'text') {
              br = document.createTextNode('\n');
              $(br).prependTo(followingSpan(n.parentNode));
            } else {
              r.insertNode(br = document.createTextNode(checkExtraNewline(r, n, div)));
            }
            r.setStart(br, br.length);
            r.setEnd(br, br.length);
            s.removeAllRanges();
            s.addRange(r);
            restorePosition(br.parentNode, function() {
              return br.parentNode.normalize();
            });
            setTimeout((function() {
              return checkEnterReparse(div, r);
            }), 1);
          } else if (c === BS || c === DEL) {
            if ((c === BS && shouldCancelBS(div, r)) || (c === DEL && shouldCancelDEL(div, r))) {
              e.preventDefault();
              return;
            } else if (c === BS && bsWillDestroyParent(r)) {
              e.preventDefault();
              el.data = el.data.substring(1);
            }
          } else if (el.nodeType === 3) {
            setTimeout((function() {
              return fancyCheckSourceMod(n, div, currentMatch, el);
            }), 1);
            return;
          }
        }
      }
      if (!cancelled && checkMod) {
        if ((getOrgType(getOrgParent(el))) === 'boundary') {
          needsReparse = true;
        }
        return setTimeout((function() {
          return fancyCheckSourceMod(n, div, currentMatch, (el.nodeType === 1 ? el.firstChild : el));
        }), 1);
      }
    };
  };

  getCodeContainer = function(node) {
    return node && (((typeof node.getAttribute === "function" ? node.getAttribute('data-org-src') : void 0) && node) || (!(typeof node.getAttribute === "function" ? node.getAttribute('data-org-type') : void 0) && getCodeContainer(node.parentNode)));
  };

  fancyCheckSourceMod = function(focus, div, currentMatch, el) {
    var code;
    if (code = getCodeContainer(focus)) {
      recreateAstButtons(div, code);
    } else if (needsNewline(el)) {
      restorePosition(el.parentNode, function() {
        el.data += '\n';
        return el.parentNode.normalize();
      });
    }
    return checkSourceMod(div, currentMatch);
  };

  needsNewline = function(el) {
    if (!el) {
      return false;
    } else if (el.nodeType === 3) {
      return needsNewline(el.parentNode);
    } else {
      return el.nodeType === 1 && $(el).is('[data-newline]');
    }
  };

  bsWillDestroyParent = function(r) {
    if (r.startContainer.nodeType === 3 && r.startOffset === 1 && r.startContainer.data.match(/^.\n?$/)) {
      return r.startContainer.parentNode.textContent === r.startContainer.data;
    } else {
      return false;
    }
  };

  allowEvents = true;

  handleMutation = function(evt) {
    if (allowEvents) {
      invalidateOrgText();
      return displaySource();
    }
  };

  executeSource = function(parent, node, cont, skipTests) {
    var doc, srcNode, text, _ref7;
    doc = topNode(node);
    _ref7 = getNodeSource(node), srcNode = _ref7[0], text = _ref7[1];
    if (srcNode) {
      createResults(srcNode);
      if (text.trim().length) {
        return executeText(text.trim(), propsFor(srcNode), orgEnv(parent, srcNode), function() {
          if (typeof cont === "function") {
            cont();
          }
          if (!skipTests) {
            return runAutotests(doc);
          }
        });
      }
    }
  };

  fancyExecuteDef = function(node, cont) {
    var doc;
    doc = topNode(node);
    return executeDef(node, function() {
      if (typeof cont === "function") {
        cont();
      }
      return runAutotests(doc);
    });
  };

  runAutotests = function(doc) {
    var n, _i, _len, _ref7, _results;
    _ref7 = $(doc).find("[data-org-results='autotest']").add($(doc).find("[data-org-update~='any']"));
    _results = [];
    for (_i = 0, _len = _ref7.length; _i < _len; _i++) {
      n = _ref7[_i];
      _results.push(runTest(doc, n));
    }
    return _results;
  };

  runTest = function(doc, node) {
    return executeSource(doc, node, ($(node).is("[data-org-results='autotest']") ? (function() {
      return checkTestResults(node);
    }) : void 0), true);
  };

  checkTestResults = function(node) {
    return node.setAttribute('data-org-test', (node.getAttribute('data-org-expected') === $(node).find('.resultscontent').text() ? 'pass' : 'fail'));
  };

  reprocessResults = function(node) {
    if (node.firstChild.shadowRoot) {
      node.firstChild.shadowRoot.innerHTML = '';
      node.firstChild.shadowRoot.applyAuthorStyles = true;
    }
    return processResults(node.firstChild.nextElementSibling.textContent, node, true);
  };

  processResults = function(str, node, skipText) {
    var line, shadow, _i, _len, _ref7, _results;
    if (!node.firstChild.shadowRoot) {
      node.firstChild.createShadowRoot();
      node.firstChild.shadowRoot.applyAuthorStyles = true;
    }
    shadow = node.firstChild.shadowRoot;
    if (!skipText) {
      node.firstChild.nextElementSibling.textContent += escapePresentationHtml(str.substring(0, str.length - 1)) + str[str.length - 1];
    }
    _ref7 = splitLines(str);
    _results = [];
    for (_i = 0, _len = _ref7.length; _i < _len; _i++) {
      line = _ref7[_i];
      if (line.match(/^: /)) {
        _results.push(shadow.innerHTML += "<div class='resultsline'>" + (line.substring(2)) + "</div>");
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  setShadowHtml = function(holder, html) {
    var el;
    if (!(el = holder.shadowRoot)) {
      el = holder.createShadowRoot();
      el.applyAuthorStyles = true;
    }
    return el.innerHTML = html;
  };

  redrawIssue = function(issue) {
    var button, c, count, issueName, name;
    issueName = issue.leisureName;
    if ((name = $("[data-org-comments='" + issueName + "']")).length) {
      count = issue.comments.length + 1;
      button = $("[data-org-codeblock='" + issueName + "'] button.comment-button");
      if (button.attr('data-org-commentcount') !== count) {
        button.attr('data-org-commentcount', count);
        button.addClass('new-comments');
      }
      setShadowHtml(button.find('span')[0], count);
      return setShadowHtml(name[0].firstChild, "<div class='" + (typeof theme !== "undefined" && theme !== null ? theme : '') + "'>" + (commentHtml(issue, 'main')) + (((function() {
        var _i, _len, _ref7, _results;
        _ref7 = issue.comments;
        _results = [];
        for (_i = 0, _len = _ref7.length; _i < _len; _i++) {
          c = _ref7[_i];
          _results.push(commentHtml(c, 'added'));
        }
        return _results;
      })()).join('')) + (newCommentBox(issueName, $(name[0].parentNode).find('.codeblock').attr('id'))) + "</div>");
    }
  };

  commentHtml = function(comment, type) {
    return "<div class='commentbox'><img src='http://gravatar.com/avatar/" + comment.user.gravatar_id + "?s=48'><div class='" + type + "'>" + comment.body + "</div></div>";
  };

  newCommentBox = function(name, codeId) {
    return "<div class='" + (typeof theme !== "undefined" && theme !== null ? theme : '') + "'><textarea pseudo='x-new-comment'></textarea><br><button onclick='Leisure.addComment(\"" + name + "\", event)'>Add Comment</button></div>";
  };

  colonify = function(str) {
    return ': ' + (str.replace(/[\n\\]/g, function(c) {
      if (c === '\n') {
        return '\\n';
      } else {
        return '\\\\';
      }
    })) + '\n';
  };

  clearResults = function(node) {
    var r;
    if ((r = node.firstChild.shadowRoot)) {
      r.innerHTML = '';
    }
    return node.firstChild.nextElementSibling.innerHTML = '';
  };

  orgEnv = function(parent, node) {
    var r;
    r = node;
    if (!$(r).is('.resultscontent')) {
      r = $(r).find('.resultscontent')[0];
    }
    if (r) {
      clearResults(r);
      return {
        __proto__: defaultEnv,
        readFile: function(filename, cont) {
          return window.setTimeout((function() {
            return $.get(filename, function(data) {
              return cont(false, data);
            });
          }), 1);
        },
        write: function(str) {
          return processResults(colonify(String(str)), r);
        },
        presentValue: presentValue,
        newCodeContent: function(name, con) {
          return console.log("NEW CODE CONTENT: " + name + ", " + con);
        },
        prompt: function(msg, cont) {
          return cont(prompt(rz(msg)));
        }
      };
    } else {
      return {
        __proto__: defaultEnv,
        readFile: function(filename, cont) {
          return window.setTimeout((function() {
            return $.get(filename, function(data) {
              return cont(false, data);
            });
          }), 1);
        },
        write: function(str) {
          return console.log(colonify(str));
        },
        newCodeContent: function(name, con) {
          return console.log("NEW CODE CONTENT: " + name + ", " + con);
        },
        prompt: function(msg, cont) {
          return cont(prompt(rz(msg)));
        }
      };
    }
  };

  hideSlider = function(numberSpan) {
    return replaceRelatedPresenter(numberSpan, emptyPresenter);
  };

  showSliderButton = function(parent, numberSpan) {
    var computing, d, inside, max, min, orgParent, orgType, sl, sliding, value;
    if (hideSlider(numberSpan)) {
      return;
    }
    inside = false;
    sliding = false;
    d = $("<div style='z-index: 1; position: absolute; width: 200px; background: white; border: solid green 1px' slider contentEditable='false'></div>")[0];
    d.style.top = "" + (numberSpan.offsetTop + numberSpan.offsetHeight + 5) + "px";
    d.style.minTop = '0px';
    d.style.left = "" + (Math.max(0, numberSpan.offsetLeft + numberSpan.offsetWidth / 2 - 100)) + "px";
    d.addEventListener('mouseover', function(e) {
      if (!inside) {
        return inside = true;
      }
    });
    d.addEventListener('mouseout', function(e) {
      if (e.toElement !== d && !d.contains(e.toElement)) {
        inside = false;
        if (!sliding) {
          return hideSlider(numberSpan);
        }
      }
    });
    value = Number(numberSpan.textContent);
    min = value < 0 ? value * 2 : value / 2;
    max = value === 0 ? 10 : value * 2;
    orgParent = getOrgParent(numberSpan);
    orgType = orgParent.getAttribute('data-org-results');
    computing = false;
    sl = $(d).slider({
      animate: 'fast',
      start: function() {
        sliding = true;
        allowEvents = false;
        return true;
      },
      stop: function(event, ui) {
        setMinMax(sl);
        allowEvents = true;
        sliding = false;
        if (!inside) {
          return hideSlider(numberSpan);
        }
      },
      slide: function(event, ui) {
        var done;
        numberSpan.innerHTML = String(ui.value);
        if (!computing && (orgType === 'dynamic' || orgType === 'def')) {
          computing = true;
          done = function() {
            return computing = false;
          };
          return setTimeout((function() {
            if (orgType === 'dynamic') {
              return root.orgApi.executeSource(parent, numberSpan.parentNode, done);
            } else if (orgType === 'def') {
              return root.orgApi.executeDef(orgParent, done);
            }
          }), 1);
        }
      },
      value: value
    });
    parent.insertBefore(d, numberSpan);
    setMinMax(sl, value);
    replacePresenter({
      numberSpan: numberSpan,
      hide: function() {
        return d.remove();
      },
      isRelated: function(node) {
        return (isOrContains(d, node)) || (isOrContains(numberSpan, node));
      }
    });
    return d.focus();
  };

  psgn = function(x) {
    if (x < 0) {
      return -1;
    } else {
      return 1;
    }
  };

  setMinMax = function(sl, value) {
    var max, min, step, _ref7;
    value = value || sl.slider("value");
    min = 0;
    max = (1 <= (_ref7 = Math.abs(value)) && _ref7 < 50) || value === 0 ? 100 * psgn(value) : value * 2;
    step = (max - min) / 100;
    if (Math.round(value) === value) {
      step = Math.round(step);
      step = Math.max(1, step - step % (max - min));
    }
    sl.slider("option", "min", min);
    sl.slider("option", "max", max);
    return sl.slider("option", "step", step);
  };

  setCurrentSlide = function(element) {
    var node, _i, _len, _ref7;
    _ref7 = $('.currentSlide');
    for (_i = 0, _len = _ref7.length; _i < _len; _i++) {
      node = _ref7[_i];
      $(node.shadowRoot.firstElementChild).removeClass('currentSlide');
    }
    $('.currentSlide').removeClass('currentSlide');
    $(element).addClass('currentSlide');
    if (element.shadowRoot) {
      return $(element.shadowRoot.firstElementChild).addClass('currentSlide');
    }
  };

  nextSlide = function() {
    var ns, slide;
    ns = null;
    if (slide = $('.currentSlide')[0]) {
      if ($(slide.nextElementSibling).has('[data-org-headline="1"]')) {
        ns = slide.nextElementSibling;
      }
    }
    if (!ns) {
      ns = $('[data-org-headline="1"]')[0];
    }
    return setCurrentSlide(ns);
  };

  prevSlide = function() {
    var ps, s, slide;
    ps = null;
    if (slide = $('.currentSlide')[0]) {
      if ($(slide.previousElementSibling).has('[data-org-headline="1"]')) {
        ps = slide.previousElementSibling;
      }
    }
    if (!$(ps).is('[data-org-headline="1"]')) {
      s = $('[data-org-headline="1"]');
      ps = s[s.length - 1];
    }
    if (ps) {
      return setCurrentSlide(ps);
    }
  };

  showSlides = function() {
    setCurrentSlide($('[data-org-headline="1"]')[0]);
    return document.body.classList.add('slides');
  };

  slideParent = function(node) {
    while (node && !$(node).is('[data-org-headline="1"]')) {
      node = node.parentNode;
    }
    return node;
  };

  documentTop = function(node) {
    var top;
    top = 0;
    while (node) {
      if (node.tagName) {
        top = top + node.offsetTop;
        node = node.offsetParent;
      } else {
        node = node.parentNode;
      }
    }
    return top;
  };

  hideSlides = function() {
    return document.body.classList.remove('slides');
  };

  slideBindings = {
    'PAGEUP': function(e, parent, r) {
      e.preventDefault();
      prevSlide();
      return false;
    },
    'PAGEDOWN': function(e, parent, r) {
      e.preventDefault();
      nextSlide();
      return false;
    }
  };

  toggleSlides = function() {
    slideMode = !slideMode;
    fancyOrg.bindings = (slideMode ? slideBindings : defaultBindings);
    if (slideMode) {
      $("#prevSlide").click(function(e) {
        return prevSlide();
      });
      $("#nextSlide").click(function(e) {
        return nextSlide();
      });
      return restorePosition(null, function() {
        $('[data-org-html]').addClass('slideHtml');
        $('body').addClass('slides');
        return nextSlide();
      });
    } else {
      $('body').removeClass('slides');
      return $('[data-org-html]').removeClass('slideHtml');
    }
  };

  theme = null;

  setTheme = function(str) {
    var el, node, _i, _len, _ref7;
    el = $('body');
    _ref7 = $('[data-org-headline="1"]').add($('[data-org-comments]').find(':first-child'));
    for (_i = 0, _len = _ref7.length; _i < _len; _i++) {
      node = _ref7[_i];
      if (node.shadowRoot) {
        el = el.add(node.shadowRoot.firstElementChild);
      }
    }
    el.add('[data-org-html]');
    if (theme && theme !== str) {
      el.removeClass(theme);
    }
    theme = str;
    if (str) {
      return el.addClass(str);
    }
  };

  define('setTheme', lz(function(str) {
    return makeSyncMonad(function(env, cont) {
      setTheme(rz(str));
      return cont(rz(L_true));
    });
  }));

  define('toggleSlides', lz(makeSyncMonad(function(env, cont) {
    toggleSlides();
    return cont(rz(L_true));
  })));

  slideOffset = function(slide) {
    var a;
    if (slide) {
      a = [];
      a.push.apply(a, $("[data-org-headline='1']"));
      return a.indexOf(slide != null ? slide : $('.currentSlide')[0]);
    } else {
      return -1;
    }
  };

  setSlideAt = function(index) {
    return setCurrentSlide($("[data-org-headline='1']")[index]);
  };

  restoreSlide = function(block) {
    var offset;
    if (!slideMode) {
      return block();
    } else {
      offset = slideOffset();
      block();
      return setSlideAt(offset);
    }
  };

  fancyOrg = {
    __proto__: orgNotebook,
    markupOrg: markupOrg,
    markupOrgWithNode: markupOrgWithNode,
    bindContent: bindContent,
    installOrgDOM: function(parent, orgNode, orgText) {
      this.parent = parent;
      return restorePosition(parent, function() {
        var node, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref10, _ref7, _ref8, _ref9,
          _this = this;
        parent.setAttribute('class', 'org-fancy');
        parent.setAttribute('maindoc', '');
        orgNotebook.installOrgDOM(parent, orgNode, orgText);
        _ref7 = $('[data-org-html]');
        for (_i = 0, _len = _ref7.length; _i < _len; _i++) {
          node = _ref7[_i];
          setShadowHtml(node, node.innerHTML);
          node.innerHTML = '';
        }
        _ref8 = $('[data-org-src]');
        for (_j = 0, _len1 = _ref8.length; _j < _len1; _j++) {
          node = _ref8[_j];
          recreateAstButtons(parent, node);
        }
        _ref9 = $('.resultscontent');
        for (_k = 0, _len2 = _ref9.length; _k < _len2; _k++) {
          node = _ref9[_k];
          reprocessResults(node);
        }
        _ref10 = $('[data-org-headline="1"]');
        for (_l = 0, _len3 = _ref10.length; _l < _len3; _l++) {
          node = _ref10[_l];
          setShadowHtml(node, "<div class='page'><div class='border'></div><div class='pagecontent'><content></content></div></div>");
        }
        setTheme(theme);
        setTimeout((function() {
          var _len4, _m, _ref11;
          _ref11 = $('[data-org-comments]');
          for (_m = 0, _len4 = _ref11.length; _m < _len4; _m++) {
            node = _ref11[_m];
            setShadowHtml(node.firstElementChild, newCommentBox(node.getAttribute('data-org-comments'), $(node.parentNode).find('.codeblock').attr('id')));
          }
          return redrawAllIssues();
        }), 1);
        return $(document).tooltip();
      });
    },
    executeSource: executeSource,
    executeDef: fancyExecuteDef,
    createResults: createResults,
    bindings: defaultBindings,
    redrawIssue: function(i) {
      return redrawIssue(i);
    },
    leisureButton: function() {
      return restorePosition(this.parent, function() {
        toggleSlides();
        if (slideMode) {
          return setTimeout((function() {
            if (!getSelection().focusNode) {
              return $('[maindoc]').focus();
            }
          }), 1);
        } else {
          return swapMarkup();
        }
      });
    }
  };

  root.fancyOrg = fancyOrg;

  root.toggleComment = toggleComment;

  root.addComment = addComment;

  root.recreateAstButtons = recreateAstButtons;

  root.setTheme = setTheme;

  root.createTestCase = createTestCase;

  root.executeCode = executeCode;

  root.toggleDynamic = toggleDynamic;

}).call(this);

/*
//@ sourceMappingURL=fancyOrg.map
*/
