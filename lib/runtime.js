// Generated by CoffeeScript 1.6.2
/*
Copyright (C) 2013, Bill Burdick, Tiny Concepts: https://github.com/zot/Leisure

(licensed with ZLIB license)

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software
in a product, an acknowledgment in the product documentation would be
appreciated but is not required.

2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.

3. This notice may not be removed or altered from any source distribution.
*/


(function() {
  var Monad, Nil, actors, amt, ast2Json, asyncMonad, basicCall, booleanFor, call, callMonad, cons, consFrom, continueMonads, curry, defaultEnv, define, ensureLeisureClass, functionInfo, getDataType, getMonadSyncMode, getType, getValue, hamt, head, identity, isMonad, left, makeHamt, makeMonad, makeSyncMonad, monadModeSync, nameSub, newRunMonad, nextMonad, nextNode, none, parensContent, parensEnd, parensStart, readDir, readFile, replaceErr, right, root, runMonad, setDataType, setType, setValue, setWarnAsync, some, statFile, strCoord, strFromList, strToList, subcurry, tail, tokenPos, tokenString, values, warnAsync, withSyncModeDo, _, _false, _identity, _ref, _ref1, _true,
    __slice = [].slice;

  _ref = root = module.exports = require('./base'), readFile = _ref.readFile, statFile = _ref.statFile, readDir = _ref.readDir, defaultEnv = _ref.defaultEnv;

  _ref1 = require('./ast'), define = _ref1.define, cons = _ref1.cons, Nil = _ref1.Nil, head = _ref1.head, tail = _ref1.tail, getType = _ref1.getType, getDataType = _ref1.getDataType, ast2Json = _ref1.ast2Json, ensureLeisureClass = _ref1.ensureLeisureClass, setType = _ref1.setType, setDataType = _ref1.setDataType, functionInfo = _ref1.functionInfo, nameSub = _ref1.nameSub;

  _ = require('./lodash.min');

  amt = require('persistent-hash-trie');

  call = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return basicCall(args, defaultEnv, identity);
  };

  callMonad = function() {
    var args, cont, env, _i;

    args = 3 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 2) : (_i = 0, []), env = arguments[_i++], cont = arguments[_i++];
    return basicCall(args, env, cont);
  };

  basicCall = function(args, env, cont) {
    var arg, res, _i, _len, _ref2;

    res = global["L_" + args[0]]();
    _ref2 = args.slice(1);
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      arg = _ref2[_i];
      res = (function(arg) {
        return res(function() {
          return arg;
        });
      })(arg);
    }
    return runMonad(res, env, cont);
  };

  consFrom = function(array, i) {
    i = i || 0;
    if (i < array.length) {
      return cons(array[i], consFrom(array, i + 1));
    } else {
      return L_nil();
    }
  };

  identity = function(x) {
    return x;
  };

  _identity = function(x) {
    return x();
  };

  _true = setType((function(a) {
    return function(b) {
      return a();
    };
  }), 'true');

  _false = setType((function(a) {
    return function(b) {
      return b();
    };
  }), 'false');

  left = function(x) {
    return setType((function(lCase) {
      return function(rCase) {
        return lCase()(function() {
          return x;
        });
      };
    }), 'left');
  };

  right = function(x) {
    return setType((function(lCase) {
      return function(rCase) {
        return rCase()(function() {
          return x;
        });
      };
    }), 'right');
  };

  some = function(x) {
    return setType((function(someCase) {
      return function(noneCase) {
        return someCase()(function() {
          return x;
        });
      };
    }), 'some');
  };

  none = setType((function(someCase) {
    return function(noneCase) {
      return noneCase();
    };
  }), 'none');

  booleanFor = function(bool) {
    if (bool) {
      return L_true();
    } else {
      return L_false();
    }
  };

  define('eq', function() {
    return function(a) {
      return function(b) {
        return booleanFor(a() === b());
      };
    };
  });

  define('==', function() {
    return function(a) {
      return function(b) {
        return booleanFor(a() === b());
      };
    };
  });

  define('hasType', function() {
    return function(data) {
      return function(func) {
        if (typeof func() === 'string') {
          return booleanFor(getType(data()) === func());
        } else {
          return booleanFor(getType(data()) === getDataType(func()));
        }
      };
    };
  });

  define('getDataType', function() {
    return function(func) {
      if (typeof func() === 'string') {
        return func();
      } else {
        return getDataType(func());
      }
    };
  });

  define('assert', function() {
    return function(bool) {
      return function(msg) {
        return function(expr) {
          return bool()(function() {
            return expr();
          })(function() {
            throw new Error(msg());
          });
        };
      };
    };
  });

  define('assertLog', function() {
    return function(bool) {
      return function(msg) {
        return function(expr) {
          return bool()(function() {
            return expr();
          })(function() {
            console.log(new Error(msg()).stack);
            console.log("LOGGED ERROR -- RESUMING EXECUTION...");
            return expr();
          });
        };
      };
    };
  });

  define('+', function() {
    return function(x) {
      return function(y) {
        return x() + y();
      };
    };
  });

  define('-', function() {
    return function(x) {
      return function(y) {
        return x() - y();
      };
    };
  });

  define('*', function() {
    return function(x) {
      return function(y) {
        return x() * y();
      };
    };
  });

  define('/', function() {
    return function(x) {
      return function(y) {
        return x() / y();
      };
    };
  });

  define('%', function() {
    return function(x) {
      return function(y) {
        return x() % y();
      };
    };
  });

  define('<', function() {
    return function(x) {
      return function(y) {
        return booleanFor(x() < y());
      };
    };
  });

  define('<=', function() {
    return function(x) {
      return function(y) {
        return booleanFor(x() <= y());
      };
    };
  });

  define('>', function() {
    return function(x) {
      return function(y) {
        return booleanFor(x() > y());
      };
    };
  });

  define('>=', function() {
    return function(x) {
      return function(y) {
        return booleanFor(x() >= y());
      };
    };
  });

  define('floor', function() {
    return function(x) {
      return Math.floor(x());
    };
  });

  define('ceil', function() {
    return function(x) {
      return Math.ceil(x());
    };
  });

  define('min', function() {
    return function(x) {
      return function(y) {
        return Math.min(x(), y());
      };
    };
  });

  define('max', function() {
    return function(x) {
      return function(y) {
        return Math.max(x(), y());
      };
    };
  });

  define('round', function() {
    return function(x) {
      return Math.round(x());
    };
  });

  define('abs', function() {
    return function(x) {
      return Math.abs(x());
    };
  });

  define('sqrt', function() {
    return function(x) {
      return Math.sqrt(x());
    };
  });

  define('acos', function() {
    return function(x) {
      return Math.acos(x());
    };
  });

  define('asin', function() {
    return function(x) {
      return Math.asin(x());
    };
  });

  define('atan', function() {
    return function(x) {
      return Math.atan(x());
    };
  });

  define('atan2', function() {
    return function(x) {
      return function(y) {
        return Math.atan2(x(), y());
      };
    };
  });

  define('cos', function() {
    return function(x) {
      return Math.cos(x());
    };
  });

  define('log', function() {
    return function(x) {
      return Math.log(x());
    };
  });

  define('sin', function() {
    return function(x) {
      return Math.sin(x());
    };
  });

  define('tan', function() {
    return function(x) {
      return Math.tan(x());
    };
  });

  define('rand', function() {
    return makeSyncMonad(function(env, cont) {
      return cont(Math.random());
    });
  });

  define('randInt', function() {
    return function(low) {
      return function(high) {
        return makeSyncMonad(function(env, cont) {
          return cont(Math.floor(low() + Math.random() * high()));
        });
      };
    };
  });

  define('^', function() {
    return function(x) {
      return function(y) {
        return Math.pow(x(), y());
      };
    };
  });

  define('strString', function() {
    return function(data) {
      return String(data());
    };
  });

  define('_strAsc', function() {
    return function(str) {
      return str().charCodeAt(0);
    };
  });

  define('_strChr', function() {
    return function(i) {
      return String.fromCharCode(i());
    };
  });

  define('_strAt', function() {
    return function(str) {
      return function(index) {
        return str()[strCoord(str(), index())];
      };
    };
  });

  define('_strStartsWith', function() {
    return function(str) {
      return function(prefix) {
        return booleanFor(str().substring(0, prefix().length) === prefix());
      };
    };
  });

  define('_strLen', function() {
    return function(str) {
      return str().length;
    };
  });

  define('_strToLowerCase', function() {
    return function(str) {
      return str().toLowerCase();
    };
  });

  define('_strToUpperCase', function() {
    return function(str) {
      return str().toUpperCase();
    };
  });

  define('_strReplace', function() {
    return function(str) {
      return function(pat) {
        return function(repl) {
          return str().replace(pat(), repl());
        };
      };
    };
  });

  strCoord = function(str, coord) {
    if (coord < 0) {
      return str.length + coord;
    } else {
      return coord;
    }
  };

  define('_strSubstring', function() {
    return function(str) {
      return function(start) {
        return function(end) {
          var a, b;

          a = strCoord(str(), start());
          b = strCoord(str(), end());
          if (b < a && end() === 0) {
            b = str().length;
          }
          return str().substring(a, b);
        };
      };
    };
  });

  define('_strSplit', function() {
    return function(str) {
      return function(pat) {
        return consFrom(str().split(pat() instanceof RegExp ? pat() : new RegExp(pat())));
      };
    };
  });

  define('_strCat', function() {
    return function(list) {
      return _.map(list().toArray(), function(el) {
        return L_show()(function() {
          return el;
        });
      }).join('');
    };
  });

  define('_strAdd', function() {
    return function(s1) {
      return function(s2) {
        return s1() + s2();
      };
    };
  });

  define('_strMatch', function() {
    return function(str) {
      return function(pat) {
        var groups, m, pos;

        m = str().match((pat() instanceof RegExp ? pat() : new RegExp(pat())));
        if (m) {
          groups = [];
          pos = 1;
          while (m[pos]) {
            groups.push(m[pos++]);
          }
          if (typeof m.index !== 'undefined') {
            return consFrom([m[0], consFrom(groups), m.index, m.input]);
          } else {
            return consFrom([m[0], consFrom(groups)]);
          }
        } else {
          return Nil;
        }
      };
    };
  });

  define('_strToList', function() {
    return function(str) {
      return strToList(str());
    };
  });

  strToList = function(str) {
    if (str === '') {
      return Nil;
    } else {
      return cons(str[0], strToList(str.substring(1)));
    }
  };

  define('_strFromList', function() {
    return function(list) {
      return strFromList(list());
    };
  });

  strFromList = function(list) {
    if (list instanceof Leisure_nil) {
      return '';
    } else {
      return head(list) + strFromList(tail(list));
    }
  };

  define('_regexp', function() {
    return function(str) {
      return new RegExp(str());
    };
  });

  define('_regexpFlags', function() {
    return function(str) {
      return function(flags) {
        return new RegExp(str(), flags());
      };
    };
  });

  define('_jsonParse', function() {
    return function(str) {
      return function(failCont) {
        return function(successCont) {
          var err, p;

          try {
            p = JSON.parse(str());
            return successCont()(function() {
              return p;
            });
          } catch (_error) {
            err = _error;
            return failCont()(function() {
              return err;
            });
          }
        };
      };
    };
  });

  define('jsonStringify', function() {
    return function(obj) {
      return function(failCont) {
        return function(successCont) {
          var err, s;

          try {
            s = JSON.stringify(obj());
            return successCont()(function() {
              return s;
            });
          } catch (_error) {
            err = _error;
            return failCont()(function() {
              return err;
            });
          }
        };
      };
    };
  });

  define('getProperties', function() {
    return function(func) {
      var _ref2;

      if ((_ref2 = func()) != null ? _ref2.properties : void 0) {
        return L_some()(function() {
          return func().properties;
        });
      } else {
        return L_none();
      }
    };
  });

  define('log', function() {
    return function(str) {
      return function(res) {
        console.log(String(str()));
        return res();
      };
    };
  });

  makeMonad = function(guts) {
    var m;

    m = function() {};
    m.__proto__ = Monad.prototype;
    m.cmd = guts;
    m.type = 'monad';
    return m;
  };

  makeSyncMonad = function(guts) {
    var m;

    m = makeMonad(guts);
    m.sync = true;
    return m;
  };

  nextMonad = function(cont) {
    return cont;
  };

  replaceErr = function(err, msg) {
    err.message = msg;
    return err;
  };

  defaultEnv.write = function(str) {
    return process.stdout.write(str);
  };

  defaultEnv.err = function(err) {
    var _ref2;

    return this.write("ENV Error: " + ((_ref2 = err.stack) != null ? _ref2 : err));
  };

  defaultEnv.prompt = function() {
    throw new Error("Environment does not support prompting!");
  };

  monadModeSync = false;

  getMonadSyncMode = function() {
    return monadModeSync;
  };

  withSyncModeDo = function(newMode, block) {
    var err, oldMode;

    oldMode = monadModeSync;
    monadModeSync = newMode;
    try {
      return block();
    } catch (_error) {
      err = _error;
      return console.log("ERR: " + err.stack);
    } finally {

    }
  };

  runMonad = function(monad, env, cont) {
    env = env != null ? env : root.defaultEnv;
    return withSyncModeDo(true, function() {
      return newRunMonad(monad, env, cont, []);
    });
  };

  isMonad = function(m) {
    return typeof m === 'function' && (m.cmd != null);
  };

  continueMonads = function(contStack, env) {
    return function(result) {
      return withSyncModeDo(false, function() {
        return newRunMonad(result, env, null, contStack);
      });
    };
  };

  asyncMonad = {
    toString: function() {
      return "<asyncMonadResult>";
    }
  };

  warnAsync = false;

  setWarnAsync = function(state) {
    return warnAsync = state;
  };

  newRunMonad = function(monad, env, cont, contStack) {
    var err, result;

    if (cont) {
      contStack.push(cont);
    }
    try {
      while (true) {
        if (isMonad(monad)) {
          if (monad.binding) {
            contStack.push((function(bnd) {
              return function(x) {
                return bnd(function() {
                  return x;
                });
              };
            })(monad.binding()));
            monad = monad.monad();
            continue;
          } else if (!monad.sync) {
            monadModeSync = false;
            if (warnAsync) {
              console.log("async monad");
            }
            monad.cmd(env, continueMonads(contStack, env));
            return asyncMonad;
          }
          result = monad.cmd(env, identity);
        } else {
          monadModeSync = true;
          result = monad;
        }
        if (!contStack.length) {
          return result;
        }
        monad = contStack.pop()(result);
      }
    } catch (_error) {
      err = _error;
      err = replaceErr(err, "\nERROR RUNNING MONAD, MONAD: " + monad + ", ENV: " + env + "...\n" + err.message);
      console.log(err.stack);
      if (env.errorHandlers.length) {
        return env.errorHandlers.pop()(err);
      }
    }
  };

  Monad = (function() {
    function Monad() {}

    Monad.prototype.toString = function() {
      return "Monad: " + (this.cmd.toString());
    };

    return Monad;

  })();

  global.L_runMonads = function(monadArray) {
    monadArray.reverse();
    return newRunMonad(0, defaultEnv, null, monadArray);
  };

  define('define', function() {
    return function(name) {
      return function(arity) {
        return function(src) {
          return function(def) {
            return makeSyncMonad(function(env, cont) {
              define(name(), def, arity(), src());
              return cont(typeof L_true !== "undefined" && L_true !== null ? L_true : _true);
            });
          };
        };
      };
    };
  });

  define('bind', function() {
    return function(m) {
      return function(binding) {
        var bindMonad;

        bindMonad = makeMonad(function(env, cont) {});
        bindMonad.monad = m;
        bindMonad.binding = binding;
        return bindMonad;
      };
    };
  });

  values = {};

  define('protect', function() {
    return function(value) {
      return makeMonad(function(env, cont) {
        var hnd;

        hnd = function(err) {
          console.log("PROTECTED ERROR: " + err.stack);
          return cont(left(err.stack));
        };
        env.errorHandlers.push(hnd);
        return runMonad(value(), env, (function(result) {
          if (env.errorHandlers.length) {
            if (env.errorHandlers[env.errorHandlers.length - 1] === hnd) {
              env.errorHandlers.pop();
            } else if (_.contains(env.errorHandlers, hnd)) {
              while (env.errorHandlers[env.errorHandlers.length - 1] !== hnd) {
                env.errorHandlers.pop();
              }
            }
          }
          return cont(right(result));
        }), []);
      });
    };
  });

  actors = {};

  define('actor', function() {
    return function(name) {
      return function(func) {
        actors[name] = func;
        func.env = {
          values: {}
        };
        return func.env.__proto__ = defaultEnv;
      };
    };
  });

  define('send', function() {
    return function(name) {
      return function(msg) {
        return setTimeout((function() {
          return runMonad(actors[name]()(msg), actors[name]().env);
        }), 1);
      };
    };
  });

  define('hasValue', function() {
    return function(name) {
      return makeSyncMonad(function(env, cont) {
        return cont(booleanFor(values[name()] != null));
      });
    };
  });

  define('getValueOr', function() {
    return function(name) {
      return function(defaultValue) {
        return makeSyncMonad(function(env, cont) {
          var _ref2;

          return cont((_ref2 = values[name()]) != null ? _ref2 : defaultValue());
        });
      };
    };
  });

  define('getValue', function() {
    return function(name) {
      return makeSyncMonad(function(env, cont) {
        if (!(name() in values)) {
          throw new Error("No value named '" + (name()) + "'");
        }
        return cont(values[name()]);
      });
    };
  });

  define('setValue', function() {
    return function(name) {
      return function(value) {
        return makeSyncMonad(function(env, cont) {
          values[name()] = value();
          return cont(_true);
        });
      };
    };
  });

  define('deleteValue', function() {
    return function(name) {
      return makeSyncMonad(function(env, cont) {
        delete values[name()];
        return cont(_true);
      });
    };
  });

  setValue = function(key, value) {
    return values[key] = value;
  };

  getValue = function(key) {
    return values[key];
  };

  define('envHas', function() {
    return function(name) {
      return makeSyncMonad(function(env, cont) {
        return cont(booleanFor(env.values[name()] != null));
      });
    };
  });

  define('envGetOr', function() {
    return function(name) {
      return function(defaultValue) {
        return makeSyncMonad(function(env, cont) {
          var _ref2;

          return cont((_ref2 = env.values[name()]) != null ? _ref2 : defaultValue());
        });
      };
    };
  });

  define('envGet', function() {
    return function(name) {
      return makeSyncMonad(function(env, cont) {
        if (!(name() in env.values)) {
          throw new Error("No value named '" + (name()) + "'");
        }
        return cont(env.values[name()]);
      });
    };
  });

  define('envSet', function() {
    return function(name) {
      return function(value) {
        return makeSyncMonad(function(env, cont) {
          env.values[name()] = value();
          return cont(_true);
        });
      };
    };
  });

  define('envDelete', function() {
    return function(name) {
      return makeSyncMonad(function(env, cont) {
        delete env.values[name()];
        return cont(_true);
      });
    };
  });

  define('createS', function() {
    return makeSyncMonad(function(env, cont) {
      return cont(_true);
    });
  });

  define('getS', function() {
    return function(state) {
      return makeSyncMonad(function(env, cont) {
        return cont(state().value);
      });
    };
  });

  define('setS', function() {
    return function(state) {
      return function(value) {
        return makeSyncMonad(function(env, cont) {
          state().value = value();
          return cont(_true);
        });
      };
    };
  });

  setValue('macros', Nil);

  define('defMacro', function() {
    return function(name) {
      return function(def) {
        return makeSyncMonad(function(env, cont) {
          values.macros = cons(cons(name(), def()), values.macros);
          return cont(_true);
        });
      };
    };
  });

  define('funcs', function() {
    return makeSyncMonad(function(env, cont) {
      console.log("Leisure functions:\n" + (_(global.leisureFuncNames.toArray()).sort().join('\n')));
      return cont(_true);
    });
  });

  define('funcSrc', function() {
    return function(func) {
      if (typeof func() === 'function' && func().src) {
        return some(func().src);
      } else {
        return none;
      }
    };
  });

  define('ast2Json', function() {
    return function(ast) {
      return JSON.stringify(ast2Json(ast()));
    };
  });

  define('override', function() {
    return function(name) {
      return function(newFunc) {
        return makeSyncMonad(function(env, cont) {
          var n, oldDef;

          n = "L_" + (nameSub(name()));
          oldDef = global[n];
          if (!oldDef) {
            throw new Error("No definition for " + (name()));
          }
          global[n] = function() {
            return newFunc()(oldDef);
          };
          return cont(_true);
        });
      };
    };
  });

  define('print', function() {
    return function(msg) {
      return makeSyncMonad(function(env, cont) {
        var m;

        m = msg();
        env.write("" + (env.presentValue(m)) + "\n");
        return cont(_true);
      });
    };
  });

  define('write', function() {
    return function(msg) {
      return makeSyncMonad(function(env, cont) {
        env.write(env.presentValue(msg()));
        return cont(_true);
      });
    };
  });

  define('readFile', function() {
    return function(name) {
      return makeMonad(function(env, cont) {
        return readFile(name(), function(err, contents) {
          return cont((err ? left(err.stack) : right(contents)));
        });
      });
    };
  });

  define('readDir', function() {
    return function(dir) {
      return makeMonad(function(env, cont) {
        return readDir(dir(), function(err, files) {
          return cont((err ? left(err.stack) : right(files)));
        });
      });
    };
  });

  define('statFile', function() {
    return function(file) {
      return makeMonad(function(env, cont) {
        return statFile(file(), function(err, stats) {
          return cont((err ? left(err.stack) : right(stats)));
        });
      });
    };
  });

  define('prompt', function() {
    return function(msg) {
      return makeMonad(function(env, cont) {
        return env.prompt(String(msg()), function(input) {
          return cont(input);
        });
      });
    };
  });

  define('rand', function() {
    return makeSyncMonad(function(env, cont) {
      return cont(Math.random());
    });
  });

  define('js', function() {
    return function(str) {
      return makeSyncMonad(function(env, cont) {
        var err, result;

        try {
          result = eval(str());
          return cont(right(result));
        } catch (_error) {
          err = _error;
          return cont(left(err));
        }
      });
    };
  });

  define('delay', function() {
    return function(timeout) {
      return makeMonad(function(env, cont) {
        return setTimeout((function() {
          return cont(_true);
        }), timeout());
      });
    };
  });

  define('altDef', function() {
    return function(name) {
      return function(alt) {
        return function(arity) {
          return function(def) {
            return makeMonad(function(env, cont) {
              var alts, i, info, newDef, nm;

              info = functionInfo[name()];
              if (!info) {
                info = functionInfo[name()] = {
                  src: '',
                  arity: -1,
                  alts: {},
                  altList: []
                };
              }
              if (!info.alts[alt()]) {
                info.altList.push(alt());
              }
              info.alts[alt()] = def;
              alts = (function() {
                var _i, _len, _ref2, _results;

                _ref2 = info.altList;
                _results = [];
                for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                  i = _ref2[_i];
                  _results.push(info.alts[i]);
                }
                return _results;
              })();
              newDef = curry(arity(), function(args) {
                var arg, opt, res, _i, _j, _k, _len, _len1, _len2;

                for (_i = 0, _len = alts.length; _i < _len; _i++) {
                  alt = alts[_i];
                  opt = alt();
                  for (_j = 0, _len1 = args.length; _j < _len1; _j++) {
                    arg = args[_j];
                    opt = opt(arg);
                  }
                  if (getType(opt) === 'some') {
                    return opt(function() {
                      return function(x) {
                        return x();
                      };
                    })(function() {
                      return _false;
                    });
                  }
                }
                if (info.mainDef) {
                  res = info.mainDef();
                  for (_k = 0, _len2 = args.length; _k < _len2; _k++) {
                    arg = args[_k];
                    res = res(arg);
                  }
                  return res;
                }
                throw new Error("No default definition for " + (name()));
              });
              nm = "L_" + (nameSub(name()));
              global[nm] = global.leisureFuncNames[nm] = newDef;
              return cont(def);
            });
          };
        };
      };
    };
  });

  curry = function(arity, func) {
    return function() {
      return subcurry(arity, func, []);
    };
  };

  subcurry = function(arity, func, args) {
    return function(arg) {
      args = args != null ? args : [];
      args.push(arg);
      if (arity === 1) {
        return func(args);
      } else {
        return subcurry(arity - 1, func, args);
      }
    };
  };

  makeHamt = function(hamt) {
    var t;

    t = setDataType((function() {}), 'hamt');
    t.hamt = hamt;
    t.type = 'hamt';
    return t;
  };

  hamt = makeHamt(amt.Trie());

  define('hamt', function() {
    return hamt;
  });

  define('hamtAssoc', function() {
    return function(key) {
      return function(value) {
        return function(hamt) {
          return makeHamt(amt.assoc(hamt().hamt, key(), value()));
        };
      };
    };
  });

  define('hamtFetch', function() {
    return function(key) {
      return function(hamt) {
        return amt.get(hamt().hamt, key());
      };
    };
  });

  define('hamtGet', function() {
    return function(key) {
      return function(hamt) {
        var v;

        v = amt.get(hamt().hamt, key());
        if (v !== null) {
          return some(v);
        } else {
          return none;
        }
      };
    };
  });

  define('hamtDissoc', function() {
    return function(key) {
      return function(hamt) {
        return makeHamt(amt.dissoc(hamt().hamt, key()));
      };
    };
  });

  define('hamtPairs', function() {
    return function(hamt) {
      return nextNode(L_cons()(function() {
        return hamt().hamt;
      })(function() {
        return L_nil();
      }));
    };
  });

  nextNode = function(stack) {
    var child, k, key, node, value, _fn, _fn1, _ref2, _ref3;

    while (true) {
      if (stack === L_nil()) {
        return stack;
      }
      node = L_head()(function() {
        return stack;
      });
      stack = L_tail()(function() {
        return stack;
      });
      switch (node.type) {
        case 'trie':
          _ref2 = node.children;
          _fn = function(c, s) {
            return stack = L_cons()(function() {
              return c;
            })(function() {
              return s;
            });
          };
          for (k in _ref2) {
            child = _ref2[k];
            _fn(child, stack);
          }
          break;
        case 'value':
          return L_acons()(function() {
            return node.key;
          })(function() {
            return node.value;
          })(function() {
            return nextNode(stack);
          });
        case 'hashmap':
          _ref3 = node.values;
          _fn1 = function(v, s) {
            return stack = L_cons()(function() {
              return v;
            })(function() {
              return s;
            });
          };
          for (key in _ref3) {
            value = _ref3[key];
            _fn1(value, stack);
          }
          break;
        default:
          console.log("UNKNOWN HAMT NODE TYPE: " + node.type);
      }
    }
  };

  ensureLeisureClass('token');

  Leisure_token.prototype.toString = function() {
    return "Token(" + (JSON.stringify(tokenString(this))) + ", " + (tokenPos(this)) + ")";
  };

  tokenString = function(t) {
    return t(function() {
      return function(txt) {
        return function(pos) {
          return txt();
        };
      };
    });
  };

  tokenPos = function(t) {
    return t(function() {
      return function(txt) {
        return function(pos) {
          return pos();
        };
      };
    });
  };

  ensureLeisureClass('parens');

  Leisure_parens.prototype.toString = function() {
    return "Parens(" + (parensStart(this)) + ", " + (parensEnd(this)) + ", " + (parensContent(this)) + ")";
  };

  parensStart = function(p) {
    return p(function() {
      return function(s) {
        return function(e) {
          return function(l) {
            return s();
          };
        };
      };
    });
  };

  parensEnd = function(p) {
    return p(function() {
      return function(s) {
        return function(e) {
          return function(l) {
            return e();
          };
        };
      };
    });
  };

  parensContent = function(p) {
    return p(function() {
      return function(s) {
        return function(e) {
          return function(l) {
            return l();
          };
        };
      };
    });
  };

  ensureLeisureClass('true');

  Leisure_true.prototype.toString = function() {
    return "true";
  };

  ensureLeisureClass('false');

  Leisure_false.prototype.toString = function() {
    return "false";
  };

  ensureLeisureClass('left');

  Leisure_left.prototype.toString = function() {
    return "Left(" + (this(function() {
      return _identity;
    })(function() {
      return _identity;
    })) + ")";
  };

  ensureLeisureClass('right');

  Leisure_right.prototype.toString = function() {
    return "Right(" + (this(function() {
      return _identity;
    })(function() {
      return _identity;
    })) + ")";
  };

  root._true = _true;

  root._false = _false;

  root.stateValues = values;

  root.runMonad = runMonad;

  root.newRunMonad = newRunMonad;

  root.isMonad = isMonad;

  root.identity = identity;

  root.setValue = setValue;

  root.getValue = getValue;

  root.makeMonad = makeMonad;

  root.makeSyncMonad = makeSyncMonad;

  root.replaceErr = replaceErr;

  root.left = left;

  root.right = right;

  root.getMonadSyncMode = getMonadSyncMode;

  root.asyncMonad = asyncMonad;

  root.setWarnAsync = setWarnAsync;

  root.call = call;

  root.callMonad = callMonad;

  root.basicCall = basicCall;

  root.booleanFor = booleanFor;

  root.newConsFrom = consFrom;

  if (typeof window !== "undefined" && window !== null) {
    window.runMonad = runMonad;
    window.setType = setType;
    window.setDataType = setDataType;
    window.defaultEnv = defaultEnv;
    window.identity = identity;
  }

}).call(this);

/*
//@ sourceMappingURL=runtime.map
*/
