<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>TODO.md</title>

</head>

<body>

<p><a href="README.html">Main</a> <a href="REFERENCE.html">Reference</a> <a href="TODO.html">Status</a> <a href="http://github.com/zot/leisure">Source</a> <a href="leisure.html">REPL</a> <a href="std.lsr">Standard functinos</a></p>

<h1>BUGS</h1>

<ul>
<li>notebook
<ul>
<li>clicking between func and expr dups last char</li>
<li>process button eats newlines at end</li>
<li>build should preserve outputs</li>
</ul></li>
</ul>

<h1>TODO</h1>

<ul>
<li>chippy demo
<ul>
<li>pan/zoom</li>
<li>Leisure-based mouse controls -- rotate rock with arrow keys</li>
</ul></li>
<li>notebook
<ul>
<li>use file system api
<ul>
<li>each webpage is a whole project and gets its own directory on the file system</li>
<li>each pre element needs a "filename" attr</li>
<li>store the contents of each pre element in the FS</li>
<li>use FS for autosave</li>
<li>"save-as" saves the web page</li>
</ul></li>
<li>incremental compilation (automatically recompile and update all errors)</li>
<li>function preconditions
<ul>
<li>"make precondition" button</li>
</ul></li>
<li>run test cases button
<ul>
<li>checkbox to run all tests on successful auto-build</li>
<li>auto build should clear tests on a recompile</li>
</ul></li>
<li>monad to present an html as an app</li>
<li>collapse auto exprs</li>
<li>command completion</li>
<li>make programs html pages with code attributes
<ul>
<li>in node, use htmlparser (npm install htmlparser)</li>
</ul></li>
<li>exprs that hang in the page should be commented out (JSON str): #@EXPR: '+ 1 2'</li>
<li>vision statements in default notebook</li>
<li>notebook-hide-source: monad to hide source</li>
<li>better formatting
<ul>
<li>comments, exprs, and test cases in column 1</li>
<li>defs in column 2</li>
<li>enclose def and corresponding comments/exprs/tests within a div</li>
<li>make tests collapseable</li>
<li>( -- maybe colums are better than this: group adjacent definitions into the same codeMain border)</li>
</ul></li>
<li>put hyperlinks in output to function definitions</li>
<li>use in-doc prompt, instad of popup</li>
<li>comments that attach event handlers?</li>
<li>optionally hide source code</li>
<li>collaboration</li>
</ul></li>
<li>keyword syntax
<ol>
<li>infix syntax, like Smalltalk?
<ul>
<li>map: m at: key -> value</li>
<li>map: m at: key put: value -> new map with key -> value</li>
</ul></li>
<li>create map arguments, like LISP?
<ul>
<li>map m at: key</li>
<li>map m at: key put: value</li>
</ul></li>
</ol></li>
<li>provide access to function ASTs at runtime</li>
<li>better error messages
<ul>
<li>debug mode should put a cons into funcs of a new error and the list from the parent
<ul>
<li>better runtime errors -- track the function name and ast</li>
<li>can use this to see the origin of a thunk</li>
</ul></li>
<li>accidental curries</li>
<li>macro for optional argument type checking</li>
</ul></li>
<li>cmd-line REPL
<ul>
<li>make nested require work</li>
<li>should parse HTML source files</li>
<li>should be multiline</li>
<li>more REPL cmds
<ul>
<li>:l should load file</li>
<li>:p to show primitives</li>
<li>:d command to show how a function is defined</li>
<li>save expr</li>
<li>run saved expr</li>
<li>save as a test case</li>
</ul></li>
</ul></li>
<li>configuration monads
<ul>
<li>default pretty-printers for output</li>
<li>run-test-cases -- run test cases after loading this file</li>
<li>set theme</li>
<li>defining monads that operate at parse-time</li>
</ul></li>
<li>test cases
<ul>
<li>make human-readable</li>
<li>add run-tests option to runRepl</li>
</ul></li>
<li>name spaces</li>
<li>number nodes so messages can refer to them -- just number them in an inorder traversal</li>
<li>change getType to return the type instead of an option, because it can never return a none</li>
<li>pretty printer function should take an assoc-list of printers for types</li>
<li>report indentation underflows</li>
<li>parser macros should return [ast, errors, warnings]
<ul>
<li>error if let/do has no expr</li>
<li>error if let finds more than one body expr</li>
</ul></li>
<li>add assertMonad() to testing.cs
<ul>
<li>probably use env for this</li>
<li>need to convert test runner to CPS</li>
</ul></li>
<li>use curlies for do/let?
<ul>
<li>handle groups properly with indentation</li>
<li>not sure what this means for indentation</li>
<li>remove intermediate step of inserting {}; -- convert directly to parenthesized groups</li>
<li>allow newlines in open groups</li>
<li>{ and } would be a grouping macros</li>
</ul></li>
<li>add prelude.lsr and put parser macros in there</li>
<li>integrate physics engine</li>
<li>multiline comments and strings, ala CoffeeScript</li>
<li>doc comments</li>
<li>allow eval to take either a string or an AST</li>
<li>better errors for file problems</li>
<li>if reqs aren't present when runing in browser, show error in output area or use alert if not in repl</li>
<li>fold, map, etc. for asts</li>
<li>make options also be monads</li>
<li>supertypes or something for things like booleans (true or false), options, eithers</li>
<li>library
<ul>
<li>string functions</li>
<li>Data structures
<ul>
<li>AMTs</li>
<li>HAMTs</li>
</ul></li>
<li>Leisure parser, generator, pretty printer, and REPL (compile and use the JS for them)</li>
<li>This will help people extend leisure</li>
</ul></li>
<li>-g option
<ul>
<li>check function types before application and print meaningful error msgs</li>
<li>generate trace</li>
</ul></li>
<li>example that reads strings and prints them until the user types 'quit'</li>
<li>infix function call syntax
<ul>
<li>allow 1.plus 2.plus 3 as an alternative to plus (plus 1 2) 3 (if @ is compose, @ (@ a b) c is a.@ b.@ c)</li>
<li>allow $ to separate expressions, so a $ b $ c is the same as (a) (b) (c) (use ~ instead?)</li>
</ul></li>
<li>generate currying functions at call sites
<ul>
<li>since cons is a global ref, cons a b -> <em>cons(a, b), instead of _cons()(a)(b)</li>
<li>cons a -> function(</em>1){return _cons(a, _1)}</li>
</ul></li>
<li>reorganize project -- make 'old' directory for old stuff that's still useful to have around (slides, etc.)</li>
<li>Generator improvements
<ul>
<li>eliminate redundant memo/deref pairs</li>
</ul></li>
<li><a href="http://research.microsoft.com/en-us/um/people/simonpj/Papers/optimistic/index.htm">optimistic evaluation</a>?</li>
<li>named parsers (alternate syntaxes)</li>
<li>macros
<ul>
<li>cond macro</li>
<li>make-struct which defines things for you, using definition monads</li>
<li>make [ a macro and remove need for commas
<ul>
<li>allow macros to define tokens</li>
<li>add helper function for defining [ macros, for varargs</li>
<li>bubba[ x x x ] seems like it would work fine as a token, because tokens are sorted by length, for matching purposes.</li>
<li>or[, and[, js[, concat[</li>
</ul></li>
</ul></li>
</ul>

<h1>DONE</h1>

<ul>
<li>a 'require' directive that works in browsers and on the cmd line
<ul>
<li>adding a script tag works in browsers, provided you're not violating access restrictions (the launch script can help with that)</li>
</ul></li>
<li>notebook style interface
<ul>
<li>run test cases button
<ul>
<li>result indicator</li>
</ul></li>
<li>show errors in output, but no make test case button if there's an error</li>
<li>cursor problems with highlight</li>
<li>highlight is wrong for defs</li>
<li>"save output as testcase" -- snapshot input and output as strings and record them as a testcase comment</li>
<li>highlighting fixes
<ul>
<li>end quote isn't highlighting</li>
<li>grouping tokens should highlight</li>
<li>when type at the beginning of a block, it puts the cursor in front of it</li>
</ul></li>
<li>auto-run exprs are gathered and executed after the file loads, then presented to indicate to the user that they auto-ran</li>
<li>load/save</li>
<li>handle nested require calls</li>
<li>make programs html pages with code attributes
<ul>
<li>in browser, use document.querySelector('[code]')</li>
<li>include &lt;script src='bootLeisure.js> element that boots the Leisure env on that page
<ul>
<li>clones doc</li>
<li>adds iframe with leisure env</li>
<li>hands leisure the clone to analyze and the current doc to mutate</li>
</ul></li>
</ul></li>
<li>move to bootLeisure.cs</li>
<li>prevent borders from taking up space in doc
<ul>
<li>separate divs by newlines</li>
<li>make divs position: relative; overflow: visible</li>
<li>use internal divs that are bigger than their parents</li>
</ul></li>
<li>make TTT into a notebook that shows the TTT grid</li>
<li>dynamically add expr box on naked input</li>
<li>monitor input and test first line to see if it changes between expr and def -- change box</li>
</ul></li>
<li>configuration monads
<ul>
<li>require</li>
</ul></li>
<li>make eval substitute macros</li>
<li>allow redefinition in REPL exprs</li>
<li>notebook style interface
<ul>
<li>get leisure.html working in notebook-style</li>
<li>make sure it runs in chrome and ff</li>
</ul></li>
<li>log function that prints while running (side effect)</li>
<li>scroll to bottom of browser on eval</li>
<li>when there are parsing or compilation errors, show which function has the problem</li>
<li>add floating point numbers to tokenDefs</li>
<li>let</li>
<li>throw error on undeclared variables -- require quotes for strings
<ul>
<li>parser macros should generate a wrapper at compile-time so that we can define things like let</li>
<li>need a way to handle macros</li>
</ul></li>
<li>parse primitive</li>
<li>replace withType with getType that returns an option</li>
<li>indentation tweak
<ul>
<li>indent line creates a nested expression</li>
</ul></li>
</ul>

<blockquote>
  <p>zip  </p>

<blockquote>
  <p>a <br />
  b</p>
</blockquote>

<p>is zip (a) (b)  </p>

<p>print "What is your name?" _. <br />
read \value . <br />
print (concat ["hello ", value, ", would you like a piece of toast?"] _ . <br />
read \value . <br />
((match value /[yY][eE][sS]/)  </p>

<blockquote>
  <p>print "Here, have one!") <br />
  print "Fine, be that way!")) _ .
print "OK, we're done." end</p>
</blockquote>

<p></blockquote></p>

<ul>
<li>parser improvements
<ul>
<li>a-b recursion?
<ul>
<li>it could do a pass to get function names, first</li>
</ul></li>
</ul></li>
<li>:r resets env in REPL</li>
<li>disallow redefinition</li>
<li>Run leisure in sandbox
<ul>
<li>Leisure.cs, std.lsr, prim.cs run in a sandbox
<ul>
<li>in browser, use an iframe with ifr.contentWindow.eval() to communicate
<ul>
<li>iframe.contentWindow holds globals</li>
<li>allow user to show or hide iframe (it's where SVG etc can be)</li>
</ul></li>
<li>in node, use VM.createContext and VM.runInContext to communicate
<ul>
<li>context holds globals</li>
</ul></li>
</ul></li>
<li>repl uses sandbox
<ul>
<li>allows for reloading, etc.</li>
</ul></li>
</ul></li>
<li>pretty print code</li>
<li>runRepl file should compile the file, eval it, and then stay in the REPL</li>
<li>get ! working on browser</li>
<li>file loading in browser</li>
<li>change to new parser</li>
<li>make bodiless lambdas eat newlines, to help with monads</li>
</ul>

<blockquote>
  <p>print "What is your name?" _. <br />
read \value . <br />
print (concat ["hello ", value, "."]) end</p>
</blockquote>

<ul>
<li>fix parser groups, etc.</li>
<li>monads and monad driver</li>
<li>primitive functions</li>
<li>simple pretty printing</li>
<li>change Standard Functions link in browser repl to paste them into the defs pane</li>
<li>separate out constant functions
<ul>
<li>so that
<ul>
<li>_cons = function(){return setDataType(function(_a){return setId(function(_b){return setType(function(_f){return _f()(_a)(_b)}, 33, 'cons')}, 32)}, 31, 'cons')}</li>
</ul></li>
<li>becomes
<ul>
<li>f_cons = setDataType(function(_a){return setId(function(_b){return setType(function(_f){return _f()(_a)(_b)}, 33, 'cons')}, 32)}, 31, 'cons')</li>
<li>_cons = function(){return f_cons}</li>
</ul></li>
</ul></li>
<li>implicit type names
<ul>
<li>if you define a function X that returns a function Y, the function Y gets "type" X</li>
<li>cons a b = \f . f a b
(cons 1 2) has type cons (the cons function is used as the type)</li>
<li><em>is value type -> true or false</li>
<li></em>is (cons 1 2) cons -> true</li>
</ul></li>
<li>use ! in REPL to evaluate JS</li>
<li>command line help (-h arg)</li>
<li>command line compile/run (-c file... or file...)</li>
<li>file compile: 
<ul>
<li>in REPL, use :c file</li>
<li>naked exprs are printed</li>
</ul></li>
<li>switched to coffeescript</li>
<li>REPL -- seems to work</li>
<li>parser improvements
<ul>
<li>quotes for names</li>
<li>each line is a definition -- main is the program
<ul>
<li>= expr runs expr (expr can also work if there is no '=' token in expr)</li>
</ul></li>
<li>allow args in definitions: func arg1 arg2 = body => func = \arg1 arg2 . body</li>
<li>allow implicit recursion?
<ul>
<li>seems like this should just work, for the compiled version</li>
</ul></li>
</ul></li>
</ul>

<h1>DEFERRED</h1>

</body>
</html>
