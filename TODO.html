<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>TODO.md</title>

</head>

<body>

<p><a href="README.html">Main</a> <a href="REFERENCE.html">Reference</a> <a href="TODO.html">Status</a> <a href="http://github.com/zot/leisure">Source</a> <a href="leisure.html">REPL</a> <a href="std.lsr">Standard functinos</a></p>

<h1>TODO</h1>

<ul>
<li>macros
<ul>
<li>cond macro</li>
</ul></li>
<li>configuration monads
<ul>
<li>require</li>
<li>default pretty-printers for output</li>
<li>run-test-cases -- run test cases after loading this file</li>
</ul></li>
<li>report indentation underflows</li>
<li>parser macros should return (ast, errors, warnings)</li>
<li>error if let/do has no expr</li>
<li>error if let finds more than one body expr</li>
<li>debug mode should put a cons into funcs of a new error and the list from the parent
<ul>
<li>can use this to see the origin of a thunk</li>
</ul></li>
<li>add assertMonad() to testing.cs
<ul>
<li>probably use env for this</li>
</ul></li>
<li>pretty printer function can take an assoc-list of printers for types</li>
<li>notebook style interface
<ul>
<li>make programs html pages with code attributes
<ul>
<li>in browser, use document.querySelector('[code]')</li>
<li>in node, use htmlparser (npm install htmlparser)</li>
<li>include \<script src='bootLeisure.js> element that boots the Leisure env on that page
<ul>
<li>clones doc</li>
<li>adds iframe with leisure env</li>
<li>hands leisure the clone to analyze and the current doc to mutate</li>
</ul></li>
</ul></li>
<li>exprs that hang in the page are commented out: #@EXPR: + 1 2</li>
<li>vision statements in default notebook</li>
<li>naked exprs are gathered and executed after the file loads, then presented to indicate to the user that they auto-run
<ul>
<li>notebook-hide-source: monad to hide source</li>
</ul></li>
<li>move to bootLeisure.cs</li>
<li>better formatting
<ul>
<li>comments, exprs, and test cases in column 1</li>
<li>defs in column 2</li>
<li>enclose def and corresponding comments/exprs/tests within a div</li>
<li>make tests collapseable</li>
<li>( -- maybe colums are better than this: group adjacent definitions into the same codeMain border)</li>
</ul></li>
<li>make cmd line runRepl parse HTML code files</li>
<li>put hyperlinks in output to function definitions</li>
<li>prevent borders from taking up space in doc
<ul>
<li>separate divs by newlines</li>
<li>make divs position: relative; overflow: visible</li>
<li>use internal divs that are bigger than their parents</li>
</ul></li>
<li>incremental compilation (recompile the file after a blank line and update all errors)
<ul>
<li>monitor input and test first line to see if it changes between expr and def -- change box</li>
<li>dynamically add expr box on naked input</li>
</ul></li>
<li>use in-doc prompt, instad of popup</li>
<li>"save output as testcase" -- snapshot input and output as strings and record them as a testcase comment</li>
<li>comments that attach event handlers?</li>
<li>make TTT into a notebook that shows the TTT grid</li>
<li>optionally hide source code</li>
<li>load/save</li>
</ul></li>
<li>a 'require' directive that works in browsers and on the cmd line
<ul>
<li>adding a script tag works in browsers, provided you're not violating access restrictions (the launch script can help with that)</li>
<li>collaboration</li>
</ul></li>
<li>use curlies for do/let?
<ul>
<li>not sure what this means for indentation</li>
<li>remove intermediate step of inserting {}; -- convert directly to parenthesized groups</li>
<li>allow newlines in open groups</li>
<li>{ and } would be a grouping macros</li>
</ul></li>
<li>add prelude.lsr
<ul>
<li>put parser macros in there</li>
</ul></li>
<li>integrate physics engine</li>
<li>doc comments</li>
<li>allow eval to take either a string or an AST</li>
<li>macros
<ul>
<li>cond macro</li>
<li>make [ a macro and remove need for commas
<ul>
<li>allow macros to define tokens</li>
<li>add helper function for defining [ macros, for varargs</li>
<li>bubba[ x x x ] seems like it would work fine as a token, because tokens are sorted by length, for matching purposes.</li>
<li>or[, and[, js[, concat[</li>
</ul></li>
</ul></li>
<li>:d command to show how a function is defined</li>
<li>multiline REPL</li>
<li>multiline comments and strings, ala CoffeeScript</li>
<li>better errors for file problems</li>
<li>if reqs aren't present when runing in browser, show error in output area or use alert if not in repl</li>
<li>fold, map, etc. for asts</li>
<li>make options also be monads</li>
<li>need supertypes or something for things like booleans (true or false), options, eithers</li>
<li>-g option
<ul>
<li>check function types before application and print meaningful error msgs</li>
<li>generate trace</li>
</ul></li>
<li>log function that prints while running (side effect)</li>
<li>:l should load file</li>
<li>example that reads strings and prints them until the user types 'quit'</li>
<li>:p to show primitives</li>
<li>infix function call syntax
<ul>
<li>allow 1.plus 2.plus 3 as an alternative to plus (plus 1 2) 3 (if @ is compose, @ (@ a b) c is a.@ b.@ c)</li>
<li>allow $ to separate expressions, so a $ b $ c is the same as (a) (b) (c) (use ~ instead?)</li>
</ul></li>
<li>generate currying functions at call sites
<ul>
<li>since cons is a global ref, cons a b -> <em>cons(a, b), instead of _cons()(a)(b)</li>
<li>cons a -> function(</em>1){return _cons(a, _1)}</li>
</ul></li>
<li>reorganize project -- make 'old' directory for old stuff that's still useful to have around (slides, etc.)</li>
<li>string functions</li>
<li>Data structures
<ul>
<li>AMTs</li>
<li>HAMTs</li>
</ul></li>
<li>leisure-code for pretty printing</li>
<li>Use leisure for parser, generator, REPL; compile them and use the JS for them
<ul>
<li>This will help people extend leisure</li>
</ul></li>
<li>Generator improvements
<ul>
<li>eliminate redundant memo/deref pairs</li>
</ul></li>
<li><a href="http://research.microsoft.com/en-us/um/people/simonpj/Papers/optimistic/index.htm">optimistic evaluation</a>?</li>
<li>named parsers</li>
</ul>

<h1>DONE</h1>

<ul>
<li>make eval substitute macros</li>
<li>allow redefinition in REPL exprs</li>
<li>notebook style interface
<ul>
<li>get leisure.html working in notebook-style</li>
<li>make sure it runs in chrome and ff</li>
</ul></li>
<li>scroll to bottom of browser on eval</li>
<li>when there are parsing or compilation errors, show which function has the problem</li>
<li>add floating point numbers to tokenDefs</li>
<li>let</li>
<li>throw error on undeclared variables -- require quotes for strings
<ul>
<li>parser macros should generate a wrapper at compile-time so that we can define things like let</li>
<li>need a way to handle macros</li>
</ul></li>
<li>parse primitive</li>
<li>replace withType with getType that returns an option</li>
<li>indentation tweak
<ul>
<li>indent line creates a nested expression</li>
</ul></li>
</ul>

<blockquote>
  <p>zip  </p>

<blockquote>
  <p>a <br />
  b</p>
</blockquote>

<p>is zip (a) (b)  </p>

<p>print "What is your name?" _. <br />
read \value . <br />
print (concat ["hello ", value, ", would you like a piece of toast?"] _ . <br />
read \value . <br />
((match value /[yY][eE][sS]/)  </p>

<blockquote>
  <p>print "Here, have one!") <br />
  print "Fine, be that way!")) _ .
print "OK, we're done." end</p>
</blockquote>

<p></blockquote></p>

<ul>
<li>parser improvements
<ul>
<li>a-b recursion?
<ul>
<li>it could do a pass to get function names, first</li>
</ul></li>
</ul></li>
<li>:r resets env in REPL</li>
<li>disallow redefinition</li>
<li>Run leisure in sandbox
<ul>
<li>Leisure.cs, std.lsr, prim.cs run in a sandbox
<ul>
<li>in browser, use an iframe with ifr.contentWindow.eval() to communicate
<ul>
<li>iframe.contentWindow holds globals</li>
<li>allow user to show or hide iframe (it's where SVG etc can be)</li>
</ul></li>
<li>in node, use VM.createContext and VM.runInContext to communicate
<ul>
<li>context holds globals</li>
</ul></li>
</ul></li>
<li>repl uses sandbox
<ul>
<li>allows for reloading, etc.</li>
</ul></li>
</ul></li>
<li>pretty print code</li>
<li>runRepl file should compile the file, eval it, and then stay in the REPL</li>
<li>get ! working on browser</li>
<li>file loading in browser</li>
<li>change to new parser</li>
<li>make bodiless lambdas eat newlines, to help with monads</li>
</ul>

<blockquote>
  <p>print "What is your name?" _. <br />
read \value . <br />
print (concat ["hello ", value, "."]) end</p>
</blockquote>

<ul>
<li>fix parser groups, etc.</li>
<li>monads and monad driver</li>
<li>primitive functions</li>
<li>simple pretty printing</li>
<li>change Standard Functions link in browser repl to paste them into the defs pane</li>
<li>separate out constant functions
<ul>
<li>so that
<ul>
<li>_cons = function(){return setDataType(function(_a){return setId(function(_b){return setType(function(_f){return _f()(_a)(_b)}, 33, 'cons')}, 32)}, 31, 'cons')}</li>
</ul></li>
<li>becomes
<ul>
<li>f_cons = setDataType(function(_a){return setId(function(_b){return setType(function(_f){return _f()(_a)(_b)}, 33, 'cons')}, 32)}, 31, 'cons')</li>
<li>_cons = function(){return f_cons}</li>
</ul></li>
</ul></li>
<li>implicit type names
<ul>
<li>if you define a function X that returns a function Y, the function Y gets "type" X</li>
<li>cons a b = \f . f a b
(cons 1 2) has type cons (the cons function is used as the type)</li>
<li><em>is value type -> true or false</li>
<li></em>is (cons 1 2) cons -> true</li>
</ul></li>
<li>use ! in REPL to evaluate JS</li>
<li>command line help (-h arg)</li>
<li>command line compile/run (-c file... or file...)</li>
<li>file compile: 
<ul>
<li>in REPL, use :c file</li>
<li>naked exprs are printed</li>
</ul></li>
<li>switched to coffeescript</li>
<li>REPL -- seems to work</li>
<li>parser improvements
<ul>
<li>quotes for names</li>
<li>each line is a definition -- main is the program
<ul>
<li>= expr runs expr (expr can also work if there is no '=' token in expr)</li>
</ul></li>
<li>allow args in definitions: func arg1 arg2 = body => func = \arg1 arg2 . body</li>
<li>allow implicit recursion?
<ul>
<li>seems like this should just work, for the compiled version</li>
</ul></li>
</ul></li>
</ul>

<h1>DEFERRED</h1>

</body>
</html>
