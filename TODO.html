<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>TODO.md</title>

</head>

<body>

<p><a href="README.html">Main</a> <a href="REFERENCE.html">Reference</a> <a href="TODO.html">Status</a> <a href="http://github.com/zot/leisure">Source</a> <a href="leisure.html">REPL</a> <a href="std.lsr">Standard functinos</a></p>

<h1>TODO</h1>

<ul>
<li>better browser environment
<ul>
<li>left side should be an editor</li>
<li>loading files should load them into the editor</li>
<li>input should be in a blinking box on the right side, not in an alert box</li>
<li>should be able to load *.lsr files into the environment</li>
</ul></li>
<li>use curlies for do/let
<ul>
<li>remove intermediate step of inserting {}; -- convert directly to parenthesized groups</li>
<li>allow newlines in open groups</li>
<li>{ and } would be a grouping macros</li>
</ul></li>
<li>debug mode should put a cons into funcs of a new exception and the list from the parent</li>
<li>macros should return an either for the parser</li>
<li>error if let finds more than one body expr</li>
<li>add prelude.lsr
<ul>
<li>put parser macros in there</li>
</ul></li>
<li>integrate physics engine</li>
<li>doc comments</li>
<li>macros
<ul>
<li>cond macro</li>
<li>make [ a macro and remove need for commas
<ul>
<li>allow macros to define tokens</li>
<li>add helper function for defining [ macros, for varargs</li>
<li>bubba[ x x x ] seems like it would work fine as a token, because tokens are sorted by length, for matching purposes.</li>
<li>or[, and[, js[, concat[</li>
</ul></li>
</ul></li>
<li>:d command to show how a function is defined</li>
<li>multiline REPL</li>
<li>allow redefinition in REPL exprs</li>
<li>multiline comments and strings, ala CoffeeScript</li>
<li>better errors for file problems</li>
<li>if reqs aren't present when runing in browser, show error in output area or use alert if not in repl</li>
<li>allow eval to take either a string or an AST</li>
<li>add assertMonad() to testing.cs</li>
<li>fold, map, etc. for asts</li>
<li>implement options that are monads and also support util functions</li>
<li>need supertypes or something for things like booleans (true or false)</li>
<li>-g option
<ul>
<li>check function types before application and print meaningful error msgs</li>
<li>generate trace</li>
</ul></li>
<li>log function that prints while running (side effect)</li>
<li>:l should load file</li>
<li>example that reads strings and prints them until the user types 'quit'</li>
<li>:p to show primitives</li>
<li>infix function call syntax
<ul>
<li>allow 1.plus 2.plus 3 as an alternative to plus (plus 1 2) 3 (if @ is compose, @ (@ a b) c is a.@ b.@ c)</li>
<li>allow $ to separate expressions, so a $ b $ c is the same as (a) (b) (c) (use ~ instead?)</li>
</ul></li>
<li>generate currying functions at call sites
<ul>
<li>since cons is a global ref, cons a b -> <em>cons(a, b), instead of _cons()(a)(b)</li>
<li>cons a -> function(</em>1){return _cons(a, _1)}</li>
</ul></li>
<li>reorganize project -- make 'old' directory for old stuff that's still useful to have around (slides, etc.)</li>
<li>string functions</li>
<li>leisure configuration environment
<ul>
<li>Pretty-printers for types</li>
<li>named parsers</li>
</ul></li>
<li>Data structures
<ul>
<li>AMTs</li>
</ul></li>
<li>leisure-code for pretty printing</li>
<li>Use leisure for parser, generator, REPL; compile them and use the JS for them
<ul>
<li>This will help people extend leisure</li>
</ul></li>
<li>Generator improvements
<ul>
<li>eliminate redundant memo/deref pairs</li>
</ul></li>
<li><a href="http://research.microsoft.com/en-us/um/people/simonpj/Papers/optimistic/index.htm">optimistic evaluation</a>?</li>
</ul>

<h1>DONE</h1>

<ul>
<li>scroll to bottom of browser on eval</li>
<li>when there are parsing or compilation errors, show which function has the problem</li>
<li>add floating point numbers to tokenDefs</li>
<li>let</li>
<li>throw error on undeclared variables -- require quotes for strings
<ul>
<li>parser macros should generate a wrapper at compile-time so that we can define things like let</li>
<li>need a way to handle macros</li>
</ul></li>
<li>parse primitive</li>
<li>replace withType with getType that returns an option</li>
<li>indentation tweak
<ul>
<li>indent line creates a nested expression</li>
</ul></li>
</ul>

<blockquote>
  <p>zip  </p>

<blockquote>
  <p>a <br />
  b</p>
</blockquote>

<p>is zip (a) (b)  </p>

<p>print "What is your name?" _. <br />
read \value . <br />
print (concat ["hello ", value, ", would you like a piece of toast?"] _ . <br />
read \value . <br />
((match value /[yY][eE][sS]/)  </p>

<blockquote>
  <p>print "Here, have one!") <br />
  print "Fine, be that way!")) _ .
print "OK, we're done." end</p>
</blockquote>

<p></blockquote></p>

<ul>
<li>parser improvements
<ul>
<li>a-b recursion?
<ul>
<li>it could do a pass to get function names, first</li>
</ul></li>
</ul></li>
<li>:r resets env in REPL</li>
<li>disallow redefinition</li>
<li>Run leisure in sandbox
<ul>
<li>Leisure.cs, std.lsr, prim.cs run in a sandbox
<ul>
<li>in browser, use an iframe with ifr.contentWindow.eval() to communicate
<ul>
<li>iframe.contentWindow holds globals</li>
<li>allow user to show or hide iframe (it's where SVG etc can be)</li>
</ul></li>
<li>in node, use VM.createContext and VM.runInContext to communicate
<ul>
<li>context holds globals</li>
</ul></li>
</ul></li>
<li>repl uses sandbox
<ul>
<li>allows for reloading, etc.</li>
</ul></li>
</ul></li>
<li>pretty print code</li>
<li>runRepl file should compile the file, eval it, and then stay in the REPL</li>
<li>get ! working on browser</li>
<li>file loading in browser</li>
<li>change to new parser</li>
<li>make bodiless lambdas eat newlines, to help with monads</li>
</ul>

<blockquote>
  <p>print "What is your name?" _. <br />
read \value . <br />
print (concat ["hello ", value, "."]) end</p>
</blockquote>

<ul>
<li>fix parser groups, etc.</li>
<li>monads and monad driver</li>
<li>primitive functions</li>
<li>simple pretty printing</li>
<li>change Standard Functions link in browser repl to paste them into the defs pane</li>
<li>separate out constant functions
<ul>
<li>so that
<ul>
<li>_cons = function(){return setDataType(function(_a){return setId(function(_b){return setType(function(_f){return _f()(_a)(_b)}, 33, 'cons')}, 32)}, 31, 'cons')}</li>
</ul></li>
<li>becomes
<ul>
<li>f_cons = setDataType(function(_a){return setId(function(_b){return setType(function(_f){return _f()(_a)(_b)}, 33, 'cons')}, 32)}, 31, 'cons')</li>
<li>_cons = function(){return f_cons}</li>
</ul></li>
</ul></li>
<li>implicit type names
<ul>
<li>if you define a function X that returns a function Y, the function Y gets "type" X</li>
<li>cons a b = \f . f a b
(cons 1 2) has type cons (the cons function is used as the type)</li>
<li><em>is value type -> true or false</li>
<li></em>is (cons 1 2) cons -> true</li>
</ul></li>
<li>use ! in REPL to evaluate JS</li>
<li>command line help (-h arg)</li>
<li>command line compile/run (-c file... or file...)</li>
<li>file compile: 
<ul>
<li>in REPL, use :c file</li>
<li>naked exprs are printed</li>
</ul></li>
<li>switched to coffeescript</li>
<li>REPL -- seems to work</li>
<li>parser improvements
<ul>
<li>quotes for names</li>
<li>each line is a definition -- main is the program
<ul>
<li>= expr runs expr (expr can also work if there is no '=' token in expr)</li>
</ul></li>
<li>allow args in definitions: func arg1 arg2 = body => func = \arg1 arg2 . body</li>
<li>allow implicit recursion?
<ul>
<li>seems like this should just work, for the compiled version</li>
</ul></li>
</ul></li>
</ul>

<h1>DEFERRED</h1>

</body>
</html>
