var std = (function(){
var root;

if ((typeof window !== 'undefined' && window !== null) && (!(typeof global !== 'undefined' && global !== null) || global === window)) {
  std = root = {};
  global = window;
} else {
  root = typeof exports !== 'undefined' && exports !== null ? exports : this;
  Parse = require('./parse');
  Leisure = require('./leisure');
  require('./prim');
  ReplCore = require('./replCore');
  Repl = require('./repl');
}
root.defs = {};
root.tokenDefs = [];
root.macros = {};

Nil = Parse.Nil;
var cons = Parse.cons;
var primCons = Parse.primCons;
var setType = Parse.setType;
var setDataType = Parse.setDataType;
var define = Parse.define;
var processResult = Repl.processResult;
var setContext = Leisure.setContext;
var funcContext = Leisure.funcContext;
var define = Parse.define;
var wrapContext = Leisure.wrapContext;
var markLeisureErrors = Leisure.markLeisureErrors;
var _dlempty, _dl, _dlPush, _dlAppend, _flatten, _subflatten, _subflatten, _remove, _removeIf, __removeIf, _removeIfNot, _filter, _any, __any, _all, __all, _find, _findIf, _findIfOpt, _findIndex, _subFindIndex, _subFindIndex, _take, __take, _takeWhile, __takeWhile, _drop, _dropWhile, _dropLast, __dropLast, _series, _from, _fromBy, _fromTo, _fromToBy, _count, _countIf, _countIfNot, _assocFromList, _assocKey, _assocValue, _assocGetPair, _assocGetPairOpt, _assocKeys, _assocNumKeys, _assocMergeKeys, _assocMerge, _assocSet, _assocGet, _assocGetWithDefault, _assocRemove, _html, _or$r, _primOrVar, _and$r, _primAndVar, _defInfixToken, _insertOperator, _insertOperator, _testInfix, _mainParseInfix, _parseInfix, _parseInfix, _parseInfix, _callParseInfixList, _printOperators, _parseInfixList, _getPrecedence, _getPrecedence, _operatorIn;
processResult(//AST(addParseFilter doFilter)
(_addParseFilter()(_doFilter)));
processResult(//AST(bind (defGroup "or[" "]") λ_ . defGroup "and[" "]")
(_bind()((function(){var $m; return (function(){return $m || ($m = (_defGroup()((function(){return "or["}))((function(){return "]"}))))})})())((function(){var $m; return (function(){return $m || ($m = (function(__){return _defGroup()((function(){return "and["}))((function(){return "]"}));}))})})())));
//dlempty = AST(id)
root.defs._dlempty = _dlempty = Parse.define('dlempty', (function _dlempty() {return ((_id()));}), 0, "id");;
//dl = AST(λitem rest . cons item rest)
root.defs._dl = _dl = Parse.define('dl', (function() {var f; return function _dl(){return f || (f = (Parse.setDataType(function(_item){return Parse.setType(function(_rest){return _cons()(_item)(_rest);}, 'dl');}, 'dl')));}})(), 1, "\\item . \\rest . [item | rest]");;
//dlPush = AST(λlist item . dlAppend list (dl item))
root.defs._dlPush = _dlPush = Parse.define('dlPush', (function() {var f; return function _dlPush(){return f || (f = (function(_list){return function(_item){return _dlAppend()(_list)((function(){var $m; return (function(){return $m || ($m = (_dl()(_item)))})})());};}));}})(), 2, "\\list item . dlAppend list (dl item)");;
//dlAppend = AST(λa b rest . a (b rest))
root.defs._dlAppend = _dlAppend = Parse.define('dlAppend', (function() {var f; return function _dlAppend(){return f || (f = (Parse.setDataType(function(_a){return function(_b){return Parse.setType(function(_rest){return _a()((function(){var $m; return (function(){return $m || ($m = (_b()(_rest)))})})());}, 'dlAppend');};}, 'dlAppend')));}})(), 2, "\\a b . \\rest . a (b rest)");;
//flatten = AST(λlist . subflatten list nil)
root.defs._flatten = _flatten = Parse.define('flatten', (function() {var f; return function _flatten(){return f || (f = (function(_list){return _subflatten()(_list)(_nil);}));}})(), 1, "\\list . subflatten list nil");;
//subflatten = AST(λlist . isStream list (dlAppend (subflatten (head list)) (subflatten (tail list))) (dl list))
root.defs._subflatten = _subflatten = Parse.define('subflatten', (function() {var f; return function _subflatten(){return f || (f = (function(_list){return _isStream()(_list)((function(){var $m; return (function(){return $m || ($m = (_dlAppend()((function(){var $m; return (function(){return $m || ($m = (_subflatten()((function(){var $m; return (function(){return $m || ($m = (_head()(_list)))})})())))})})())((function(){var $m; return (function(){return $m || ($m = (_subflatten()((function(){var $m; return (function(){return $m || ($m = (_tail()(_list)))})})())))})})())))})})())((function(){var $m; return (function(){return $m || ($m = (_dl()(_list)))})})());}));}})(), 1, "\\list . isStream list\n  dlAppend (subflatten (head list)) (subflatten (tail list))\n  dl list");;
//subflatten = AST(λlist . dlempty)
root.defs._subflatten = _subflatten = Leisure.makeDispatchFunction('subflatten', '_subflatten', '_list', ['_subflatten', '_list']);
Leisure.createMethod('nil', 'subflatten', "\\list      . dlempty", function(_list) {return _dlempty();});
//remove = AST(λx l . removeIf (eq x) l)
root.defs._remove = _remove = Parse.define('remove', (function() {var f; return function _remove(){return f || (f = (function(_x){return function(_l){return _removeIf()((function(){var $m; return (function(){return $m || ($m = (_eq()(_x)))})})())(_l);};}));}})(), 2, "\\x l . removeIf (eq x) l");;
//removeIf = AST(λf l . _removeIf (pairFunc l) f l)
root.defs._removeIf = _removeIf = Parse.define('removeIf', (function() {var f; return function _removeIf(){return f || (f = (function(_f){return function(_l){return __removeIf()((function(){var $m; return (function(){return $m || ($m = (_pairFunc()(_l)))})})())(_f)(_l);};}));}})(), 2, "\\f l . _removeIf (pairFunc l) f l");;
//_removeIf = AST(λpairF f l . if (eq l nil) nil (if (f (head l)) (_removeIf pairF f (tail l)) (pairF (head l) (_removeIf pairF f (tail l)))))
root.defs.__removeIf = __removeIf = Parse.define('_removeIf', (function() {var f; return function __removeIf(){return f || (f = (function(_pairF){return function(_f){return function(_l){return _if()((function(){var $m; return (function(){return $m || ($m = (_eq()(_l)(_nil)))})})())(_nil)((function(){var $m; return (function(){return $m || ($m = (_if()((function(){var $m; return (function(){return $m || ($m = (_f()((function(){var $m; return (function(){return $m || ($m = (_head()(_l)))})})())))})})())((function(){var $m; return (function(){return $m || ($m = (__removeIf()(_pairF)(_f)((function(){var $m; return (function(){return $m || ($m = (_tail()(_l)))})})())))})})())((function(){var $m; return (function(){return $m || ($m = (_pairF()((function(){var $m; return (function(){return $m || ($m = (_head()(_l)))})})())((function(){var $m; return (function(){return $m || ($m = (__removeIf()(_pairF)(_f)((function(){var $m; return (function(){return $m || ($m = (_tail()(_l)))})})())))})})())))})})())))})})());};};}));}})(), 3, "\\pairF f l . if (eq l nil) nil\n  if (f (head l)) (_removeIf pairF f (tail l))\n    pairF (head l) (_removeIf pairF f (tail l))");;
//removeIfNot = AST(λf l . removeIf λx . not (f x) l)
root.defs._removeIfNot = _removeIfNot = Parse.define('removeIfNot', (function() {var f; return function _removeIfNot(){return f || (f = (function(_f){return function(_l){return _removeIf()((function(){var $m; return (function(){return $m || ($m = (function(_x){return _not()((function(){var $m; return (function(){return $m || ($m = (_f()(_x)))})})());}))})})())(_l);};}));}})(), 2, "\\f l . removeIf (\\x. not (f x)) l");;
//filter = AST(λf . removeIf (compose not f))
root.defs._filter = _filter = Parse.define('filter', (function() {var f; return function _filter(){return f || (f = (function(_f){return _removeIf()((function(){var $m; return (function(){return $m || ($m = (_compose()(_not)(_f)))})})());}));}})(), 1, "\\f . removeIf (compose not f)");;
//any = AST(λf l . _any (pairFunc l) f l)
root.defs._any = _any = Parse.define('any', (function() {var f; return function _any(){return f || (f = (function(_f){return function(_l){return __any()((function(){var $m; return (function(){return $m || ($m = (_pairFunc()(_l)))})})())(_f)(_l);};}));}})(), 2, "\\f l . _any (pairFunc l) f l");;
//_any = AST(λpairF f l . null? l false (or (f (head l)) (_any pairF f (tail l))))
root.defs.__any = __any = Parse.define('_any', (function() {var f; return function __any(){return f || (f = (function(_pairF){return function(_f){return function(_l){return _null$e()(_l)(_false)((function(){var $m; return (function(){return $m || ($m = (_or()((function(){var $m; return (function(){return $m || ($m = (_f()((function(){var $m; return (function(){return $m || ($m = (_head()(_l)))})})())))})})())((function(){var $m; return (function(){return $m || ($m = (__any()(_pairF)(_f)((function(){var $m; return (function(){return $m || ($m = (_tail()(_l)))})})())))})})())))})})());};};}));}})(), 3, "\\pairF f l . null? l\n  false\n  or\n    f (head l)\n    _any pairF f (tail l)");;
//all = AST(λf l . _all (pairFunc l) f l)
root.defs._all = _all = Parse.define('all', (function() {var f; return function _all(){return f || (f = (function(_f){return function(_l){return __all()((function(){var $m; return (function(){return $m || ($m = (_pairFunc()(_l)))})})())(_f)(_l);};}));}})(), 2, "\\f l . _all (pairFunc l) f l");;
//_all = AST(λpairF f l . null? l true (and (f (head l)) (_all pairF f (tail l))))
root.defs.__all = __all = Parse.define('_all', (function() {var f; return function __all(){return f || (f = (function(_pairF){return function(_f){return function(_l){return _null$e()(_l)(_true)((function(){var $m; return (function(){return $m || ($m = (_and()((function(){var $m; return (function(){return $m || ($m = (_f()((function(){var $m; return (function(){return $m || ($m = (_head()(_l)))})})())))})})())((function(){var $m; return (function(){return $m || ($m = (__all()(_pairF)(_f)((function(){var $m; return (function(){return $m || ($m = (_tail()(_l)))})})())))})})())))})})());};};}));}})(), 3, "\\pairF f l . null? l\n  true\n  and\n    f (head l)\n    _all pairF f (tail l)");;
//find = AST(λx l . findIf (eq x) l)
root.defs._find = _find = Parse.define('find', (function() {var f; return function _find(){return f || (f = (function(_x){return function(_l){return _findIf()((function(){var $m; return (function(){return $m || ($m = (_eq()(_x)))})})())(_l);};}));}})(), 2, "\\x l . findIf (eq x) l");;
//findIf = AST(λf l . null? l nil (f (head l) (head l) (findIf f (tail l))))
root.defs._findIf = _findIf = Parse.define('findIf', (function() {var f; return function _findIf(){return f || (f = (function(_f){return function(_l){return _null$e()(_l)(_nil)((function(){var $m; return (function(){return $m || ($m = (_f()((function(){var $m; return (function(){return $m || ($m = (_head()(_l)))})})())((function(){var $m; return (function(){return $m || ($m = (_head()(_l)))})})())((function(){var $m; return (function(){return $m || ($m = (_findIf()(_f)((function(){var $m; return (function(){return $m || ($m = (_tail()(_l)))})})())))})})())))})})());};}));}})(), 2, "\\f l . null? l\n  nil\n  f (head l)\n    head l\n    findIf f (tail l)");;
//findIfOpt = AST(λf l . null? l none (f (head l) (some (head l)) (findIfOpt f (tail l))))
root.defs._findIfOpt = _findIfOpt = Parse.define('findIfOpt', (function() {var f; return function _findIfOpt(){return f || (f = (function(_f){return function(_l){return _null$e()(_l)(_none)((function(){var $m; return (function(){return $m || ($m = (_f()((function(){var $m; return (function(){return $m || ($m = (_head()(_l)))})})())((function(){var $m; return (function(){return $m || ($m = (_some()((function(){var $m; return (function(){return $m || ($m = (_head()(_l)))})})())))})})())((function(){var $m; return (function(){return $m || ($m = (_findIfOpt()(_f)((function(){var $m; return (function(){return $m || ($m = (_tail()(_l)))})})())))})})())))})})());};}));}})(), 2, "\\f l . null? l\n  none\n  f (head l)\n    some (head l)\n    findIfOpt f (tail l)");;
//findIndex = AST(λfunc list . subFindIndex 0 func list)
root.defs._findIndex = _findIndex = Parse.define('findIndex', (function() {var f; return function _findIndex(){return f || (f = (function(_func){return function(_list){return _subFindIndex()((function(){return 0}))(_func)(_list);};}));}})(), 2, "\\func list . subFindIndex 0 func list");;
//subFindIndex = AST(λindex func list . func (head list) index (subFindIndex (+ 1 index) func (tail list)))
root.defs._subFindIndex = _subFindIndex = Parse.define('subFindIndex', (function() {var f; return function _subFindIndex(){return f || (f = (function(_index){return function(_func){return function(_list){return _func()((function(){var $m; return (function(){return $m || ($m = (_head()(_list)))})})())(_index)((function(){var $m; return (function(){return $m || ($m = (_subFindIndex()((function(){var $m; return (function(){return $m || ($m = (_$o()((function(){return 1}))(_index)))})})())(_func)((function(){var $m; return (function(){return $m || ($m = (_tail()(_list)))})})())))})})());};};}));}})(), 3, "\\index func list . func (head list)\n  index\n  subFindIndex (+ 1 index) func (tail list)");;
//subFindIndex = AST(λindex func list . -1)
root.defs._subFindIndex = _subFindIndex = Leisure.makeDispatchFunction('subFindIndex', '_subFindIndex', '_list', ['_subFindIndex', '_index', '_func', '_list']);
Leisure.createMethod('nil', 'subFindIndex', "\\index func list      . -1", function(_index, _func, _list) {return -1;});
//take = AST(λn list . _take (pairFunc list) n list)
root.defs._take = _take = Parse.define('take', (function() {var f; return function _take(){return f || (f = (function(_n){return function(_list){return __take()((function(){var $m; return (function(){return $m || ($m = (_pairFunc()(_list)))})})())(_n)(_list);};}));}})(), 2, "\\n list . _take (pairFunc list) n list");;
//_take = AST(λpairF n list . positive n (null? list nil (pairF (head list) (_take pairF (-- n) (tail list)))) nil)
root.defs.__take = __take = Parse.define('_take', (function() {var f; return function __take(){return f || (f = (function(_pairF){return function(_n){return function(_list){return _positive()(_n)((function(){var $m; return (function(){return $m || ($m = (_null$e()(_list)(_nil)((function(){var $m; return (function(){return $m || ($m = (_pairF()((function(){var $m; return (function(){return $m || ($m = (_head()(_list)))})})())((function(){var $m; return (function(){return $m || ($m = (__take()(_pairF)((function(){var $m; return (function(){return $m || ($m = (_$_$_()(_n)))})})())((function(){var $m; return (function(){return $m || ($m = (_tail()(_list)))})})())))})})())))})})())))})})())(_nil);};};}));}})(), 3, "\\pairF n list . positive n\n  null? list\n    nil\n    pairF (head list) (_take pairF (-- n) (tail list))\n  nil");;
//takeWhile = AST(λpredicate list . _takeWhile (pairFunc list) predicate list)
root.defs._takeWhile = _takeWhile = Parse.define('takeWhile', (function() {var f; return function _takeWhile(){return f || (f = (function(_predicate){return function(_list){return __takeWhile()((function(){var $m; return (function(){return $m || ($m = (_pairFunc()(_list)))})})())(_predicate)(_list);};}));}})(), 2, "\\predicate list . _takeWhile (pairFunc list) predicate list");;
//_takeWhile = AST(λpairF predicate list . null? list nil (predicate (head list) (pairF (head list) (_takeWhile pairF predicate (tail list))) nil))
root.defs.__takeWhile = __takeWhile = Parse.define('_takeWhile', (function() {var f; return function __takeWhile(){return f || (f = (function(_pairF){return function(_predicate){return function(_list){return _null$e()(_list)(_nil)((function(){var $m; return (function(){return $m || ($m = (_predicate()((function(){var $m; return (function(){return $m || ($m = (_head()(_list)))})})())((function(){var $m; return (function(){return $m || ($m = (_pairF()((function(){var $m; return (function(){return $m || ($m = (_head()(_list)))})})())((function(){var $m; return (function(){return $m || ($m = (__takeWhile()(_pairF)(_predicate)((function(){var $m; return (function(){return $m || ($m = (_tail()(_list)))})})())))})})())))})})())(_nil)))})})());};};}));}})(), 3, "\\pairF predicate list . null? list\n  nil\n  predicate (head list)\n    pairF (head list) (_takeWhile pairF predicate (tail list))\n    nil");;
//drop = AST(λx list . positive x (null? list nil (drop (-- x) (tail list))) list)
root.defs._drop = _drop = Parse.define('drop', (function() {var f; return function _drop(){return f || (f = (function(_x){return function(_list){return _positive()(_x)((function(){var $m; return (function(){return $m || ($m = (_null$e()(_list)(_nil)((function(){var $m; return (function(){return $m || ($m = (_drop()((function(){var $m; return (function(){return $m || ($m = (_$_$_()(_x)))})})())((function(){var $m; return (function(){return $m || ($m = (_tail()(_list)))})})())))})})())))})})())(_list);};}));}})(), 2, "\\x list . positive x\n  null? list\n    nil\n    drop (-- x) (tail list)\n  list");;
//dropWhile = AST(λpredicate list . null? list nil (predicate (head list) (dropWhile predicate (tail list)) list))
root.defs._dropWhile = _dropWhile = Parse.define('dropWhile', (function() {var f; return function _dropWhile(){return f || (f = (function(_predicate){return function(_list){return _null$e()(_list)(_nil)((function(){var $m; return (function(){return $m || ($m = (_predicate()((function(){var $m; return (function(){return $m || ($m = (_head()(_list)))})})())((function(){var $m; return (function(){return $m || ($m = (_dropWhile()(_predicate)((function(){var $m; return (function(){return $m || ($m = (_tail()(_list)))})})())))})})())(_list)))})})());};}));}})(), 2, "\\predicate list . null? list\n  nil\n  predicate (head list)\n    dropWhile predicate (tail list)\n    list");;
//dropLast = AST(λn list . tail (_dropLast (pairFunc list) n list))
root.defs._dropLast = _dropLast = Parse.define('dropLast', (function() {var f; return function _dropLast(){return f || (f = (function(_n){return function(_list){return _tail()((function(){var $m; return (function(){return $m || ($m = (__dropLast()((function(){var $m; return (function(){return $m || ($m = (_pairFunc()(_list)))})})())(_n)(_list)))})})());};}));}})(), 2, "\\n list . tail (_dropLast (pairFunc list) n list)");;
//_dropLast = AST(λpairF n list . eq list nil (cons 0 nil) ((λnext . gt n (head next) (cons (+ 1 (head next)) nil) (cons n (pairF (head list) (tail next)))) (_dropLast pairF n (tail list))))
root.defs.__dropLast = __dropLast = Parse.define('_dropLast', (function() {var f; return function __dropLast(){return f || (f = (function(_pairF){return function(_n){return function(_list){return _eq()(_list)(_nil)((function(){var $m; return (function(){return $m || ($m = (_cons()((function(){return 0}))(_nil)))})})())((function(){var $m; return (function(){return $m || ($m = (function(_next){return _gt()(_n)((function(){var $m; return (function(){return $m || ($m = (_head()(_next)))})})())((function(){var $m; return (function(){return $m || ($m = (_cons()((function(){var $m; return (function(){return $m || ($m = (_$o()((function(){return 1}))((function(){var $m; return (function(){return $m || ($m = (_head()(_next)))})})())))})})())(_nil)))})})())((function(){var $m; return (function(){return $m || ($m = (_cons()(_n)((function(){var $m; return (function(){return $m || ($m = (_pairF()((function(){var $m; return (function(){return $m || ($m = (_head()(_list)))})})())((function(){var $m; return (function(){return $m || ($m = (_tail()(_next)))})})())))})})())))})})());}((function(){var $m; return (function(){return $m || ($m = (__dropLast()(_pairF)(_n)((function(){var $m; return (function(){return $m || ($m = (_tail()(_list)))})})())))})})())))})})());};};}));}})(), 3, "\\pairF n list . eq list nil\n  [0]\n  (\\next . gt n (head next)\n    [(+ 1 (head next))]\n    [n | (pairF (head list) (tail next))]) (_dropLast pairF n (tail list))");;
//series = AST(λfunc n . cons n (series func (func n)))
root.defs._series = _series = Parse.define('series', (function() {var f; return function _series(){return f || (f = (function(_func){return function(_n){return _cons()(_n)((function(){var $m; return (function(){return $m || ($m = (_series()(_func)((function(){var $m; return (function(){return $m || ($m = (_func()(_n)))})})())))})})());};}));}})(), 2, "\\func n . [n | (series func (func n))]");;
//from = AST(λn . series ++ n)
root.defs._from = _from = Parse.define('from', (function() {var f; return function _from(){return f || (f = (function(_n){return _series()(_$o$o)(_n);}));}})(), 1, "\\n . series ++ n");;
//fromBy = AST(λn inc . series (+ inc) n)
root.defs._fromBy = _fromBy = Parse.define('fromBy', (function() {var f; return function _fromBy(){return f || (f = (function(_n){return function(_inc){return _series()((function(){var $m; return (function(){return $m || ($m = (_$o()(_inc)))})})())(_n);};}));}})(), 2, "\\n inc . series (+ inc) n");;
//fromTo = AST(λn m . takeWhile (> m) (from n))
root.defs._fromTo = _fromTo = Parse.define('fromTo', (function() {var f; return function _fromTo(){return f || (f = (function(_n){return function(_m){return _takeWhile()((function(){var $m; return (function(){return $m || ($m = (_$z()(_m)))})})())((function(){var $m; return (function(){return $m || ($m = (_from()(_n)))})})());};}));}})(), 2, "\\n m . takeWhile (> m) (from n)");;
//fromToBy = AST(λn m inc . takeWhile (> m) (fromBy n inc))
root.defs._fromToBy = _fromToBy = Parse.define('fromToBy', (function() {var f; return function _fromToBy(){return f || (f = (function(_n){return function(_m){return function(_inc){return _takeWhile()((function(){var $m; return (function(){return $m || ($m = (_$z()(_m)))})})())((function(){var $m; return (function(){return $m || ($m = (_fromBy()(_n)(_inc)))})})());};};}));}})(), 3, "\\n m inc . takeWhile (> m) (fromBy n inc)");;
//count = AST(λx l . countIf (eq x) l)
root.defs._count = _count = Parse.define('count', (function() {var f; return function _count(){return f || (f = (function(_x){return function(_l){return _countIf()((function(){var $m; return (function(){return $m || ($m = (_eq()(_x)))})})())(_l);};}));}})(), 2, "\\x l . countIf (eq x) l");;
//countIf = AST(λf l . if (eq l nil) 0 (+ (f (head l) 1 0) (countIf f (tail l))))
root.defs._countIf = _countIf = Parse.define('countIf', (function() {var f; return function _countIf(){return f || (f = (function(_f){return function(_l){return _if()((function(){var $m; return (function(){return $m || ($m = (_eq()(_l)(_nil)))})})())((function(){return 0}))((function(){var $m; return (function(){return $m || ($m = (_$o()((function(){var $m; return (function(){return $m || ($m = (_f()((function(){var $m; return (function(){return $m || ($m = (_head()(_l)))})})())((function(){return 1}))((function(){return 0}))))})})())((function(){var $m; return (function(){return $m || ($m = (_countIf()(_f)((function(){var $m; return (function(){return $m || ($m = (_tail()(_l)))})})())))})})())))})})());};}));}})(), 2, "\\f l . if (eq l nil) 0\n  + (f (head l) 1 0) (countIf f (tail l))");;
//countIfNot = AST(λf l . countIf λx . not (f x) l)
root.defs._countIfNot = _countIfNot = Parse.define('countIfNot', (function() {var f; return function _countIfNot(){return f || (f = (function(_f){return function(_l){return _countIf()((function(){var $m; return (function(){return $m || ($m = (function(_x){return _not()((function(){var $m; return (function(){return $m || ($m = (_f()(_x)))})})());}))})})())(_l);};}));}})(), 2, "\\f l . countIf (\\x. not (f x)) l");;
//assocFromList = AST(λl . if (null? l) nil (assocSet (head l) (head (tail l)) (assocFromList (tail (tail l)))))
root.defs._assocFromList = _assocFromList = Parse.define('assocFromList', (function() {var f; return function _assocFromList(){return f || (f = (function(_l){return _if()((function(){var $m; return (function(){return $m || ($m = (_null$e()(_l)))})})())(_nil)((function(){var $m; return (function(){return $m || ($m = (_assocSet()((function(){var $m; return (function(){return $m || ($m = (_head()(_l)))})})())((function(){var $m; return (function(){return $m || ($m = (_head()((function(){var $m; return (function(){return $m || ($m = (_tail()(_l)))})})())))})})())((function(){var $m; return (function(){return $m || ($m = (_assocFromList()((function(){var $m; return (function(){return $m || ($m = (_tail()((function(){var $m; return (function(){return $m || ($m = (_tail()(_l)))})})())))})})())))})})())))})})());}));}})(), 1, "\\l . if (null? l) nil\n  assocSet (head l) (head (tail l)) (assocFromList (tail (tail l)))");;
//assocKey = AST(λcons . head cons)
root.defs._assocKey = _assocKey = Parse.define('assocKey', (function() {var f; return function _assocKey(){return f || (f = (function(_cons){return _head()(_cons);}));}})(), 1, "\\cons . head cons");;
//assocValue = AST(λcons . tail cons)
root.defs._assocValue = _assocValue = Parse.define('assocValue', (function() {var f; return function _assocValue(){return f || (f = (function(_cons){return _tail()(_cons);}));}})(), 1, "\\cons . tail cons");;
//assocGetPair = AST(λk anAssoc . findIf λx . eq (head x) k anAssoc)
root.defs._assocGetPair = _assocGetPair = Parse.define('assocGetPair', (function() {var f; return function _assocGetPair(){return f || (f = (function(_k){return function(_anAssoc){return _findIf()((function(){var $m; return (function(){return $m || ($m = (function(_x){return _eq()((function(){var $m; return (function(){return $m || ($m = (_head()(_x)))})})())(_k);}))})})())(_anAssoc);};}));}})(), 2, "\\k anAssoc . findIf (\\x . eq (head x) k) anAssoc");;
//assocGetPairOpt = AST(λk l . l λh t D . h λkk vv . eq k kk (some2 kk vv) (assocGetPairOpt k t) none)
root.defs._assocGetPairOpt = _assocGetPairOpt = Parse.define('assocGetPairOpt', (function() {var f; return function _assocGetPairOpt(){return f || (f = (function(_k){return function(_l){return _l()((function(){var $m; return (function(){return $m || ($m = (function(_h){return function(_t){return function(_D){return _h()((function(){var $m; return (function(){return $m || ($m = (function(_kk){return function(_vv){return _eq()(_k)(_kk)((function(){var $m; return (function(){return $m || ($m = (_some2()(_kk)(_vv)))})})())((function(){var $m; return (function(){return $m || ($m = (_assocGetPairOpt()(_k)(_t)))})})());};}))})})());};};}))})})())(_none);};}));}})(), 2, "\\k l . l (\\h t D . h (\\kk vv . (eq k kk) (some2 kk vv) (assocGetPairOpt k t))) none");;
//assocKeys = AST(λanAssoc . map λcell . assocKey cell anAssoc)
root.defs._assocKeys = _assocKeys = Parse.define('assocKeys', (function() {var f; return function _assocKeys(){return f || (f = (function(_anAssoc){return _map()((function(){var $m; return (function(){return $m || ($m = (function(_cell){return _assocKey()(_cell);}))})})())(_anAssoc);}));}})(), 1, "\\anAssoc . map (\\cell . (assocKey cell)) anAssoc");;
//assocNumKeys = AST(λanAssoc . length (assocKeys anAssoc))
root.defs._assocNumKeys = _assocNumKeys = Parse.define('assocNumKeys', (function() {var f; return function _assocNumKeys(){return f || (f = (function(_anAssoc){return _length()((function(){var $m; return (function(){return $m || ($m = (_assocKeys()(_anAssoc)))})})());}));}})(), 1, "\\anAssoc . length (assocKeys anAssoc)");;
//assocMergeKeys = AST(λhm1 hm2 keys . if (null? keys) hm1 (if (null? (assocGetPair (head keys) hm1)) (cons (assocGetPair (head keys) hm2) (assocMergeKeys hm1 hm2 (tail keys))) (assocMergeKeys hm1 hm2 (tail keys))))
root.defs._assocMergeKeys = _assocMergeKeys = Parse.define('assocMergeKeys', (function() {var f; return function _assocMergeKeys(){return f || (f = (function(_hm1){return function(_hm2){return function(_keys){return _if()((function(){var $m; return (function(){return $m || ($m = (_null$e()(_keys)))})})())(_hm1)((function(){var $m; return (function(){return $m || ($m = (_if()((function(){var $m; return (function(){return $m || ($m = (_null$e()((function(){var $m; return (function(){return $m || ($m = (_assocGetPair()((function(){var $m; return (function(){return $m || ($m = (_head()(_keys)))})})())(_hm1)))})})())))})})())((function(){var $m; return (function(){return $m || ($m = (_cons()((function(){var $m; return (function(){return $m || ($m = (_assocGetPair()((function(){var $m; return (function(){return $m || ($m = (_head()(_keys)))})})())(_hm2)))})})())((function(){var $m; return (function(){return $m || ($m = (_assocMergeKeys()(_hm1)(_hm2)((function(){var $m; return (function(){return $m || ($m = (_tail()(_keys)))})})())))})})())))})})())((function(){var $m; return (function(){return $m || ($m = (_assocMergeKeys()(_hm1)(_hm2)((function(){var $m; return (function(){return $m || ($m = (_tail()(_keys)))})})())))})})())))})})());};};}));}})(), 3, "\\hm1 hm2 keys . if (null? keys) hm1\n  if (null? (assocGetPair (head keys) hm1) )\n    [(assocGetPair (head keys) hm2) | (assocMergeKeys hm1 hm2 (tail keys))]\n    assocMergeKeys hm1 hm2 (tail keys)");;
//assocMerge = AST(λhm1 hm2 . assocMergeKeys hm1 hm2 (assocKeys hm2))
root.defs._assocMerge = _assocMerge = Parse.define('assocMerge', (function() {var f; return function _assocMerge(){return f || (f = (function(_hm1){return function(_hm2){return _assocMergeKeys()(_hm1)(_hm2)((function(){var $m; return (function(){return $m || ($m = (_assocKeys()(_hm2)))})})());};}));}})(), 2, "\\hm1 hm2 . assocMergeKeys hm1 hm2 (assocKeys hm2)");;
//assocSet = AST(λk v anAssoc . cons (cons k v) (assocRemove k anAssoc))
root.defs._assocSet = _assocSet = Parse.define('assocSet', (function() {var f; return function _assocSet(){return f || (f = (function(_k){return function(_v){return function(_anAssoc){return _cons()((function(){var $m; return (function(){return $m || ($m = (_cons()(_k)(_v)))})})())((function(){var $m; return (function(){return $m || ($m = (_assocRemove()(_k)(_anAssoc)))})})());};};}));}})(), 3, "\\k v anAssoc . [(cons k v) | (assocRemove k anAssoc)]");;
//assocGet = AST(λk anAssoc . assocGetPair k anAssoc λh t D . some h none)
root.defs._assocGet = _assocGet = Parse.define('assocGet', (function() {var f; return function _assocGet(){return f || (f = (function(_k){return function(_anAssoc){return _assocGetPair()(_k)(_anAssoc)((function(){var $m; return (function(){return $m || ($m = (function(_h){return function(_t){return function(_D){return _some()(_h);};};}))})})())(_none);};}));}})(), 2, "\\k anAssoc . (assocGetPair k anAssoc) (\\h t D . some h) none");;
//assocGetWithDefault = AST(λk default anAssoc . assocGetPair k anAssoc λh t D . t default)
root.defs._assocGetWithDefault = _assocGetWithDefault = Parse.define('assocGetWithDefault', (function() {var f; return function _assocGetWithDefault(){return f || (f = (function(_k){return function(_default){return function(_anAssoc){return _assocGetPair()(_k)(_anAssoc)((function(){var $m; return (function(){return $m || ($m = (function(_h){return function(_t){return function(_D){return _t();};};}))})})())(_default);};};}));}})(), 3, "\\k default anAssoc . (assocGetPair k anAssoc) (\\h t D . t) default");;
//assocRemove = AST(λk anAssoc . removeIf λx . eq (assocKey x) k anAssoc)
root.defs._assocRemove = _assocRemove = Parse.define('assocRemove', (function() {var f; return function _assocRemove(){return f || (f = (function(_k){return function(_anAssoc){return _removeIf()((function(){var $m; return (function(){return $m || ($m = (function(_x){return _eq()((function(){var $m; return (function(){return $m || ($m = (_assocKey()(_x)))})})())(_k);}))})})())(_anAssoc);};}));}})(), 2, "\\k anAssoc . removeIf (\\x . eq (assocKey x) k) anAssoc");;
//html = AST(λx f . f x)
root.defs._html = _html = Parse.define('html', (function() {var f; return function _html(){return f || (f = (Parse.setDataType(function(_x){return Parse.setType(function(_f){return _f()(_x);}, 'html');}, 'html')));}})(), 1, "\\x . \\f . f x");;
//or[ = AST(λlist . primOrVar list (dropLast 1 (tail list)))
root.defs._or$r = _or$r = Parse.defineMacro('or[', (function() {var f; return function _or$r(){return f || (f = (function(_list){return _primOrVar()(_list)((function(){var $m; return (function(){return $m || ($m = (_dropLast()((function(){return 1}))((function(){var $m; return (function(){return $m || ($m = (_tail()(_list)))})})())))})})());}));}})(), 1, "\\list . primOrVar list (dropLast 1 (tail list))");
root.tokenDefs.push('or[', '=M=');;
//primOrVar = AST(λlist args . eq args nil (cons "true" nil) (eq (tail args) nil args (foldr1 λv el . cons "or" (cons v (cons el nil)) args)))
root.defs._primOrVar = _primOrVar = Parse.define('primOrVar', (function() {var f; return function _primOrVar(){return f || (f = (function(_list){return function(_args){return _eq()(_args)(_nil)((function(){var $m; return (function(){return $m || ($m = (_cons()((function(){return "true"}))(_nil)))})})())((function(){var $m; return (function(){return $m || ($m = (_eq()((function(){var $m; return (function(){return $m || ($m = (_tail()(_args)))})})())(_nil)(_args)((function(){var $m; return (function(){return $m || ($m = (_foldr1()((function(){var $m; return (function(){return $m || ($m = (function(_v){return function(_el){return _cons()((function(){return "or"}))((function(){var $m; return (function(){return $m || ($m = (_cons()(_v)((function(){var $m; return (function(){return $m || ($m = (_cons()(_el)(_nil)))})})())))})})());};}))})})())(_args)))})})())))})})());};}));}})(), 2, "\\list args . eq args nil\n  ['true']\n  eq (tail args) nil\n    args\n    foldr1 (\\v el . ['or' v el]) args");;
//and[ = AST(λlist . primAndVar list (dropLast 1 (tail list)))
root.defs._and$r = _and$r = Parse.defineMacro('and[', (function() {var f; return function _and$r(){return f || (f = (function(_list){return _primAndVar()(_list)((function(){var $m; return (function(){return $m || ($m = (_dropLast()((function(){return 1}))((function(){var $m; return (function(){return $m || ($m = (_tail()(_list)))})})())))})})());}));}})(), 1, "\\list . primAndVar list (dropLast 1 (tail list))");
root.tokenDefs.push('and[', '=M=');;
//primAndVar = AST(λlist args . eq args nil (cons "false" nil) (eq (tail args) nil args (foldr1 λv el . cons "and" (cons v (cons el nil)) args)))
root.defs._primAndVar = _primAndVar = Parse.define('primAndVar', (function() {var f; return function _primAndVar(){return f || (f = (function(_list){return function(_args){return _eq()(_args)(_nil)((function(){var $m; return (function(){return $m || ($m = (_cons()((function(){return "false"}))(_nil)))})})())((function(){var $m; return (function(){return $m || ($m = (_eq()((function(){var $m; return (function(){return $m || ($m = (_tail()(_args)))})})())(_nil)(_args)((function(){var $m; return (function(){return $m || ($m = (_foldr1()((function(){var $m; return (function(){return $m || ($m = (function(_v){return function(_el){return _cons()((function(){return "and"}))((function(){var $m; return (function(){return $m || ($m = (_cons()(_v)((function(){var $m; return (function(){return $m || ($m = (_cons()(_el)(_nil)))})})())))})})());};}))})})())(_args)))})})())))})})());};}));}})(), 2, "\\list args . eq args nil\n  ['false']\n  eq (tail args) nil\n    args\n    foldr1 (\\v el . ['and' v el]) args");;
//defInfixToken = AST(λtokenName location reference . bind (defToken tokenName) λ_ . bind getParseFilterInfo λdefs . (λoperators . (λoperators . setParseFilterInfo (assocSet "infix" operators defs)) (eq reference nil (eq location "before" (cons (cons tokenName nil) operators) (append operators (cons (cons tokenName nil) nil))) (insertOperator tokenName location reference operators))) (assocGetWithDefault "infix" nil defs))
root.defs._defInfixToken = _defInfixToken = Parse.define('defInfixToken', (function() {var f; return function _defInfixToken(){return f || (f = (function(_tokenName){return function(_location){return function(_reference){return _bind()((function(){var $m; return (function(){return $m || ($m = (_defToken()(_tokenName)))})})())((function(){var $m; return (function(){return $m || ($m = (function(__){return _bind()(_getParseFilterInfo)((function(){var $m; return (function(){return $m || ($m = (function(_defs){return function(_operators){return function(_operators){return _setParseFilterInfo()((function(){var $m; return (function(){return $m || ($m = (_assocSet()((function(){return "infix"}))(_operators)(_defs)))})})());}((function(){var $m; return (function(){return $m || ($m = (_eq()(_reference)(_nil)((function(){var $m; return (function(){return $m || ($m = (_eq()(_location)((function(){return "before"}))((function(){var $m; return (function(){return $m || ($m = (_cons()((function(){var $m; return (function(){return $m || ($m = (_cons()(_tokenName)(_nil)))})})())(_operators)))})})())((function(){var $m; return (function(){return $m || ($m = (_append()(_operators)((function(){var $m; return (function(){return $m || ($m = (_cons()((function(){var $m; return (function(){return $m || ($m = (_cons()(_tokenName)(_nil)))})})())(_nil)))})})())))})})())))})})())((function(){var $m; return (function(){return $m || ($m = (_insertOperator()(_tokenName)(_location)(_reference)(_operators)))})})())))})})());}((function(){var $m; return (function(){return $m || ($m = (_assocGetWithDefault()((function(){return "infix"}))(_nil)(_defs)))})})());}))})})());}))})})());};};}));}})(), 3, "\\tokenName location reference . do\n  defToken tokenName\n  defs <- getParseFilterInfo\n  operators = assocGetWithDefault 'infix' nil defs\n  operators = eq reference nil\n    eq location 'before'\n      [[tokenName] | operators]\n      append operators [[tokenName]]\n    insertOperator tokenName location reference operators\n  setParseFilterInfo (assocSet 'infix' operators defs)");;
//insertOperator = AST(λtokenName location reference operators . any (eq reference) (head operators) (eq location "before" (cons (cons tokenName nil) operators) (cons (cons tokenName (head operators)) (tail operators))) (cons (head operators) (insertOperator tokenName location reference (tail operators))))
root.defs._insertOperator = _insertOperator = Parse.define('insertOperator', (function() {var f; return function _insertOperator(){return f || (f = (function(_tokenName){return function(_location){return function(_reference){return function(_operators){return _any()((function(){var $m; return (function(){return $m || ($m = (_eq()(_reference)))})})())((function(){var $m; return (function(){return $m || ($m = (_head()(_operators)))})})())((function(){var $m; return (function(){return $m || ($m = (_eq()(_location)((function(){return "before"}))((function(){var $m; return (function(){return $m || ($m = (_cons()((function(){var $m; return (function(){return $m || ($m = (_cons()(_tokenName)(_nil)))})})())(_operators)))})})())((function(){var $m; return (function(){return $m || ($m = (_cons()((function(){var $m; return (function(){return $m || ($m = (_cons()(_tokenName)((function(){var $m; return (function(){return $m || ($m = (_head()(_operators)))})})())))})})())((function(){var $m; return (function(){return $m || ($m = (_tail()(_operators)))})})())))})})())))})})())((function(){var $m; return (function(){return $m || ($m = (_cons()((function(){var $m; return (function(){return $m || ($m = (_head()(_operators)))})})())((function(){var $m; return (function(){return $m || ($m = (_insertOperator()(_tokenName)(_location)(_reference)((function(){var $m; return (function(){return $m || ($m = (_tail()(_operators)))})})())))})})())))})})());};};};}));}})(), 4, "\\tokenName location reference operators . any (eq reference) (head operators)\n  eq location 'before'\n    [[tokenName] | operators]\n    [[tokenName | (head operators)] | (tail operators)]\n  [(head operators) | (insertOperator tokenName location reference (tail operators))]");;
//insertOperator = AST(λtokenName location reference operators . cons (cons tokenName nil) nil)
root.defs._insertOperator = _insertOperator = Leisure.makeDispatchFunction('insertOperator', '_insertOperator', '_operators', ['_insertOperator', '_tokenName', '_location', '_reference', '_operators']);
Leisure.createMethod('nil', 'insertOperator', "\\tokenName location reference operators      . [[tokenName]]", function(_tokenName, _location, _reference, _operators) {return _cons()((function(){var $m; return (function(){return $m || ($m = (_cons()(_tokenName)(_nil)))})})())(_nil);});
//testInfix = AST(λstr . bind (getValueOr "parseFilter.defs" nil) λdefs . bind (print (concat (cons "defs: " (cons defs nil)))) λ_ . print (mainParseInfix defs (scan str id id)))
root.defs._testInfix = _testInfix = Parse.define('testInfix', (function() {var f; return function _testInfix(){return f || (f = (function(_str){return _bind()((function(){var $m; return (function(){return $m || ($m = (_getValueOr()((function(){return "parseFilter.defs"}))(_nil)))})})())((function(){var $m; return (function(){return $m || ($m = (function(_defs){return _bind()((function(){var $m; return (function(){return $m || ($m = (_print()((function(){var $m; return (function(){return $m || ($m = (_concat()((function(){var $m; return (function(){return $m || ($m = (_cons()((function(){return "defs: "}))((function(){var $m; return (function(){return $m || ($m = (_cons()(_defs)(_nil)))})})())))})})())))})})())))})})())((function(){var $m; return (function(){return $m || ($m = (function(__){return _print()((function(){var $m; return (function(){return $m || ($m = (_mainParseInfix()(_defs)((function(){var $m; return (function(){return $m || ($m = (_scan()(_str)(_id)(_id)))})})())))})})());}))})})());}))})})());}));}})(), 1, "\\str . do\n  defs <- getValueOr 'parseFilter.defs' nil\n  print concat['defs: ' defs]\n  print (mainParseInfix defs (scan str id id))");;
//mainParseInfix = AST(λparseDefs list . parseInfix (assocGetWithDefault "infix" nil parseDefs) list)
root.defs._mainParseInfix = _mainParseInfix = Parse.define('mainParseInfix', (function() {var f; return function _mainParseInfix(){return f || (f = (function(_parseDefs){return function(_list){return _parseInfix()((function(){var $m; return (function(){return $m || ($m = (_assocGetWithDefault()((function(){return "infix"}))(_nil)(_parseDefs)))})})())(_list);};}));}})(), 2, "\\parseDefs list . parseInfix (assocGetWithDefault 'infix' nil parseDefs) list");;
//parseInfix = AST(λtokens list . list)
root.defs._parseInfix = _parseInfix = Parse.define('parseInfix', (function() {var f; return function _parseInfix(){return f || (f = (function(_tokens){return function(_list){return _list();};}));}})(), 2, "\\tokens list . list");;
//parseInfix = AST(λtokens list . callParseInfixList tokens list)
root.defs._parseInfix = _parseInfix = Leisure.makeDispatchFunction('parseInfix', '_parseInfix', '_list', ['_parseInfix', '_tokens', '_list']);
Leisure.createMethod('cons', 'parseInfix', "\\tokens list       . callParseInfixList tokens list", function(_tokens, _list) {return _callParseInfixList()(_tokens)(_list);});
//parseInfix = AST(λtokens list . callParseInfixList tokens list)
root.defs._parseInfix = _parseInfix = Leisure.makeDispatchFunction('parseInfix', '_parseInfix', '_list', ['_parseInfix', '_tokens', '_list']);
Leisure.createMethod('lexCons', 'parseInfix', "\\tokens list          . callParseInfixList tokens list", function(_tokens, _list) {return _callParseInfixList()(_tokens)(_list);});
//callParseInfixList = AST(λtokens list . (λprep . parseInfixList tokens dlempty (head prep) (tail prep)) (map (parseInfix tokens) list))
root.defs._callParseInfixList = _callParseInfixList = Parse.define('callParseInfixList', (function() {var f; return function _callParseInfixList(){return f || (f = (function(_tokens){return function(_list){return function(_prep){return _parseInfixList()(_tokens)(_dlempty)((function(){var $m; return (function(){return $m || ($m = (_head()(_prep)))})})())((function(){var $m; return (function(){return $m || ($m = (_tail()(_prep)))})})());}((function(){var $m; return (function(){return $m || ($m = (_map()((function(){var $m; return (function(){return $m || ($m = (_parseInfix()(_tokens)))})})())(_list)))})})());};}));}})(), 2, "\\tokens list . do\n  prep = map (parseInfix tokens) list\n  parseInfixList tokens dlempty (head prep) (tail prep)");;
//printOperators = AST(bind getParseFilterInfo λdefs . print (assocGetWithDefault "infix" nil defs))
root.defs._printOperators = _printOperators = Parse.define('printOperators', (function _printOperators() {return ((_bind()(_getParseFilterInfo)((function(){var $m; return (function(){return $m || ($m = (function(_defs){return _print()((function(){var $m; return (function(){return $m || ($m = (_assocGetWithDefault()((function(){return "infix"}))(_nil)(_defs)))})})());}))})})())));}), 0, "do\n  defs <- getParseFilterInfo\n  print (assocGetWithDefault 'infix' nil defs)");;
//parseInfixList = AST(λtokens firstList token restList . (λfullList . (λop . (λnextTok . (λnextRest . (λprec . (λnextPrec . (λnextParsed . null? tokens fullList (null? restList (parseInfixList (tail tokens) dlempty (head fullList) (tail fullList)) (eq prec (length tokens) (parseInfixList tokens (dlPush firstList token) op (tail restList)) (null? (tail restList) (error (concat (cons "Parse error -- expected token after operator: " (cons op nil)))) (< prec nextPrec (parseInfixList tokens firstList (cons op (cons token (cons nextTok nil))) nextRest) (parseInfixList tokens firstList (cons op (cons token (cons (head nextParsed) nil))) (tail nextParsed))))))) (parseInfixList tokens dlempty nextTok nextRest)) (or (null? restList) (or (null? (tail restList)) (null? nextRest)) (length tokens) (getPrecedence 0 (head nextRest) tokens))) (getPrecedence 0 op tokens)) (tail (tail restList))) (head (tail restList))) (head restList)) (firstList (cons token restList)))
root.defs._parseInfixList = _parseInfixList = Parse.define('parseInfixList', (function() {var f; return function _parseInfixList(){return f || (f = (function(_tokens){return function(_firstList){return function(_token){return function(_restList){return function(_fullList){return function(_op){return function(_nextTok){return function(_nextRest){return function(_prec){return function(_nextPrec){return function(_nextParsed){return _null$e()(_tokens)(_fullList)((function(){var $m; return (function(){return $m || ($m = (_null$e()(_restList)((function(){var $m; return (function(){return $m || ($m = (_parseInfixList()((function(){var $m; return (function(){return $m || ($m = (_tail()(_tokens)))})})())(_dlempty)((function(){var $m; return (function(){return $m || ($m = (_head()(_fullList)))})})())((function(){var $m; return (function(){return $m || ($m = (_tail()(_fullList)))})})())))})})())((function(){var $m; return (function(){return $m || ($m = (_eq()(_prec)((function(){var $m; return (function(){return $m || ($m = (_length()(_tokens)))})})())((function(){var $m; return (function(){return $m || ($m = (_parseInfixList()(_tokens)((function(){var $m; return (function(){return $m || ($m = (_dlPush()(_firstList)(_token)))})})())(_op)((function(){var $m; return (function(){return $m || ($m = (_tail()(_restList)))})})())))})})())((function(){var $m; return (function(){return $m || ($m = (_null$e()((function(){var $m; return (function(){return $m || ($m = (_tail()(_restList)))})})())((function(){var $m; return (function(){return $m || ($m = (_error()((function(){var $m; return (function(){return $m || ($m = (_concat()((function(){var $m; return (function(){return $m || ($m = (_cons()((function(){return "Parse error -- expected token after operator: "}))((function(){var $m; return (function(){return $m || ($m = (_cons()(_op)(_nil)))})})())))})})())))})})())))})})())((function(){var $m; return (function(){return $m || ($m = (_$y()(_prec)(_nextPrec)((function(){var $m; return (function(){return $m || ($m = (_parseInfixList()(_tokens)(_firstList)((function(){var $m; return (function(){return $m || ($m = (_cons()(_op)((function(){var $m; return (function(){return $m || ($m = (_cons()(_token)((function(){var $m; return (function(){return $m || ($m = (_cons()(_nextTok)(_nil)))})})())))})})())))})})())(_nextRest)))})})())((function(){var $m; return (function(){return $m || ($m = (_parseInfixList()(_tokens)(_firstList)((function(){var $m; return (function(){return $m || ($m = (_cons()(_op)((function(){var $m; return (function(){return $m || ($m = (_cons()(_token)((function(){var $m; return (function(){return $m || ($m = (_cons()((function(){var $m; return (function(){return $m || ($m = (_head()(_nextParsed)))})})())(_nil)))})})())))})})())))})})())((function(){var $m; return (function(){return $m || ($m = (_tail()(_nextParsed)))})})())))})})())))})})())))})})())))})})())))})})());}((function(){var $m; return (function(){return $m || ($m = (_parseInfixList()(_tokens)(_dlempty)(_nextTok)(_nextRest)))})})());}((function(){var $m; return (function(){return $m || ($m = (_or()((function(){var $m; return (function(){return $m || ($m = (_null$e()(_restList)))})})())((function(){var $m; return (function(){return $m || ($m = (_or()((function(){var $m; return (function(){return $m || ($m = (_null$e()((function(){var $m; return (function(){return $m || ($m = (_tail()(_restList)))})})())))})})())((function(){var $m; return (function(){return $m || ($m = (_null$e()(_nextRest)))})})())))})})())((function(){var $m; return (function(){return $m || ($m = (_length()(_tokens)))})})())((function(){var $m; return (function(){return $m || ($m = (_getPrecedence()((function(){return 0}))((function(){var $m; return (function(){return $m || ($m = (_head()(_nextRest)))})})())(_tokens)))})})())))})})());}((function(){var $m; return (function(){return $m || ($m = (_getPrecedence()((function(){return 0}))(_op)(_tokens)))})})());}((function(){var $m; return (function(){return $m || ($m = (_tail()((function(){var $m; return (function(){return $m || ($m = (_tail()(_restList)))})})())))})})());}((function(){var $m; return (function(){return $m || ($m = (_head()((function(){var $m; return (function(){return $m || ($m = (_tail()(_restList)))})})())))})})());}((function(){var $m; return (function(){return $m || ($m = (_head()(_restList)))})})());}((function(){var $m; return (function(){return $m || ($m = (_firstList()((function(){var $m; return (function(){return $m || ($m = (_cons()(_token)(_restList)))})})())))})})());};};};}));}})(), 4, "\\tokens firstList token restList . do\n  fullList = firstList [token | restList]\n  op = head restList\n  nextTok = head (tail restList)\n  nextRest = tail (tail restList)\n  prec = getPrecedence 0 op tokens\n  nextPrec = or (null? restList) (or (null? (tail restList)) (null? nextRest))\n    length tokens\n    getPrecedence 0 (head nextRest) tokens\n  nextParsed = parseInfixList tokens dlempty nextTok nextRest\n  null? tokens\n    fullList\n    null? restList\n      parseInfixList (tail tokens) dlempty (head fullList) (tail fullList)\n      eq prec (length tokens)\n        parseInfixList tokens (dlPush firstList token) op (tail restList)\n        null? (tail restList)\n          error concat['Parse error -- expected token after operator: ' op]\n          < prec nextPrec\n            parseInfixList tokens firstList [op token nextTok] nextRest\n            parseInfixList tokens firstList [op token (head nextParsed)] (tail nextParsed)");;
//getPrecedence = AST(λindex op tokens . any (eq (tokString op)) (head tokens) index (getPrecedence (+ 1 index) op (tail tokens)))
root.defs._getPrecedence = _getPrecedence = Parse.define('getPrecedence', (function() {var f; return function _getPrecedence(){return f || (f = (function(_index){return function(_op){return function(_tokens){return _any()((function(){var $m; return (function(){return $m || ($m = (_eq()((function(){var $m; return (function(){return $m || ($m = (_tokString()(_op)))})})())))})})())((function(){var $m; return (function(){return $m || ($m = (_head()(_tokens)))})})())(_index)((function(){var $m; return (function(){return $m || ($m = (_getPrecedence()((function(){var $m; return (function(){return $m || ($m = (_$o()((function(){return 1}))(_index)))})})())(_op)((function(){var $m; return (function(){return $m || ($m = (_tail()(_tokens)))})})())))})})());};};}));}})(), 3, "\\index op tokens . any (eq (tokString op)) (head tokens)\n  index\n  getPrecedence (+ 1 index) op (tail tokens)");;
//getPrecedence = AST(λindex op tokens . index)
root.defs._getPrecedence = _getPrecedence = Leisure.makeDispatchFunction('getPrecedence', '_getPrecedence', '_tokens', ['_getPrecedence', '_index', '_op', '_tokens']);
Leisure.createMethod('nil', 'getPrecedence', "\\index op tokens      . index", function(_index, _op, _tokens) {return _index();});
//operatorIn = AST(λop tokens . (λopEq . any λtoks . any opEq toks tokens) (eq (tokString op)))
root.defs._operatorIn = _operatorIn = Parse.define('operatorIn', (function() {var f; return function _operatorIn(){return f || (f = (function(_op){return function(_tokens){return function(_opEq){return _any()((function(){var $m; return (function(){return $m || ($m = (function(_toks){return _any()(_opEq)(_toks);}))})})())(_tokens);}((function(){var $m; return (function(){return $m || ($m = (_eq()((function(){var $m; return (function(){return $m || ($m = (_tokString()(_op)))})})())))})})());};}));}})(), 2, "\\op tokens . do\n  opEq = eq (tokString op)\n  any (\\toks . any opEq toks) tokens");;

//if (typeof window !== 'undefined' && window !== null) {
//  Leisure.processTokenDefs(root.tokenDefs);
//}
return root;
}).call(this)