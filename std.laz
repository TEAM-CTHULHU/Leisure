# primitives
#
# eq a b -> true if they are equal or false otherwise
#
# withType value (\type . true-case) false-case
#    if the value has a type, it calls true-case with it
#    otherwise, return false-case
# 
# is value type -> true if the value has type type, false otherwise
#
# eval ast -> evaluates ast and returns the result
#
#    MONAD-constructors
#
# bind m binding -> transform a monad with a lambda
#
# print string binding -> print a string, continue with binding (or end)
#
# prompt string binding -> ask user for input, contine with binding (or end)
#
# return value binding -> run binding with value
#
# js string binding -> run JS code and continue with value
#
# end -- the string 'end' -- ends a monad chain
#
#    STRING functions
#
# concat list -> string
#
#    AST-constructors
#
# lit value -> a lit AST node, containing value
#
# ref var-name -> a ref AST node, containing var-name
#
# lambda var-name body-ast -> a lambda AST node, with var-name and the body AST
#
# apply func-ast body-ast -> an apply AST node, with func and body ASTs
#
# prim arg rest-ast -> a prim AST node, rest-ast should either be a ref or a prim
# 

id x = x

# booleans
true = \a b . a
false = \a b . b

# The Y combinator, for reference
#
# Y = \g  .  (\x  .  g (x x)) \x  .  g (x x)
# rec = \f . f (Y f)

# lists
cons a b = \f . f a b
nil = \a b . b
append l1 l2 = l1 (\h t D . cons h (append t l2)) l2

# simple list constructor syntax
[ =(]= \item c . c \rest . cons item rest
, =.= \f item c . c \rest . f (cons item rest)
] =)= \f . f nil
| =.= \f rest g . f rest

# difference lists
dl list = append list
dlAppend da db list = da (db list)
dlList dl = dl nil
