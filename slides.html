<!doctype html>
<html>
<head> 
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>My Slides</title> 
  <link rel="stylesheet" type="text/css" media="screen, projection, print" 
   href="slidy.css" />
  <script src="showdown.js"></script>
  <script src="slidy.js"></script>
  <style>
.def {
  color: blue;
}
  </style>
</head>
<body>
<script type=text/markdown>
<!--
#Back to BASICs: Primordial Programming

Getting **REALLY** close to the metal with untyped Lambda Calculus

<br>  
<br>  
<br>  
<b>cflip</b>    = <span class="def">λn</span> . n e s a2 a1 m  
<b>flip</b>     = func-to-row cflip  
<b>allFlip</b>  = row-to-func flip  
<b>start</b>    = <span class="def">λstatef</span> . statef gridStart shipStart t slowest  
<b>checkDir</b> = <span class="def">λgrid left?</span> . left? (grid isAllFirstEmpty) (not (grid isAllLastEmpty))  
<b>next</b>     = <span class="def">λgrid ship left? ctr statef</span> . (<span class="def">λdir</span> . statef (ctr cTrue (grid (dir allLeft allRight) allFlip) grid) ship dir (ctr cNext)) (checkDir grid left?)  
<b>moveLeft</b>  = <span class="def">λgrid ship left? ctr</span> . next grid (ship (ship onFirstEmpty left)) left? ctr  
<b>moveRight</b> = <span class="def">λgrid ship left? ctr</span> . next grid (ship (ship right onFirstEmpty right)) left? ctr  
<b>stay</b>      = <span class="def">λgrid ship left? ctr</span> . next grid ship left? ctr  
<b>fire</b>      = <span class="def">λgrid ship left? ctr</span> . next (missile grid ship) ship left? ctr  

***
#Disclaimer: I'm not selling a language or a paradigm

Languages are tools and they all have advantages and disadvantages

I think programmers should know more languages, because they open your mind to different ways to solve problems

To understand a language, you need to program something nontrivial in a way that depends on that language's "goodies"

Examples of some fairly uncommon languages that can teach you interesting things (this list is not exhaustive)...

<table>
<tr><td>LISP (macros, code is data)
</td><td>Scheme (continuations)
</td></tr><tr><td>Haskell (lazy evaluation, monads, etc.)
</td><td>Scala (OO + functional, actors)
</td></tr><tr><td>Erlang (actors)
</td><td>Go/Oberon (implicit interfaces)
</td></tr><tr><td>TCL (dual-ported objects, uplevel)
</td><td>Smalltalk/Squeak/Scratch (foundational OO)
</td></tr><tr><td>OPS5 (forward chaining)
</td><td>Prolog (unification/backtracking)
</td></tr><tr><td>Icon (goal-directed execution/backtracking)
</td><td>FORTH/PostScript/Factor (stack languages, compile-time execution)
</td></tr><tr><td>Lua (meta model)
</td><td>Self/Io (pure prototype-based OO)</td></tr>
</table>
***
#Lambda Calculus is a Functional Programming Language

Alonzo Church (Alan Turing's professor) created Lambda Calculus around 1928.
***
#Lambda Calculus is a Functional Programming Language

Alonzo Church (Alan Turing's professor) created Lambda Calculus around 1928.

It's not the oldest programming language
***
#Lambda Calculus is a Functional Programming Language

Alonzo Church (Alan Turing's professor) created Lambda Calculus around 1928.

It's not the oldest programming language

Some Indian guy named Pāṇini beat him to the punch, when he made a grammatical system for Sanskrit that is actually a "turing equivalent" programming language
***
#Lambda Calculus is a Functional Programming Language

Alonzo Church (Alan Turing's professor) created Lambda Calculus around 1928.

It's not the oldest programming language

Some Indian guy named Pāṇini beat him to the punch, when he made a grammatical system for Sanskrit that is actually a "turing equivalent" programming language

Around 400 BC 
***
#Lambda Calculus is a Functional Programming Language

Alonzo Church (Alan Turing's professor) created Lambda Calculus around 1928.

It's not the oldest programming language

Some Indian guy named Pāṇini beat him to the punch, when he made a grammatical system for Sanskrit that is actually a "turing equivalent" programming language

Around 400 BC 

But I still think LC is truly primordial, based on its simplicity (very few "moving parts")
***
#Lambda Calculus is a Functional Programming Language

It's very simple

I think it's ideal for teaching CS concepts

There's just so little to get in the way
***
#Neato things that are easy to do in Lambda calculus

* custom control structures
* computed streams of data
* generators/iterators
* infinite streams
* deep code factoring (combinators)
* extensible syntax (parsing tricks can make this even more powerful)
* ***parallel computing*** (ooh... ahh...)
***
#Neato things that are easy to do in Lambda calculus

* custom control structures  
    ex: pattern matching "switch", comprehensions (that transform structures), visitors, ...
* computed streams of data
* generators/iterators
* infinite streams
* deep code factoring (combinators)
* extensible syntax (parsing tricks can make this even more powerful)
* ***parallel computing*** (ooh... ahh...)
***
#Neato things that are easy to do in Lambda calculus

* custom control structures  
    ex: pattern matching "switch", comprehensions (that transform structures), visitors, ...
* computed streams of data  
    transformable collections of values produced by functions
* generators/iterators
* infinite streams
* deep code factoring (combinators)
* extensible syntax (parsing tricks can make this even more powerful)
* ***parallel computing*** (ooh... ahh...)
***
#Neato things that are easy to do in Lambda calculus

* custom control structures  
    ex: pattern matching "switch", comprehensions (that transform structures), visitors, ...
* computed streams of data  
    transformable collections of values produced by functions
* generators/iterators  
    present datastructures as streams
* infinite streams
* deep code factoring (combinators)
* extensible syntax (parsing tricks can make this even more powerful)
* ***parallel computing*** (ooh... ahh...)
***
#Neato things that are easy to do in Lambda calculus

* custom control structures  
    ex: pattern matching "switch", comprehensions (that transform structures), visitors, ...
* computed streams of data  
    transformable collections of values produced by functions
* generators/iterators  
    present datastructures as streams
* infinite streams  
    simple and complex streams of infinite values are good for loops and some computations
* deep code factoring (combinators)
* extensible syntax (parsing tricks can make this even more powerful)
* ***parallel computing*** (ooh... ahh...)
***
#Neato things that are easy to do in Lambda calculus

* custom control structures  
    ex: pattern matching "switch", comprehensions (that transform structures), visitors, ...
* computed streams of data  
    transformable collections of values produced by functions
* generators/iterators  
    present datastructures as streams
* infinite streams  
    simple and complex streams of infinite values are good for loops and some computations
* deep code factoring (combinators)  
    types of code factoring that you don't really see in mainstream languages (C/C++/Java/C#/Python)
* extensible syntax (parsing tricks can make this even more powerful)
* ***parallel computing*** (ooh... ahh...)
***
#Neato things that are easy to do in Lambda calculus

* custom control structures  
    ex: pattern matching "switch", comprehensions (that transform structures), visitors, ...
* computed streams of data  
    transformable collections of values produced by functions
* generators/iterators  
    present datastructures as streams
* infinite streams  
    simple and complex streams of infinite values are good for loops and some computations
* deep code factoring (combinators)  
    types of code factoring that you don't really see in mainstream languages (C/C++/Java/C#/Python)
* extensible syntax (parsing tricks can make this even more powerful)  
    create Domain Specific Languages (DSLs)
* ***parallel computing*** (ooh... ahh...)
***
#Neato things that are easy to do in Lambda calculus

* custom control structures  
    ex: pattern matching "switch", comprehensions (that transform structures), visitors, ...
* computed streams of data  
    transformable collections of values produced by functions
* generators/iterators  
    present datastructures as streams
* infinite streams  
    simple and complex streams of infinite values are good for loops and some computations
* deep code factoring (combinators)  
    types of code factoring that you don't really see in mainstream languages (C/C++/Java/C#/Python)
* extensible syntax (parsing tricks can make this even more powerful)  
    create Domain Specific Languages (DSLs)
* ***parallel computing*** (ooh... ahh...)  
    LC (and other functional languages) have tools for massively parallel programs (20,000+ threads)
***
#Neato things that are easy to do in Lambda calculus

* custom control structures  
    ex: pattern matching "switch", comprehensions (that transform structures), visitors, ...
* computed streams of data  
    transformable collections of values produced by functions
* generators/iterators  
    present datastructures as streams
* infinite streams  
    simple and complex streams of infinite values are good for loops and some computations
* deep code factoring (combinators)  
    types of code factoring that you don't really see in mainstream languages (C/C++/Java/C#/Python)
* extensible syntax (parsing tricks can make this even more powerful)  
    create Domain Specific Languages (DSLs)
* ***parallel computing*** (ooh... ahh...)  
    LC (and other functional languages) have tools for massively parallel programs (20,000+ threads)

You can do some of these things in a lot of other languages, but they probably won't be as straight-forward.  They can still be very useful and powerful, though.  One example of this is the [Functional Java](http://functionaljava.org/) library, which bolts functional capabilities onto Java.
***
#Lambda Calculus is Primordial

How primordial is it?
***
<table style="position: absolute; height: 100%; width: 100%"><tr><td style="vertical-align: center"><h1 style="text-align: center; font-size: 64px">
THERE ARE NO NUMBERS
</h1></td></tr></table>
***
<table style="position: absolute; height: 100%; width: 100%"><tr><td style="vertical-align: center"><h1 style="text-align: center; font-size: 64px">
THERE ARE NO BITS
</h1></td></tr></table>
***
<table style="position: absolute; height: 100%; width: 100%"><tr><td style="vertical-align: center"><h1 style="text-align: center; font-size: 64px">
THERE ARE NO COMPARISONS
</h1></td></tr></table>
***
<table style="position: absolute; height: 100%; width: 100%"><tr><td style="vertical-align: center"><h1 style="text-align: center; font-size: 64px">
WHAT THE?
</h1></td></tr></table>
***
<table style="position: absolute; height: 100%; width: 100%"><tr><td style="vertical-align: center"><h1 style="text-align: center; font-size: 64px">
YOU CAN'T EVEN REASSIGN VARIABLES
</h1></td></tr></table>
***
<table style="position: absolute; height: 100%; width: 100%"><tr><td style="vertical-align: center"><h1 style="text-align: center; font-size: 64px">
WHAT THE?
</h1></td></tr></table>
***
#It's not as bad as it seems

It's actually very powerful

It's easy to use, once you get the hang of it

(and modern versions of typed LC, like Haskell do give you primitive numbers and comparisons)
***
#It's not as bad as it seems

No numbers or comparisons &rArr; students can implement them themselves

How do you define bits, numbers, and ">" in C or assembly?

This is the primoridal value of LC

But even at this low level, you can still do "real" things...
***
#It's not as bad as it seems

To show this, I started on a version of [Space Invaders in Lambda Calculus](http://tinyconcepts.com/invaders.html)

55 lines of code, so far (including definitions for numbers and comparisons)

Uses JavaScript to display the state and get events
***
#Evaluator

To run it, I made a [Lambda Calculus evaluator](evaluator.html) in JavaScript

It can run Lambda Calculus 3 different ways...

1. compile into JavaScript
1. interpret in JavaScript and show the substitution steps
1. compile into virtual machine bytecode (and run it)

I'm working on an LLVM code generator to compile into native machine code (and let you link with libraries)

The idea here is to give people insight into how compilers, interpreters, and VMs work
***
#Brief Overview

Teaching and experimentation

The things in this talk also work in Haskell

Haskell has proven to be practical and fast (DARCS DVCS is written in Haskell)

Maybe untyped LC could be too

**LC gives you a lot of power and productivity, even though it's low-level**

* LC uses "lazy evaluation" -- function arguments are never evaluated until they are used (and this is transitive)
* LC is just functions -- data is also functions, which means data is also lazy
* LC allows "currying" -- calling a 3-arg function with only the first 2 args returns a 1-arg function that "saves" the first 2

Lazy evaluation + currying + data/functions can be very powerful

Most languages don't support this
***
#Brief Overview: Functions

LC is just functions and functions are like subroutines

Here's a JavaScript function: `function(argument) {return body}`
***
#Brief Overview: Functions

LC is just functions and functions are like subroutines

Here's a JavaScript function: `function(argument) {return body}`

In Lambda Calculus, you would say this:

<span class="def">λargument</span> . body
***
#Brief Overview: Functions

LC is just functions and functions are like subroutines

Here's a JavaScript function: `function(argument) {return body}`

In Lambda Calculus, you would say this:

<span class="def">λargument</span> . body
<br>  
<br>  
A function body can...

* return function: <span class="def">λa</span> . <span class="def">λb</span> . a
***
#Brief Overview: Functions

LC is just functions and functions are like subroutines

Here's a JavaScript function: `function(argument) {return body}`

In Lambda Calculus, you would say this:

<span class="def">λargument</span> . body
<br>  
<br>  
A function body can...

* return function: <span class="def">λa</span> . <span class="def">λb</span> . a
* return an argument: <span class="def">λb</span> . a
***
#Brief Overview: Functions

LC is just functions and functions are like subroutines

Here's a JavaScript function: `function(argument) {return body}`

In Lambda Calculus, you would say this:

<span class="def">λargument</span> . body
<br>  
<br>  
A function body can...

* return function: <span class="def">λa</span> . <span class="def">λb</span> . a
* return an argument: <span class="def">λb</span> . a
* call a function with a value (and the result with another value, etc.): <span class="def">λa</span> . <span class="def">λb</span> . <span class="def">λf</span> . (f a) b
***
#Brief Overview: Functions

LC is just functions and functions are like subroutines

Here's a JavaScript function: `function(argument) {return body}`

In Lambda Calculus, you would say this:

<span class="def">λargument</span> . body
<br>  
<br>  
A function body can...

* return function: <span class="def">λa</span> . <span class="def">λb</span> . a
* return an argument: <span class="def">λb</span> . a
* call a function with a value (and the result with another value, etc.): <span class="def">λa</span> . <span class="def">λb</span> . <span class="def">λf</span> . (f a) b

Values can be functions or undefined
***
#Brief Overview: Functions

A function which returns another function acts like it takes another argument

because `(func X) Y` sends `Y` to the function returned by `(func X)`

but LC is "right associative" and lets you say `func X Y`, instead

(so `func X` is really currying `func X Y`)

So people smash together functions that return other functions; they write

<span class="def">λa</span> . <span class="def">λb</span> . <span class="def">λf</span> . f a b

as

<span class="def">λa b f</span> . f a b

It's less of a pain
***
#Brief Overview: Data

Here's how you can define a simple "person record"...

* makePerson = <span class="def">λname number f</span> . f name number
***
#Brief Overview: Data

Here's how you can define a simple "person record"...

* makePerson = <span class="def">λname number f</span> . f name number

Calling makePerson with a name returns a function that takes a number and returns another function:

makePerson fred &rArr; <span class="def">λnumber f</span> . f fred number
***
#Brief Overview: Data

Here's how you can define a simple "person record"...

* makePerson = <span class="def">λname number f</span> . f name number

Calling makePerson with a name returns a function that takes a number and returns another function:

makePerson fred &rArr; <span class="def">λnumber f</span> . f fred number

You can call that with a number to get a "person record":

(makePerson fred) 777-2344 &rArr; <span class="def">λf</span> . f fred 777-2344
***
#Brief Overview: Data

Here's how you can define a simple "person record"...

* makePerson = <span class="def">λname number f</span> . f name number

Calling makePerson with a name returns a function that takes a number and returns another function:

makePerson fred &rArr; <span class="def">λnumber f</span> . f fred number

You can call that with a number to get a "person record":

(makePerson fred) 777-2344 &rArr; <span class="def">λf</span> . f fred 777-2344

Lambda Calculus is "left associative" to make this easier:

makePerson fred 777-2344 &rArr; <span class="def">λnumber f</span> . f fred 777-2344
***
#Brief Overview: Data

**Wait -- what just happened?**

***
#Brief Overview: Data

**Wait -- what just happened?**

We used currying to create a "person record"...
***
#Brief Overview: Data

**Wait -- what just happened?**

We used currying to create a "person record"...

* makePerson = <span class="def">λname number f</span> . f name number
***
#Brief Overview: Data

**Wait -- what just happened?**

We used currying to create a "person record"...

* makePerson = <span class="def">λname number f</span> . f name number

makePerson fred 777-2344 &rArr; <span class="def">λnumber f</span> . f fred 777-2344
***
#Brief Overview: Data

**Wait -- what just happened?**

We used currying to create a "person record"...

* makePerson = <span class="def">λname number f</span> . f name number

makePerson fred 777-2344 &rArr; <span class="def">λnumber f</span> . f fred 777-2344

See how makePerson defines this "f" argument, but we aren't using it?
***
#Brief Overview: Data

**Wait -- what just happened?**

We used currying to create a "person record"...

* makePerson = <span class="def">λname number f</span> . f name number

makePerson fred 777-2344 &rArr; <span class="def">λnumber f</span> . f fred 777-2344

See how makePerson defines this "f" argument, but we aren't using it?

When I send only 2 arguments to makePerson, I get back a function that takes an "f"
***
#Brief Overview: Data

**Wait -- what just happened?**

We used currying to create a "person record"...

* makePerson = <span class="def">λname number f</span> . f name number

makePerson fred 777-2344 &rArr; <span class="def">λnumber f</span> . f fred 777-2344

See how makePerson defines this "f" argument, but we aren't using it?

When I send only 2 arguments to makePerson, I get back a function that takes an "f"

The fact that I can send in "f" later allows the "person record function" to work
***
#Brief Overview: Data

**Wait -- what just happened?**

We used currying to create a "person record"...

* makePerson = <span class="def">λname number f</span> . f name number

makePerson fred 777-2344 &rArr; <span class="def">λnumber f</span> . f fred 777-2344

See how makePerson defines this "f" argument, but we aren't using it?

When I send only 2 arguments to makePerson, I get back a function that takes an "f"

The fact that I can send in "f" later allows the "person record function" to work

LC uses currying for a LOT of things
***
#Brief Overview: Data

<span class="def">λf</span> . f fred 777-2344

This "person record" takes a function (f) and applies it to the name and number

You could define getName to return the name of the person
***
#Brief Overview: Data

<span class="def">λf</span> . f fred 777-2344

This "person record" takes a function (f) and applies it to the name and number

You could define getName to return the name of the person

* getName = <span class="def">λperson</span> . person (<span class="def">λname number</span> . name)
***
#Brief Overview: Data

<span class="def">λf</span> . f fred 777-2344

This "person record" takes a function (f) and applies it to the name and number

You could define getName to return the name of the person

* getName = <span class="def">λperson</span> . person (<span class="def">λname number</span> . name)

getName (<span class="def">λf</span> . f fred 777-2344) &rArr; fred
***
#Brief Overview: Data

<span class="def">λf</span> . f fred 777-2344

This "person record" takes a function (f) and applies it to the name and number

You could define getName to return the name of the person

* getName = <span class="def">λperson</span> . person (<span class="def">λname number</span> . name)

getName (<span class="def">λf</span> . f fred 777-2344) &rArr; fred

This is a lot like `struct person p = {"fred", "777-2344"};` in C
***
#Brief Overview: Data

<span class="def">λf</span> . f fred 777-2344

This "person record" takes a function (f) and applies it to the name and number

You could define getName to return the name of the person

* getName = <span class="def">λperson</span> . person (<span class="def">λname number</span> . name)

getName (<span class="def">λf</span> . f fred 777-2344) &rArr; fred

This is a lot like `struct person p = {"fred", "777-2344"};` in C

but later, we'll see some powerful differences.
***
#Custom Control Structures

You can use booleans in LC as if-then statements, kind of like how C uses && and ||

* true = <span class="def">λa b</span> . a
* false = <span class="def">λa b</span> . b
***
#Custom Control Structures

You can use booleans in LC as if-then statements, kind of like how C uses && and ||

* true = <span class="def">λa b</span> . a
* false = <span class="def">λa b</span> . b

true really just means "choose the first one"
***
#Custom Control Structures

You can use booleans in LC as if-then statements, kind of like how C uses && and ||

* true = <span class="def">λa b</span> . a
* false = <span class="def">λa b</span> . b

true really just means "choose the first one"

false really just means "choose the second one"
***
#Custom Control Structures

You can use booleans in LC as if-then statements, kind of like how C uses && and ||

* true = <span class="def">λa b</span> . a
* false = <span class="def">λa b</span> . b

true really just means "choose the first one"

false really just means "choose the second one"

kind of like an if-then statement
***
#Custom Control Structures

You can use booleans in LC as if-then statements, kind of like how C uses && and ||

* true = <span class="def">λa b</span> . a
* false = <span class="def">λa b</span> . b

true really just means "choose the first one"

false really just means "choose the second one"

kind of like an if-then statement

Suppose you have three variables, v1 = true, v2 = false, and v3 = false
***
#Custom Control Structures

You can use booleans in LC as if-then statements, kind of like how C uses && and ||

* true = <span class="def">λa b</span> . a
* false = <span class="def">λa b</span> . b

true really just means "choose the first one"

false really just means "choose the second one"

kind of like an if-then statement

Suppose you have three variables, v1 = true, v2 = false, and v3 = false

v1 (v2 a b) (v3 c d) &rArr; b
***
#Custom Control Structures

You can use booleans in LC as if-then statements, kind of like how C uses && and ||

* true = <span class="def">λa b</span> . a
* false = <span class="def">λa b</span> . b

true really just means "choose the first one"

false really just means "choose the second one"

kind of like an if-then statement

Suppose you have three variables, v1 = true, v2 = false, and v3 = false

v1 (v2 a b) (v3 c d) &rArr; b

This does not evaluate the second argument, just like C wouldn't: (v1 && ((v2 && a) || b)) || ((v3 && c) || d)
***
#Custom Control Structures

You can use booleans in LC as if-then statements, kind of like how C uses && and ||

* true = <span class="def">λa b</span> . a
* false = <span class="def">λa b</span> . b

true really just means "choose the first one"

false really just means "choose the second one"

kind of like an if-then statement

Suppose you have three variables, v1 = true, v2 = false, and v3 = false

v1 (v2 a b) (v3 c d) &rArr; b

This does not evaluate the second argument, just like C wouldn't: (v1 && ((v2 && a) || b)) || ((v3 && c) || d)

Lazy evaluation makes **everything** use "short-circuit" evaluation, like C's && and ||
***
#Custom Control Structures

Control structures are all about choosing what to do

Lazy evaluation lets you define your own control structures, like if, for, while, switch, etc.

There are some pretty useful control structures that aren't in C or Java

(like Scala's pattern matching "switch" and powerful "for")
***
#Computed Streams of Data

(cons a b) makes a list with a as the "head" and b as the "tail"
***
#Computed Streams of Data

(cons a b) makes a list with a as the "head" and b as the "tail"

The tail is usually either nil or another cons, which makes a chain of values
***
#Computed Streams of Data

(cons a b) makes a list with a as the "head" and b as the "tail"

The tail is usually either nil or another cons, which makes a chain of values

So, cons A (cons B nil) makes [A, B] and cons A (cons B (cons C nil)) makes [A, B, C]
***
#Computed Streams of Data

(cons a b) makes a list with a as the "head" and b as the "tail"

The tail is usually either nil or another cons, which makes a chain of values

So, cons A (cons B nil) makes [A, B] and cons A (cons B (cons C nil)) makes [A, B, C]

Here are the LC definitions:

* cons = <span class="def">λh t f</span> . f h t
* head = <span class="def">λlist</span> . list (<span class="def">λhead tail</span> . head)
* tail = <span class="def">λlist</span> . list (<span class="def">λhead tail</span> . tail)
* nil = <span class="def">λa b</span> . b
* null = <span class="def">λlist</span> . list (<span class="def">λhead tail DUMMY </span> . false) true
***
#Computed Streams of Data

(cons a b) makes a list with a as the "head" and b as the "tail"

The tail is usually either nil or another cons, which makes a chain of values

So, cons A (cons B nil) makes [A, B] and cons A (cons B (cons C nil)) makes [A, B, C]

Here are the LC definitions:

* cons = <span class="def">λh t f</span> . f h t
* head = <span class="def">λlist</span> . list (<span class="def">λhead tail</span> . head)
* tail = <span class="def">λlist</span> . list (<span class="def">λhead tail</span> . tail)
* nil = <span class="def">λa b</span> . b
* null = <span class="def">λlist</span> . list (<span class="def">λhead tail DUMMY </span> . false) true

Null uses a currying trick which we can go into if anyone is interested
***
#Computed Streams of Data

(cons a b) makes a list with a as the "head" and b as the "tail"

The tail is usually either nil or another cons, which makes a chain of values

So, cons A (cons B nil) makes [A, B] and cons A (cons B (cons C nil)) makes [A, B, C]

Here are the LC definitions:

* cons = <span class="def">λh t f</span> . f h t
* head = <span class="def">λlist</span> . list (<span class="def">λhead tail</span> . head)
* tail = <span class="def">λlist</span> . list (<span class="def">λhead tail</span> . tail)
* nil = <span class="def">λa b</span> . b
* null = <span class="def">λlist</span> . list (<span class="def">λhead tail DUMMY </span> . false) true

Null uses a currying trick which we can go into if anyone is interested

Lazy evaluation makes computing a list in LC like making a Java/C++ iterator or a Python generator
***
#Computed Streams of Data

(cons a b) makes a list with a as the "head" and b as the "tail"

The tail is usually either nil or another cons, which makes a chain of values

So, cons A (cons B nil) makes [A, B] and cons A (cons B (cons C nil)) makes [A, B, C]

Here are the LC definitions:

* cons = <span class="def">λh t f</span> . f h t
* head = <span class="def">λlist</span> . list (<span class="def">λhead tail</span> . head)
* tail = <span class="def">λlist</span> . list (<span class="def">λhead tail</span> . tail)
* nil = <span class="def">λa b</span> . b
* null = <span class="def">λlist</span> . list (<span class="def">λhead tail DUMMY </span> . false) true

Null uses a currying trick which we can go into if anyone is interested

Lazy evaluation makes computing a list in LC like making a Java/C++ iterator or a Python generator

Ever write an iterator for a recursive data structure, like a tree or graph?
***
#Computed Streams of Data

What cons does...
***
#Computed Streams of Data

What cons does...

cons A nil &rArr; <span class="def">λf</span> . f A nil
***
#Computed Streams of Data

What cons does...

cons A nil &rArr; <span class="def">λf</span> . f A nil

cons B (cons A nil) &rArr; <span class="def">λf2</span> . f2 B (<span class="def">λf</span> . f A nil)
***
#Computed Streams of Data

What cons does...

cons A nil &rArr; <span class="def">λf</span> . f A nil

cons B (cons A nil) &rArr; <span class="def">λf2</span> . f2 B (<span class="def">λf</span> . f A nil)

Right?
***
#Computed Streams of Data

What cons does...

cons A nil &rArr; <span class="def">λf</span> . f A nil

cons B (cons A nil) &rArr; <span class="def">λf2</span> . f2 B (<span class="def">λf</span> . f A nil)

Right?

Let's look at the replay...
***
#Computed Streams of Data

What cons does...

cons A nil &rArr; <span class="def">λf</span> . f A nil

cons B (cons A nil) &rArr; <span class="def">λf2</span> . f2 B (<span class="def">λf</span> . f A nil)

Right?

Let's look at the replay...

cons B (cons A nil) &rArr; <span class="def">λf2</span> . f2 B (cons A nil)
***
#Computed Streams of Data

What cons does...

cons A nil &rArr; <span class="def">λf</span> . f A nil

cons B (cons A nil) &rArr; <span class="def">λf2</span> . f2 B (<span class="def">λf</span> . f A nil)

Right?

Let's look at the replay...

cons B (cons A nil) &rArr; <span class="def">λf2</span> . f2 B (cons A nil)

(cons A nil) doesn't get evaulated until you "use" it, like head (tail (cons B (cons A nil)))
***
#Computed Streams of Data

You can produce a new list by:

* Transforming the elements of the original
* Discarding some of the elements of the original
* Inserting elements into the original
* Merging several lists together
* Combining the above operations

Kind of like SQL, only for lists
***
#Generators

Here's an example tree traversal stream

traverse (nd 1 (nd 2 nil nil) (nd 3 nil nil)) &rArr; [1,2,3]  
<br>  

* nd = <span class="def">λvalue left right f</span> . f value left right
* value = <span class="def">λtree</span> . tree (<span class="def">λv l r</span> . v)
* left = <span class="def">λtree</span> . tree (<span class="def">λv l r</span> . l)
* right = <span class="def">λtree</span> . tree (<span class="def">λv l r</span> . r)
* traverse = rec <span class="def">λtr tree</span> . tree (<span class="def">λv l r D</span> . (cons (value tree) (append (tr (left tree)) (tr (right tree))))) nil

(rec is a function which uses the "Y-combinator" to define a recursive function, so "tr" becomes the recursive name for "traverse")
***
#Generators

Here's an example tree traversal stream

traverse (nd 1 (nd 2 nil nil) (nd 3 nil nil)) &rArr; [1,2,3]  
But [1,2,3] is a **lazy** list
  
* nd = <span class="def">λvalue left right f</span> . f value left right
* value = <span class="def">λtree</span> . tree (<span class="def">λv l r</span> . v)
* left = <span class="def">λtree</span> . tree (<span class="def">λv l r</span> . l)
* right = <span class="def">λtree</span> . tree (<span class="def">λv l r</span> . r)
* traverse = rec <span class="def">λtr tree</span> . tree (<span class="def">λv l r D</span> . (cons (value tree) (append (tr (left tree)) (tr (right tree))))) nil

(rec is a function which uses the "Y-combinator" to define a recursive function, so "tr" becomes the recursive name for "traverse")
***
#Generators

[1,2,3] is really just <span class="def">λf</span> . f (node-value) (traverse-the-rest)

It continues the tree traversal as you draw elements from the list

Lazy evaluation makes this automatic
***
#Generators

Only the parts of the list you access are actually computed

The rest remain _virtual_

This brings us to...
***
#Infinite Streams

* natural numbers
* whole numbers
* even numbers
* random numbers
* ...
***
#Infinite Streams

* natural numbers
* whole numbers
* even numbers
* random numbers
* ...

You can use infinite streams in a loop to generate values

**map FUNC (remove (not prime) naturals)**  
// this would be kind of like: for (i in naturals - !prime) {FUNC}  
// if - and not applied to lists and functions

**map FUNC (map square naturals)**  
// this would be kind of like: for (i in square * naturals) {...}
// if * applied to lists and functions
***
#Infinite Streams

* natural numbers
* whole numbers
* even numbers
* random numbers
* ...

You can use infinite streams in a loop to generate values

**map FUNC (remove (not prime) naturals)**  
// this would be kind of like: for (i in naturals - !prime) {FUNC}  
// if - and not applied to lists and functions

**map FUNC (map square naturals)**  
// this would be kind of like: for (i in square * naturals) {...}
// if * applied to lists and functions

**map FUNC (map square (remove (! (prime || ten || even)) naturals))**  
// this would be like for (i in squares * (naturals - !(prime || ten || odd))) {...}  
// if "|" alternated  
// so naturals - ((!prime & !ten) | even) is all naturals which are prime or odd or multiples of 10
***
#Deep Factoring

You can transform and filter lists, just like you can in Smalltalk, LISP, Haskell, etc.

"Currying" when mapping or filtering produces a new function that operates on any list

You can compose them with other functions that operate on lists:  
mogrify = <span class="def">λfunc l</span> . map func (map square (remove (! (prime || ten || even)) l))  
`mogrify bob` uses currying to make a combinator you can use on lists or in other list combinators

This makes it easy to create and reuse functions that transform lists

You can use these techniques for things other than collections, too, like "parser combinators"
***
#Extensible Syntax

[ 1 , 2 , 3 ] constructs lists

"[", ",", and "]" are really just functions

"[" creates a "list builder function"

"," makes the list builder continue

"]" makes the list builder produce the final list

Without any extra rules, you can make functions that look like infix

Extra parsing goodies will let you do even better

Like allowing you to leave out spaces and define groups:

append [1,2,3] [4,5]

This and custom control structures are good for creating your own "DSLs" -- domain specific languages
***
#Parallel Computing

A thread changing data while another thread uses it is one of the worst horrors of parallel computing

But in functional programs, you ***can't change data***

The data you have is going to remain as it is

That means another thread can't change it underneath you

The way you make "changes" is to return "transformed replacements"
***
#Parallel Computing

Isn't creating new data instead of changing existing data inefficient?
***
#Parallel Computing

Isn't creating new data instead of changing existing data inefficient?

Yes, but transformed data structures can reuse parts of the original structure
***
#Parallel Computing

Isn't creating new data instead of changing existing data inefficient?

Yes, but transformed data structures can reuse parts of the original structure

And speed != efficiency (a Viper isn't quite as efficient as a Prius)
***
#Parallel Computing

Isn't creating new data instead of changing existing data inefficient?

Yes, but transformed data structures can reuse parts of the original structure

And speed != efficiency (a Viper isn't quite as efficient as a Prius)

NVIDIA Fermi needs to run over 20,000 of threads for optimal usage
***
#Parallel Computing

Isn't creating new data instead of changing existing data inefficient?

Yes, but transformed data structures can reuse parts of the original structure

And speed != efficiency (a Viper isn't quite as efficient as a Prius)

NVIDIA Fermi needs to run over 20,000 of threads for optimal usage

But to use that many threads, we needs automatic ways to *massively* parellelize code
***
#Parallel Computing

Isn't creating new data instead of changing existing data inefficient?

Yes, but transformed data structures can reuse parts of the original structure

And speed != efficiency (a Viper isn't quite as efficient as a Prius)

NVIDIA Fermi needs to run over 20,000 of threads for optimal usage

But to use that many threads, we needs automatic ways to *massively* parellelize code

Relegating high-level tasks to another thread (like updating a browser tab) isn't good enough
***
#Parallel Computing

So, functional programming can *support* parallel computing well, but can it make it easier?

Those stream operations we talked about, before: transforming, discarding, inserting

Those are a lot like Google's map/reduce (because it's based on functional concepts)

Google's Map/reduce operates "in the large", on server farms

Functional programming languages can do this "in the small" (like on your laptop)
***
#Parallel Computing

Map is a function that transforms a list of values by applying a function to each element:

map twice [1,2,3] &rArr; [2,4,6]  
(i.e. map (<span class="def">λitem</span> . times 2 item) [1,2,3])

Parallel functional languages (like Haskell and Scala) support parallel list transformations

So they would send each element of the list to a different processor (if you have that many processors)

This works on other types of collections, besides streams, of course (trees, arrays, etc.)
***
# The End

<img src="qrCode.png" alt="qrcode">
***
#Resources

* Documents about functional programming and lazy evaluation
 *  Talk on Why Functional Programming Matters: [http://www.infoq.com/interviews/john-hughes-fp](http://www.infoq.com/interviews/john-hughes-fp)
 *  Why Functional Programming Matters paper: [http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.63.7911&rep=rep1&type=pdf](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.63.7911&rep=rep1&type=pdf)
 *  Tim Sweeney's (of Epic Games) talk on the future of graphics programming: [http://www.cs.princeton.edu/~dpw/popl/06/Tim-POPL.ppt](http://www.cs.princeton.edu/~dpw/popl/06/Tim-POPL.ppt)
 *  The Real Point of Laziness: [http://existentialtype.wordpress.com/2011/04/24/the-real-point-of-laziness/](http://existentialtype.wordpress.com/2011/04/24/the-real-point-of-laziness/)
 *  More Points for Lazy Evaluation: [http://augustss.blogspot.com/2011/05/more-points-for-lazy-evaluation-in.html](http://augustss.blogspot.com/2011/05/more-points-for-lazy-evaluation-in.html)
 *  Martin Odersky's [talk on Scala and parallel computing](http://www.parleys.com/#st=5&id=2184)
 *  My [parallel collection Go library](https://github.com/zot/seq)
* Tools for easy slide presentations, like this
 * QuickSlides: [http://tobyho.com/Quick-and-Dirty\_Presentations\_in\_Markdown](http://tobyho.com/Quick-and-Dirty_Presentations_in_Markdown)
 * Slidy: [http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js.gz](http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js.gz)
 * Slidy CSS: [http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css](http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css)
 * Showdown: [http://softwaremaniacs.org/playground/showdown-highlight/](http://softwaremaniacs.org/playground/showdown-highlight/)
-->
</script>
<script>
var scripts = document.getElementsByTagName('script');
for (var i = 0; i < scripts.length; i++){
    var script = scripts[i];
    if (script.type != 'text/markdown') continue;
    var md = script.innerHTML.replace(/^\s<!--*/, '')
        .replace(/-->\s*$/, '');
    var markup = new Showdown.converter().makeHtml(md);
    var slides = markup.split('<hr />');
    for (var j = 0; j < slides.length; j++)
      document.write('<div class=slide>' + slides[j] + '</div>');
}
w3c_slidy.add_listener(document.body, "touchend", w3c_slidy.mouse_button_click);
</script>
</body>
</html>
