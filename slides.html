<!doctype html>
<html>
<head> 
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>My Slides</title> 
  <link rel="stylesheet" type="text/css" media="screen, projection, print" 
   href="slidy.css" />
  <script src="showdown.js"></script>
  <script src="slidy.js"></script>
  <style>
.def {
  color: blue;
}
  </style>
</head>
<body>
<script type=text/markdown>
<!--
#Back to BASICs: Primordial Programming

Getting **REALLY** close to the metal with untyped Lambda Calculus
***
#Disclaimer: I'm not selling a language or a paradigm

Languages are tools and they all have advantages and disadvantages

I think programmers should know more languages, because they open your mind to different ways to solve problems

To understand a language, you need to program something nontrivial in a way that depends on that language's "goodies"

Examples of some fairly uncommon languages that can teach you interesting things (this list is not exhaustive)...

<table>
<tr><td>LISP (macros, code is data)
</td><td>Scheme (continuations)
</td></tr><tr><td>Haskell (lazy evaluation, monads, etc.)
</td><td>Scala (OO + functional, actors)
</td></tr><tr><td>Erlang (actors)
</td><td>Go/Oberon (implicit interfaces)
</td></tr><tr><td>TCL (dual-ported objects, uplevel)
</td><td>Smalltalk/Squeak/Scratch (foundational OO)
</td></tr><tr><td>OPS5 (forward chaining)
</td><td>Prolog (unification/backtracking)
</td></tr><tr><td>Icon (goal-directed execution/backtracking)
</td><td>FORTH/PostScript/Factor (stack languages, compile-time execution)
</td></tr><tr><td>Lua (meta model)
</td><td>Self/Io (pure prototype-based OO)</td></tr>
</table>
***
#Lambda Calculus is a Programming Language

Alonzo Church (Alan Turing's professor) created Lambda Calculus around 1928.

It's not the oldest programming language

(around 400 BC, an Indian guy named P&#257;&#7751;ini made a grammatical system for Sanskrit that is actually a "turing equivalent" programming language)

But I still think LC is truly primordial, based on its simplicity (very few "moving parts")
***
#Lambda Calculus is a Programming Language

It's very simple

I think it's ideal for teaching CS concepts

There's just so little to get in the way
***
#Lambda Calculus is a Programming Language

Some neato things that are easy to do in Lambda calculus

* custom control structures
* computed streams of data
* generators/iterators
* infinite streams
* deep code factoring (combinators)
* extensible syntax (parsing tricks can make this even more powerful)
* ***parallel computing*** (ooh... ahh...)

You can do some of these things in a lot of other languages, but they probably won't be as straight-forward.  They can still be very useful and powerful, though.  One example of this is the [Functional Java](http://functionaljava.org/) library, which bolts functional capabilities onto Java.
***
#Lambda Calculus is a Programming Language

How primordial is it?
***
#THERE ARE NO NUMBERS
***
#THERE ARE NO BITS
***
#THERE ARE NO COMPARISONS
***
#WHAT THE?
***
#YOU CAN'T EVEN REASSIGN VARIABLES
***
#WHAT THE?
***
#It's not as bad as it seems

It's actually very powerful

It's easy to use, once you get the hang of it

(and modern versions of typed LC, like Haskell do give you primitive numbers and comparisons)
***
#It's not as bad as it seems

No numbers and comparisons &rArr; students can implement them

How do you show how to define bits, numbers, and ">" in C or assembly?

This is the primoridal value of LC

But even at this low level, you can still do "real" things...
***
#It's not as bad as it seems

To show this, I started on a version of [Space Invaders in Lambda Calculus](http://tinyconcepts.com/invaders.html)

55 lines of code, so far (including definitions for numbers and comparisons)

Uses JavaScript to display the state and get events
***
#Evaluator

To run it, I made a [Lambda Calculus evaluator](evaluator.html) in JavaScript

It can run Lambda Calculus 3 different ways.  It can...

1. compile into JavaScript
1. interpret in JavaScript and see the substitution steps
1. compile into virtual machine bytecode (and run it)

I'm working on a LLVM code generator to compile into native machine code (and let you link with libraries)

The idea here is to give people insight into how compilers, interpreters, and VMs work
***
#Brief Overview

Teaching and experimentation

The things in this talk also work in Haskell

Haskell has proven to be practical and fast (DARCS DVCS is written in Haskell)

Maybe untyped LC could be too

**LC gives you a lot of power and productivity, even though it's low-level**

* LC uses "lazy evaluation" -- function arguments are never evaluated until they are used (and this is transitive)
* LC is just functions -- data is also functions, which means data is also lazy
* LC allows "currying" -- calling a 3-arg function with only the first 2 args returns a 1-arg function that "saves" the first 2

Most languages don't have lazy evaluation + currying + data/functions

This combination can be really powerful
***
#Brief Overview: Functions

LC is just functions and functions are like subroutines

function = argument + body: <span class="def">λargument</span> . body

A function body can be...

* another function: <span class="def">λa</span> . <span class="def">λb</span> . a
* an argument: <span class="def">λb</span> . a
* calling a value with another value (and the result with another value, etc.): <span class="def">λa</span> . <span class="def">λb</span> . <span class="def">λf</span> . (f a) b

Values can be functions or undefined
***
#Brief Overview: Functions

A function which returns another function acts like it takes another argument

because `(func X) Y` sends `Y` to the function returned by `(func X)`

but LC is "right associative" and lets you say `func X Y`, instead

(so `func X` is really currying `func X Y`)

So people smash together functions that return other functions; they write

<span class="def">λa</span> . <span class="def">λb</span> . <span class="def">λf</span> . f a b

as

<span class="def">λa b f</span> . f a b

It's less of a pain
***
#Brief Overview: Data

Here's how you can define a simple "person record"...

* makePerson = <span class="def">λname number f</span> . f name number
***
#Brief Overview: Data

Here's how you can define a simple "person record"...

* makePerson = <span class="def">λname number f</span> . f name number

Calling makePerson with a name returns a function that takes a number and returns another function:

makePerson fred &rArr; <span class="def">λnumber f</span> . f fred number
***
#Brief Overview: Data

Here's how you can define a simple "person record"...

* makePerson = <span class="def">λname number f</span> . f name number

Calling makePerson with a name returns a function that takes a number and returns another function:

makePerson fred &rArr; <span class="def">λnumber f</span> . f fred number

You can call that with a number to get a "person record":

(makePerson fred) 777-2344 &rArr; <span class="def">λf</span> . f fred 777-2344
***
#Brief Overview: Data

Here's how you can define a simple "person record"...

* makePerson = <span class="def">λname number f</span> . f name number

Calling makePerson with a name returns a function that takes a number and returns another function:

makePerson fred &rArr; <span class="def">λnumber f</span> . f fred number

You can call that with a number to get a "person record":

(makePerson fred) 777-2344 &rArr; <span class="def">λf</span> . f fred 777-2344

Lambda Calculus is "left associative" to make this easier:

makePerson fred 777-2344 &rArr; <span class="def">λnumber f</span> . f fred 777-2344
***
#Brief Overview: Data

**Wait -- what just happened?**

We used currying to create a "person record"...

* makePerson = <span class="def">λname number f</span> . f name number

makePerson fred 777-2344 &rArr; <span class="def">λnumber f</span> . f fred 777-2344

See how makePerson defines this "f" argument, but we aren't using it?

When I send only 2 arguments to makePerson, I get back a function that takes an "f"

The fact that I can send in "f" later allows the "person record function" to work

LC uses currying for a LOT of things
***
#Brief Overview: Data

<span class="def">λf</span> . f fred 777-2344

This "person record" takes a function (f) and applies it to the name and number

You could define getName to return the name of the person
***
#Brief Overview: Data

<span class="def">λf</span> . f fred 777-2344

This "person record" takes a function (f) and applies it to the name and number

You could define getName to return the name of the person

* getName = <span class="def">λperson</span> . person (<span class="def">λname number</span> . name)
***
#Brief Overview: Data

<span class="def">λf</span> . f fred 777-2344

This "person record" takes a function (f) and applies it to the name and number

You could define getName to return the name of the person

* getName = <span class="def">λperson</span> . person (<span class="def">λname number</span> . name)

getName (<span class="def">λf</span> . f fred 777-2344) &rArr; fred
***
#Brief Overview: Data

<span class="def">λf</span> . f fred 777-2344

This "person record" takes a function (f) and applies it to the name and number

You could define getName to return the name of the person

* getName = <span class="def">λperson</span> . person (<span class="def">λname number</span> . name)

getName (<span class="def">λf</span> . f fred 777-2344) &rArr; fred

This is a lot like `struct person p = {"fred", "777-2344"};` in C
***
#Brief Overview: Data

<span class="def">λf</span> . f fred 777-2344

This "person record" takes a function (f) and applies it to the name and number

You could define getName to return the name of the person

* getName = <span class="def">λperson</span> . person (<span class="def">λname number</span> . name)

getName (<span class="def">λf</span> . f fred 777-2344) &rArr; fred

This is a lot like `struct person p = {"fred", "777-2344"};` in C

but later, we'll see some powerful differences.
***
#Custom Control Structures

You can use booleans in LC as if-then statements, kind of like how C uses && and ||

* true = <span class="def">λa b</span> . a
* false = <span class="def">λa b</span> . b

Suppose you have three variables, v1 = true, v2 = false, and v3 = false

v1 (v2 a b) (v3 c d) &rArr; b

This does not evaluate the second argument, just like C wouldn't: (v1 && ((v2 && a) || b)) || ((v3 && c) || d)

"lazy evaluation" makes **everything** use "short-circuit" evaluation, like C's && and ||
***
#Custom Control Structures

Lazy evaluation lets you define your own control structures, like if, for, while, switch, etc.

There are some pretty useful control structures that aren't in C or Java

(like Scala's "for comprehension", which looks like a "for" loop but is a lot more powerful)
***
#Computed Streams of Data

* cons = <span class="def">λh t f</span> . f h t
* head = <span class="def">λlist</span> . list (<span class="def">λhead tail</span> . head)
* tail = <span class="def">λlist</span> . list (<span class="def">λhead tail</span> . tail)
* nil = false

Cons makes a list.

This is a lot like makePerson, but you use it differently.

The "head" is an item in the list.

The "tail" is the rest of the list (either another cons or nil).

Lazy evaluation makes computing a list in LC like making a Java/C++ iterator or a Python generator
***
#Computed Streams of Data

* cons = <span class="def">λh t f</span> . f h t
* head = <span class="def">λlist</span> . list (<span class="def">λhead tail</span> . head)
* tail = <span class="def">λlist</span> . list (<span class="def">λhead tail</span> . tail)
* nil = false

Cons makes a list.

This is a lot like makePerson, but you use it differently.

The "head" is an item in the list.

The "tail" is the rest of the list (either another cons or nil).

Lazy evaluation makes computing a list in LC like making a Java/C++ iterator or a Python generator

Ever write an iterator for a recursive data structure, like a tree or graph?
***
#Computed Streams of Data

What cons does...
***
#Computed Streams of Data

What cons does...

cons A nil &rArr; <span class="def">λf</span> . f A nil
***
#Computed Streams of Data

What cons does...

cons A nil &rArr; <span class="def">λf</span> . f A nil

cons B (cons A nil) &rArr; <span class="def">λf2</span> . f2 B (<span class="def">λf</span> . f A nil)
***
#Computed Streams of Data

What cons does...

cons A nil &rArr; <span class="def">λf</span> . f A nil

cons B (cons A nil) &rArr; <span class="def">λf2</span> . f2 B (<span class="def">λf</span> . f A nil)

Right?
***
#Computed Streams of Data

What cons does...

cons A nil &rArr; <span class="def">λf</span> . f A nil

cons B (cons A nil) &rArr; <span class="def">λf2</span> . f2 B (<span class="def">λf</span> . f A nil)

Right?

Let's look at the [replay](slideEx.html)...
***
#Computed Streams of Data

What can you do with them?

* Produce a new stream by transform the elements of the original
* Produce a new stream by discarding some of the elements of the original
* Produce a new stream by inserting elements into the original
* Combine the above operations
* Produce a new stream by merging several streams together
* Kind of like SQL
***
#Generators

* nd = <span class="def">λvalue left right f</span> . f value left right
* value = <span class="def">λtree</span> . tree (<span class="def">λv l r</span> . v)
* left = <span class="def">λtree</span> . tree (<span class="def">λv l r</span> . l)
* right = <span class="def">λtree</span> . tree (<span class="def">λv l r</span> . r)
* traverse = rec <span class="def">λtr tree</span> . tree (<span class="def">λv l r D</span> . (cons (value tree) (append (tr (left tree)) (tr (right tree))))) nil

(rec is a function which uses the "Y-combinator" to define a recursive function, so "tr" becomes the recursive name for "traverse")

Traverse just creates of a list of the preorder traversal of the tree:

traverse (nd 1 (nd 2 nil nil) (nd 3 nil nil)) &rArr; [1,2,3]
***
#Generators

* nd = <span class="def">λvalue left right f</span> . f value left right
* value = <span class="def">λtree</span> . tree (<span class="def">λv l r</span> . v)
* left = <span class="def">λtree</span> . tree (<span class="def">λv l r</span> . l)
* right = <span class="def">λtree</span> . tree (<span class="def">λv l r</span> . r)
* traverse = rec <span class="def">λtr tree</span> . tree (<span class="def">λv l r D</span> . (cons (value tree) (append (tr (left tree)) (tr (right tree))))) nil

(rec is a function which uses the "Y-combinator" to define a recursive function, so "tr" becomes the recursive name for "traverse")

Traverse just creates of a list of the preorder traversal of the tree:

traverse (nd 1 (nd 2 nil nil) (nd 3 nil nil)) &rArr; [1,2,3]

But [1,2,3] is a **lazy** list
***
#Generators

The result ([1,2,3]) is really just <span class="def">λf</span> . f (node-value) (traverse-the-rest)

It traverses the tree as you draw elements from the list

Lazy evaluation makes this automatic
***
#Generators

Only the parts of the list you access are actually computed

The rest remain _virtual_

This brings us to...
***
#Infinite Streams

* natural numbers
* whole numbers
* even numbers
* random numbers
* ...
***
#Infinite Streams

* natural numbers
* whole numbers
* even numbers
* random numbers
* ...

You can use infinite streams in a loop to generate values

map FUNC (remove (not prime) naturals)  
// this would be kind of like: for (i in naturals - !prime) {FUNC}  
// if - and not applied to lists and functions

map FUNC (map square naturals)  
// this would be kind of like: for (i in square * naturals) {...}
// if * applied to lists and functions
***
#Infinite Streams

* natural numbers
* whole numbers
* even numbers
* random numbers
* ...

You can use infinite streams in a loop to generate values

map FUNC (remove (not prime) naturals)  
// this would be kind of like: for (i in naturals - !prime) {FUNC}  
// if - and not applied to lists and functions

map FUNC (map square naturals)  
// this would be kind of like: for (i in square * naturals) {...}
// if * applied to lists and functions

map FUNC (map square (remove (! (prime || ten || even)) naturals))  
for (i in squares * (naturals - !(prime || ten || odd))) {...}  
// I'm using "|" to alternate, so naturals - ((!prime & !ten) | even) is  
// all naturals which are prime or odd or multiples of 10
***
#Deep Factoring

You can transform and filter lists, just like you can in Smalltalk, LISP, Haskell, etc.

"Currying" when mapping or filtering produces a new function that operates on any list

You can compose them with other functions that operate on lists:  
`mogrify = λfunc l . map func (map square (remove (! (prime || ten || even)) l))`  
`mogrify bob` uses currying to make a combinator you can use on lists or in other list combinators

This makes it easy to create and reuse functions that transform lists

You can use these techniques for things other than collections, too, like "parser combinators"
***
#Extensible Syntax

[ 1 , 2 , 3 ] constructs lists

"[", ",", and "]" are really just functions

"[" creates a "list builder function"

"," makes the list builder continue

"]" makes the list builder produce the final list

Without any extra rules, you can make functions that look like infix

Extra parsing goodies will let you do even better

Like allowing you to leave out spaces and define groups:

append [1,2,3] [4,5]

This and custom control structures are good for creating your own "DSLs" -- domain specific languages
***
#Parallel Computing

A thread changing data while another thread uses it is one of the worst horrors of parallel computing

But in functional programs, you ***can't change data***

The data you have is going to remain as it is

That means another thread can't change it underneath you

The way you make "changes" is to return "transformed replacements"
***
#Parallel Computing

Isn't creating new data instead of changing existing data inefficient?
***
#Parallel Computing

Isn't creating new data instead of changing existing data inefficient?

Yes, but transformed data structures can reuse parts of the original structure
***
#Parallel Computing

Isn't creating new data instead of changing existing data inefficient?

Yes, but transformed data structures can reuse parts of the original structure

And speed != efficiency (a Viper isn't quite as efficient as a Prius)
***
#Parallel Computing

Isn't creating new data instead of changing existing data inefficient?

Yes, but transformed data structures can reuse parts of the original structure

And speed != efficiency (a Viper isn't quite as efficient as a Prius)

Nvidia Fermi needs to run over 20,000 of threads for optimal usage
***
#Parallel Computing

Isn't creating new data instead of changing existing data inefficient?

Yes, but transformed data structures can reuse parts of the original structure

And speed != efficiency (a Viper isn't quite as efficient as a Prius)

Nvidia Fermi needs to run over 20,000 of threads for optimal usage

But to use that many threads, we needs automatic ways to *massively* parellelize code
***
#Parallel Computing

Isn't creating new data instead of changing existing data inefficient?

Yes, but transformed data structures can reuse parts of the original structure

And speed != efficiency (a Viper isn't quite as efficient as a Prius)

Nvidia Fermi needs to run over 20,000 of threads for optimal usage

But to use that many threads, we needs automatic ways to *massively* parellelize code

Relegating high-level tasks to another thread (like updating a browser tab) isn't good enough
***
#Parallel Computing

So, functional programming can *support* parallel computing well, but can it make it easier?

Those stream operations we talked about, before: transforming, discarding, inserting

Those are a lot like Google's map/reduce (because it's based on functional concepts)

Google's Map/reduce operates "in the large", on server farms

Functional programming languages can do this "in the small" (like on an SMP machine)
***
#Parallel Computing

Map is a function that transforms a list of values by applying a function to each element:

map twice [1,2,3] &rArr; [2,4,6]

Parallel functional languages (like Haskell and Scala) support parallel list transformations

So they would send each element of the list to a different processor (if you have that many processors)

This works on other types of collections, besides streams, of course (trees, arrays, etc.)
***
# The End

<img src="qrCode.png" alt="qrcode">
***
#Resources

* Documents about functional programming and lazy evaluation
 *  Talk on Why Functional Programming Matters: [http://www.infoq.com/interviews/john-hughes-fp](http://www.infoq.com/interviews/john-hughes-fp)
 *  Why Functional Programming Matters paper: [http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.63.7911&rep=rep1&type=pdf](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.63.7911&rep=rep1&type=pdf)
 *  Tim Sweeney's (of Epic Games) talk on the future of graphics programming: [http://www.cs.princeton.edu/~dpw/popl/06/Tim-POPL.ppt](http://www.cs.princeton.edu/~dpw/popl/06/Tim-POPL.ppt)
 *  The Real Point of Laziness: [http://existentialtype.wordpress.com/2011/04/24/the-real-point-of-laziness/](http://existentialtype.wordpress.com/2011/04/24/the-real-point-of-laziness/)
 *  More Points for Lazy Evaluation: [http://augustss.blogspot.com/2011/05/more-points-for-lazy-evaluation-in.html](http://augustss.blogspot.com/2011/05/more-points-for-lazy-evaluation-in.html)
 *  Martin Odersky's [talk on Scala and parallel computing](http://www.parleys.com/#st=5&id=2184)
 *  My [parallel collection Go library](https://github.com/zot/seq)
* Tools for easy slide presentations, like this
 * QuickSlides: [http://tobyho.com/Quick-and-Dirty\_Presentations\_in\_Markdown](http://tobyho.com/Quick-and-Dirty_Presentations_in_Markdown)
 * Slidy: [http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js.gz](http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js.gz)
 * Slidy CSS: [http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css](http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css)
 * Showdown: [http://softwaremaniacs.org/playground/showdown-highlight/](http://softwaremaniacs.org/playground/showdown-highlight/)
-->
</script>
<script>
var scripts = document.getElementsByTagName('script');
for (var i = 0; i < scripts.length; i++){
    var script = scripts[i];
    if (script.type != 'text/markdown') continue;
    var md = script.innerHTML.replace(/^\s<!--*/, '')
        .replace(/-->\s*$/, '');
    var markup = new Showdown.converter().makeHtml(md);
    var slides = markup.split('<hr />');
    for (var j = 0; j < slides.length; j++)
      document.write('<div class=slide>' + slides[j] + '</div>');
}
w3c_slidy.add_listener(document.body, "touchend", w3c_slidy.mouse_button_click);
</script>
</body>
</html>
