<!doctype html>
<html>
<head> 
  <title>My Slides</title> 
  <link rel="stylesheet" type="text/css" media="screen, projection, print" 
   href="slidy.css" />
  <script src="showdown.js"></script>
  <script src="slidy.js"></script>
</head>
<body>
<script type=text/markdown>
<!--
#Primordial Programming...

Getting close to the metal with untyped Lambda Calculus
***
#Disclaimer: I'm not selling a language or a paradigm

Languages are tools and they all have advantages and disadvantages

Programmers should know more languages, because they open your mind to different ways to solve problems

To understand a language, you need to program something nontrivial in a way that depends on that language's "goodies"

Examples of some fairly uncommon languages that can teach you interesting things (this list is not exhaustive)...

<table>
<tr><td>LISP (macros, code is data)
</td><td>Scheme (continuations)
</td></tr><tr><td>Haskell (lazy evaluation, monads, etc.)
</td><td>Scala (OO + functional, actors)
</td></tr><tr><td>Erlang (actors)
</td><td>Go/Oberon (implicit interfaces)
</td></tr><tr><td>TCL (dual-ported objects, uplevel)
</td><td>Smalltalk/Squeak/Scratch (foundational OO)
</td></tr><tr><td>OPS5 (forward chaining)
</td><td>Prolog (unification/backtracking)
</td></tr><tr><td>Icon (goal-directed execution/backtracking)
</td><td>FORTH/PostScript/Factor (stack languages, compile-time execution)
</td></tr><tr><td>Lua (meta model)
</td><td>Self/Io (pure prototype-based OO)</td></tr>
</table>
***
#Background info

Haskell is the most popular version of Lambda Calculus around

***
#Background info

Haskell is the most popular version of Lambda Calculus around

Haskell is (very) strongly typed.
***
#Background info

Haskell is the most popular version of Lambda Calculus around

Haskell is (very) strongly typed.

It's one of the _most_ strongly typed languages around.
***
#Background info

Haskell is the most popular version of Lambda Calculus around

Haskell is (very) strongly typed.

It's one of the _most_ strongly typed languages around.

If you think Java's and C++'s Generics are complicated, that's just peanuts compared to Haskell's
***
#Background info

Haskell is the most popular version of Lambda Calculus around

Haskell is (very) strongly typed.

It's one of the _most_ strongly typed languages around.

If you think Java's and C++'s Generics are complicated, that's just peanuts compared to Haskell's

But this talk is not about Haskell.
***
#Some neato things you can easily do in Lambda calculus

* generators (iterators)
* infinite streams (good for filtering/generate and test)
* custom control structures
* varargs (without extra language constructs)
* deep code factoring (eg. combinators)
***
#Generators

* makeTree = &lambda;value left right f . f value left right
* value = &lambda;tree . tree &lambda;v l r . v
* left = &lambda;tree . tree &lambda;v l r . l
* right = &lambda;tree . tree &lambda;v l r . r
* traverse = rec &lambda;tr tree . tree (&lambda;v l r D . (cons (value tree) (append (tr (left tree)) (tr (right tree))))) nil

Traverse just creates of a list of the preorder traversal of the tree:

traverse (nd 1 (nd 2 nil nil) (nd 3 nil nil) nil) &rArr; [1,2,3]
***
#Generators

* makeTree = &lambda;value left right f . f value left right
* value = &lambda;tree . tree &lambda;v l r . v
* left = &lambda;tree . tree &lambda;v l r . l
* right = &lambda;tree . tree &lambda;v l r . r
* traverse = rec &lambda;tr tree . tree (&lambda;v l r D . (cons (value tree) (append (tr (left tree)) (tr (right tree))))) nil

Traverse just creates of a list of the preorder traversal of the tree:

traverse (nd 1 (nd 2 nil nil) (nd 3 nil nil) nil) &rArr; [1,2,3]

Right?
***
#Generators

* makeTree = &lambda;value left right f . f value left right
* value = &lambda;tree . tree &lambda;v l r . v
* left = &lambda;tree . tree &lambda;v l r . l
* right = &lambda;tree . tree &lambda;v l r . r
* traverse = rec &lambda;tr tree . tree (&lambda;v l r D . (cons (value tree) (append (tr (left tree)) (tr (right tree))))) nil

Traverse just creates of a list of the preorder traversal of the tree:

traverse (nd 1 (nd 2 nil nil) (nd 3 nil nil) nil) &rArr; [1,2,3]

Right?

Well... 
***
#Generators

* makeTree = &lambda;value left right f . f value left right
* value = &lambda;tree . tree &lambda;v l r . v
* left = &lambda;tree . tree &lambda;v l r . l
* right = &lambda;tree . tree &lambda;v l r . r
* traverse = rec &lambda;tr tree . tree (&lambda;v l r D . (cons (value tree) (append (tr (left tree)) (tr (right tree))))) nil

Traverse just creates of a list of the preorder traversal of the tree:

traverse (nd 1 (nd 2 nil nil) (nd 3 nil nil) nil) &rArr; [1,2,3]

Right?

Well... 

Check out what it _really_ returns...
***
#Generators
λf_1 . f_1 (getValue (nd 1 false false)) (rec (λappend_1 l1 l2 . l1 (λh t D . cons h (append_1 t l2)) l2) (Y (λtraverse_2 tree_1 . tree_1 (λv_1 l_1 r_1 D_1 . cons (getValue tree_1) (rec (λappend_1 l1 l2 . l1 (λh t D . cons h (append_1 t l2)) l2) (traverse_2 (getLeft tree_1)) (traverse_2 (getRight tree_1)))) false) (getLeft (nd 1 false false))) (Y (λtraverse_2 tree_1 . tree_1 (λv_1 l_1 r_1 D_1 . cons (getValue tree_1) (rec (λappend_1 l1 l2 . l1 (λh t D . cons h (append_1 t l2)) l2) (traverse_2 (getLeft tree_1)) (traverse_2 (getRight tree_1)))) false) (getRight (nd 1 false false))))

Complicated, but this is the "captured execution".
***
#Generators

Lazy evaluation means that only the parts of the list you access are actually computed.  The rest remain _virtual_.

This brings us to...
***
#Infinite streams

Example infinite streams:

* natural numbers
* whole numbers
* even numbers
* random numbers (given a seed)

With lazy evaluation, you can make functions that filter streams, transform them, skip elements, truncating them (and more).

You can send this function an infinite stream and 
***
#Custom control structures
***
#Varargs
***
#Deep factoring
***
#So what?
***
#So what?

Teaching people about deep CS concepts (recursion, laziness, functional, ...)
***
#So what?

Teaching people about deep CS concepts (recursion, laziness, functional, ...)

[Evaluator](evaluator.html)
***
#So what?

Teaching people about deep CS concepts (recursion, laziness, functional, ...)

[Evaluator](evaluator.html)

[Space Invaders](http://tinyconcepts.com/invaders.html)
***
# These slides

<img src="http://qrcode.kaywa.com/img.php?s=8&d=http%3A%2F%2Ftinyconcepts.com%2Ffs.pl%2Flambda.fsl%2Fdoc%2Ftip%2Fslides.html" alt="qrcode">
***
# Resources

* Documents about functional programming and lazy evaluation
 *  Talk on Why Functional Programming Matters: [http://www.infoq.com/interviews/john-hughes-fp](http://www.infoq.com/interviews/john-hughes-fp)
 *  Why Functional Programming Matters paper: [http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.63.7911&rep=rep1&type=pdf](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.63.7911&rep=rep1&type=pdf)
 *  Tim Sweeney's (of Epic Games) talk on the future of graphics programming: [http://www.cs.princeton.edu/~dpw/popl/06/Tim-POPL.ppt](http://www.cs.princeton.edu/~dpw/popl/06/Tim-POPL.ppt)
 *  The Real Point of Laziness: [http://existentialtype.wordpress.com/2011/04/24/the-real-point-of-laziness/](http://existentialtype.wordpress.com/2011/04/24/the-real-point-of-laziness/)
 *  More Points for Lazy Evaluation: [http://augustss.blogspot.com/2011/05/more-points-for-lazy-evaluation-in.html](http://augustss.blogspot.com/2011/05/more-points-for-lazy-evaluation-in.html)
* Markdown slide presentations
 * QuickSlides: [http://tobyho.com/Quick-and-Dirty\_Presentations\_in\_Markdown](http://tobyho.com/Quick-and-Dirty_Presentations_in_Markdown)
 * Slidy: [http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js.gz](http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js.gz)
 * Slidy CSS: [http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css](http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css)
 * Showdown: [http://softwaremaniacs.org/playground/showdown-highlight/](http://softwaremaniacs.org/playground/showdown-highlight/)
-->
</script>
<script>
var scripts = document.getElementsByTagName('script');
for (var i = 0; i < scripts.length; i++){
    var script = scripts[i];
    if (script.type != 'text/markdown') continue;
    var md = script.innerHTML.replace(/^\s<!--*/, '')
        .replace(/-->\s*$/, '');
    var markup = new Showdown.converter().makeHtml(md);
    var slides = markup.split('<hr />');
    for (var j = 0; j < slides.length; j++)
      document.write('<div class=slide>' + slides[j] + '</div>');
}
w3c_slidy.add_listener(document.body, "touchend", w3c_slidy.mouse_button_click);
</script>
</body>
</html>
