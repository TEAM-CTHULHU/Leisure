# primitives
#
# eq a b -> true if they are equal or false otherwise
#
# getType value -> an option containing the type
# 
# is value type -> true if the value has type type, false otherwise
#
# eval ast -> evaluates ast and returns the result
#
# parse string -> an Either with ast or error msg (give it two functions)
#
# pretty value -> pretty print a value
#
# funcSource func -> option with function's src or none if no source (e.g. primitive or lambda)
#
#    MONADS
#
# bind m binding -> transform a monad with a function and continue with result of function
#
# print string -> print a string and continue with false
#
# prompt string -> ask user for input and continue with value
#
# return value -> continus with value
#
# js string -> run JS code and continue with value
#
# createS -> create a new state variable and continue with it
#
# getS var -> get the value from the state variable var and continue with it
#
# setS var val -> set the state variable var to val and continue with false
#
#    STRING functions
#
# concat list -> string
#
#    AST-constructors
#
# lit value -> a lit AST node, containing value
#
# ref var-name -> a ref AST node, containing var-name
#
# lambda var-name body-ast -> a lambda AST node, with var-name and the body AST
#
# apply func-ast body-ast -> an apply AST node, with func and body ASTs
#
# prim arg rest-ast -> a prim AST node, rest-ast should either be a ref or a prim
#
#    List functions
#
# MORE DOCUMETATION NEEDED :)
#

#@auto
defGroup '[' ']'
#@auto
defGroup 'concat[' ']'
#@Xauto
#defGroup 'and[' ']'
#@Xauto
#defGroup 'or[' ']'
#@auto
defToken '|'
#@auto
defToken ','
#@auto
defToken '<-'
#@auto
defToken '::'

id x = x

# make a new function that takes two args in opposite order than the original function
# eq. flip cons nil 1 gives cons: [1]
flip f = \a b . f b a

compose f g = \x . f ( g x)

# The Y combinator, for reference
#
# Y = \g  .  (\x  .  g (x x)) \x  .  g (x x)
# rec = \f . f (Y f)

# booleans
true = \a b . a
false = \a b . b
and a b = a b false
or a = a true
not a = a false true
neq a b = not (eq a b)

# choices
left v = \l r . l v
right v = \l r . r v
some x = \yes no . yes x
some2 a b = \yes no . yes a b
none = \yes no . no

# numerics

iszero = eq 0
positive = < 0

-- = (flip -) 1
++ = + 1
even? x = iszero (% x 2)
odd? x = eq 1 (% x 2)
max a b = (gt a b) a b
min a b = (lt a b) a b

######################
# Lists
######################

# some list functions are primitives, for the time being: cons, nil
# cons a b = \f . f a b
# nil = \a b . b

isStream x = false
isStream x::cons = true
isStream x::lexCons = true
head l::cons = l \h t . h
tail l::cons = l \h t . t
head l::lexCons = l \h s t e . h
tail l::lexCons = l \h s t e . t
length l = (eq l nil) 0 (++ (length (tail l) ) )
last l = eq (tail l) nil
  head l
  last (tail l)
startPos l::lexCons = lexStart l
startPos t::token = t \t p . p
endPos l::lexCons = lexEnd l
endPos t::token = + (tokenStart t) (strlen (tokenName t))
pairFunc l = false
pairFunc l::cons = cons
pairFunc l::lexCons = lexConsFuzzy
pairFunc l::token = lexConsFuzzy
lexConsFuzzy h t = null? t
  lexCons h (startPos h) nil (endPos h)
  lexCons h (startPos h) t (endPos t)
null? x = false
null? x::nil = true

# make a new list by applying func (which takes exactly 1 arg) to each element of list
# eg. map (+ 1) [4 27 54] gives cons: [5 28 55]
map func list = _map (pairFunc list) func list
_map pairF func list = null? list
  nil
  pairF (func (head list)) (_map pairF func (tail list))

# foldl (\prev el . ...) list
# foldr (\el prev . ...) list
# call func on list items and previous result of fold
# foldl uses the head of the list for the previous results
# foldr uses the tail of the list for the previous results
# foldr can work on infinite lists, but foldl cannot
foldl func arg list = foldl func (func arg (head list)) (tail list)
foldl func arg list::nil = arg
foldl1 func list = foldl func (head list) (tail list)
foldl1 func list::nil = nil
foldr func arg list = null? list
  arg
  func (head list) (foldr func arg (tail list))
foldr1 func list = eq (tail list) nil
  head list
  func (head list) (foldr1 func (tail list))
foldr1 func list::nil = nil

append l1 l2 = _append (pairFunc l1) l1 l2
append l1::nil l2 = l2
_append pairF l1 l2 = pairF (head l1) (_append pairF (tail l1) l2)
_append pairF l1::nil l2 = l2

reverse l = subreverse l nil
subreverse l result = l (\h t D . subreverse t (cons h result)) result

if = id
at l x = (iszero (x)) (head l) (at (tail l) (-- (x) ) )

index_combine x y = (or (eq x nil) (eq y nil)) (nil) (+ x y)

# return nil if not found, or 0 based index of the first match
indexof l x = if (eq l nil) (nil) (if (eq x (head l)) (0) (index_combine 1 (indexof (tail l) x ) ) )

# position does the same thing as indexof, but takes the args in opposite order
position l x = indexof x l

# Macros

#
# List constructor macro
#

# pure Lambda Calculus list constructor, for reference
#[ =(]= \item c . c \rest . cons item rest
#, =.= \f item c . c \rest . f (cons item rest)
#] =)= \f . f nil
#| =.= \f rest g . f rest

[ list =M= constructList (tail list)

constructList list = cl (head list) (tokString (head list)) (tail list)
constructList list::nil = nil

cl h hs t = eq hs '|'
  eq (length t) 2
    # -- scanner ensures: eq (tokString (head (tail t))) ']'
    cons (head t) nil
    error "Bad list format."
  eq hs ']'
    # -- scanner ensures: eq t nil
    cons 'nil' nil
    eq hs ','
      constructList t
      cons (cons 'cons' (cons h (constructList t))) nil

tokString x = x
tokString t::token = t \t p . t

identMacro list =M= tail list

macroCons list =M= cons 'cons' (tail list)

#concat[ list =M= cons 'concat' (cons (cons '[' (tail list)) nil)

concat[ list =M= cons (token 'concat' (tokenStart list)) (cons (cons (token '[' (tokenStart (tail list))) (tail list)) nil)

intersperse x l = or (eq l nil) (eq (tail l) nil) l [(head l) x | (intersperse x (tail l))]

intercalate x l = concat (intersperse x l)

# and[ list =M= intersperse (token 'and' (tokenStart (list))) (removeLast (tail list))
# or[ list =M= intersperse (token 'or' (tokenStart (list))) (removeLast (tail list))
# 
# removeLast list = rl list (tail list)
# rl list rest = cons (head list) (rl (tail list) (tail rest))
# rl list rest::nil = nil
# 
# intersperse item list = head (isp item list (tail list))
# isp item list rest = cons (cons item (cons (head list) (isp item (tail list) (tail rest)))) nil
# isp item list rest::nil = list

######################
# Do
######################

doFilter parseDefs list = transformDo list

transformDo list = list
transformDo list::cons = subDos list
transformDo list::lexCons = subDos list

subDos list = eq 'do' (tokString (head list))
  foldr1 (\el . doClause el) (subNextDos (tail list))
  subNextDos list

subNextDos nonlist = nonlist
subNextDos list::cons = listSubNextDos list
subNextDos list::lexCons = listSubNextDos list

listSubNextDos list = eq '.' (tokString (head list))
  cons (head list) (transformDo (tail list))
  cons (transformDo (head list)) (subNextDos (tail list))

doClause clause rest = doExtractVar clause '<-'
  \var . cons 'bind' (cons (tail (tail clause)) (cons '\\' (cons var (cons '.' (cons rest nil)))))
  doExtractVar clause '='
    \var . cons (cons '\\' (cons var (cons '.' (cons rest nil)))) (cons (tail (tail clause)) nil)
    cons 'bind' (cons clause (cons '\\' (cons '_' (cons '.' (cons rest nil)))))

doExtractVar list tokName = none
doExtractVar list::cons tokName = listDoExtractVar list tokName
doExtractVar list::lexCons tokName = listDoExtractVar list tokName

listDoExtractVar list tokName = or (null? (tail list)) (neq tokName (tokString (head (tail list))))
  none
  some (head list)

#@auto
addParseFilter doFilter

######################
# More list stuff
######################

#@auto
do
  defGroup 'or[' ']'
  defGroup 'and[' ']'

# difference lists
dlempty = id
dl item = \rest . [item | rest]
dlPush list item = dlAppend list (dl item)
dlAppend a b = \rest . a (b rest)

flatten list = subflatten list nil
subflatten list = isStream list
  dlAppend (subflatten (head list)) (subflatten (tail list))
  dl list
subflatten list::nil = dlempty

# remove any x's found in list
remove x l = removeIf (eq x) l

# remove any elements where f evals to true, f must take exactly one argument
removeIf f l = _removeIf (pairFunc l) f l
_removeIf pairF f l  = if (eq l nil) nil
  if (f (head l)) (_removeIf pairF f (tail l))
    pairF (head l) (_removeIf pairF f (tail l))
removeIfNot f l = removeIf (\x. not (f x)) l

filter f = removeIf (compose not f)

# return true if any elements of l satisfy f, which takes exactly one arg
# eg. any (eq 0) [1 2 0] gives true: true
any f l = _any (pairFunc l) f l
_any pairF f l = null? l
  false
  or
    f (head l)
    _any pairF f (tail l)

# return true if ALL elements of l satisfy f, which takes exactly one arg
# eg. all (eq 0) [0 0 0] gives true: true
# caveat!  return true for nil lists
all f l = _all (pairFunc l) f l
_all pairF f l = null? l
  true
  and
    f (head l)
    _all pairF f (tail l)

# find returns x if x is present inside l, otherwise returns nil.
find x l = findIf (eq x) l

# findIf returns the first element that satisfies f or nil is none do
findIf f l = null? l
  nil
  f (head l)
    head l
    findIf f (tail l)

findIfOpt f l = null? l
  none
  f (head l)
    some (head l)
    findIfOpt f (tail l)

findIndex func list = subFindIndex 0 func list
subFindIndex index func list = func (head list)
  index
  subFindIndex (+ 1 index) func (tail list)
subFindIndex index func list::nil = -1

take n list = _take (pairFunc list) n list
_take pairF n list = positive n
  null? list
    nil
    pairF (head list) (_take pairF (-- n) (tail list))
  nil
takeWhile predicate list = _takeWhile (pairFunc list) predicate list
_takeWhile pairF predicate list = null? list
  nil
  predicate (head list)
    pairF (head list) (_takeWhile pairF predicate (tail list))
    nil
drop x list = positive x
  null? list
    nil
    drop (-- x) (tail list)
  list
dropWhile predicate list = null? list
  nil
  predicate (head list)
    dropWhile predicate (tail list)
    list
dropLast n list = tail (_dropLast (pairFunc list) n list)
_dropLast pairF n list = eq list nil
  [0]
  (\next . gt n (head next)
    [(+ 1 (head next))]
    [n | (pairF (head list) (tail next))]) (_dropLast pairF n (tail list))

series func n = [n | (series func (func n))]
from n = series ++ n
fromBy n inc = series (+ inc) n
fromTo n m = takeWhile (> m) (from n)
fromToBy n m inc = takeWhile (> m) (fromBy n inc)

# count returns the number of times x appears in l
count x l = countIf (eq x) l

# countIf returns the number of times x satifies f in l, f must take a single argument
# eg. countIf odd? [3 1] gives number: 2
countIf f l = if (eq l nil) 0
  + (f (head l) 1 0) (countIf f (tail l))
countIfNot f l = countIf (\x. not (f x)) l

# list sorting
# merge sort implemented according to http://www.haskell.org/haskellwiki/Performance/Laziness

odds l = [(head l) | (evens (tail l))]
odds l::nil = nil

evens l = odds (tail l)
evens l::nil = nil

cleave l = [(evens l) | (odds l)]

# boy, this sure would look better with less limited patterns...
merge cmp a b = submerge cmp b a
merge cmp a b::nil = a

submerge cmp a b = cmp (head a) (head b)
  [(head a) | (merge cmp (tail a) b)]
  [(head b) | (merge cmp a (tail b))]
submerge a b::nil = a

mergeSort cmp l = eq (tail l) nil
  l
  do
    cl = cleave l
    e = head cl
    o = tail cl
    merge cmp (mergeSort cmp e) (mergeSort cmp o)

mergeSort cmp l::nil = nil

sort l = sortBy lte l
sortBy cmp l = mergeSort cmp l

###########
# Assoc lists (from Roy's hashmap code)
###########

assocFromList l = if (null? l) nil
  assocSet (head l) (head (tail l)) (assocFromList (tail (tail l)))

assocKey cons = head cons
assocValue cons = tail cons

assocGetPair k anAssoc = findIf (\x . eq (head x) k) anAssoc

# assocGetPairOpt returns a 2Valued option
assocGetPairOpt k l = l (\h t D . h (\kk vv . (eq k kk) (some2 kk vv) (assocGetPairOpt k t))) none

assocKeys anAssoc = map (\cell . (assocKey cell)) anAssoc
assocNumKeys anAssoc = length (assocKeys anAssoc)

assocMergeKeys hm1 hm2 keys = if (null? keys) hm1
  if (null? (assocGetPair (head keys) hm1) )
    [(assocGetPair (head keys) hm2) | (assocMergeKeys hm1 hm2 (tail keys))]
    assocMergeKeys hm1 hm2 (tail keys)

# keys in hm2 take precedence over keys in hm1
assocMerge hm1 hm2 = assocMergeKeys hm1 hm2 (assocKeys hm2)

assocSet k v anAssoc = [(cons k v) | (assocRemove k anAssoc)]

assocGet k anAssoc = (assocGetPair k anAssoc) (\h t D . some h) none

assocGetWithDefault k default anAssoc = (assocGetPair k anAssoc) (\h t D . t) default

assocRemove k anAssoc = removeIf (\x . eq (assocKey x) k) anAssoc

######################
# output tag functions
######################

html x = \f . f x

######################
# Macros
######################

or[ list =M= primOrVar list (dropLast 1 (tail list))
primOrVar list args = eq args nil
  ['true']
  eq (tail args) nil
    args
    foldr1 (\v el . ['or' v el]) args

and[ list =M= primAndVar list (dropLast 1 (tail list))
primAndVar list args = eq args nil
  ['false']
  eq (tail args) nil
    args
    foldr1 (\v el . ['and' v el]) args

######################
# Infix
######################

# defInfixToken tok location reference
# defInfixToken '/' 'before' nil -- make + the tightest binding operator
# defInfixToken '@' 'same' nil -- make @ the loosest binding operator
# defInfixToken '+' 'before' '/' -- make + bind just tighter than /
# defInfixToken '-' 'same' '+' -- make - bind the same strength as +
defInfixToken tokenName location reference = do
  defToken tokenName
  defs <- getParseFilterInfo
  operators = assocGetWithDefault 'infix' nil defs
  operators = eq reference nil
    eq location 'before'
      [[tokenName] | operators]
      append operators [[tokenName]]
    insertOperator tokenName location reference operators
  setParseFilterInfo (assocSet 'infix' operators defs)

insertOperator tokenName location reference operators = any (eq reference) (head operators)
  eq location 'before'
    [[tokenName] | operators]
    [[tokenName | (head operators)] | (tail operators)]
  [(head operators) | (insertOperator tokenName location reference (tail operators))]
insertOperator tokenName location reference operators::nil = [[tokenName]]

testInfix str = do
  defs <- getValueOr 'parseFilter.defs' nil
  print concat['defs: ' defs]
  print (mainParseInfix defs (scan str id id))

mainParseInfix parseDefs list = parseInfix (assocGetWithDefault 'infix' nil parseDefs) list

parseInfix tokens list = list
parseInfix tokens list::cons = callParseInfixList tokens list
parseInfix tokens list::lexCons = callParseInfixList tokens list

callParseInfixList tokens list = do
  prep = collapseInnerTokens tokens (collapseFirstTokens tokens (map (parseInfix tokens) list))
  parseInfixList tokens dlempty (head prep) (tail prep)

collapseInnerTokens tokens list = list
collapseInnerTokens tokens list::cons = collapseInner1 tokens (head list) (tail list) list

collapseInner1 tokens op rest orig = orig
collapseInner1 tokens op rest::cons orig = collapseInner2 tokens op (head rest) (tail rest)

collapseInner2 tokens op 2nd rest = [op 2nd | rest]
collapseInner2 tokens op 2nd rest::cons = collapseInner3 tokens op 2nd (head rest) (tail rest)

collapseInner3 tokens op 2nd 3rd rest = [op | (collapseInner2 tokens 2nd 3rd rest)]
collapseInner3 tokens op::token 2nd 3rd rest = collapseInner4 tokens op 2nd 3rd rest

collapseInner4 tokens op 2nd 3rd rest = [op | (collapseInner2 tokens 2nd 3rd rest)]
collapseInner4 tokens op 2nd::token 3rd rest = collapseInner5 tokens op 2nd 3rd rest

collapseInner5 tokens op 2nd 3rd rest = [op | (collapseInner2 tokens 2nd 3rd rest)]
collapseInner5 tokens op 2nd 3rd::token rest = and
  isOperator tokens op
  and
    isOperator tokens 2nd
    adjacent 2nd 3rd
  [op (collapseTokens 2nd 3rd) | (collapseInnerTokens tokens rest)]
  [op | (collapseInner2 tokens 2nd 3rd rest)]

isOperator tokens tok = < (getPrecedence 0 tok tokens) (length tokens)

collapseFirstTokens tokens list = list
collapseFirstTokens tokens list::cons = null? (tail list)
  list
  collapseFirstTokens1 tokens (head list) (head (tail list)) (tail (tail list))
    id
    list

collapseFirstTokens1 tokens op next rest = none
collapseFirstTokens1 tokens op::token next rest = isOperator tokens op
  collapseFirstTokens2 tokens op next rest
  none

collapseFirstTokens2 tokens op next rest = none
collapseFirstTokens2 tokens op next::token rest = adjacent op next
  some [(collapseTokens op next) | rest]
  none

adjacent tok1 tok2 = eq (+ (tokenStart tok1) (strlen (tokenName tok1))) (tokenStart tok2)

collapseTokens tok1 tok2 = token concat[(tokenName tok1) (tokenName tok2)] (tokenStart tok1)

printOperators = do
  defs <- getParseFilterInfo
  print (assocGetWithDefault 'infix' nil defs)

# tokens is the list of operator lists
# firstList is the reversed first part of the list
#
# right associative, for now; for left-associative, use <= instead of <
parseInfixList tokens firstList token restList = do
  fullList = firstList [token | restList]
  op = head restList
  nextTok = head (tail restList)
  nextRest = tail (tail restList)
  prec = getPrecedence 0 op tokens
  nextPrec = or (null? restList) (or (null? (tail restList)) (null? nextRest))
    length tokens
    getPrecedence 0 (head nextRest) tokens
  nextParsed = parseInfixList tokens dlempty nextTok nextRest
  null? tokens
    fullList
    null? restList
      parseInfixList (tail tokens) dlempty (head fullList) (tail fullList)
      eq prec (length tokens)
        parseInfixList tokens (dlPush firstList token) op (tail restList)
        null? (tail restList)
          error concat['Parse error -- expected token after operator: ' op]
          < prec nextPrec
            parseInfixList tokens firstList [op token nextTok] nextRest
            parseInfixList tokens firstList [op token (head nextParsed)] (tail nextParsed)

getPrecedence index op tokens = any (eq (tokString op)) (head tokens)
  index
  getPrecedence (+ 1 index) op (tail tokens)
getPrecedence index op tokens::nil = index

# TODO optimizer could factor out opEq by itself, since it only depends on op.  That would prevent repeated application
operatorIn op tokens = do
  opEq = eq (tokString op)
  any (\toks . any opEq toks) tokens

#@auto
do
  x = log 'infix' 1
  defInfixToken '*' 'before' nil
  defInfixToken '/' 'at' '*'
  defInfixToken '+' 'at' nil
  defInfixToken '-' 'at' '+'
  defInfixToken '<' 'at' nil
  defInfixToken '>' 'at' nil
  x = log 'filter' 2
  addParseFilter mainParseInfix
  forward 'getURI'
  forward 'setURI'
  forward 'getDocument'
  forward 'replaceDocument'

save = do
  uri <- getURI
  doc <- getDocument
  write uri doc

saveAs newUri = do
  doc <- getDocument
  write newUri doc

open uri = do
  contents? <- read uri
  contents?
    \data. do
      setURI uri
      replaceDocument data
    \err . print concat['Error: ' err]
