#vararg macros
#@auto
do
  defGroup 'or[' ']'
  defGroup 'and[' ']'

# difference lists
dlempty = id
dl item = \rest . [item | rest]
dlAppend a b = \rest . a (b rest)

# make a new list by applying func (which takes exactly 1 arg) to each element of list
# eg. map (+ 1) [4 27 54] gives cons: [5 28 55]
map func list = _map (pairFunc list) func list
_map pairF func list = null? list
  nil
  pairF (func (head list)) (_map pairF func (tail list))

# remove any x's found in list
remove x l = removeIf (eq x) l

# remove any elements where f evals to true, f must take exactly one argument
removeIf f l = _removeIf (pairFunc l) f l
_removeIf pairF f l  = if (eq l nil) nil
  if (f (head l)) (_removeIf pairF f (tail l))
    pairF (head l) (_removeIf pairF f (tail l))
removeIfNot f l = removeIf (\x. not (f x)) l

filter f = removeIf (compose not f)

# return true if any elements of l satisfy f, which takes exactly one arg
# eg. any (eq 0) [1 2 0] gives true: true
any f l = _any (pairFunc l) f l
_any pairF f l = null? l
  false
  or
    f (head l)
    _any pairF f (tail l)

# return true if ALL elements of l satisfy f, which takes exactly one arg
# eg. all (eq 0) [0 0 0] gives true: true
# caveat!  return true for nil lists
all f l = _all (pairFunc l) f l
_all pairF f l = null? l
  true
  and
    f (head l)
    _all pairF f (tail l)

# find returns x if x is present inside l, otherwise returns nil.
find x l = findIf (eq x) l

findIf f l = null? l
  nil
  (f (head l)) (head l) (findIf f (tail l))

findIfOpt f l = null? l
  none
  (f (head l)) (some (head l)) (findIfOpt f (tail l))

take n list = _take (pairFunc list) n list
_take pairF n list = positive n
  null? list
    nil
    pairF (head list) (_take pairF (-- n) (tail list))
  nil
takeWhile predicate list = _takeWhile (pairFunc list) predicate list
_takeWhile pairF predicate list = null? list
  nil
  predicate (head list)
    pairF (head list) (_takeWhile pairF predicate (tail list))
    nil
drop x list = positive x
  null? list
    nil
    drop (-- x) (tail list)
  list
dropWhile predicate list = null? list
  nil
  predicate (head list)
    dropWhile predicate (tail list)
    list
dropLast n list = tail (_dropLast (pairFunc list) n list)
_dropLast pairF n list = eq list nil
  [0]
  (\next . gt n (head next)
    [(+ 1 (head next))]
    [n | (pairF (head list) (tail next))]) (_dropLast pairF n (tail list))

series func n = [n | (series func (func n))]
from n = series ++ n
fromBy n inc = series (+ inc) n
fromTo n m = takeWhile (> m) (from n)
fromToBy n m inc = takeWhile (> m) (fromBy n inc)

# count returns the number of times x appears in l
count x l = countIf (eq x) l

# countIf returns the number of times x satifies f in l, f must take a single argument
# eg. countIf odd? [3 1] gives number: 2
countIf f l = if (eq l nil) 0
  + (f (head l) 1 0) (countIf f (tail l))
countIfNot f l = countIf (\x. not (f x)) l

###########
# Assoc lists (from Roy's hashmap code)
###########

assocFromList l = if (null? l) nil
  assocSet (head l) (head (tail l)) (assocFromList (tail (tail l)))

assocKey cons = head cons
assocValue cons = tail cons

assocGetPair k anAssoc = findIf (\x . eq (head x) k) anAssoc

# assocGetPairOpt returns a 2Valued option
assocGetPairOpt k l = l (\h t D . h (\kk vv . (eq k kk) (some2 kk vv) (assocGetPairOpt k t))) none

valueOrDefault value default = if (neq value nil) value default

assocKeys anAssoc = map (\cell . (assocKey cell)) anAssoc
assocNumKeys anAssoc = length (assocKeys anAssoc)

assocMergeKeys hm1 hm2 keys = if (null? keys) hm1
  if (null? (assocGetPair (head keys) hm1) )
    [(assocGetPair (head keys) hm2) | (assocMergeKeys hm1 hm2 (tail keys))]
    assocMergeKeys hm1 hm2 (tail keys)

# keys in hm2 take precedence over keys in hm1
assocMerge hm1 hm2 = assocMergeKeys hm1 hm2 (assocKeys hm2)

assocSet k v anAssoc = [(cons k v) | (assocRemove k anAssoc)]

assocGet k anAssoc = (assocGetPair k anAssoc) (\h t D . some h) none

assocGetWithDefault k default anAssoc = valueOrDefault (assocGet k anAssoc) default

assocRemove k anAssoc = removeIf (\x . eq (assocKey x) k) anAssoc

######################
# output tag functions
######################

html x = \f . f x

#
# Macros
#

or[ list =M= primOrVar list (dropLast 1 (tail list))
primOrVar list args = eq args nil
  ['true']
  eq (tail args) nil
    args
    foldr1 (\v el . ['or' v el]) args

and[ list =M= primAndVar list (dropLast 1 (tail list))
primAndVar list args = eq args nil
  ['false']
  eq (tail args) nil
    args
    foldr1 (\v el . ['and' v el]) args

#
# Infix
#

# for debugging
lexAsCons l = eq l nil
  nil
  is l lexCons
    [(lexAsCons (head l)) | (lexAsCons (tail l))]
    is l token
      tokenName l
      l

defInfixToken tokenName location reference = do
  defToken tokenName
  defs <- getValueOr 'parseFilter.defs' nil
  operators = assocGetWithDefault 'infix' nil defs
  operators = eq reference nil
    eq location 'before'
      [[tokenName] | operators]
      append operators [tokenName]
    insertOperator tokenName reference operators
  setValue 'parseFilter.defs' (assocSet 'infix' operators defs)

insertOperator tokenName reference operators = null? operators
  [[tokenName]]
  find reference (head operators)
    [[tokenName | (head operators)] | (tail operators)]
    [(head operators) | (insertOperator tokenName reference (tail operators))]

# parseInfix parseDefs list = parseInfixList (assocGet 'infix' parseDefs) list
#
# parseInfixList tokens list = is list lexCons
#   rearrange tokens (lexMap (parseInfix tokens) list)
#   list
#
# rearrange operators precedence list = 
