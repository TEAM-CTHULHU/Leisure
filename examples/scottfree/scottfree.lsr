require '../../newCode/std.lsr'

# extract an element from one of the global lists
peek name idx = do
  global <- getValue name
  > (length global) idx
    at global idx
    print "ERROR: PEEK OUT OF BOUNDS"

# save an element into one of the global lists
poke name idx value = do
  global <- getValue name
  > (length global) idx
    do 
      new_global = append (take idx global) (append [ value ] (drop (++ idx) global) )
      setValue name new_global
      value
    print "ERROR: POKE OUT OF BOUNDS"

# constants
LIGHT_SOURCE = 9  # light is always at index 9
DESTROYED = 0     # room location for 'destroyed' items
CARRIED = 255     # room location for carried items

# indexes into BitFields list
DARKBIT = 15
LIGHTOUTBIT = 16

# indexes into GameHeader list
GH_MAGIC = 0
GH_NUM_ITEMS = 1
GM_NUM_ACTIONS = 2
GH_NUM_WORDS = 3   # shorter list of nouns and verbs is padded
GH_NUM_ROOMS = 4
GH_MAX_CARRY = 5
GH_PLAYER_ROOM = 6
GH_NUM_TREASURES = 7
GH_WORD_LENGTH = 8
GH_LIGHT_TIME = 9
GH_NUM_MESSAGES = 10
GH_TREASURE_ROOM = 11
GH_SIZEOF = 12

# indexes into the GlobalVars list
LIGHT_REFILL = 0
REDRAW = 1

conditions = [ '' 'HAS' 'IS_in_AR' 'IS_AVAIL' 'PLAYER_IN' 'IS_NOT_in_AR' 'HAS_NOT' 'PLAYER_NOT_IN' 'SET_BIT' 'CLEARED_BIT' 'HAS_SOMETHING' 'HAS_NOTHING' 'IS_NOT_AVAIL' 'IS_NOT_in_ROOM0' 'IS_in_ROOM0' 'COUNTER <=' 'COUNTER >' 'IS_in_OrigROOM' 'IS_NOT_in_OrigROOM' 'COUNTER ==' ]

NONE = 1
ACTION = 2
ITEM = 3
ROOM = 4
NUMBER = 5
BITFLAG = 6

conddata = [  ACTION ITEM ITEM ITEM ROOM ITEM ITEM ROOM BITFLAG BITFLAG NONE NONE ITEM ITEM ITEM NUMBER NUMBER ITEM ITEM NUMBER ]

acts = flatten [
  ['GET' 'MOVE_INTO_AR' 'GOTO' 'REMOVE' 'SET_NIGHT']
  ['SET_DAY' 'SET_BIT' 'REMOVE' 'CLEAR_BIT' 'KILL_PLAYER']
  ['MOVE_X_INTO_Y' 'QUIT' 'LOOK' 'SCORE' 'INVENTORY']
  ['SET_BIT (0)' 'CLEAR_BIT (0)' 'FILL_LAMP' 'CLS' 'SAVE']
  ['SWAP_ITEMS' 'CONTINUE:' 'GET_ALWAYS' 'PUT_X_WITH_Y' 'LOOK']
  ['COUNTER -= 1' 'PRINT_COUNTER' 'COUNTER =' 'SWAP_LOC_RV' 'SWAP_COUNTER']
  ['COUNTER +=' 'COUNTER -=' 'ECHO_NOUN' 'ECHO_NOUN_CR' 'CR']
  ['SELECT_RV' 'DELAY' 'SHOW_PIC' 'COMM90' 'COMM91']
  ['COMM92' 'COMM93' 'COMM94' 'COMM95' 'COMM96']
  ['COMM97' 'COMM98' 'COMM99' 'COMM100' 'COMM101'] ]

NOT = 0
IT = 1
RO = 2
FL = 3
IT_RO = 4
IT_IT = 5
NUM = 6

actdata = flatten [
  [IT IT RO IT NOT NOT FL IT FL NOT]
  [IT_RO NOT NOT NOT NOT NOT NOT NOT NOT NOT]
  [IT_IT NOT IT IT_IT NOT NOT NOT NUM NOT FL]
  [NUM NUM NOT NOT NOT FL NOT FL NOT NOT]
  [NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT] ]

direct = [ 'north' 'south' 'east' 'west' 'up' 'down' ]

loadGame filename = do
  result <- readFile filename
  result
    \err . print concat[ 'Error: ' err ]
    \contents . processFile (everyLinesForFile contents)

#everyLinesForFile text =  collapseStrings (strSplit (strReplace text lineScrub '\n') '\\r?\\n')
everyLinesForFile text =  collapseStrings (strSplit text '\\r?\\n')

# for every string that starts with " and doesn't end, combine following strings into a single string element 
collapseStrings list = isNil list
   list
   isPartialString (head list)
     collapseStrings (cons ((head list) + '{nl}' + (head (tail list))) (tail (tail list)))
     cons (head list) (collapseStrings (tail list))

# return true if the string starts with " but doesn't end in one, but we need special case for item lines that have an extra int at the end of the line
isPartialString string = strMatches string '^".*"\\s+[0-9]+\\s*$'
  false
  strMatches string '^".*[^"]\\s*$'

# convert a list of strings into integers by multiplying each element by 1
asInts list = map (* 1) list

# convert all but last element into an int for a room list
asRoom list = append (asInts (removeLast list)) (tail list)
asRooms list = map (asRoom) list

# convert into an item list which is name, room#, and autoget string
asItem string = do
  matches = strMatch string '^(".*")\\s+([0-9]+)\\s*$'
  name = head (at matches 1)
  room = 1 * (at (at matches 1) 1)
  agmatch = strMatch name '/(.*)/'
  isCons agmatch
    [ (strReplace name (regexp '/.*/') '') room (head (at agmatch 1)) ]
    [ name room '' ]
asItems list = map (asItem) list  

processFile contents = do
  #print contents
  #print (at contents 0)
  setValue 'BitFlags' [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ]  # up to 32 bits of flags supported
  GameHeader = asInts (take GH_SIZEOF contents)
  setValue 'GameHeader' GameHeader
  GlobalVars = [ (at GameHeader GH_LIGHT_TIME) 0 ]  # store light time in refill time for later use
  setValue 'GlobalVars' GlobalVars
  after_header = (drop GH_SIZEOF contents)
  num_actions = (at GameHeader GM_NUM_ACTIONS)
  max_actions = (num_actions * 1 + 1) * 8
  #print concat[ 'num actions: ' num_actions ' max actions: ' max_actions]
  Actions = asInts (box 8 (take max_actions after_header))
  setValue 'Actions' Actions
  after_actions = drop max_actions after_header
  num_words = at GameHeader GH_NUM_WORDS
  max_words = (num_words * 1 + 1) * 2
  Words = take max_words after_actions
  setValue 'Nouns' (evens Words)
  setValue 'Verbs' (odds Words)
  after_words = drop max_words after_actions
  num_rooms = at GameHeader GH_NUM_ROOMS
  max_rooms = (num_rooms * 1 + 1) * 7
  Rooms = asRooms (box 7 (take max_rooms after_words))
  setValue 'Rooms' Rooms
  after_rooms = drop max_rooms after_words
  num_msgs = (at GameHeader GH_NUM_MESSAGES)
  max_msgs = num_msgs * 1 + 1
  Messages = take max_msgs after_rooms
  setValue 'Messages' Messages
  after_msgs = drop max_msgs after_rooms
  num_items = at GameHeader GH_NUM_ITEMS
  max_items = num_items * 1 + 1
  Items = asItems (take max_items after_msgs)
  setValue 'Items' Items
  after_items = drop max_items after_msgs
  Comments = take (num_actions * 1 + 1) after_items
  setValue 'Comments' Comments
  after_comments = drop (num_actions * 1 + 1) after_items
  GameFooter = asInts (take 3 after_comments)
  setValue 'GameFooter' GameFooter
  "Data File Loaded."

merge list1 list2 = isNil list1
  nil
  isNil list2
    nil
    append [ (head list1) (head list2) ] (merge (tail list1) (tail list2))

debugGame = do
  GameHeader <- getValue 'GameHeader'
  print (merge [ '\nmagic: ' '\nnum items: ' '\nnum actions: ' '\nnum words: ' '\nnum rooms: ' '\nmax carry: ' '\nplayer room: ' '\ntreasures: ' '\nword len: ' '\nlight time: ' '\nnum msgs: ' '\ntreasure room: ' ] GameHeader)
  GlobalVars <- getValue 'GlobalVars'
  print (merge [ '\nlight refill: ' '\nredraw: ' ] GlobalVars)
  Actions <- getValue 'Actions'
  print concat[ "\nNum Actions: " (length Actions) "\nFirst Action: " (at Actions 0) "\nLast Action: " (last Actions) ]
  Nouns <- getValue 'Nouns'
  print concat[ "\nNum Nouns: " (length Nouns) " Nouns: " Nouns]
  Verbs <- getValue 'Verbs'
  print concat[ "\nNum Verbs: " (length Verbs) " Verbs: " Verbs]
  Rooms <- getValue 'Rooms'
  print concat[ "\nNum Rooms: " (length Rooms) '\nFirst Room: ' (at Rooms 0) '\nLast Room: ' (last Rooms)]
  print concat[ "\nAll Rooms: " Rooms ]
  Messages <- getValue 'Messages'
  print concat[ "\nNum Messsages: " (length Messages) " All Messages: " Messages ]
  Items <- getValue 'Items'
  print concat[ "\nNum Items: " (length Items) " All Items: " Items ]
  GameFooter <- getValue 'GameFooter'
  print (merge [ '\nversion: ' '\nnadv number: ' '\nunknown: '] GameFooter)
  "Debug finished."
# can't put these inside the function or it craps out  
#  Comments <- getValue 'Comments'
#  print concat[ "\nNum Comments: " (length Comments) " All Comments: " Comments ]


# lets do this!
playGame = do
  look
  performActions 0 0
  print concat[ "\nTell me what to do ? " ]
  input = getInput
  result = performActions (at input 0) (at input 1)
  eq result -1
    print concat[ "I don't understand your command.\n" ]
    eq result -2
      print concat[ "You can't do that yet.\n" ]
      nil
  processLight
  #playGame

# decrement the light this turn if needed  
processLight = do
  timeleft = peek 'GameHeader' GH_LIGHT_TIME
  light = peek 'Items' LIGHT_SOURCE
  where = at light 1
  or (eq where DESTROYED) (eq timeleft -1) # -1 means lasts forever, nothing to do
    nil         
    lightTick

# we need to decrement the light
lightTick = do
  timeleft = (peek 'GameHeader' GH_LIGHT_TIME) - 1
  myloc = peek 'GameHeader' GH_PLAYER_ROOM
  >= timeleft 0  # save it back if not negative
    poke 'GameHeader' GH_LIGHT_TIME timeleft
    nil
  eq timeleft 0
    do
      poke 'BitFlags' LIGHTOUTBIT 1
      isLightPresent myloc
        print "Your light has run out.\n"
        nil
    and (< timeleft 25) (isLightPresent myloc)
      print concat[ "You light runs out in " timeleft " turns.\n"]
      nil
      
# take a looksy  
look = do
  myloc = peek 'GameHeader' GH_PLAYER_ROOM
  and (eq (peek 'BitFlags' DARKBIT) 1) (not (isLightPresent myloc))
    print "You can't see. It is too dark!\n"
    basicLook myloc

basicLook myloc = do
  room = peek 'Rooms' myloc
  name = strReplace (at room 7) (regexp '\\{nl\\}') '\n'  # swap out any {nl} for real newlines
  strMatches name '^\\*'
    print name
    print concat[ "You are in a " name ]
  printExits room
  printItems myloc
  print "\n"

printExits room = do
  exits = nil
  eq exits nil
    print "Obvious exits: none.\n"
    print concat [ "Obvious exits: "  (intersperse exits ", ")  ".\n" ]
    
printItems myloc = do
  print "Items:\n"  

# check to see if the light is either in the given room or carried by the player
isLightPresent myloc = do
  light = peek 'Items' LIGHT_SOURCE
  where = at light 1
  or (eq where myloc) (eq where CARRIED)

# return a pair of ints for the intended verb/noun combo   
getInput = do
  move <- prompt (concat ["Tell me what to do?" ])
  [ 0 0 ]

performActions verb noun = do
  -1
