require '../../newCode/std.lsr'

# create a comma sep list for pretty printing
csv list = flatten [ "[ " (intersperse list ', ') " ]" ]

# create a list of duplicate values
duplicate value times = <= times 0
  nil
  [ value | (duplicate value (--times))]

aconsf key value list = [[key | value] | removeIf (\el . el \h t . h == key) list]
  
afetch k list = assoc k list
  \x. x
  nil

test = do
  world = aconsf 'Rooms' 5 nil
  world = aconsf 'Rooms' 6 world
  world = aconsf 'Rooms' 8 world
  print world
  world

# is this value between lower & upper bounds inclusively?  
between value low up = and (>= value low) (<= value up)
betweenEx value low up = and (> value low) (< value up)

# extract an element from one of the global lists
peek name idx = do
  global <- getValue name
  > (length global) idx
    at global idx
    print "ERROR: PEEK OUT OF BOUNDS"

# save an element into one of the global lists
poke name idx value = do
  global <- getValue name
  > (length global) idx
    do 
      new_global = pokeList global idx value #append (take idx global) (append [ value ] (drop (++ idx) global) )
      setValue name new_global
      value
    print "ERROR: POKE OUT OF BOUNDS"

# poke a new element into the middle of a list
pokeList list idx value = append (take idx list) (append [ value ] (drop (++ idx) list) )

# constants
LIGHT_SOURCE = 9  # light is always at index 9
DESTROYED = 0     # room location for 'destroyed' items
CARRIED = 255     # room location for carried items

# indexes into BitFields list
DARKBIT = 15
LIGHTOUTBIT = 16

# indexes into GameHeader list
GH_MAGIC = 0
GH_NUM_ITEMS = 1
GM_NUM_ACTIONS = 2
GH_NUM_WORDS = 3   # shorter list of nouns and verbs is padded
GH_NUM_ROOMS = 4
GH_MAX_CARRY = 5
GH_PLAYER_ROOM = 6
GH_NUM_TREASURES = 7
GH_WORD_LENGTH = 8
GH_LIGHT_TIME = 9
GH_NUM_MESSAGES = 10
GH_TREASURE_ROOM = 11
GH_SIZEOF = 12

# indexes into the GlobalVars list
LIGHT_REFILL = 0
REDRAW = 1

conditions = [ '' 'HAS' 'IS_in_AR' 'IS_AVAIL' 'PLAYER_IN' 'IS_NOT_in_AR' 'HAS_NOT' 'PLAYER_NOT_IN' 'SET_BIT' 'CLEARED_BIT' 'HAS_SOMETHING' 'HAS_NOTHING' 'IS_NOT_AVAIL' 'IS_NOT_in_ROOM0' 'IS_in_ROOM0' 'COUNTER <=' 'COUNTER >' 'IS_in_OrigROOM' 'IS_NOT_in_OrigROOM' 'COUNTER ==' ]

NONE = 1
ACTION = 2
ITEM = 3
ROOM = 4
NUMBER = 5
BITFLAG = 6

conddata = [  ACTION ITEM ITEM ITEM ROOM ITEM ITEM ROOM BITFLAG BITFLAG NONE NONE ITEM ITEM ITEM NUMBER NUMBER ITEM ITEM NUMBER ]

acts = flatten [
  ['GET' 'MOVE_INTO_AR' 'GOTO' 'REMOVE' 'SET_NIGHT']
  ['SET_DAY' 'SET_BIT' 'REMOVE' 'CLEAR_BIT' 'KILL_PLAYER']
  ['MOVE_X_INTO_Y' 'QUIT' 'LOOK' 'SCORE' 'INVENTORY']
  ['SET_BIT (0)' 'CLEAR_BIT (0)' 'FILL_LAMP' 'CLS' 'SAVE']
  ['SWAP_ITEMS' 'CONTINUE:' 'GET_ALWAYS' 'PUT_X_WITH_Y' 'LOOK']
  ['COUNTER -= 1' 'PRINT_COUNTER' 'COUNTER =' 'SWAP_LOC_RV' 'SWAP_COUNTER']
  ['COUNTER +=' 'COUNTER -=' 'ECHO_NOUN' 'ECHO_NOUN_CR' 'CR']
  ['SELECT_RV' 'DELAY' 'SHOW_PIC' 'COMM90' 'COMM91']
  ['COMM92' 'COMM93' 'COMM94' 'COMM95' 'COMM96']
  ['COMM97' 'COMM98' 'COMM99' 'COMM100' 'COMM101'] ]

NOT = 0
IT = 1
RO = 2
FL = 3
IT_RO = 4
IT_IT = 5
NUM = 6

actdata = flatten [
  [IT IT RO IT NOT NOT FL IT FL NOT]
  [IT_RO NOT NOT NOT NOT NOT NOT NOT NOT NOT]
  [IT_IT NOT IT IT_IT NOT NOT NOT NUM NOT FL]
  [NUM NUM NOT NOT NOT FL NOT FL NOT NOT]
  [NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT] ]

Exits = [ 'North' 'South' 'East' 'West' 'Up' 'Down' ]

loadGame filename = do
  result <- readFile filename
  result
    \err . print concat[ 'Error: ' err ]
    \contents . processFile (everyLinesForFile contents)

#everyLinesForFile text =  collapseStrings (strSplit (strReplace text lineScrub '\n') '\\r?\\n')
everyLinesForFile text =  collapseStrings (strSplit text '\\r?\\n')

# for every string that starts with " and doesn't end, combine following strings into a single string element 
collapseStrings list = isNil list
   list
   isPartialString (head list)
     collapseStrings (cons ((head list) + '{nl}' + (head (tail list))) (tail (tail list)))
     cons (head list) (collapseStrings (tail list))

# return true if the string starts with " but doesn't end in one, but we need special case for item lines that have an extra int at the end of the line
isPartialString string = strMatches string '^".*"\\s+[0-9]+\\s*$'
  false
  strMatches string '^".*[^"]\\s*$'

# convert a list of strings into integers by multiplying each element by 1
asInts list = map (* 1) list

extract str pattern = do
  matches = strMatch str pattern
  isCons matches
    isNil (at matches 1)
      ''
      head (at matches 1)
    str

unquote str = extract str (regexp '^"(.*)"$')

# convert all but last element into an int for a room list
asRoom list = append (asInts (removeLast list)) [ (unquote (last list)) ]
asRooms list = map (asRoom) list

# convert into an item list which is name, room#, and autoget string
asItem string = do
  matches = strMatch string '^("?.*"?)\\s+([0-9]+)\\s*$'
  isCons matches
    do
      name = unquote (head (at matches 1))
      room = 1 * (at (at matches 1) 1)
      agmatch = strMatch name '/(.*)/'
      isCons agmatch
        [ (strReplace name (regexp '/.*/') '') room (head (at agmatch 1)) ]
        [ name room '' ]
    [ string 0 'BAD REGEXP' ]      
asItems list = map (asItem) list  

processFile contents = do
  #print contents
  #print (at contents 0)
  setValue 'BitFlags' (duplicate false 32)  # up to 32 bits of flags supported
  GameHeader = asInts (take GH_SIZEOF contents)
  setValue 'GameHeader' GameHeader
  GlobalVars = [ (at GameHeader GH_LIGHT_TIME) 0 ]  # store light time in refill time for later use
  setValue 'GlobalVars' GlobalVars
  after_header = (drop GH_SIZEOF contents)
  num_actions = (at GameHeader GM_NUM_ACTIONS)
  max_actions = (num_actions * 1 + 1) * 8
  #print concat[ 'num actions: ' num_actions ' max actions: ' max_actions]
  Actions = box 8 (asInts (take max_actions after_header))
  setValue 'Actions' Actions
  after_actions = drop max_actions after_header
  num_words = at GameHeader GH_NUM_WORDS
  max_words = (num_words * 1 + 1) * 2
  Words = map unquote (take max_words after_actions)
  setValue 'Nouns' (evens Words)
  setValue 'Verbs' (odds Words)
  after_words = drop max_words after_actions
  processFile2 after_words

processFile2 after_words = do 
  GameHeader <- getValue 'GameHeader'
  num_actions = (at GameHeader GM_NUM_ACTIONS)  
  num_rooms = at GameHeader GH_NUM_ROOMS
  max_rooms = (num_rooms * 1 + 1) * 7
  Rooms = asRooms (box 7 (take max_rooms after_words))
  setValue 'Rooms' Rooms
  after_rooms = drop max_rooms after_words
  num_msgs = (at GameHeader GH_NUM_MESSAGES)
  max_msgs = num_msgs * 1 + 1
  Messages = map unquote (take max_msgs after_rooms)
  setValue 'Messages' Messages
  after_msgs = drop max_msgs after_rooms
  num_items = at GameHeader GH_NUM_ITEMS
  max_items = num_items * 1 + 1
  Items = asItems (take max_items after_msgs)
  setValue 'Items' Items
  after_items = drop max_items after_msgs
  Comments = map unquote (take (num_actions * 1 + 1) after_items)
  setValue 'Comments' Comments
  after_comments = drop (num_actions * 1 + 1) after_items
  GameFooter = asInts (take 3 after_comments)
  setValue 'GameFooter' GameFooter
  "Data File Loaded."

merge list1 list2 = isNil list1
  nil
  isNil list2
    nil
    append [ (head list1) (head list2) ] (merge (tail list1) (tail list2))

debugGame = do
  GameHeader <- getValue 'GameHeader'
  print (merge [ '\nmagic: ' '\nnum items: ' '\nnum actions: ' '\nnum words: ' '\nnum rooms: ' '\nmax carry: ' '\nplayer room: ' '\ntreasures: ' '\nword len: ' '\nlight time: ' '\nnum msgs: ' '\ntreasure room: ' ] GameHeader)
  GlobalVars <- getValue 'GlobalVars'
  print (merge [ '\nlight refill: ' '\nredraw: ' ] GlobalVars)
  Actions <- getValue 'Actions'
  print concat[ "\nNum Actions: " (length Actions) "\nFirst Action: "  (csv (at Actions 0)) "\nLast Action: " (csv (last Actions)) ]
  Nouns <- getValue 'Nouns'
  print concat[ "\nNum Nouns: " (length Nouns) " Nouns: " (csv Nouns) ]
  Verbs <- getValue 'Verbs'
  print concat[ "\nNum Verbs: " (length Verbs) " Verbs: " (csv Verbs) ]
  debugGame2

debugGame2 = do    
  Rooms <- getValue 'Rooms'
  print concat[ "\nNum Rooms: " (length Rooms) '\nFirst Room: ' (csv (at Rooms 0)) '\nLast Room: ' (csv (last Rooms)) ]
  print concat[ "\nAll Rooms: " (csv Rooms) ]
  Messages <- getValue 'Messages'
  print concat[ "\nNum Messsages: " (length Messages) " All Messages: " (csv Messages) ]
  Items <- getValue 'Items'
  print concat[ "\nNum Items: " (length Items) " All Items: " (csv Items) ]
  GameFooter <- getValue 'GameFooter'
  print (merge [ '\nversion: ' '\nnadv number: ' '\nunknown: '] GameFooter)
  "Debug finished."

# lets do this!
playGame = do
  look
  getInput
  processLight
  playGame

# decrement the light this turn if needed  
processLight = do
  timeleft <- peek 'GameHeader' GH_LIGHT_TIME
  light <- peek 'Items' LIGHT_SOURCE
  where = at light 1
  or (eq where DESTROYED) (eq timeleft -1) # -1 means lasts forever, nothing to do
    nil         
    lightTick

# we need to decrement the light
lightTick = do
  timeleft <- (peek 'GameHeader' GH_LIGHT_TIME) - 1
  myloc <- peek 'GameHeader' GH_PLAYER_ROOM
  >= timeleft 0  # save it back if not negative
    poke 'GameHeader' GH_LIGHT_TIME timeleft
    nil
  light <- isLightPresent myloc
  eq timeleft 0
    do
      poke 'BitFlags' LIGHTOUTBIT true
      light
        print "Your light has run out.\n"
        nil
    and (< timeleft 25) light
      print concat[ "You light runs out in " timeleft " turns.\n"]
      nil

# take a looksy  
look = do
  myloc <- peek 'GameHeader' GH_PLAYER_ROOM
  darkbit <- peek 'BitFlags' DARKBIT
  light <- isLightPresent myloc
  and darkbit (not light)
    print "You can't see. It is too dark!\n"
    basicLook myloc

basicLook myloc = do
  room <- peek 'Rooms' myloc
  name = strReplace (at room 6) (regexpFlags '\\{nl\\}' 'g' ) '\n'  # swap out any {nl} for real newlines
  strMatches name '^\\*'
    print name
    print concat[ "You are in a " name ]
  printExits room
  printItems myloc
  print "\n"

isNumber i = == (getType i) '*number'

safeat list idx = isCons list
  isNumber idx
    > (length list) idx
      at list idx
      'OOB LIST'
    'IDX NOT NUM'  
  'LIST NOT LIST'

#map func l = l (\h t D . cons (func h) (map func t)) nil
mapIndex func l = _mapIndex 0 func l
_mapIndex idx func l = l (\h t D . cons (func h idx) (_mapIndex (+ 1 idx) func t)) nil

hasExit exit idx = eq exit 0
  ''
  safeat Exits idx

# chop off the last element (its name) from the room and compute the valid exits    
printExits room = do
  exits = removeIf (eq '') (mapIndex (hasExit) (removeLast room))
  isNil exits
    print "Obvious exits: none."
    print concat[ "Obvious exits: "  (intersperse exits ", ") "."]

printItems myloc = do
  allitems <- getValue 'Items'
  items <- findItemsInLocation myloc allitems
  isNil items
    items
    print concat[ "You can also see: " (intersperse (map (\x . strReplace (at x 0) (regexpFlags '\\{nl\\}' 'g' ) '\n' ) items) ', ') "." ]  #have to extract the name from each item

# return a list of items that are in this location    
#  and (> (length (head items)) 1) (eq (safeat (head items) 1) myloc)
findItemsInLocation myloc items = isNil items
  nil
  eq (at (head items) 1) myloc
    cons (head items) (findItemsInLocation myloc (tail items))
    findItemsInLocation myloc (tail items)

# return the number of items in the given location, you must pass in all items list to start    
countItemsInLocation myloc items = isNil items
  0
  eq (at (head items) 1) myloc
    1 + (countItemsInLocation myloc (tail items))
    countItemsInLocation myloc (tail items)

countCarried = do
  allitems <- getValue 'Items'
  countItemsInLocation CARRIED allitems

# quick debug function to move items around
moveItem idx newloc = do
  item <- peek 'Items' idx
  newitem = pokeList item 1 newloc
  poke 'Items' idx newitem

# quick debug function for checking out the diff rooms
tp room = do
  poke 'GameHeader' GH_PLAYER_ROOM room
  look

# check to see if the light is either in the given room or carried by the player
isLightPresent myloc = do
  light <- peek 'Items' LIGHT_SOURCE
  where = at light 1
  or (eq where myloc) (eq where CARRIED)

# return a pair of ints for the intended verb/noun combo   
getInput = do
  str <- prompt (concat[ "Tell me what to do? " ])
  n_v <- basicGetInput str
  v = at n_v 0
  n = at n_v 1
  wasAll = at n_v 2
  log concat['n_v ' (csv n_v) ] 0
  eq v (0-1)
    print "You use word(s) I don't know"
    do
      x <- performActions v n wasAll 0
      eq x (0-1)
        print "I don't understand your command."
        eq x (0-2)
          print "You can't do that yet."
          eq x (0-3)
            print "* GAME OVER*"
            nil

# returns a list of [ verb_index noun_index wasAll ]  wasAll is a boolean that says whether they typed in 'ALL' which is special cased      
basicGetInput str = do
  verb_noun = strMatch str (regexp '(\\w+)\\s*(\\w*)')
  isCons verb_noun
    do
      nc = (0-1)
      vc = (0-1)
      wordlen <- peek 'GameHeader' GH_WORD_LENGTH
      m = at verb_noun 1
      verb = strToUpperCase (strSubstring (at m 0) 0 wordlen)
      noun = (eq 1 (length m)) ('') (strToUpperCase (strSubstring (at m 1) 0 wordlen))
      verb = verbShortcuts verb noun
      go <- whichNoun verb
      isDir = between go 1 6
      vc <- (isDir) 1 (whichVerb verb)
      nc <- (isDir) nc (whichNoun noun)
      log concat[ "M: " (csv m) " V: " verb " N: " noun " isDir: " isDir " vc: " vc " nc: " nc " go: " go ] nil
      isDir
        [ vc go false ]
        [ vc nc (eq noun 'ALL') ]
    [ (0-1) (0-1) false ]  
#    print "You use word(s) I don't know"

verbShortcuts v n = and (eq 1 (strLen v)) (eq 0 (strLen n))
  do
    i = findIndex (eq (strToUpperCase v)) [ 'N' 'S' 'E' 'W' 'U' 'D' 'I' ]
    >= i 0
      at [ 'NOR' 'SOU' 'EAS' 'WES' 'UP' 'DOWN' 'INV' ] i
      v
  v

whichNoun noun = do
  nouns <- getValue 'Nouns'
  whichWord noun nouns

whichVerb verb = do
  verbs <- getValue 'Verbs'
  whichWord verb verbs

# loop over the list of words, any words that start with * should return the index of the last non-* word before it. return -1 if no match found  
whichWord word list = basicWhichWord 0 0 word list  
basicWhichWord idx result word list = isNil list
  (0-1)
  do
    w = head list
    star = (strStartsWith w '*')
    w = (star) (strSubstring w 1 99) w
    w = (> (strLen w) (strLen word)) (strSubstring w 0 (strLen word)) w
    result = (star) result idx #log ("w: " + w + " star: "  + star + " idx: " + idx + " result: " + result) 0
    eq word w
      result
      basicWhichWord (++ idx) result word (tail list)

performActions verb noun wasAll disable_sysfunc = eq verb 1
  performMove verb noun
  do
    actions <- getValue 'Actions'
    f1 <- crazyLoopHere verb noun 0 0 0 false disable_sysfunc actions
    eq f1 (0-4)
      f1
      and (neq f1 0) (eq 0 disable_sysfunc)
        eq verb 18
          f1 <- getAll verb noun wasAll disable_sysfunc
          eq verb 10
            f1 <- dropAll verb noun wasAll disable_sysfunc
            f1

# whole lotta code to process actions    
crazyLoopHere vb no ct vv nv doagain disable_sysfunc actions = isNil actions
    f1 <- (0-1)
    action <- head actions
    vv <- at action 0
    and (neq vb 0) (and doagain (neq vv 0))
      f1
      and (neq vb 0) (and (not doagain) (eq f1 0))
        f1
        do
          nv = vv % 150
          vv = vv / 150
          rand <- randomPercent nv
          or (eq vv vb) (and doagain (eq (at action 0) 0))
            or doagain (or (and (eq vv 0) rand) (and (neq vv 0) (or (eq nv no) (eq nv 0))))
              do
                f2 <- 0
                f1 <- (eq f1 (0-1)) (0-2) f1
                f2 <- performLine ct
                > f2 0
                  do
                    f1 <- 0
                    doagain <- (eq f2 2) true doagain
                    and (neq vb 0) (not doagain)
                      (0-4)   # using -4 to mean abort looping and get/drop ALL
                      crazyLoopHere vb no (++ ct) vv nv ((eq (at action 0) 0) 0 doagain) disable_sysfunc (tail actions)
                  crazyLoopHere vb no (++ ct) vv nv ((eq (at action 0) 0) 0 doagain) disable_sysfunc (tail actions)
              crazyLoopHere vb no (++ ct) vv nv ((eq (at action 0) 0) 0 doagain) disable_sysfunc (tail actions)
            crazyLoopHere vb no (++ ct) vv nv ((eq (at action 0) 0) 0 doagain) disable_sysfunc (tail actions)
        
performLine ct = do
   action <- peek 'Actions' ct
   results <- meetsConditions [ 0 0 0 0 0 ] (take 5 action))
   not (at results 0)
     0
     do
       param <- at results 1
       pptr <- at results 2
       'placeholder'
     
# takes param list, pptr, and list of conditions to test - returns a list of the final return value param pptr and
meetsConditions param pptr conds = isNil conds
  [ true param pptr ]
  do
    cv <- head conds
    dv = cv / 20
    cv <- cv % 20
    keep = true
    and keep (eq cv 0)
      do
        param <- pokeList param pptr dv
        pptr = ++ pptr
      keep = false
    and keep (eq cv 1)
      do
        item <- peek 'Items' dv
        keep = eq (at item 1) CARRIED
      keep = false
      
      
    
# return true if a random percent is less than the value passed in
randomPercent n = do
  r <- randInt 0 99
  < r n
            
getAll verb noun wasAll disable_sysfunc = do
    eq wasAll 'ALL'
      do
        myloc <- peek 'GameHeader' GH_PLAYER_ROOM  #log "here0" 9
        light <- isLightPresent myloc
        dark <- light false (peek 'BitFlags' DARKBIT) #log "here1" 9
        dark
          printReturn "It is dark." 0
          nil          
      0
      
dropAll verb noun wasAll disable_sysfunc = 'placeholder'    

# given an item name to any AUTOGETs, see if it's in the same room as the player for picking up
matchUpItem name myloc = do
  wordlen <- peek 'GameHeader' GH_WORD_LENGTH
  name <- strToUpperCase (strSubstring name 0 wordlen)
  match <- mapSynonym name
  allitems <- getValue 'Items'
  basicMatchUpItem match myloc 0 allitems
  
basicMatchUpItem name myloc idx allitems = isNil allitems
  (0-1)
  do
    i = head allitems  #    log concat[ 'testing item: ' i ] 0
    and (eq (at i 2) name) (eq (at i 1) myloc)
      idx
      basicMatchUpItem name myloc (++ idx) (tail allitems)
 
# the name the player gives may be a synonym, if so return the original item name, if not return the original name passed in
# refactored from original to use WhichWords call  
mapSynonym noun = do
  idx <- whichNoun noun
  eq idx (0-1)
    noun
    peek 'Nouns' idx

printReturn msg value = do
  print msg
  value

performMove verb noun = do
  eq noun (0-1)
    printReturn "Give me a direction too." 0
    not (between noun 1 6)
      (0-1)
      do      
        myloc <- peek 'GameHeader' GH_PLAYER_ROOM  #log "here0" 9
        light <- isLightPresent myloc
        dark <- light false (peek 'BitFlags' DARKBIT) #log "here1" 9
        dark (print "Dangerous to move in the dark!") nil
        room <- peek 'Rooms' myloc
        ridx = at room (noun - 1)  #log concat[ "room " (csv room) " ridx: " ridx ] 0
        eq ridx 0
          dark
            printReturn "You fell down and broke your neck." (0-3)
            printReturn "You can't go in that direction." 0
         do
           tp ridx
           0