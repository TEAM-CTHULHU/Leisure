require '../../newCode/std.lsr'

# extract an element from one of the global lists
peek name idx = do
  global <- getValue name
  > (length global) idx
    at global idx
    print "ERROR: PEEK OUT OF BOUNDS"

# save an element into one of the global lists
poke name idx value = do
  global <- getValue name
  > (length global) idx
    do 
      new_global = append (take idx global) (append [ value ] (drop (++ idx) global) )
      setValue name new_global
      value
    print "ERROR: POKE OUT OF BOUNDS"

# constants
LIGHT_SOURCE = 9  # light is always at index 9
DESTROYED = 0     # room location for 'destroyed' items
CARRIED = 255     # room location for carried items

# indexes into BitFields list
DARKBIT = 15
LIGHTOUTBIT = 16

# indexes into GameHeader list
GH_MAGIC = 0
GH_NUM_ITEMS = 1
GM_NUM_ACTIONS = 2
GH_NUM_WORDS = 3   # shorter list of nouns and verbs is padded
GH_NUM_ROOMS = 4
GH_MAX_CARRY = 5
GH_PLAYER_ROOM = 6
GH_NUM_TREASURES = 7
GH_WORD_LENGTH = 8
GH_LIGHT_TIME = 9
GH_NUM_MESSAGES = 10
GH_TREASURE_ROOM = 11
GH_SIZEOF = 12

# indexes into the GlobalVars list
LIGHT_REFILL = 0
REDRAW = 1

conditions = [ '' 'HAS' 'IS_in_AR' 'IS_AVAIL' 'PLAYER_IN' 'IS_NOT_in_AR' 'HAS_NOT' 'PLAYER_NOT_IN' 'SET_BIT' 'CLEARED_BIT' 'HAS_SOMETHING' 'HAS_NOTHING' 'IS_NOT_AVAIL' 'IS_NOT_in_ROOM0' 'IS_in_ROOM0' 'COUNTER <=' 'COUNTER >' 'IS_in_OrigROOM' 'IS_NOT_in_OrigROOM' 'COUNTER ==' ]

NONE = 1
ACTION = 2
ITEM = 3
ROOM = 4
NUMBER = 5
BITFLAG = 6

conddata = [  ACTION ITEM ITEM ITEM ROOM ITEM ITEM ROOM BITFLAG BITFLAG NONE NONE ITEM ITEM ITEM NUMBER NUMBER ITEM ITEM NUMBER ]

acts = flatten [
  ['GET' 'MOVE_INTO_AR' 'GOTO' 'REMOVE' 'SET_NIGHT']
  ['SET_DAY' 'SET_BIT' 'REMOVE' 'CLEAR_BIT' 'KILL_PLAYER']
  ['MOVE_X_INTO_Y' 'QUIT' 'LOOK' 'SCORE' 'INVENTORY']
  ['SET_BIT (0)' 'CLEAR_BIT (0)' 'FILL_LAMP' 'CLS' 'SAVE']
  ['SWAP_ITEMS' 'CONTINUE:' 'GET_ALWAYS' 'PUT_X_WITH_Y' 'LOOK']
  ['COUNTER -= 1' 'PRINT_COUNTER' 'COUNTER =' 'SWAP_LOC_RV' 'SWAP_COUNTER']
  ['COUNTER +=' 'COUNTER -=' 'ECHO_NOUN' 'ECHO_NOUN_CR' 'CR']
  ['SELECT_RV' 'DELAY' 'SHOW_PIC' 'COMM90' 'COMM91']
  ['COMM92' 'COMM93' 'COMM94' 'COMM95' 'COMM96']
  ['COMM97' 'COMM98' 'COMM99' 'COMM100' 'COMM101'] ]

NOT = 0
IT = 1
RO = 2
FL = 3
IT_RO = 4
IT_IT = 5
NUM = 6

actdata = flatten [
  [IT IT RO IT NOT NOT FL IT FL NOT]
  [IT_RO NOT NOT NOT NOT NOT NOT NOT NOT NOT]
  [IT_IT NOT IT IT_IT NOT NOT NOT NUM NOT FL]
  [NUM NUM NOT NOT NOT FL NOT FL NOT NOT]
  [NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT] ]

Exits = [ 'North' 'South' 'East' 'West' 'Up' 'Down' ]

loadGame filename = do
  result <- readFile filename
  result
    \err . print concat[ 'Error: ' err ]
    \contents . processFile (everyLinesForFile contents)

#everyLinesForFile text =  collapseStrings (strSplit (strReplace text lineScrub '\n') '\\r?\\n')
everyLinesForFile text =  collapseStrings (strSplit text '\\r?\\n')

# for every string that starts with " and doesn't end, combine following strings into a single string element 
collapseStrings list = isNil list
   list
   isPartialString (head list)
     collapseStrings (cons ((head list) + '{nl}' + (head (tail list))) (tail (tail list)))
     cons (head list) (collapseStrings (tail list))

# return true if the string starts with " but doesn't end in one, but we need special case for item lines that have an extra int at the end of the line
isPartialString string = strMatches string '^".*"\\s+[0-9]+\\s*$'
  false
  strMatches string '^".*[^"]\\s*$'

# convert a list of strings into integers by multiplying each element by 1
asInts list = map (* 1) list

extract str pattern = do
  matches = strMatch str pattern
  isCons matches
    isNil (at matches 1)
      ''
      head (at matches 1)
    str

unquote str = extract str (regexp '^"(.*)"$')
    
# convert all but last element into an int for a room list
asRoom list = append (asInts (removeLast list)) [ (unquote (last list)) ]
asRooms list = map (asRoom) list

# convert into an item list which is name, room#, and autoget string
asItem string = do
  matches = strMatch string '^("?.*"?)\\s+([0-9]+)\\s*$'
  isCons matches
    do
      name = unquote (head (at matches 1))
      room = 1 * (at (at matches 1) 1)
      agmatch = strMatch name '/(.*)/'
      isCons agmatch
        [ (strReplace name (regexp '/.*/') '') room (head (at agmatch 1)) ]
        [ name room '' ]
    [ string 0 'BAD REGEXP' ]      
asItems list = map (asItem) list  

processFile contents = do
  #print contents
  #print (at contents 0)
  setValue 'BitFlags' [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ]  # up to 32 bits of flags supported
  GameHeader = asInts (take GH_SIZEOF contents)
  setValue 'GameHeader' GameHeader
  GlobalVars = [ (at GameHeader GH_LIGHT_TIME) 0 ]  # store light time in refill time for later use
  setValue 'GlobalVars' GlobalVars
  after_header = (drop GH_SIZEOF contents)
  num_actions = (at GameHeader GM_NUM_ACTIONS)
  max_actions = (num_actions * 1 + 1) * 8
  #print concat[ 'num actions: ' num_actions ' max actions: ' max_actions]
  Actions = asInts (box 8 (take max_actions after_header))
  setValue 'Actions' Actions
  after_actions = drop max_actions after_header
  num_words = at GameHeader GH_NUM_WORDS
  max_words = (num_words * 1 + 1) * 2
  Words = map unquote (take max_words after_actions)
  setValue 'Nouns' (evens Words)
  setValue 'Verbs' (odds Words)
  after_words = drop max_words after_actions
  processFile2 after_words
  
processFile2 after_words = do 
  GameHeader <- getValue 'GameHeader'
  num_actions = (at GameHeader GM_NUM_ACTIONS)  
  num_rooms = at GameHeader GH_NUM_ROOMS
  max_rooms = (num_rooms * 1 + 1) * 7
  Rooms = asRooms (box 7 (take max_rooms after_words))
  setValue 'Rooms' Rooms
  after_rooms = drop max_rooms after_words
  num_msgs = (at GameHeader GH_NUM_MESSAGES)
  max_msgs = num_msgs * 1 + 1
  Messages = map unquote (take max_msgs after_rooms)
  setValue 'Messages' Messages
  after_msgs = drop max_msgs after_rooms
  num_items = at GameHeader GH_NUM_ITEMS
  max_items = num_items * 1 + 1
  Items = asItems (take max_items after_msgs)
  setValue 'Items' Items
  after_items = drop max_items after_msgs
  Comments = map unquote (take (num_actions * 1 + 1) after_items)
  setValue 'Comments' Comments
  after_comments = drop (num_actions * 1 + 1) after_items
  GameFooter = asInts (take 3 after_comments)
  setValue 'GameFooter' GameFooter
  "Data File Loaded."

merge list1 list2 = isNil list1
  nil
  isNil list2
    nil
    append [ (head list1) (head list2) ] (merge (tail list1) (tail list2))

debugGame = do
  GameHeader <- getValue 'GameHeader'
  print (merge [ '\nmagic: ' '\nnum items: ' '\nnum actions: ' '\nnum words: ' '\nnum rooms: ' '\nmax carry: ' '\nplayer room: ' '\ntreasures: ' '\nword len: ' '\nlight time: ' '\nnum msgs: ' '\ntreasure room: ' ] GameHeader)
  GlobalVars <- getValue 'GlobalVars'
  print (merge [ '\nlight refill: ' '\nredraw: ' ] GlobalVars)
  Actions <- getValue 'Actions'
  print concat[ "\nNum Actions: " (length Actions) "\nFirst Action: " (at Actions 0) "\nLast Action: " (last Actions) ]
  Nouns <- getValue 'Nouns'
  print concat[ "\nNum Nouns: " (length Nouns) " Nouns: " Nouns]
  Verbs <- getValue 'Verbs'
  print concat[ "\nNum Verbs: " (length Verbs) " Verbs: " Verbs]
  debugGame2
  
debugGame2 = do    
  Rooms <- getValue 'Rooms'
  print concat[ "\nNum Rooms: " (length Rooms) '\nFirst Room: ' (at Rooms 0) '\nLast Room: ' (last Rooms)]
  print concat[ "\nAll Rooms: " Rooms ]
  Messages <- getValue 'Messages'
  print concat[ "\nNum Messsages: " (length Messages) " All Messages: " Messages ]
  Items <- getValue 'Items'
  print concat[ "\nNum Items: " (length Items) " All Items: " Items ]
  GameFooter <- getValue 'GameFooter'
  print (merge [ '\nversion: ' '\nnadv number: ' '\nunknown: '] GameFooter)
  "Debug finished."

# lets do this!
playGame = do
  look
  performActions 0 0
  print concat[ "\nTell me what to do ? " ]
  input = getInput
  result = performActions (at input 0) (at input 1)
  eq result -1
    print concat[ "I don't understand your command.\n" ]
    eq result -2
      print concat[ "You can't do that yet.\n" ]
      nil
  processLight
  #playGame

# decrement the light this turn if needed  
processLight = do
  timeleft <- peek 'GameHeader' GH_LIGHT_TIME
  light <- peek 'Items' LIGHT_SOURCE
  where = at light 1
  or (eq where DESTROYED) (eq timeleft -1) # -1 means lasts forever, nothing to do
    nil         
    lightTick
  
# we need to decrement the light
lightTick = do
  timeleft <- (peek 'GameHeader' GH_LIGHT_TIME) - 1
  myloc <- peek 'GameHeader' GH_PLAYER_ROOM
  >= timeleft 0  # save it back if not negative
    poke 'GameHeader' GH_LIGHT_TIME timeleft
    nil
  eq timeleft 0
    do
      poke 'BitFlags' LIGHTOUTBIT 1
      isLightPresent myloc
        print "Your light has run out.\n"
        nil
    and (< timeleft 25) (isLightPresent myloc)
      print concat[ "You light runs out in " timeleft " turns.\n"]
      nil
      
# take a looksy  
look = do
  myloc <- peek 'GameHeader' GH_PLAYER_ROOM
  darkbit <- peek 'BitFlags' DARKBIT
  and (eq darkbit 1) (not (isLightPresent myloc))
    print "You can't see. It is too dark!\n"
    basicLook myloc

basicLook myloc = do
  room <- peek 'Rooms' myloc
  name = strReplace (at room 6) (regexpFlags '\\{nl\\}' 'g' ) '\n'  # swap out any {nl} for real newlines
  strMatches name '^\\*'
    print name
    print concat[ "You are in a " name ]
  printExits room
  printItems myloc
  print "\n"

isNumber i = == (getType i) '*number'

safeat list idx = isCons list
  isNumber idx
    > (length list) idx
      at list idx
      'OOB LIST'
    'IDX NOT NUM'  
  'LIST NOT LIST'

#map func l = l (\h t D . cons (func h) (map func t)) nil
mapIndex func l = _mapIndex 0 func l
_mapIndex idx func l = l (\h t D . cons (func h idx) (_mapIndex (+ 1 idx) func t)) nil

hasExit exit idx = eq exit 0
  ''
  safeat Exits idx

# chop off the last element (its name) from the room and compute the valid exits    
printExits room = do
  exits = removeIf (eq '') (mapIndex (hasExit) (removeLast room))
  isNil exits
    print "Obvious exits: none."
    print concat[ "Obvious exits: "  (intersperse exits ", ") "."]

printItems myloc = do
  allitems <- getValue 'Items'
  items <- findItemsInLocation myloc allitems
  isNil items
    items
    print concat[ "You can also see: " (intersperse (map (\x . strReplace (at x 0) (regexpFlags '\\{nl\\}' 'g' ) '\n' ) items) ', ') "." ]  #have to extract the name from each item

# return a list of items that are in this location    
#  and (> (length (head items)) 1) (eq (safeat (head items) 1) myloc)
findItemsInLocation myloc items = isNil items
  nil
  eq (at (head items) 1) myloc
    cons (head items) (findItemsInLocation myloc (tail items))
    findItemsInLocation myloc (tail items)

# quick debug function for checking out the diff rooms
tp room = do
  poke 'GameHeader' GH_PLAYER_ROOM room
  look
  
# check to see if the light is either in the given room or carried by the player
isLightPresent myloc = do
  light <- peek 'Items' LIGHT_SOURCE
  where = at light 1
  or (eq where myloc) (eq where CARRIED)

# return a pair of ints for the intended verb/noun combo   
getInput = do
  str <- prompt (concat[ "Tell me what to do? " ])
  basicGetInput str

basicGetInput str = do
  verb_noun = strMatch str (regexp '(\\w+)\\s*(\\w*)')
  isCons verb_noun
    do
      wordlen <- peek 'GameHeader' GH_WORD_LENGTH
      m = at verb_noun 1
      v = strToUpperCase (strSubstring (at m 0) 0 wordlen)
      n = (eq 1 (length m)) ('') (strToUpperCase (strSubstring (at m 1) 0 wordlen))
      n = "DERP"
      log concat[ "M: " m " V: " v " N: " n] nil
    print "You use words I don't know"
  
testWhichNoun noun = do
  nouns <- getValue 'Nouns'
  whichWord noun nouns
  
testWhichVerb verb = do
  verbs <- getValue 'Verbs'
  whichWord verb verbs
  
# loop over the list of words, any words that start with * should return the index of the last non-* word before it. return -1 if no match found  
whichWord word list = basicWhichWord 0 0 word list  
basicWhichWord idx result word list = isNil list
  -1
  do
    w = head list
    star = (strStartsWith w '*')
    w = (star) (strSubstring w 1 99) w
    log ("w: " + w + " star: "  + star + " idx: " + idx + " result: " + result) 0
    eq word w
      result
      star
         basicWhichWord (++ idx) result word (tail list)
         basicWhichWord (++ idx) (++ idx) word (tail list)

         
performActions verb noun = do
  -1
