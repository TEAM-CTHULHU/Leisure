require '../../newCode/std.lsr'

 
# loop over the four possible actions to do them all in order
crash act = find (\el . eq act (head el))
  [ [52 action52 1] [53 action53 1] [54 action54 1] [55 action55 1] [56 action56] [57 action57] [58 action58 1] [59 action59 2] [60 action60 1] [61 action61] [62 action62 2] [63 action63] [64 action64] [65 action65] [66 action66] [67 action67] [68 action68] [60 action60] [69 action69] [70 action70] [71 action71] [72 action72 2] [74 action74 2] [75 action75 2] [76 action76] [77 action77] [78 action78] [79 action79 1] [80 action80] [810 action81 1] [82 action82 1] [83 action83 1] [84 action84] [85 action85] [86 action86] [87 action87 1] [88 action88] [89 action89 1] ]
  \cell . do
    executeAction act cell param pptr
    eq (length cell) 3
      (at cell 2)    # finally return the amount to bump pptr by!
      0
  printReturn concat[ "No action found for: " act ] 0   # called when find fails



# takes param list, pptr, and list of conditions to test - returns a list of the final return value param pptr and
meetsConditions param pptr conds = isNil conds
  [ true param pptr ]
  do
    cv <- head conds
    dv = cv / 20
    cv <- cv % 20
    myloc <- peek 'GameHeader' GH_PLAYER_ROOM  #log "here0" 9
    item <- peek 'Items' dv
    param = (eq cv 0) (pokeList param pptr dv) param  # save a param for case 0
    pptr = (eq cv 0) (++ pptr) pptr                   # inc the pptr for case 0
    keep <-           (eq cv 1)   (neq (at item ITEM_LOCATION) CARRIED) true   # player has an item     #if(Items[dv].Location!=CARRIED) return(0);
    keep <- (and keep (eq cv 2))  (neq (at item ITEM_LOCATION) myloc) true   # item is in room   # if(Items[dv].Location!=MyLoc) return(0);
meetsConditions param pptr conds = isNil conds
  [ true param pptr ]
  do
    cv <- head conds
    dv = cv / 20
    cv <- cv % 20
    myloc <- peek 'GameHeader' GH_PLAYER_ROOM  #log "here0" 9
    item <- peek 'Items' dv
    param = (eq cv 0) (pokeList param pptr dv) param  # save a param for case 0
    pptr = (eq cv 0) (++ pptr) pptr                   # inc the pptr for case 0
    keep <-           (eq cv 1)   (neq (at item ITEM_LOCATION) CARRIED) true   # player has an item     #if(Items[dv].Location!=CARRIED) return(0);
    keep <- (and keep (eq cv 2))  (neq (at item ITEM_LOCATION) myloc) true   # item is in room   # if(Items[dv].Location!=MyLoc) return(0);
    keep <- (and keep (eq cv 3))  (and (neq (at item ITEM_LOCATION) CARRIED) (neq (at item ITEM_LOCATION) myloc)) true    # item is 'available' to player # if(Items[dv].Location!=CARRIED&& Items[dv].Location!=MyLoc) return(0);
    keep <- (and keep (eq cv 4))  (neq myloc dv) true   # is player in room  # if(MyLoc!=dv) return(0);
    keep <- (and keep (eq cv 5))  (eq (at items ITEM_LOCATION) myloc) true  # is item not in this room   # if(Items[dv].Location==MyLoc) return(0);
    keep <- (and keep (eq cv 6))  (eq (at item ITEM_LOCATION) CARRIED) true  # it player doesn't have the item # if(Items[dv].Location==CARRIED) return(0);
    keep <- (and keep (eq cv 7))  (eq myloc dv) true # is player is not in room # if(MyLoc==dv) return(0);
    keep <- (and keep (eq cv 8))  (do (bf <- peek 'BitFlags' (^ 2 dv)) (eq bf false)) true   # is bit set   # if((BitFlags&(1<<dv))==0) return(0);     
    keep <- (and keep (eq cv 9))  (do (bf <- peek 'BitFlags' (^ 2 dv)) (eq bf true)) true  #is bit clear   # if(BitFlags&(1<<dv)) return(0);       
    keep (meetsConditions param pptr (tail conds)) [ false param pptr]    keep (meetsConditions param pptr (tail conds)) [ false param pptr]
           
duplicate value times = <= times 0
  nil
  [ value | (duplicate value (--times))]

processLight = do
  timeleft = peek 'GameHeader' GH_LIGHT_TIME
  light = peek 'Items' LIGHT_SOURCE
  where = at light 1
  or (eq where DESTROYED) (eq timeleft -1) # -1 means lasts forever, nothing to do
    nil
    lightTick
# why is this nil required??? if i take it out, it goes bonkers


playGame = do
  look # if this doesn't have an argument, it hangs the parser
  performActions 0 0  
  
findItemsInLocation myloc items = isNil items
  nil
  eq (at (head items) 1) myloc
    do
      print (head items)
      print (tail items)
      cons (head items) (findItemsInLocation myloc (tail items))
    do
      print myloc
      print (head items)
      print (at (head (tail items)) 1)
      findItemsInLocation myloc (tail items)
  